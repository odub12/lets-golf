<!--
================================================================================
    Let's Golf - Golf Tournament Scoring Application
    
    © 2026 Otis Williams. All Rights Reserved.
    
    This software and its source code are the intellectual property of 
    Otis Williams. Unauthorized copying, modification, distribution, or use 
    of this code, in whole or in part, is strictly prohibited without prior 
    written permission from the copyright holder.
    
    For licensing inquiries, contact the author.
================================================================================
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Let's Golf">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Let's Golf">
    <meta name="theme-color" content="#1e3a5f">
    <meta name="msapplication-TileColor" content="#1e3a5f">
    <meta name="msapplication-navbutton-color" content="#1e3a5f">
    
    <!-- SEO & Social Meta Tags -->
    <meta name="description" content="Real-time golf scoring app for tournaments and casual rounds. Track scores, calculate handicaps, and compete with friends.">
    <meta name="keywords" content="golf, scoring, tournament, handicap, leaderboard, sports">
    <meta name="author" content="Otis Williams">
    
    <!-- Open Graph / Social Sharing -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Let's Golf - Tournament Scoring">
    <meta property="og:description" content="Real-time golf scoring app for tournaments and casual rounds.">
    <meta property="og:image" content="/icons/icon-512x512.png">
    
    <!-- App Icons -->
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#1e3a5f">
    <link rel="shortcut icon" href="favicon.ico">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <title>Let's Golf</title>
    
    <!-- QR Code Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging-compat.js"></script>
    
    <!-- VERSION: 2026-01-31-v15.9.56-signin-fixes-fullscorecard-preview -->
    <style>
        /* ============================================
           RESKIN v1.0 - Navy + Tan Theme
           ============================================ */
        
        :root {
            /* Primary Navy Palette */
            --navy-dark: #1e3a5f;
            --navy-medium: #2d4a6f;
            --navy-light: #3d5a7f;
            --navy-btn: rgba(45, 74, 111, 0.85);
            
            /* Tan/Gold Accents */
            --tan-highlight: rgba(212, 165, 116, 0.7);
            --tan-border: rgba(180, 130, 80, 0.5);
            --tan-solid: #d4b896;
            
            /* Neutral Palette */
            --warm-white: #ffffff;
            --gray-50: #f9fafb;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-400: #9ca3af;
            --gray-500: #6b7280;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            
            /* Text Colors */
            --text-dark: #111827;
            --text-medium: #374151;
            --text-light: #6b7280;
            --text-muted: #9ca3af;
            
            /* Border Colors */
            --border-light: #e5e7eb;
            --border-medium: #d1d5db;
            
            /* Semantic Colors */
            --score-green: #166534;
            --score-red: #a51c30;
            --green-500: #166534;
            --green-600: #16a34a;
            --red-500: #a51c30;
            --red-600: #a51c30;
            
            /* Spacing & Radius */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--navy-dark); /* Fallback solid color */
            min-height: 100vh;
            min-height: -webkit-fill-available; /* iOS Safari fix */
            padding: 0;
            overflow-x: hidden;
            touch-action: pan-y; /* Allow vertical scrolling */
            position: relative;
            overscroll-behavior: none; /* Prevent pull-to-refresh */
            -webkit-overflow-scrolling: touch;
        }
        
        /* Fixed background that works on iOS */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(150deg, var(--navy-dark) 0%, var(--navy-medium) 100%);
            z-index: -1;
        }

        html {
            height: -webkit-fill-available; /* iOS Safari fix */
            overscroll-behavior: none; /* Prevent pull-to-refresh */
        }

        /* Page Container */
        .page {
            display: none;
            min-height: 100vh;
            padding: 12px;
            overscroll-behavior: none; /* Prevent pull-to-refresh */
            background: transparent;
            overflow-x: hidden;
        }

        .page.active {
            display: block;
            animation: slideIn 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background: transparent;
        }
        
        /* Lock scroll on home pages only - fit to screen */
        #guestHomePage.active,
        #hostHomePage.active {
            display: flex !important;
            flex-direction: column;
            overflow: hidden;
            height: 100vh;
            max-height: 100vh;
            touch-action: none;
            overscroll-behavior: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9000;
            /* iOS safe area support for notch/Dynamic Island */
            padding: env(safe-area-inset-top) 20px env(safe-area-inset-bottom) 20px;
            /* Ensure background covers everything */
            background: linear-gradient(150deg, var(--navy-dark) 0%, var(--navy-medium) 100%);
        }
        
        /* Management pages - prevent pull-to-refresh, allow scrolling, transparent bg */
        #playerManagementPage.active,
        #myPlayersPage.active {
            overscroll-behavior-y: none;
            -webkit-overflow-scrolling: touch;
            background: transparent !important;
        }
        
        /* Force transparent background on content areas */
        #hostContentArea,
        #playerContentArea {
            background: transparent !important;
        }
        
        /* Small screen fallback - allow scroll if content doesn't fit */
        @media (max-height: 650px) {
            #guestHomePage.active,
            #hostHomePage.active {
                overflow-y: auto;
                touch-action: pan-y;
            }
        }

        @keyframes slideIn {
            from { 
                opacity: 0; 
                transform: translateX(20px);
            }
            to { 
                opacity: 1; 
                transform: translateX(0);
            }
        }
        
        @keyframes slideOut {
            from { 
                opacity: 1; 
                transform: translateX(0);
            }
            to { 
                opacity: 0; 
                transform: translateX(20px);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Header */
        .header {
            background: var(--warm-white);
            padding: 14px;
            border-radius: var(--radius-md);
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            margin-bottom: 12px;
            text-align: center;
        }

        .header h1 {
            color: var(--navy-dark);
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 2px;
        }

        .header p {
            color: var(--text-light);
            font-size: 12px;
        }
        
        /* Sticky Header for Setup Page */
        .setup-header-sticky {
            position: fixed;
            top: 12px;
            left: 12px;
            right: 12px;
            z-index: 500;
            background: var(--warm-white);
            border-radius: var(--radius-md);
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* Add padding to setup container to account for fixed header */
        #setupPage .setup-container {
            margin-top: 160px;
        }
        
        .setup-header-title {
            padding: 12px 16px 10px 16px;
            text-align: center;
            border-bottom: 1px solid var(--border-light);
        }
        
        .setup-header-title h1 {
            color: var(--navy-dark);
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 2px;
        }
        
        .setup-header-title p {
            color: var(--text-light);
            font-size: 11px;
            margin: 0;
        }
        
        .setup-header-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            padding: 10px 12px;
            background: var(--gray-50);
        }

        /* Setup Page */
        .setup-container {
            background: var(--warm-white);
            border-radius: var(--radius-md);
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            overflow-x: hidden;
        }
        
        /* Compact form spacing for setup page */
        .setup-container .form-group {
            margin-bottom: 12px;
        }
        
        .setup-container .form-group label {
            margin-bottom: 6px;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            color: var(--navy-dark);
            font-weight: 600;
            margin-bottom: 6px;
            font-size: 13px;
        }

        .form-group input:not([type="checkbox"]),
        .form-group select {
            width: 100%;
            max-width: 100%;
            padding: 12px;
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-md);
            font-size: 15px;
            transition: all 0.2s;
            -webkit-appearance: none;
            appearance: none;
            background: var(--warm-white);
            color: #3b6b9b;
        }

        .form-group input[type="date"] {
            padding: 10px 12px;
            font-size: 14px;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--tan-solid);
            background: var(--gray-50);
        }

        /* Card Base Style */
        .card {
            background: var(--warm-white);
            border-radius: var(--radius-md);
            padding: 16px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
        }

        /* Player Input Grid */
        .player-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .player-row-wrapper {
            position: relative;
            overflow: hidden;
            border-radius: var(--radius-md);
        }

        /* Delete button - sits behind the row */
        .player-row-delete {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 80px;
            background: #a51c30;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            z-index: 0;
        }
        
        .player-row-delete:active {
            background: #7f1521;
        }

        .player-row {
            display: grid;
            grid-template-columns: 1fr 70px;
            gap: 6px;
            align-items: center;
            position: relative;
            background: var(--gray-50);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            z-index: 1;
            transform: translateX(0);
            transition: transform 0.2s ease-out;
        }
        
        .player-row.ghin-mode {
            grid-template-columns: 1fr 55px 45px;
        }
        
        .player-row.swiped {
            transform: translateX(-80px);
        }
        
        .player-row.has-suggestions {
            z-index: 100;
        }

        .player-row.deleting {
            opacity: 0;
            transform: translateX(-300px);
            transition: all 0.3s ease;
        }

        .player-name-input {
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 15px;
            width: 100%;
            background: white;
            position: relative;
            z-index: 1;
        }

        .player-name-input::placeholder {
            color: #94a3b8;
        }

        .player-hcp-input {
            width: 70px;
            padding: 8px 4px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 16px;
            text-align: center;
            background: white;
            flex-shrink: 0;
        }

        .player-hcp-input::placeholder {
            color: #94a3b8;
            font-size: 12px;
        }
        
        /* P.H. input - no longer used but kept for compatibility */
        .player-ph-input {
            display: none;
        }
        
        .course-hcp-display {
            width: 50px;
            padding: 12px 4px;
            background: #dbeafe;
            border: 2px solid #1e3a5f;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 700;
            text-align: center;
            color: #1e3a5f;
        }
        
        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
            flex-shrink: 0;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--gray-300);
            transition: 0.3s;
            border-radius: 24px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        
        .toggle-switch input:checked + .toggle-slider {
            background-color: #d4b896;
        }
        
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(20px);
            background-color: #1e3a5f;
        }
        
        .player-course-hcp {
            width: 45px;
            padding: 10px 4px;
            background: rgba(22, 101, 52, 0.15);
            border: 1px solid rgba(22, 101, 52, 0.3);
            border-radius: var(--radius-md);
            font-size: 14px;
            font-weight: 700;
            text-align: center;
            color: #166534;
        }
        
        /* Custom GHIN Checkbox Styling */
        .ghin-checkbox {
            appearance: none;
            -webkit-appearance: none;
            width: 20px !important;
            height: 20px !important;
            min-width: 20px;
            max-width: 20px;
            min-height: 20px;
            max-height: 20px;
            border: 2px solid #166534;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
            flex-grow: 0;
        }
        
        .ghin-checkbox:checked {
            background: #166534;
        }
        
        .ghin-checkbox:checked::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
        }

        /* Autocomplete Suggestions */
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 90px;
            background: white;
            border: 2px solid #1e3a5f;
            border-top: none;
            border-radius: 0 0 12px 12px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: none;
        }

        .autocomplete-suggestions.show {
            display: block;
        }

        .suggestion-item {
            padding: 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e2e8f0;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover,
        .suggestion-item:active {
            background: #eff6ff;
        }

        .suggestion-name {
            font-weight: 600;
            color: #1e3a5f;
        }

        .suggestion-hcp {
            color: #64748b;
            font-size: 14px;
        }

        .btn-add-player {
            width: auto;
            min-width: 140px;
            padding: 10px 20px;
            background: white;
            color: #1e3a5f;
            border: 2px solid #1e3a5f;
            border-radius: 6px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            margin: 10px auto 0;
            transition: all 0.2s;
            display: block;
        }

        .btn-add-player:active {
            background: #eff6ff;
        }

        .btn-add-player:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Quick Add Player Buttons */
        .quick-add-btn {
            padding: 8px 12px;
            background: #eff6ff;
            color: #1e3a5f;
            border: 2px solid #1e3a5f;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            position: relative;
        }

        .quick-add-btn:active {
            background: #dbeafe;
            transform: scale(0.95);
        }

        .quick-add-btn.show-delete {
            padding-right: 36px;
        }

        .quick-add-delete {
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            background: #a51c30;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .quick-add-btn.show-delete .quick-add-delete {
            display: flex;
        }

        /* Team Setup */
        .team-container {
            background: #f8fafc;
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .team-header {
            color: #1e3a5f;
            font-weight: 700;
            margin-bottom: 12px;
            font-size: 16px;
        }

        .team-member-select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 8px;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: var(--radius-md);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 8px;
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto;
            position: relative;
            z-index: 10;
        }

        .btn-primary {
            background: var(--navy-btn);
            color: white;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(30, 58, 95, 0.2);
        }

        .btn-primary:active {
            background: var(--navy-dark);
            transform: scale(0.98);
            box-shadow: 0 1px 2px rgba(30, 58, 95, 0.2);
        }

        .btn-primary::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn-primary:active::after {
            width: 300px;
            height: 300px;
        }

        .btn-secondary {
            background: var(--gray-200);
            color: var(--text-medium);
            -webkit-user-select: none;
            user-select: none;
            z-index: 1000 !important;
        }

        .btn-secondary:active {
            background: var(--gray-300);
            transform: scale(0.98);
        }

        /* Game Toggle Tabs */
        .game-tab {
            flex: 1;
            min-width: 80px;
            padding: 8px 14px;
            background: rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
            border: none;
            border-radius: var(--radius-sm);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            text-align: center;
        }

        .game-tab.active {
            background: var(--tan-highlight);
            color: var(--gray-700);
            box-shadow: 0 1px 4px rgba(0,0,0,0.15);
        }

        .game-tab:active {
            transform: scale(0.95);
        }

        /* Player Device Item */
        .player-device-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: var(--radius-md);
            margin-bottom: 6px;
        }

        .player-device-item h4 {
            color: white;
            font-size: 14px;
            margin-bottom: 2px;
        }

        .player-device-item p {
            color: rgba(255, 255, 255, 0.7);
            font-size: 13px;
            margin-bottom: 8px;
        }

        .player-device-item button {
            padding: 6px 12px;
            font-size: 13px;
            margin-right: 8px;
        }

        /* Leaderboard Styles */
        .leaderboard-entry {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .leaderboard-entry.first {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
        }

        .leaderboard-entry.second {
            background: linear-gradient(135deg, #94a3b8, #64748b);
        }

        .leaderboard-entry.third {
            background: linear-gradient(135deg, #fb923c, #ea580c);
        }

        .leaderboard-rank {
            font-size: 20px;
            font-weight: 700;
            min-width: 40px;
        }

        .leaderboard-name {
            flex: 1;
            font-weight: 600;
            color: white;
        }

        .leaderboard-score {
            font-size: 18px;
            font-weight: 700;
            color: white;
        }

        /* Scoring Page */
        .scoring-header {
            background: var(--warm-white);
            padding: 10px 12px;
            border-radius: var(--radius-md);
            margin-bottom: 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: fixed;
            top: 12px;
            left: 12px;
            right: 12px;
            z-index: 50;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .header-top-row {
            display: none; /* Deprecated - using new layout */
        }

        .header-bottom-row {
            display: flex; /* Changed from none - needed for setup page toggle */
        }
        
        /* Hide old row only in scoring header */
        .scoring-header .header-bottom-row {
            display: none; /* Old row - replaced by button grid */
        }
        
        .scoring-button-grid {
            display: flex;
            justify-content: center;
            gap: 6px;
            padding: 0 4px;
        }
        
        /* Grouped toggle button pairs */
        .btn-toggle-group {
            display: flex;
            background: var(--gray-200);
            border-radius: var(--radius-md);
            padding: 2px;
            gap: 0;
        }
        
        .btn-toggle-group .toggle-btn {
            flex: 1;
            padding: 6px 10px;
            background: transparent;
            border: none;
            border-radius: var(--radius-sm);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 4px;
            color: var(--text-light);
            white-space: nowrap;
        }
        
        .btn-toggle-group .toggle-btn.active {
            background: #1e3a5f;
            color: white;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        
        .btn-toggle-group .toggle-btn.voice-active {
            background: #166534;
            color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }
        
        .scoring-grid-btn {
            padding: 10px 8px;
            background: #f1f5f9;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            color: #64748b;
        }
        
        .scoring-grid-btn.active {
            background: #1e3a5f;
            border-color: #1e3a5f;
            color: white;
        }
        
        .scoring-grid-btn.voice-btn.active {
            background: #166534;
            border-color: #166534;
            color: white;
        }
        
        .scoring-grid-btn.card-btn {
            background: #1e3a5f;
            border-color: #1e3a5f;
            color: white;
        }
        
        .scoring-grid-btn.myplayers-btn {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            border-color: #f59e0b;
            color: #78350f;
        }
        
        .scoring-grid-btn.manage-btn {
            background: #f59e0b;
            border-color: #f59e0b;
            color: white;
        }

        .tournament-info-centered {
            text-align: center;
        }

        .tournament-info-centered h2 {
            font-size: 16px;
            font-weight: 700;
            color: #1e293b;
            margin: 0;
            line-height: 1.2;
        }

        .tournament-info-centered p {
            font-size: 12px;
            color: #64748b;
            margin: 2px 0 0 0;
        }

        /* Results page header - simple single row */
        .results-sticky-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 50;
            background: transparent;
            padding: 12px 12px 10px 12px;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* Add padding to results page content to account for fixed header */
        #resultsPage .results-container {
            margin-top: 200px;
        }
        
        .results-page-header {
            background: var(--warm-white);
            padding: 10px 12px;
            border-radius: var(--radius-md);
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: stretch;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
        }

        .tournament-info-simple {
            flex: 1;
            min-width: 0;
        }

        .tournament-info-simple h2 {
            color: var(--navy-dark);
            font-size: 14px;
            margin-bottom: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .tournament-info-simple p {
            color: var(--text-light);
            font-size: 11px;
            margin: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .scoring-content {
            padding-top: 200px;
            padding-left: 0;
            padding-right: 0;
        }

        .round-indicator.active ~ .scoring-header,
        #scoringPage .round-indicator.active ~ .scoring-header {
            top: 44px;
        }

        .round-indicator.active ~ .scoring-content,
        #scoringPage .round-indicator.active ~ .scoring-content {
            padding-top: 240px;
        }


        .finish-btn {
            padding: 8px 16px;
            background: #166534;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 13px;
            white-space: nowrap;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            pointer-events: auto;
            position: relative;
            z-index: 10;
        }

        .finish-btn:active {
            background: #166534;
        }

        .back-btn {
            padding: 8px 12px;
            background: #64748b;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            white-space: nowrap;
            -webkit-tap-highlight-color: rgba(100, 116, 139, 0.3);
            touch-action: manipulation;
            pointer-events: auto;
            position: relative;
            z-index: 1000;
            -webkit-user-select: none;
            user-select: none;
        }

        .back-btn:active {
            background: #475569;
        }

        /* Player Card */
        .player-card {
            background: white;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        /* Swipe Carousel for Player View */
        .player-carousel {
            position: relative;
            overflow: hidden;
            width: 100%;
            touch-action: pan-x;
            overscroll-behavior: contain;
        }
        
        .player-carousel-track {
            display: flex;
            transition: transform 0.3s ease-out;
            touch-action: pan-x;
        }
        
        /* Lock vertical scroll when in Players view */
        #scoringPage.players-view-active {
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            touch-action: none;
        }
        
        #scoringPage.players-view-active .scoring-content {
            overflow: hidden;
            touch-action: pan-x;
        }
        
        .player-carousel-slide {
            flex: 0 0 100%;
            width: 100%;
            padding: 0 8px;
            box-sizing: border-box;
        }
        
        .player-card-fit {
            background: white;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 220px);
        }
        
        .player-card-fit .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            border-bottom: 2px solid #e2e8f0;
            margin-bottom: 8px;
            flex-shrink: 0;
        }
        
        .player-card-fit .player-name {
            font-size: 18px;
            font-weight: 700;
            color: #1e3a5f;
        }
        
        .player-card-fit .player-total {
            font-size: 20px;
            font-weight: 700;
            color: #1e3a5f;
        }
        
        /* Compact holes grid for auto-fit */
        .holes-grid-fit {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
            width: 100%;
            box-sizing: border-box;
            flex: 1;
            overflow-y: auto;
        }
        
        .hole-input-fit {
            background: #f8fafc;
            border-radius: 8px;
            padding: 4px;
            min-width: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .hole-input-fit .hole-num {
            font-size: 10px;
            font-weight: 700;
            color: #1e3a5f;
        }
        
        .hole-input-fit .hole-par {
            font-size: 8px;
            color: #64748b;
        }
        
        .hole-input-fit .score-display {
            font-size: 18px;
            font-weight: 700;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            margin: 2px 0;
        }
        
        .hole-input-fit .score-btns {
            display: flex;
            gap: 2px;
        }
        
        .hole-input-fit .score-btn-sm {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .hole-input-fit .score-btn-sm.minus {
            background: #fee2e2;
            color: #a51c30;
        }
        
        .hole-input-fit .score-btn-sm.plus {
            background: #dbeafe;
            color: #1e3a5f;
        }
        
        /* Carousel navigation dots */
        .carousel-dots {
            display: flex;
            justify-content: center;
            gap: 8px;
            padding: 12px 0;
        }
        
        .carousel-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #cbd5e1;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .carousel-dot.active {
            background: #1e3a5f;
            transform: scale(1.2);
        }
        
        /* Carousel nav arrows */
        .carousel-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }
        
        .carousel-nav-btn {
            padding: 8px 16px;
            background: #1e3a5f;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .carousel-nav-btn:disabled {
            background: #e2e8f0;
            color: #94a3b8;
            cursor: not-allowed;
        }
        
        .carousel-player-name {
            font-size: 16px;
            font-weight: 700;
            color: #1e3a5f;
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        }

        .player-name {
            font-size: 20px;
            font-weight: 700;
            color: #1e3a5f;
        }

        .player-total {
            font-size: 24px;
            font-weight: 700;
            color: #1e3a5f;
        }

        /* Hole Grid */
        .holes-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
            box-sizing: border-box;
        }

        .hole-input-group {
            background: #f8fafc;
            border-radius: 6px;
            padding: 8px 5px;
            min-width: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hole-label {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
            font-size: 11px;
            color: #64748b;
            font-weight: 600;
            min-height: 32px;
        }

        .par-badge {
            background: #dbeafe;
            color: #1e3a5f;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 9px;
            white-space: nowrap;
        }

        .score-input-wrapper {
            display: flex;
            align-items: center;
            gap: 3px;
            min-width: 0;
        }

        .score-btn {
            width: 28px;
            height: 28px;
            min-width: 28px;
            border: none;
            background: #1e3a5f;
            color: white;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        .score-btn:active {
            background: #1e3a5f;
            transform: scale(0.95);
        }

        .score-input {
            width: 100%;
            max-width: 100%;
            min-width: 0;
            text-align: center;
            padding: 6px 2px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 700;
            color: #1e3a5f;
            box-sizing: border-box;
        }

        .score-input:focus {
            outline: none;
            border-color: #1e3a5f;
        }

        /* Score coloring */
        .score-input.birdie-better {
            background: #dcfce7 !important;
            border-color: #166534 !important;
            color: #166534 !important;
            font-weight: 600;
        }

        .score-input.par {
            background: #f8fafc !important;
            border-color: #d1d5db !important;
            color: #1e3a5f !important;
            font-weight: 600;
        }

        .score-input.bogey {
            background: #fef2f2 !important;
            border-color: #a51c30 !important;
            color: #a51c30 !important;
            font-weight: 600;
        }

        .score-input.double-bogey-plus {
            background: #fef2f2 !important;
            border-color: #a51c30 !important;
            color: #a51c30 !important;
            font-weight: 600;
        }

        /* Results Page */
        .results-container {
            background: white;
            border-radius: 8px;
            padding: 24px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .results-title {
            color: #1e293b;
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
            text-align: center;
        }

        .results-player {
            background: #f8fafc;
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .results-player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .results-player-name {
            font-size: 18px;
            font-weight: 700;
            color: #1e3a5f;
        }

        .results-score {
            font-size: 24px;
            font-weight: 700;
            color: #1e3a5f;
        }

        .results-details {
            display: flex;
            gap: 16px;
            font-size: 13px;
            color: #64748b;
        }

        .results-stat {
            display: flex;
            flex-direction: column;
        }

        .results-stat-label {
            font-weight: 600;
            margin-bottom: 2px;
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: 40px;
            color: #64748b;
        }

        /* Share Tournament Section */
        .share-section {
            background: white;
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .share-section h3 {
            color: #1e3a5f;
            margin-bottom: 16px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .share-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .share-btn {
            background: white;
            color: #1e3a5f;
            border: 2px solid #1e3a5f;
            padding: 12px 8px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .share-btn:active {
            transform: scale(0.98);
            background: #f8fafc;
        }

        .share-btn.copy {
            color: #166534;
            border-color: #166534;
        }

        .share-btn.qr {
            color: #a855f7;
            border-color: #a855f7;
        }

        .share-btn.download {
            color: #f59e0b;
            border-color: #f59e0b;
        }

        #qrCodeContainer {
            text-align: center;
            padding: 20px;
            background: #f8fafc;
            border-radius: 8px;
            margin-top: 16px;
        }

        #qrCodeContainer canvas {
            margin: 0 auto;
            display: block;
        }

        .tournament-id {
            font-family: monospace;
            background: #f1f5f9;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            color: #475569;
            margin-top: 10px;
            word-break: break-all;
        }

        /* ===== UI ENHANCEMENTS ===== */
        
        /* Player Avatar Circles */
        .player-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 12px;
            color: white;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .player-avatar-large {
            width: 48px;
            height: 48px;
            font-size: 18px;
        }

        /* Score Color Coding */
        .score-eagle {
            background: linear-gradient(135deg, #166534, #166534);
            color: white;
            font-weight: 700;
        }

        .score-birdie {
            background: linear-gradient(135deg, #166534, #228b22);
            color: white;
            font-weight: 700;
        }

        .score-par {
            background: #f1f5f9;
            color: #475569;
        }

        .score-bogey {
            background: linear-gradient(135deg, #f59e0b, #fbbf24);
            color: white;
            font-weight: 700;
        }

        .score-double {
            background: linear-gradient(135deg, #a51c30, #c53030);
            color: white;
            font-weight: 700;
        }

        /* Enhanced Shadows */
        .card-shadow {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
        }

        .card-shadow-lg {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
        }

        .card-shadow-xl {
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
        }

        /* Pulse Animation for Score Changes */
        @keyframes scorePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .score-changed {
            animation: scorePulse 0.3s ease-out;
        }

        /* Trophy Icons */
        .trophy-gold {
            color: #fbbf24;
            font-size: 24px;
            margin-right: 8px;
        }

        .trophy-silver {
            color: #d1d5db;
            font-size: 22px;
            margin-right: 8px;
        }

        .trophy-bronze {
            color: #c27803;
            font-size: 20px;
            margin-right: 8px;
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 0;
        }
        
        /* Progress bar in scoring header uses gradient background */
        .scoring-header .progress-bar {
            background: #e2e8f0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #166534, #1e3a5f);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        /* Confetti Animation */
        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            z-index: 9999;
            pointer-events: none;
        }

        /* Ripple Effect */
        .ripple {
            position: relative;
            overflow: hidden;
        }

        .ripple::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .ripple:active::after {
            width: 300px;
            height: 300px;
        }

        /* Number Count Animation */
        @keyframes numberCount {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .number-animate {
            animation: numberCount 0.3s ease-out;
        }

        /* Scorecard Modal */
        .scorecard-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .scorecard-modal.active {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 20px;
        }

        .scorecard-content {
            background: white;
            border-radius: 6px;
            max-width: 900px;
            width: 100%;
            margin: 20px auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .scorecard-header {
            padding: 20px;
            border-bottom: 2px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .scorecard-body {
            padding: 12px;
            max-height: 75vh;
            overflow: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        /* Sticky header and column for scorecard table */
        .scorecard-table thead th {
            position: sticky;
            top: 0;
            z-index: 1;
        }
        
        .scorecard-table thead th:first-child {
            position: sticky;
            left: 0;
            top: 0;
            z-index: 3;
        }
        
        .scorecard-table tbody td:first-child {
            position: sticky;
            left: 0;
            z-index: 1;
            background: inherit;
        }

        .scorecard-footer {
            padding: 16px;
            border-top: 2px solid #e2e8f0;
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .scorecard-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 11px;
            table-layout: auto;
        }

        .scorecard-table th,
        .scorecard-table td {
            border: 1px solid #cbd5e1;
            padding: 4px 2px;
            text-align: center;
            min-width: 35px;
            line-height: 1.2;
        }

        .scorecard-table th {
            background: #1e3a5f;
            color: white;
            font-weight: 600;
            font-size: 10px;
            padding: 3px 2px;
        }

        .scorecard-table .player-name-cell {
            background: #dbeafe;
            font-weight: 600;
            color: #1e3a5f;
        }

        .scorecard-table .total-row {
            background: #f1f5f9;
            font-weight: 600;
        }

        .scorecard-individual {
            background: white;
            border: 1.5px solid #cbd5e1;
            border-radius: 4px;
            padding: 16px;
            margin-bottom: 20px;
            page-break-inside: avoid;
            break-inside: avoid;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .scorecard-player-header {
            text-align: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        }

        .scorecard-player-name {
            font-size: 20px;
            font-weight: 700;
            color: #1e3a5f;
            margin-bottom: 4px;
        }

        .scorecard-player-info {
            font-size: 14px;
            color: #64748b;
        }

        /* Round in Progress Indicator */
        .round-indicator {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); /* Bright orange/amber */
            color: white;
            padding: 12px 16px; /* Slightly taller */
            text-align: center;
            font-size: 14px; /* Larger text */
            font-weight: 700; /* Bolder */
            z-index: 9998;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4); /* Stronger shadow with orange tint */
            display: none;
            border-bottom: 2px solid #fff; /* White bottom border */
        }

        .round-indicator.active {
            display: block;
        }

        .round-indicator-icon {
            display: inline-block;
            width: 10px; /* Slightly larger dot */
            height: 10px;
            background: #fff;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1.5s infinite; /* Faster pulse */
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .auto-save-toast {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: #166534;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 9999;
            pointer-events: none;
        }

        .auto-save-toast.show {
            opacity: 1;
        }

        .resume-round-section {
            background: linear-gradient(135deg, #1e3a5f 0%, #1e3a5f 100%);
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
            color: white;
            display: none;
        }

        .resume-round-section.active {
            display: block;
        }

        .resume-round-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .resume-round-info {
            font-size: 14px;
            margin-bottom: 16px;
            opacity: 0.9;
        }

        .resume-round-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        /* Force share buttons to be visible on all devices including iPhone */
        #resumeShareButtons {
            min-height: 44px !important; /* iOS minimum tap target */
            overflow: visible !important;
        }
        
        #resumeShareButtons.visible {
            display: grid !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .resume-btn {
            background: #166534;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
        }

        .discard-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* View Toggle Buttons in Header */
        .view-toggle-btn-header {
            padding: 8px 16px;
            background: #f1f5f9;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            color: #64748b;
            flex: 1;
            justify-content: center;
        }

        .view-toggle-btn-header.active {
            background: #1e3a5f;
            border-color: #1e3a5f;
            color: white;
        }

        /* Old toggle buttons - can remove */
        .view-toggle-btn {
            flex: 1;
            padding: 8px 16px;
            background: white;
            border: 2px solid #cbd5e1;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #64748b;
            cursor: pointer;
            transition: all 0.2s;
        }

        .view-toggle-btn.active {
            background: #1e3a5f;
            border-color: #1e3a5f;
            color: white;
        }

        /* Hole View Styles */
        .hole-view-container {
            background: white;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .hole-header {
            text-align: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        }
        
        .hole-nav-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        
        .hole-nav-btn-compact {
            padding: 8px 14px;
            background: #1e3a5f;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            min-width: 60px;
        }
        
        .hole-nav-btn-compact:active {
            transform: scale(0.95);
        }
        
        .hole-title-section {
            flex: 1;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 8px;
            transition: background 0.2s;
        }
        
        .hole-title-section:active {
            background: #f1f5f9;
        }

        .hole-number {
            font-size: 32px;
            font-weight: 700;
            color: #1e3a5f;
            margin-bottom: 2px;
        }

        .hole-info {
            font-size: 15px;
            color: #64748b;
            font-weight: 600;
            white-space: nowrap;
        }

        .hole-player-row-ticker {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            padding: 16px;
            margin-bottom: 12px;
            background: #f8fafc;
            border-radius: 6px;
            gap: 16px;
        }

        .hole-player-info {
            flex: 1;
        }

        .hole-player-name {
            font-size: 18px;
            font-weight: 700;
            color: #1e3a5f;
        }

        .hole-player-hcp {
            font-size: 14px;
            color: #64748b;
            margin-top: 4px;
            font-weight: 500;
        }

        .hole-score-section {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 12px;
        }

        .hole-score-ticker {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .hole-hcp-dots {
            display: flex;
            gap: 3px;
            justify-content: center;
            margin-bottom: 4px;
            min-height: 10px;
            width: 100%;
        }
        
        .hcp-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .hcp-dot.green {
            background: #166534;
        }
        
        .hcp-dot.red {
            background: #a51c30;
        }

        .hole-net-score {
            font-size: 18px;
            color: #64748b;
            font-weight: 600;
            background: #f5f5f5;
            padding: 8px 14px;
            border-radius: 8px;
            min-width: 45px;
            text-align: center;
        }

        .hole-score-ticker .score-btn {
            display: none; /* Hide +/- buttons - using quick tap popup instead */
        }

        .hole-score-ticker .score-input {
            width: 60px;
            height: 60px;
            font-size: 26px;
            font-weight: 700;
            text-align: center;
            border: 2px solid #d1d5db;
            border-radius: 50%;
            background: white;
            color: #1e3a5f;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            -webkit-appearance: none;
            -moz-appearance: textfield;
        }

        .hole-score-ticker .score-input:focus {
            outline: none;
            border-color: #1e3a5f;
        }
        
        /* Watch-only row styling */
        .hole-player-row-ticker.watch-only {
            opacity: 0.85;
            background: #f8fafc;
        }
        
        .hole-score-display {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* Score coloring for hole view - use !important to ensure these take precedence */
        .hole-score-ticker .score-input.eagle-better {
            background: white !important;
            border: 2px solid #166534 !important;
            color: #166534 !important;
            border-radius: 50% !important;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #166534 !important;
        }
        
        .hole-score-ticker .score-input.birdie-better,
        .hole-score-ticker .score-input.birdie {
            background: white !important;
            border: 2px solid #166534 !important;
            color: #166534 !important;
            border-radius: 50% !important;
        }

        .hole-score-ticker .score-input.par {
            background: white !important;
            border: 1.5px solid #d1d5db !important;
            color: #1e3a5f !important;
            border-radius: 4px !important;
        }

        .hole-score-ticker .score-input.bogey {
            background: white !important;
            border: 2px solid #a51c30 !important;
            color: #a51c30 !important;
            border-radius: 4px !important;
        }

        .hole-score-ticker .score-input.double-bogey-plus {
            background: white !important;
            border: 2px solid #a51c30 !important;
            color: #a51c30 !important;
            border-radius: 4px !important;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #a51c30 !important;
        }

        .hole-player-row {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            padding: 12px;
            margin-bottom: 12px;
            background: #f8fafc;
            border-radius: 6px;
            gap: 12px;
        }

        .hole-player-name {
            font-size: 16px;
            font-weight: 600;
            color: #1e3a5f;
        }

        .hole-player-hcp {
            font-size: 13px;
            color: #64748b;
            margin-top: 2px;
        }

        .hole-score-input {
            width: 60px;
            height: 60px;
            font-size: 24px;
            font-weight: 700;
            text-align: center;
            border: 2px solid #cbd5e1;
            border-radius: 6px;
            background: white;
            color: #1e3a5f;
        }

        .hole-score-input:focus {
            outline: none;
            border-color: #1e3a5f;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .hole-navigation {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 12px;
            align-items: center;
            margin-top: 24px;
        }

        .hole-nav-btn {
            padding: 12px 20px;
            background: #1e3a5f;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .hole-nav-btn:disabled {
            background: #e2e8f0;
            color: #94a3b8;
            cursor: not-allowed;
        }

        .hole-counter {
            text-align: center;
            font-size: 16px;
            font-weight: 600;
            color: #64748b;
        }

        /* Swipe gesture support */
        .hole-view-container {
            touch-action: pan-y;
            position: relative;
        }

        /* Score Picker Overlay */
        .score-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 20px;
        }

        .score-picker {
            background: white;
            border-radius: 8px;
            padding: 24px;
            width: 100%;
            max-width: 320px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .score-picker-header {
            text-align: center;
            font-size: 16px;
            color: #1e3a5f;
            margin-bottom: 16px;
        }

        .score-display {
            text-align: center;
            font-size: 48px;
            font-weight: 700;
            color: #1e3a5f;
            margin: 20px 0;
        }

        .score-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }

        .score-btn {
            padding: 16px;
            background: #1e3a5f;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            transition: background 0.2s;
        }

        .score-btn:active {
            background: #1e3a5f;
        }

        .score-close {
            width: 100%;
            padding: 14px;
            background: #166534;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        /* Wrapper for table to enable horizontal scroll */
        .table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin-bottom: 20px;
        }

        @media print {
            .scorecard-modal {
                display: block !important;
                position: static;
                background: white;
            }

            .scorecard-content {
                box-shadow: none;
                max-width: 100%;
            }

            .scorecard-header,
            .scorecard-footer {
                display: none !important;
            }

            .scorecard-body {
                max-height: none;
                overflow: visible;
            }
            
            .scorecard-individual {
                page-break-inside: avoid;
                break-inside: avoid;
            }
            
            .table-wrapper {
                overflow: visible;
            }
            
            .scorecard-table {
                font-size: 10px;
            }
            
            .scorecard-table th,
            .scorecard-table td {
                padding: 4px 2px;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
                padding: 0;
            }

            .page {
                display: none;
            }

            #printableScorecard {
                display: block !important;
            }

            .btn, .form-group, #resultsGameType {
                display: none !important;
            }

            .print-scorecard {
                display: block;
                padding: 20px;
                font-family: Arial, sans-serif;
                color: black;
            }

            .print-header {
                text-align: center;
                margin-bottom: 20px;
                border-bottom: 2px solid black;
                padding-bottom: 10px;
            }

            .print-table {
                width: 100%;
                border-collapse: collapse;
                margin-bottom: 20px;
                page-break-inside: avoid;
            }

            .print-table th,
            .print-table td {
                border: 1px solid black;
                padding: 6px;
                text-align: center;
                font-size: 11px;
            }

            .print-table th {
                background: #e0e0e0;
                font-weight: bold;
            }

            .print-results {
                margin-top: 20px;
                page-break-before: avoid;
            }

            .print-results h3 {
                border-bottom: 2px solid black;
                padding-bottom: 5px;
                margin-bottom: 10px;
            }
            
            /* Make scorecard table fit on one page */
            .scorecard-table {
                font-size: 9px !important;
                width: 100%;
                page-break-inside: avoid;
            }
            
            .scorecard-table th,
            .scorecard-table td {
                padding: 4px 2px !important;
                font-size: 9px !important;
            }
            
            .scorecard-table th {
                font-size: 8px !important;
                font-weight: 700;
            }
            
            /* Hide modal chrome in print */
            .scorecard-header,
            .scorecard-footer {
                display: none !important;
            }
            
            .scorecard-modal {
                position: static !important;
                background: white !important;
            }
            
            .scorecard-content {
                max-width: 100% !important;
                margin: 0 !important;
                box-shadow: none !important;
            }
            
            .scorecard-body {
                padding: 10px !important;
            }
        }

        .print-scorecard {
            display: none;
        }
        
        /* Voice/Keyboard Input Toggle */
        .input-mode-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f1f5f9;
            border-radius: 8px;
            margin: 8px 0;
        }
        
        .input-mode-toggle label {
            font-size: 12px;
            color: #64748b;
            font-weight: 600;
        }
        
        .input-mode-btn {
            padding: 6px 12px;
            border: 2px solid #e2e8f0;
            background: white;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .input-mode-btn.active {
            background: #1e3a5f;
            border-color: #1e3a5f;
            color: white;
        }
        
        .input-mode-btn:hover:not(.active) {
            border-color: #1e3a5f;
        }
        
        /* Voice listening indicator */
        .voice-listening {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 32px 48px;
            border-radius: 8px;
            z-index: 10001;
            text-align: center;
            display: none;
        }
        
        .voice-listening.active {
            display: block;
        }
        
        .voice-listening .mic-icon {
            font-size: 48px;
            animation: pulse 1s infinite;
        }
        
        .voice-listening .voice-text {
            font-size: 18px;
            margin-top: 12px;
            font-weight: 600;
        }
        
        .voice-listening .voice-result {
            font-size: 48px;
            margin-top: 16px;
            font-weight: 700;
            color: #166534;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        /* Compact Player Card (9-column grid for auto-fit) */
        .player-card-compact {
            background: white;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .player-card-compact.watched {
            background: #f8fafc;
            border: 2px dashed #94a3b8;
        }
        
        .player-card-compact .player-header-compact {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            border-bottom: 2px solid #e2e8f0;
            margin-bottom: 8px;
        }
        
        .player-card-compact .player-name-compact {
            font-size: 16px;
            font-weight: 700;
            color: #1e3a5f;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .player-card-compact .player-total-compact {
            font-size: 18px;
            font-weight: 700;
            color: #1e3a5f;
        }
        
        .nine-section {
            margin-bottom: 16px;
        }
        
        .nine-section-label {
            font-size: 11px;
            font-weight: 700;
            color: #64748b;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .nine-section-total {
            font-size: 12px;
            font-weight: 700;
            color: #1e3a5f;
        }
        
        .holes-grid-6 {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
        }
        
        /* Expanded score input modal */
        .expanded-score-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 10002;
            align-items: center;
            justify-content: center;
        }
        
        .expanded-score-modal.active {
            display: flex;
        }
        
        .expanded-score-content {
            background: white;
            border-radius: 8px;
            padding: 20px;
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .expanded-hole-header {
            text-align: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        }
        
        .expanded-hole-number {
            font-size: 24px;
            font-weight: 700;
            color: #1e3a5f;
        }
        
        .expanded-hole-info {
            font-size: 14px;
            color: #64748b;
        }
        
        .expanded-player-name {
            font-size: 18px;
            font-weight: 600;
            color: #1e3a5f;
            margin-bottom: 16px;
            text-align: center;
        }
        
        .expanded-score-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            margin-bottom: 20px;
        }
        
        .expanded-score-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 28px;
            font-weight: 700;
            cursor: pointer;
            background: transparent;
        }
        
        .expanded-score-btn.minus {
            border: 2px solid #a51c30;
            color: #a51c30;
        }
        
        .expanded-score-btn.plus {
            border: 2px solid #2d5a3d;
            color: #2d5a3d;
        }
        
        .expanded-score-value {
            font-size: 48px;
            font-weight: 700;
            width: 80px;
            text-align: center;
            color: #1e3a5f;
        }
        
        .expanded-quick-scores {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .quick-score-btn {
            padding: 12px;
            border: 1.5px solid #d1d5db;
            border-radius: 6px;
            background: white;
            font-size: 16px;
            font-weight: 600;
            color: #1e3a5f;
            cursor: pointer;
        }
        
        .quick-score-btn:active {
            background: #1e3a5f;
            color: white;
            border-color: #1e3a5f;
        }
        
        .expanded-actions {
            display: flex;
            gap: 12px;
        }
        
        .expanded-actions button {
            flex: 1;
            padding: 14px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }
        
        /* Putt Tracking Styles */
        .putt-btn {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 2px solid #8b5cf6;
            background: #f5f0e8;
            color: #1e3a5f;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
            flex-shrink: 0;
            transition: all 0.2s;
        }
        
        .putt-btn:active {
            background: #8b5cf6;
            color: white;
        }
        
        .putt-btn.has-putt {
            background: #8b5cf6;
            color: white;
            border-color: #1e3a5f;
        }
        
        .putt-popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 10003;
            align-items: center;
            justify-content: center;
        }
        
        .putt-popup.active {
            display: flex;
        }
        
        .putt-popup-content {
            background: white;
            border-radius: 8px;
            padding: 20px;
            max-width: 320px;
            width: 90%;
            text-align: center;
        }
        
        .putt-popup-title {
            font-size: 22px;
            font-weight: 700;
            color: #1e3a5f;
            margin-bottom: 4px;
        }
        
        .putt-popup-info {
            font-size: 14px;
            color: #64748b;
            margin-bottom: 16px;
        }
        
        .putt-options {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 16px;
        }
        
        .putt-option-btn {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 6px;
            border: 2px solid #e2e8f0;
            background: white;
            font-size: 24px;
            font-weight: 700;
            color: #1e3a5f;
            cursor: pointer;
            transition: all 0.15s;
            min-height: 52px;
        }
        
        .putt-option-btn:active {
            background: #8b5cf6;
            color: white;
            border-color: #8b5cf6;
            transform: scale(0.95);
        }
        
        .putt-option-btn.selected {
            background: #8b5cf6;
            color: white;
            border-color: #1e3a5f;
        }
        
        .putt-clear-btn {
            width: 100%;
            padding: 12px;
            background: #fee2e2;
            color: #a51c30;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .putt-clear-btn:active {
            background: #a51c30;
            color: white;
        }
        
        .hole-cell {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 3px 2px;
            background: #f8fafc;
            border-radius: 6px;
            min-width: 0;
            height: 110px;
            overflow: visible;
        }
        
        .hole-cell .hole-num {
            font-size: 12px;
            font-weight: 700;
            color: #1e3a5f;
            margin-bottom: 1px;
        }
        
        .hole-cell .hole-par {
            font-size: 9px;
            color: #64748b;
            font-weight: 600;
        }
        
        .hole-cell .hole-hcp {
            font-size: 8px;
            color: #94a3b8;
            font-weight: 500;
            margin-bottom: 2px;
        }
        
        .hole-cell .par-hcp-stack {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0px;
            margin-bottom: 2px;
        }
        
        .hole-cell .par-hcp-line {
            display: flex;
            align-items: center;
            gap: 3px;
            font-size: 9px;
        }
        
        .hole-cell .par-hcp-line .label {
            color: #94a3b8;
            font-weight: 500;
            min-width: 20px;
            text-align: right;
        }
        
        .hole-cell .par-hcp-line .value {
            color: #475569;
            font-weight: 700;
            min-width: 14px;
        }
        
        /* Legacy classes - keep for backward compatibility */
        .hole-cell .par-hcp-row {
            display: none;
        }
        
        .hole-cell .par-hcp-col {
            display: none;
        }
        
        .hole-cell .par-hcp-label {
            display: none;
        }
        
        .hole-cell .par-hcp-value {
            display: none;
        }
        
        .hole-cell .par-hcp-divider {
            display: none;
        }
        
        .hole-cell .score-cell {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 700;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s;
            background: white;
            color: #1e3a5f; /* Default navy text for unclassified scores */
        }
        
        .hole-cell .score-cell:active {
            transform: scale(0.95);
        }
        
        .hole-cell .score-cell.empty {
            background: transparent;
            color: #94a3b8;
            border: 1.5px dashed #d1d5db;
            border-radius: 4px;
        }
        
        .hole-cell .score-cell.eagle-better {
            background: white !important;
            color: #166534 !important;
            border: 1.5px solid #166534 !important;
            border-radius: 50% !important;
            box-shadow: 0 0 0 1px white, 0 0 0 2.5px #166534 !important;
        }
        
        .hole-cell .score-cell.birdie {
            background: white !important;
            color: #166534 !important;
            border: 1.5px solid #166534 !important;
            border-radius: 50% !important;
        }
        
        .hole-cell .score-cell.par {
            background: white !important;
            color: #1e3a5f !important;
            border: 1.5px solid #d1d5db !important;
            border-radius: 4px !important;
        }
        
        .hole-cell .score-cell.bogey {
            background: white !important;
            color: #a51c30 !important;
            border: 1.5px solid #a51c30 !important;
            border-radius: 4px !important;
        }
        
        .hole-cell .score-cell.double-plus {
            background: white !important;
            color: #a51c30 !important;
            border: 1.5px solid #a51c30 !important;
            border-radius: 4px !important;
            box-shadow: 0 0 0 1px white, 0 0 0 2.5px #a51c30 !important;
        }
        
        .hole-cell .net-score {
            font-size: 9px;
            color: #64748b;
            font-weight: 600;
            margin-top: 1px;
        }
        
        .hcp-dots-compact {
            display: flex;
            gap: 2px;
            justify-content: center;
            height: 8px;
            margin-bottom: 2px;
        }
        
        .hcp-dot-compact {
            width: 5px;
            height: 5px;
            border-radius: 50%;
        }
        
        .hcp-dot-compact.green {
            background: #166534;
        }
        
        .hcp-dot-compact.red {
            background: #a51c30;
        }
        
        .hole-cell .score-btns-mini {
            display: flex;
            gap: 2px;
        }
        
        .hole-cell .btn-mini {
            width: 20px;
            height: 18px;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        
        .hole-cell .btn-mini.minus {
            background: #fee2e2;
            color: #a51c30;
        }
        
        .hole-cell .btn-mini.plus {
            background: #dbeafe;
            color: #1e3a5f;
        }
        
        /* Fullscreen mode - expanded scorecard - fill screen */
        .fullscreen-mode .player-card-compact {
            max-width: 100%;
            margin: 0 8px;
            padding: 16px 16px 12px 16px;
            min-height: calc(100vh - 120px);
            display: flex;
            flex-direction: column;
        }
        
        .fullscreen-mode .holes-grid-6 {
            gap: 8px;
        }
        
        .fullscreen-mode .hole-cell {
            padding: 10px 6px 8px 6px;
            border-radius: 6px;
            height: auto;
            min-height: 140px;
            justify-content: space-between;
        }
        
        .fullscreen-mode .hole-cell .hole-num {
            font-size: 18px;
            margin-bottom: 4px;
        }
        
        .fullscreen-mode .hole-cell .hole-par {
            font-size: 12px;
        }
        
        .fullscreen-mode .hole-cell .hole-hcp {
            font-size: 10px;
            color: #64748b;
            font-weight: 500;
        }
        
        .fullscreen-mode .hole-cell .par-hcp-stack {
            gap: 2px;
            margin-bottom: 6px;
        }
        
        .fullscreen-mode .hole-cell .par-hcp-line {
            font-size: 12px;
            gap: 4px;
        }
        
        .fullscreen-mode .hole-cell .par-hcp-line .label {
            min-width: 26px;
        }
        
        .fullscreen-mode .hole-cell .par-hcp-line .value {
            min-width: 18px;
            font-size: 13px;
        }
        
        .fullscreen-mode .hole-cell .score-cell {
            width: 48px;
            height: 48px;
            font-size: 24px;
        }
        
        .fullscreen-mode .hole-cell .net-score {
            font-size: 14px;
            color: #475569;
            margin-top: 6px;
            font-weight: 700;
        }
        
        .fullscreen-mode .nine-section {
            margin-bottom: 12px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .fullscreen-mode .nine-section-label {
            font-size: 13px;
            margin-bottom: 6px;
            flex-shrink: 0;
        }
        
        .fullscreen-mode .holes-grid-6 {
            flex: 1;
        }
        
        .fullscreen-mode .totals-row {
            padding: 16px 20px;
            margin-top: auto;
            flex-shrink: 0;
        }
        
        .fullscreen-mode .totals-row .total-label {
            font-size: 11px;
        }
        
        .fullscreen-mode .total-value {
            font-size: 22px;
        }
        
        .fullscreen-mode .carousel-nav {
            margin: 8px 12px 12px 12px !important;
        }
        
        .totals-row {
            display: flex;
            justify-content: space-around;
            padding: 10px 8px;
            background: linear-gradient(135deg, #1e3a5f 0%, #1e3a5f 100%);
            border-radius: 8px;
            margin-top: 8px;
        }
        
        .totals-row .total-item {
            text-align: center;
            color: white;
        }
        
        .totals-row .total-label {
            font-size: 10px;
            opacity: 0.8;
        }
        
        .totals-row .total-value {
            font-size: 16px;
            font-weight: 700;
        }
        
        .totals-row .total-value.over-par {
            color: #e57373;
        }
        
        .totals-row .total-value.under-par {
            color: #86efac;
        }
        
        /* Scorecard Color Coding */
        .scorecard-col-claimed {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%) !important;
        }
        
        .scorecard-col-watching {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%) !important;
        }
        
        .scorecard-cell-skin {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%) !important;
            font-weight: 700 !important;
            position: relative;
        }
        
        .scorecard-cell-skin::after {
            content: "🏆";
            position: absolute;
            right: 4px;
            top: 2px;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <!-- Setup Page -->
    <div id="setupPage" class="page active">
        <!-- Sticky Header with Actions -->
        <div class="setup-header-sticky">
            <div class="setup-header-title">
                <h1>⛳ Let's Golf <span style="font-size: 11px; font-weight: 500; color: #6b7280;">by Otis Williams</span> <span id="setupConnectionDot" style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: #166534; margin-left: 6px;"></span></h1>
                <p>Golf Games and Tournaments</p>
            </div>
            <div class="setup-header-actions">
                <button type="button" onclick="startScoring()" style="padding: 10px 14px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;">
                    <span>⛳</span> Start Tournament
                </button>
                <button type="button" onclick="cancelSetup()" style="padding: 10px 14px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;">
                    <span>🏠</span> Back to Home
                </button>
            </div>
        </div>

        <div class="setup-container">
            <div class="form-group">
                <label>Tournament Name <span style="color: #9ca3af; font-weight: 400; font-size: 12px;">(Optional)</span></label>
                <input type="text" id="tournamentName" placeholder="e.g., Saturday Morning Scramble" style="color: #111827;">
            </div>

            <div class="form-group">
                <label>Tournament Date</label>
                <input type="date" id="tournamentDate" placeholder="Select a Date" required>
            </div>

            <div class="form-group">
                <label>Course</label>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <select id="courseSelect" onchange="updateCourse()" style="flex: 1;">
                        <option value="" selected>Select a Course</option>
                        <optgroup label="⭐ Favorites" id="favoritesOptgroup"></optgroup>
                        <optgroup label="➕ Find Course">
                            <option value="search_course">🔍 Search for a Course...</option>
                            <option value="custom_course">✏️ Add Custom Course...</option>
                        </optgroup>
                    </select>
                    <button type="button" id="favoriteBtn" onclick="toggleCurrentCourseFavorite()" 
                        style="width: 40px; height: 40px; border: 1px solid #d1d5db; border-radius: 6px; background: white; font-size: 18px; cursor: pointer; display: none;"
                        title="Add to favorites">☆</button>
                </div>
                <p id="noFavoritesHint" style="font-size: 11px; color: #64748b; margin-top: 6px; display: none;">💡 Search for courses and ⭐ star them to add to your favorites</p>
            </div>
            
            <!-- Tee Selection (shown after course is selected) -->
            <div id="teeSelectionSection" class="form-group" style="display: none;">
                <label>Playing Tees</label>
                <div id="teeButtons" style="display: flex; gap: 8px; flex-wrap: wrap;"></div>
                <div id="teeInfo" style="margin-top: 6px; font-size: 11px; color: #6b7280; text-align: center;"></div>
            </div>

            <div class="form-group">
                <label>Game Type</label>
                <select id="gameType" onchange="handleGameTypeChange()">
                    <option value="Stroke Play" selected>Stroke Play</option>
                    <option value="Skins">Skins</option>
                    <option value="Stableford">Stableford</option>
                    <option value="Stableford (Modified)">Stableford (Modified)</option>
                    <option value="Footlong">Footlong</option>
                    <option value="Nassau">Nassau</option>
                    <option value="Best Ball">Best Ball</option>
                    <option value="Wolf">🐺 Wolf</option>
                    <option value="Vegas">🎰 Vegas</option>
                    <option value="Sixes">🔄 Sixes</option>
                    <option value="Dots">🔵 Dots</option>
                </select>
            </div>

            <!-- Wolf Setup Section (shown when Wolf selected) -->
            <div id="wolfSetupSection" class="form-group" style="display: none;">
                <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border: 2px solid #b45309; border-radius: 6px; padding: 14px;">
                    <div style="font-weight: 700; color: #92400e; font-size: 14px; margin-bottom: 12px; text-align: center;">🐺 Wolf Setup</div>
                    
                    <!-- Player Order -->
                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 11px; color: #92400e; margin-bottom: 6px; font-weight: 600;">Tee Order (drag to reorder):</div>
                        <div id="wolfPlayerOrder" style="display: flex; flex-direction: column; gap: 4px;">
                            <!-- Populated dynamically -->
                        </div>
                        <div style="font-size: 10px; color: #a16207; margin-top: 4px; text-align: center;">Wolf rotates each hole • Wolf tees off last</div>
                    </div>
                    
                    <!-- Wolf Options -->
                    <div style="margin-bottom: 10px;">
                        <div style="font-size: 11px; color: #92400e; margin-bottom: 6px; font-weight: 600;">Options:</div>
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 12px; color: #78350f; margin-bottom: 6px; cursor: pointer;">
                            <input type="checkbox" id="wolfAllowBlind" checked style="width: 16px; height: 16px;">
                            Allow Blind Wolf (3x points)
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 12px; color: #78350f; margin-bottom: 6px; cursor: pointer;">
                            <input type="checkbox" id="wolfAllowPig" style="width: 16px; height: 16px;">
                            Allow Pig (partner rejection, 2x)
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 12px; color: #78350f; cursor: pointer;">
                            <input type="checkbox" id="wolfLastPlaceFinal" checked style="width: 16px; height: 16px;">
                            Last place is Wolf on 17 & 18
                        </label>
                    </div>
                    
                    <!-- Point Values -->
                    <div style="background: white; border-radius: 4px; padding: 10px; margin-top: 10px;">
                        <div style="font-size: 10px; color: #92400e; margin-bottom: 6px; font-weight: 600; text-align: center;">POINT VALUES</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 11px; color: #78350f;">
                            <div>Wolf+Partner win:</div><div style="font-weight: 600;">2 pts each</div>
                            <div>Non-Wolf team wins:</div><div style="font-weight: 600;">3 pts each</div>
                            <div>Lone Wolf wins:</div><div style="font-weight: 600;">4 pts</div>
                            <div>Lone Wolf loses:</div><div style="font-weight: 600;">1 pt each opp</div>
                            <div>Blind Wolf wins:</div><div style="font-weight: 600;">12 pts</div>
                            <div>Blind Wolf loses:</div><div style="font-weight: 600;">3 pts each opp</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Vegas Setup Section (shown when Vegas selected) -->
            <div id="vegasSetupSection" class="form-group" style="display: none;">
                <div style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); border: 2px solid #dc2626; border-radius: 6px; padding: 14px;">
                    <div style="font-weight: 700; color: #dc2626; font-size: 14px; margin-bottom: 12px; text-align: center;">🎰 Vegas Setup</div>
                    
                    <div style="font-size: 12px; color: #991b1b; margin-bottom: 12px; text-align: center;">
                        2v2 Teams • Combine scores into a number • Low number wins
                    </div>
                    
                    <!-- Team Assignment -->
                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 11px; color: #dc2626; margin-bottom: 6px; font-weight: 600;">Teams (drag to assign):</div>
                        <div id="vegasTeamSetup" style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                            <!-- Team A -->
                            <div style="background: #fee2e2; border: 2px solid #f87171; border-radius: 6px; padding: 8px;">
                                <div style="font-weight: 700; color: #dc2626; font-size: 12px; text-align: center; margin-bottom: 6px;">Team A</div>
                                <div id="vegasTeamA" style="min-height: 60px;">
                                    <!-- Populated dynamically -->
                                </div>
                            </div>
                            <!-- Team B -->
                            <div style="background: #dbeafe; border: 2px solid #60a5fa; border-radius: 6px; padding: 8px;">
                                <div style="font-weight: 700; color: #2563eb; font-size: 12px; text-align: center; margin-bottom: 6px;">Team B</div>
                                <div id="vegasTeamB" style="min-height: 60px;">
                                    <!-- Populated dynamically -->
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Vegas Options -->
                    <div style="margin-bottom: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 12px; color: #991b1b; cursor: pointer;">
                            <input type="checkbox" id="vegasFlipRule" checked style="width: 16px; height: 16px;">
                            Flip Rule (birdie flips opponent's number)
                        </label>
                    </div>
                    
                    <!-- How It Works -->
                    <div style="background: white; border-radius: 4px; padding: 10px; margin-top: 10px;">
                        <div style="font-size: 10px; color: #dc2626; margin-bottom: 6px; font-weight: 600; text-align: center;">HOW IT WORKS</div>
                        <div style="font-size: 11px; color: #991b1b; line-height: 1.4;">
                            • Each team combines scores: 4 & 5 = "45"<br>
                            • Lower number wins the difference<br>
                            • Birdie? Flip opponent's number: 36 → 63
                        </div>
                    </div>
                </div>
            </div>

            <!-- Sixes Setup Section (shown when Sixes selected) -->
            <div id="sixesSetupSection" class="form-group" style="display: none;">
                <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border: 2px solid #16a34a; border-radius: 6px; padding: 14px;">
                    <div style="font-weight: 700; color: #16a34a; font-size: 14px; margin-bottom: 12px; text-align: center;">🔄 Sixes (Round Robin)</div>
                    
                    <div style="font-size: 12px; color: #166534; margin-bottom: 12px; text-align: center;">
                        4 Players • Partners rotate every 6 holes
                    </div>
                    
                    <!-- Player Assignment -->
                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 11px; color: #16a34a; margin-bottom: 6px; font-weight: 600;">Player Positions (A, B, C, D):</div>
                        <div id="sixesPlayerSetup" style="display: flex; flex-direction: column; gap: 4px;">
                            <!-- Populated dynamically -->
                        </div>
                    </div>
                    
                    <!-- Rotation Preview -->
                    <div style="background: white; border-radius: 4px; padding: 10px; margin-top: 10px;">
                        <div style="font-size: 10px; color: #16a34a; margin-bottom: 6px; font-weight: 600; text-align: center;">PARTNER ROTATION</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; font-size: 10px; text-align: center;">
                            <div style="background: #dcfce7; padding: 6px; border-radius: 4px;">
                                <div style="font-weight: 700; color: #166534;">Holes 1-6</div>
                                <div style="color: #166534;">A+B vs C+D</div>
                            </div>
                            <div style="background: #dbeafe; padding: 6px; border-radius: 4px;">
                                <div style="font-weight: 700; color: #2563eb;">Holes 7-12</div>
                                <div style="color: #2563eb;">A+C vs B+D</div>
                            </div>
                            <div style="background: #fef3c7; padding: 6px; border-radius: 4px;">
                                <div style="font-weight: 700; color: #b45309;">Holes 13-18</div>
                                <div style="color: #b45309;">A+D vs B+C</div>
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #6b7280; text-align: center; margin-top: 6px;">Best ball each hole • 1 point per hole won</div>
                    </div>
                </div>
            </div>

            <!-- Dots Setup Section (shown when Dots selected) -->
            <div id="dotsSetupSection" class="form-group" style="display: none;">
                <div style="background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border: 2px solid #2563eb; border-radius: 6px; padding: 14px;">
                    <div style="font-weight: 700; color: #2563eb; font-size: 14px; margin-bottom: 12px; text-align: center;">🔵 Dots (Trash/Garbage)</div>
                    
                    <div style="font-size: 12px; color: #1d4ed8; margin-bottom: 12px; text-align: center;">
                        Earn dots for achievements • Most dots wins
                    </div>
                    
                    <!-- Dot Categories -->
                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 11px; color: #2563eb; margin-bottom: 6px; font-weight: 600;">Enabled Dots:</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                            <label style="display: flex; align-items: center; gap: 6px; font-size: 11px; color: #1e40af; cursor: pointer;">
                                <input type="checkbox" id="dotsBirdie" checked style="width: 14px; height: 14px;">
                                🐦 Birdie (+1)
                            </label>
                            <label style="display: flex; align-items: center; gap: 6px; font-size: 11px; color: #1e40af; cursor: pointer;">
                                <input type="checkbox" id="dotsEagle" checked style="width: 14px; height: 14px;">
                                🦅 Eagle (+2)
                            </label>
                            <label style="display: flex; align-items: center; gap: 6px; font-size: 11px; color: #1e40af; cursor: pointer;">
                                <input type="checkbox" id="dotsSandy" checked style="width: 14px; height: 14px;">
                                🏖️ Sandy (+1)
                            </label>
                            <label style="display: flex; align-items: center; gap: 6px; font-size: 11px; color: #1e40af; cursor: pointer;">
                                <input type="checkbox" id="dotsGreenie" checked style="width: 14px; height: 14px;">
                                🎯 Greenie (+1)
                            </label>
                            <label style="display: flex; align-items: center; gap: 6px; font-size: 11px; color: #1e40af; cursor: pointer;">
                                <input type="checkbox" id="dotsPoley" checked style="width: 14px; height: 14px;">
                                🏌️ Poley (+1)
                            </label>
                            <label style="display: flex; align-items: center; gap: 6px; font-size: 11px; color: #dc2626; cursor: pointer;">
                                <input type="checkbox" id="dots3Putt" checked style="width: 14px; height: 14px;">
                                😬 3-Putt (-1)
                            </label>
                        </div>
                    </div>
                    
                    <!-- Dot Definitions -->
                    <div style="background: white; border-radius: 4px; padding: 10px; margin-top: 10px;">
                        <div style="font-size: 10px; color: #2563eb; margin-bottom: 6px; font-weight: 600; text-align: center;">DOT DEFINITIONS</div>
                        <div style="font-size: 10px; color: #1e40af; line-height: 1.5;">
                            <strong>Sandy:</strong> Out of bunker, make par or better<br>
                            <strong>Greenie:</strong> Closest to pin on par 3, make par or better<br>
                            <strong>Poley:</strong> 1-putt from outside flag length
                        </div>
                    </div>
                </div>
            </div>

            <!-- Best Ball Setup Section (shown when Best Ball selected) -->
            <div id="bestBallSetupSection" class="form-group" style="display: none;">
                <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border: 2px solid #166534; border-radius: 6px; padding: 14px;">
                    <div style="font-weight: 700; color: #166534; font-size: 13px; margin-bottom: 10px; text-align: center;">Best Ball Setup</div>
                    
                    <div style="margin-bottom: 10px;">
                        <div style="font-size: 11px; color: #374151; margin-bottom: 6px;">Players per team:</div>
                        <div style="display: flex; gap: 6px;">
                            <button type="button" class="bestball-option-btn" data-field="playersPerTeam" data-value="2" onclick="setBestBallOption('playersPerTeam', 2)" style="flex: 1; padding: 8px; border: 1px solid #166534; background: #166534; color: white; border-radius: 4px; font-weight: 600; font-size: 13px; cursor: pointer;">2</button>
                            <button type="button" class="bestball-option-btn" data-field="playersPerTeam" data-value="3" onclick="setBestBallOption('playersPerTeam', 3)" style="flex: 1; padding: 8px; border: 1px solid #d1d5db; background: white; color: #374151; border-radius: 4px; font-weight: 600; font-size: 13px; cursor: pointer;">3</button>
                            <button type="button" class="bestball-option-btn" data-field="playersPerTeam" data-value="4" onclick="setBestBallOption('playersPerTeam', 4)" style="flex: 1; padding: 8px; border: 1px solid #d1d5db; background: white; color: #374151; border-radius: 4px; font-weight: 600; font-size: 13px; cursor: pointer;">4</button>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <div style="font-size: 11px; color: #374151; margin-bottom: 6px;">Scores to count per hole:</div>
                        <div style="display: flex; gap: 6px;">
                            <button type="button" class="bestball-option-btn" data-field="scoresPerHole" data-value="1" onclick="setBestBallOption('scoresPerHole', 1)" style="flex: 1; padding: 8px; border: 1px solid #166534; background: #166534; color: white; border-radius: 4px; font-weight: 600; font-size: 13px; cursor: pointer;">1</button>
                            <button type="button" class="bestball-option-btn" data-field="scoresPerHole" data-value="2" onclick="setBestBallOption('scoresPerHole', 2)" style="flex: 1; padding: 8px; border: 1px solid #d1d5db; background: white; color: #374151; border-radius: 4px; font-weight: 600; font-size: 13px; cursor: pointer;">2</button>
                            <button type="button" class="bestball-option-btn" data-field="scoresPerHole" data-value="3" onclick="setBestBallOption('scoresPerHole', 3)" style="flex: 1; padding: 8px; border: 1px solid #d1d5db; background: white; color: #374151; border-radius: 4px; font-weight: 600; font-size: 13px; cursor: pointer;">3</button>
                        </div>
                    </div>
                    
                    <div>
                        <div style="font-size: 11px; color: #374151; margin-bottom: 6px;">Format:</div>
                        <div style="display: flex; gap: 6px;">
                            <button type="button" class="bestball-option-btn" data-field="format" data-value="stroke" onclick="setBestBallOption('format', 'stroke')" style="flex: 1; padding: 8px; border: 1px solid #166534; background: #166534; color: white; border-radius: 4px; font-weight: 600; font-size: 12px; cursor: pointer;">Stroke Play</button>
                            <button type="button" class="bestball-option-btn" data-field="format" data-value="match" onclick="setBestBallOption('format', 'match')" style="flex: 1; padding: 8px; border: 1px solid #d1d5db; background: white; color: #374151; border-radius: 4px; font-weight: 600; font-size: 12px; cursor: pointer;">Match Play</button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="teamSetupSection" class="form-group" style="display: none;">
                <label>Team Setup</label>
                <div id="teamSetupContent"></div>
            </div>

            <div class="form-group">
                <label>Players & Handicaps</label>
                
                <!-- Add Player and Quick Add Side by Side - Swapped positions -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
                    <button type="button" onclick="addPlayerRow()" id="addPlayerBtn" 
                        style="padding: 8px 10px; background: #1e3a5f; border: none; border-radius: 6px; color: white; font-size: 12px; font-weight: 600; cursor: pointer; display: flex; flex-direction: row; align-items: center; justify-content: center; gap: 6px;">
                        <span style="font-size: 14px; font-weight: 700;">+</span> Add Player
                    </button>
                    <button type="button" id="quickAddBtn" onclick="showQuickAddModal()" 
                        style="padding: 8px 10px; background: white; border: 1px solid #1e3a5f; border-radius: 6px; color: #1e3a5f; font-size: 12px; font-weight: 600; cursor: pointer; display: none; flex-direction: row; align-items: center; justify-content: center; gap: 6px;">
                        👥 Quick Add
                    </button>
                </div>
                
                <!-- GHIN Toggle -->
                <label id="setupGhinToggle" style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0; margin-bottom: 10px;">
                    <input type="checkbox" id="setupUseGhinCheckbox" class="ghin-checkbox" onchange="toggleSetupGhinMode(this.checked)" checked>
                    <span style="color: #475569; font-weight: 600; font-size: 13px;">Use GHIN Handicap Index</span>
                    <span id="setupGhinHint" style="font-size: 11px; color: #64748b; margin-left: auto;">Enter GHIN Index</span>
                </label>
                
                <!-- Column Headers - 2 column default, 3 column in GHIN mode -->
                <div id="setupColumnHeaders" style="display: grid; grid-template-columns: 1fr 55px 45px; gap: 6px; margin-bottom: 6px; padding: 0 4px;">
                    <div style="font-size: 10px; color: #6b7280; font-weight: 600; text-transform: uppercase;">Name</div>
                    <div id="setupHcpHeader" style="font-size: 10px; color: #6b7280; font-weight: 600; text-transform: uppercase; text-align: center;">H.I.</div>
                    <div id="setupCourseHcpHeader" style="font-size: 10px; color: #166534; font-weight: 600; text-transform: uppercase; text-align: center; display: block;">Course</div>
                </div>
                
                <div class="player-list" id="playerList">
                    <div class="player-row-wrapper">
                        <div class="player-row-delete" onclick="removePlayer(1)">Delete</div>
                        <div class="player-row ghin-mode" data-player="1">
                            <input type="text" class="player-name-input" placeholder="Player Name" id="player1">
                            <input type="text" class="player-hcp-input" placeholder="H.I." id="hcp1" pattern="-?[0-9.]*" inputmode="decimal" step="0.1" oninput="updateSetupCourseHcp(1)">
                            <span class="player-course-hcp" id="courseHcp1" style="display: block;"></span>
                        </div>
                    </div>
                </div>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importTournamentBackup(event)">
            </div>
            
            <!-- Tournament Privacy Settings -->
            <div class="form-group">
                <label style="display: flex; align-items: center; gap: 8px;">
                    <span>🔒</span> Tournament Privacy
                </label>
                <div style="background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 6px; padding: 14px;">
                    <!-- View Leaderboard Toggle -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <div>
                            <div style="font-weight: 600; color: #111827; font-size: 13px;">Players can view leaderboard</div>
                            <div style="font-size: 10px; color: #6b7280;">Results, summary table, other scorecards</div>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="privacyViewLeaderboard" checked onchange="updatePrivacyToggles()">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <!-- Signed Early Toggle (only shows when leaderboard is OFF) -->
                    <div id="privacySignedEarlySection" style="display: none; margin-left: 16px; margin-bottom: 12px; padding-left: 12px; border-left: 2px solid #e5e7eb;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-weight: 600; color: #111827; font-size: 13px;">Signed players can view early</div>
                                <div style="font-size: 10px; color: #6b7280;">Unlock after signing scorecard</div>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="privacySignedEarly">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <!-- Watch Others Toggle -->
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-weight: 600; color: #111827; font-size: 13px;">Players can watch others</div>
                            <div style="font-size: 10px; color: #6b7280;">Watch players they haven't claimed</div>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="privacyWatchOthers" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>

            <button type="button" class="btn btn-primary" id="resumeScoringBtn" style="background: #166534; display: none;" onclick="resumeScoring()">Resume Scoring</button>
        </div>
    </div>

    <!-- Scoring Page -->
    <div id="scoringPage" class="page">
        <!-- Round in Progress Indicator -->
        <div id="roundIndicator" class="round-indicator">
            <span class="round-indicator-icon"></span>
            <span>Round in Progress • Auto-saved</span>
        </div>
        
        <!-- Voice Listening Overlay -->
        <div id="voiceListening" class="voice-listening">
            <div class="mic-icon">🎤</div>
            <div class="voice-text">Listening...</div>
            <div class="voice-result" id="voiceResult"></div>
        </div>
        
        <!-- Expanded Score Input Modal -->
        <div id="expandedScoreModal" class="expanded-score-modal">
            <div class="expanded-score-content">
                <div class="expanded-hole-header">
                    <div class="expanded-hole-number" id="expandedHoleNumber">HOLE 1</div>
                    <div class="expanded-hole-info" id="expandedHoleInfo">Par 4 • HCP 5</div>
                </div>
                <div class="expanded-player-name" id="expandedPlayerName">Player Name</div>
                <div class="expanded-score-display">
                    <button class="expanded-score-btn minus" onclick="expandedDecrement()">−</button>
                    <div class="expanded-score-value" id="expandedScoreValue">-</div>
                    <button class="expanded-score-btn plus" onclick="expandedIncrement()">+</button>
                </div>
                <div class="expanded-quick-scores" id="expandedQuickScores">
                    <!-- Quick score buttons populated dynamically -->
                </div>
                <div class="expanded-actions">
                    <button onclick="closeExpandedScore()" style="background: #d4b896; color: #1e3a5f; border: none;">Cancel</button>
                    <button onclick="saveExpandedScore()" style="background: #1e3a5f; color: white; border: none;">Save</button>
                </div>
            </div>
        </div>
        
        <!-- Putt Input Popup -->
        <div id="puttPopup" class="putt-popup">
            <div class="putt-popup-content">
                <div class="putt-popup-title">Putts</div>
                <div class="putt-popup-info" id="puttPopupInfo">Hole 1 • Par 4</div>
                <div class="putt-options" id="puttOptions">
                    <!-- Putt buttons populated dynamically -->
                </div>
                <button class="putt-clear-btn" onclick="clearPutt()">Clear</button>
            </div>
        </div>
        
        <!-- Wolf Decision Modal -->
        <div id="wolfDecisionModal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 10000; display: none; align-items: center; justify-content: center; padding: 16px;">
            <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-radius: 12px; max-width: 360px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
                <!-- Header -->
                <div style="background: linear-gradient(135deg, #92400e 0%, #b45309 100%); padding: 16px; border-radius: 12px 12px 0 0; text-align: center;">
                    <div style="font-size: 28px; margin-bottom: 4px;">🐺</div>
                    <div id="wolfDecisionHoleInfo" style="color: white; font-size: 18px; font-weight: 700;">Hole 1</div>
                    <div id="wolfDecisionWolfName" style="color: #fde68a; font-size: 14px; margin-top: 4px;"></div>
                </div>
                
                <div style="padding: 16px;">
                    <!-- Blind Wolf Option (before tee shots) -->
                    <div id="wolfBlindOption" style="margin-bottom: 16px;">
                        <button onclick="declareBlindWolf()" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%); color: white; border: none; border-radius: 8px; font-size: 15px; font-weight: 700; cursor: pointer; box-shadow: 0 2px 8px rgba(220,38,38,0.3);">
                            🎯 BLIND WOLF (3x Points!)
                        </button>
                        <div style="text-align: center; font-size: 11px; color: #92400e; margin-top: 4px;">Declare before anyone hits • High risk, high reward!</div>
                    </div>
                    
                    <!-- Divider -->
                    <div style="text-align: center; margin: 12px 0; position: relative;">
                        <div style="position: absolute; top: 50%; left: 0; right: 0; height: 1px; background: #d4a373;"></div>
                        <span style="position: relative; background: #fef3c7; padding: 0 12px; color: #92400e; font-size: 11px; font-weight: 600;">OR PICK A PARTNER</span>
                    </div>
                    
                    <!-- Partner Selection -->
                    <div id="wolfPartnerOptions" style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 16px;">
                        <!-- Populated dynamically -->
                    </div>
                    
                    <!-- Lone Wolf Option (after seeing all shots) -->
                    <div id="wolfLoneOption" style="margin-top: 12px;">
                        <button onclick="declareLoneWolf()" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 700; cursor: pointer;">
                            🐺 GO LONE WOLF (2x Points)
                        </button>
                        <div style="text-align: center; font-size: 11px; color: #92400e; margin-top: 4px;">Play alone against everyone</div>
                    </div>
                    
                    <!-- Skip/Default -->
                    <button onclick="closeWolfDecisionModal()" style="width: 100%; padding: 10px; background: transparent; color: #92400e; border: 1px solid #d4a373; border-radius: 6px; font-size: 13px; cursor: pointer; margin-top: 12px;">
                        Decide Later
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Wolf Hole Result Modal -->
        <div id="wolfResultModal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 10000; align-items: center; justify-content: center; padding: 16px;">
            <div style="background: white; border-radius: 12px; max-width: 340px; width: 100%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
                <div style="background: linear-gradient(135deg, #92400e 0%, #b45309 100%); padding: 16px; border-radius: 12px 12px 0 0; text-align: center;">
                    <div style="font-size: 24px;">🐺</div>
                    <div id="wolfResultHoleInfo" style="color: white; font-size: 16px; font-weight: 700;">Hole 1 Result</div>
                </div>
                <div id="wolfResultContent" style="padding: 20px; text-align: center;">
                    <!-- Populated dynamically -->
                </div>
                <div style="padding: 0 16px 16px;">
                    <button onclick="closeWolfResultModal()" style="width: 100%; padding: 12px; background: #92400e; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                        Continue
                    </button>
                </div>
            </div>
        </div>
        
        <div class="scoring-header">
            <!-- Row 1: Title with Connection Dot -->
            <div style="text-align: center; display: flex; align-items: center; justify-content: center; gap: 6px;">
                <h2 style="color: #1e3a5f; font-size: 16px; margin: 0;">⛳ Let's Golf <span style="font-size: 10px; font-weight: 500; color: #6b7280;">by Otis Williams</span></h2>
                <span id="scoringConnectionDot" title="Connection status" style="width: 8px; height: 8px; border-radius: 50%; background: #166534; flex-shrink: 0;"></span>
            </div>
            
            <!-- Row 2: Smart Info Line -->
            <div style="text-align: center;">
                <p id="scoringSmartInfo" style="font-size: 11px; color: #1e3a5f; font-weight: 600; margin: 0;"></p>
            </div>
            
            <!-- Row 3: Navigation Buttons - all no fill except tan for manage/my players -->
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 6px; padding: 0 4px;">
                <button type="button" onclick="confirmBackToHome()" style="flex: 1; height: 40px; border-radius: 6px; border: 1.5px solid #1e3a5f; background: white; color: #1e3a5f; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Home">🏠</button>
                <button type="button" id="managePlayersBtn" onclick="showPlayerManagement()" style="display: none; flex: 1; height: 40px; border-radius: 6px; border: 1.5px solid rgba(180, 130, 80, 0.5); background: rgba(212, 165, 116, 0.7); color: #78350f; font-size: 18px; cursor: pointer; align-items: center; justify-content: center;" title="Manage Tournament">⚙️</button>
                <button type="button" id="myPlayersBtnHeader" onclick="showMyPlayersPage()" style="display: none; flex: 1; height: 40px; border-radius: 6px; border: 1.5px solid rgba(180, 130, 80, 0.5); background: rgba(212, 165, 116, 0.7); color: #78350f; font-size: 18px; cursor: pointer; align-items: center; justify-content: center;" title="My Players">👤</button>
                <button type="button" onclick="openScorecardModal()" style="flex: 1; height: 40px; border-radius: 6px; border: 1.5px solid #1e3a5f; background: white; color: #1e3a5f; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Scorecard">📋</button>
                <button type="button" id="finishRoundBtn" onclick="showPage('resultsPage')" style="flex: 1; height: 40px; border-radius: 6px; border: 1.5px solid #1e3a5f; background: white; color: #1e3a5f; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Results">🏆</button>
            </div>
            
            <!-- Row 4: Toggle Buttons - Navy blue active state -->
            <div style="display: flex; justify-content: center; gap: 10px;">
                <div class="btn-toggle-group" style="display: flex; background: #e5e7eb; border-radius: 6px; padding: 2px;">
                    <button type="button" id="toggleHoleView" class="toggle-btn active" onclick="switchToHoleView()" style="padding: 6px 14px; font-size: 12px; font-weight: 600; border-radius: 4px; border: none; background: #1e3a5f; color: white; cursor: pointer;">⛳ Holes</button>
                    <button type="button" id="togglePlayerView" class="toggle-btn" onclick="switchToPlayerView()" style="padding: 6px 14px; font-size: 12px; font-weight: 600; border-radius: 4px; border: none; background: transparent; color: #6b7280; cursor: pointer;">👤 Players</button>
                </div>
                <div class="btn-toggle-group" style="display: flex; background: #e5e7eb; border-radius: 6px; padding: 2px;">
                    <button type="button" class="toggle-btn active" id="keyboardModeBtn" onclick="setInputMode('keyboard')" style="padding: 6px 14px; font-size: 12px; font-weight: 600; border-radius: 4px; border: none; background: #1e3a5f; color: white; cursor: pointer;">👆 Touch</button>
                    <button type="button" class="toggle-btn" id="voiceModeBtn" onclick="setInputMode('voice')" style="padding: 6px 14px; font-size: 12px; font-weight: 600; border-radius: 4px; border: none; background: transparent; color: #6b7280; cursor: pointer;">🎤 Voice</button>
                </div>
            </div>
            
            <!-- Hidden host badge for JS compatibility -->
            <span id="scoringHostBadge" style="display: none;"></span>
        </div>

        <div class="scoring-content">

            <div id="playerCards"></div>
            
            <!-- By Hole View (hidden by default) -->
            <div id="holeView" style="display: none;">
                <div id="holeViewContent"></div>
            </div>
        </div>
    </div>

    <!-- Results Page -->
    <div id="resultsPage" class="page">
        <div class="results-sticky-header">
            <div class="results-page-header">
                <!-- Row 1: Title with Connection Dot -->
                <div style="text-align: center; display: flex; align-items: center; justify-content: center; gap: 6px;">
                    <h2 style="color: #1e3a5f; font-size: 16px; margin: 0;">🏆 Let's Golf <span style="font-size: 10px; font-weight: 500; color: #6b7280;">by Otis Williams</span></h2>
                    <span id="resultsConnectionDot" title="Connection status" style="width: 8px; height: 8px; border-radius: 50%; background: #166534; flex-shrink: 0;"></span>
                </div>
                
                <!-- Row 2: Smart Info Line -->
                <div style="text-align: center;">
                    <p id="resultsSmartInfo" style="font-size: 11px; color: #1e3a5f; font-weight: 600; margin: 0;"></p>
                </div>
                
                <!-- Row 3: Navigation Buttons - all no fill except tan for manage/my players -->
                <div style="display: flex; justify-content: space-between; align-items: center; gap: 6px; padding: 0 4px;">
                    <button type="button" onclick="confirmBackToHome()" style="flex: 1; height: 40px; border-radius: 6px; border: 1.5px solid #1e3a5f; background: white; color: #1e3a5f; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Home">🏠</button>
                    <button type="button" id="resultsManageBtn" onclick="showPlayerManagement()" style="display: none; flex: 1; height: 40px; border-radius: 6px; border: 1.5px solid rgba(180, 130, 80, 0.5); background: rgba(212, 165, 116, 0.7); color: #78350f; font-size: 18px; cursor: pointer; align-items: center; justify-content: center;" title="Manage Tournament">⚙️</button>
                    <button type="button" id="resultsMyPlayersBtn" onclick="showMyPlayersPage()" style="display: none; flex: 1; height: 40px; border-radius: 6px; border: 1.5px solid rgba(180, 130, 80, 0.5); background: rgba(212, 165, 116, 0.7); color: #78350f; font-size: 18px; cursor: pointer; align-items: center; justify-content: center;" title="My Players">👤</button>
                    <button type="button" id="resultsScorecardBtn" onclick="openScorecardModal()" style="flex: 1; height: 40px; border-radius: 6px; border: 1.5px solid #1e3a5f; background: white; color: #1e3a5f; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="View Scorecards">📋</button>
                    <button type="button" onclick="showPage('scoringPage')" style="flex: 1; height: 40px; border-radius: 6px; border: 1.5px solid #1e3a5f; background: white; color: #1e3a5f; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Scoring">🏌️‍♂️</button>
                </div>
                
                <!-- Row 4: Tournament / Side Game Toggle (shown in tourney mode) -->
                <div id="resultsModeToggleRow" style="display: flex; justify-content: center;">
                    <div style="display: flex; background: #e5e7eb; border-radius: 6px; padding: 3px;">
                        <button type="button" id="tourneyModeToggle" onclick="setResultsMode('tourney')" style="padding: 10px 24px; font-size: 13px; font-weight: 600; border-radius: 5px; border: none; background: #1e3a5f; color: white; cursor: pointer;">Tournament</button>
                        <button type="button" id="sideGameModeToggle" onclick="setResultsMode('sideGame')" style="padding: 10px 24px; font-size: 13px; font-weight: 600; border-radius: 5px; border: none; background: transparent; color: #6b7280; cursor: pointer;">Side Game</button>
                    </div>
                </div>
                
                <!-- Row 4 Alt: Side Game buttons (shown in side game mode) -->
                <div id="resultsSideGameBtnRow" style="display: none; justify-content: center; gap: 10px;">
                    <button type="button" onclick="setResultsMode('tourney')" style="padding: 8px 16px; font-size: 12px; font-weight: 600; border-radius: 6px; border: none; background: #1e3a5f; color: white; cursor: pointer;">← Back to Tournament</button>
                    <button type="button" onclick="showResultsBestBallSetup()" style="padding: 8px 16px; font-size: 12px; font-weight: 600; border-radius: 6px; border: 1px solid #1e3a5f; background: white; color: #1e3a5f; cursor: pointer;">Edit Teams</button>
                </div>
                
                <!-- Hidden elements for backward compatibility -->
                <span id="resultsHostBadge" style="display: none;"></span>
                <div id="resultsTourneyHeaderRow" style="display: none;"></div>
                <div id="resultsSideGameHeaderRow" style="display: none;"></div>
                <div id="resultsFilterToggleHeader" style="display: none;">
                    <button type="button" id="resultsToggleMineHeader" style="display: none;"></button>
                    <button type="button" id="resultsToggleAllHeader" style="display: none;"></button>
                </div>
                <div id="tourneyToggleHeader" style="display: none;">
                    <button type="button" id="tourneyModeBtnHeader" style="display: none;"></button>
                    <button type="button" id="sideGameModeBtnHeader" style="display: none;"></button>
                </div>
            </div>
        </div>

        <div class="results-container">
            <!-- Settings Card - Tournament Mode -->
            <div id="resultsSettingsCard" style="background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 6px; padding: 12px; margin-bottom: 10px;">
                <!-- Row 1: Game Type Dropdown + My Players/All Players Toggle -->
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                    <select id="resultsGameType" onchange="updateResultsGameType()" style="padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; background: white; color: #374151;">
                        <option value="Stroke Play">Stroke Play</option>
                        <option value="Skins">Skins</option>
                        <option value="Stableford">Stableford</option>
                        <option value="Stableford (Modified)">Stableford (Modified)</option>
                        <option value="Footlong">Footlong</option>
                        <option value="Nassau">Nassau</option>
                    </select>
                    <div id="resultsFilterToggle" style="display: flex; background: #e5e7eb; border-radius: 6px; padding: 2px;">
                        <button type="button" id="resultsToggleMine" onclick="setResultsFilter('mine')" style="padding: 6px 10px; font-size: 11px; font-weight: 500; border-radius: 4px; border: none; background: transparent; color: #6b7280; cursor: pointer; white-space: nowrap;">My Players</button>
                        <button type="button" id="resultsToggleAll" onclick="setResultsFilter('all')" style="padding: 6px 10px; font-size: 11px; font-weight: 500; border-radius: 4px; border: none; background: #1e3a5f; color: white; cursor: pointer; white-space: nowrap;">All Players</button>
                    </div>
                </div>
                
                <!-- Row 2: Scoring Method Buttons - rectangular -->
                <div style="display: flex; gap: 8px;">
                    <button type="button" id="scoringMethodGross" onclick="setScoringMethod('gross')" 
                        style="flex: 1; padding: 10px 8px; border: none; background: #1e3a5f; color: white; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                        Gross
                    </button>
                    <button type="button" id="scoringMethodNet" onclick="setScoringMethod('net')" 
                        style="flex: 1; padding: 10px 8px; border: 1px solid #d1d5db; background: white; color: #374151; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                        Net
                    </button>
                    <button type="button" id="scoringMethodNet18" onclick="setScoringMethod('net18')" 
                        style="flex: 1; padding: 10px 8px; border: 1px solid #d1d5db; background: white; color: #374151; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                        Net 18
                    </button>
                    <button type="button" id="scoringMethodNetHalf" onclick="setScoringMethod('netHalf')" 
                        style="flex: 1; padding: 10px 8px; border: 1px solid #d1d5db; background: white; color: #9ca3af; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer; opacity: 0.5;" disabled>
                        Net ½
                    </button>
                </div>
            </div>
            
            <!-- Settings Card - Side Game Mode (hidden by default) -->
            <div id="sideGameSettingsCard" style="display: none; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 6px; padding: 12px; margin-bottom: 10px;">
                <!-- Scoring Method Buttons for Side Game - medium blue active -->
                <div style="display: flex; gap: 8px;">
                    <button type="button" id="sideGameMethodGross" onclick="setScoringMethod('gross')" 
                        style="flex: 1; padding: 10px 8px; border: none; background: #1e3a5f; color: white; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                        Gross
                    </button>
                    <button type="button" id="sideGameMethodNet" onclick="setScoringMethod('net')" 
                        style="flex: 1; padding: 10px 8px; border: 1px solid #d1d5db; background: white; color: #374151; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                        Net
                    </button>
                    <button type="button" id="sideGameMethodNet18" onclick="setScoringMethod('net18')" 
                        style="flex: 1; padding: 10px 8px; border: 1px solid #d1d5db; background: white; color: #374151; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                        Net 18
                    </button>
                    <button type="button" id="sideGameMethodNetHalf" onclick="setScoringMethod('netHalf')" 
                        style="flex: 1; padding: 10px 8px; border: 1px solid #d1d5db; background: white; color: #9ca3af; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer; opacity: 0.5;" disabled>
                        Net ½
                    </button>
                </div>
            </div>
            
            <!-- Hidden elements for backward compatibility -->
            <div id="resultsRow1" style="display: none;"></div>
            <div id="resultsFilterRow" style="display: none;"></div>
            <div id="tourneyToggleContainer" style="display: none;">
                <button id="tourneyModeBtn" style="display: none;"></button>
                <button id="sideGameModeBtn" style="display: none;"></button>
            </div>
            
            <!-- Live Status Row -->
            <div id="liveUpdateIndicator" style="display: flex; align-items: center; justify-content: center; gap: 6px; margin-bottom: 10px; padding: 6px 0;">
                <span style="width: 8px; height: 8px; border-radius: 50%; background: #166534; animation: pulse 2s infinite;"></span>
                <span id="leaderboardStatusText" style="font-size: 12px; color: #1e3a5f; font-weight: 600;"></span>
            </div>
            
            <!-- Leaderboard Card -->
            <div style="background: white; border: 1px solid #e5e7eb; border-radius: 8px; padding: 0; overflow: hidden; box-shadow: 0 2px 8px rgba(30, 58, 95, 0.1);">
                <!-- Trophy Header - Navy Blue -->
                <div style="background: linear-gradient(135deg, #1e3a5f, #2d4a6f); padding: 10px 16px; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <span style="font-size: 18px;">🏆</span>
                    <span style="font-size: 14px; font-weight: 700; color: white; text-transform: uppercase; letter-spacing: 1px;">Leaderboard</span>
                    <span style="font-size: 18px;">🏆</span>
                </div>
                
                <!-- Results Content -->
                <div id="resultsContent" style="padding: 12px; background: white;">
                    <!-- Generated dynamically -->
                </div>
            </div>
            
            <!-- Foursome Games Results Card (Wolf, Vegas, Sixes, Dots) -->
            <div id="foursomeGamesCard" style="display: none; margin-top: 12px; background: white; border: 1px solid #e5e7eb; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 8px rgba(30, 58, 95, 0.1);">
                <!-- Dynamic Header based on game type -->
                <div id="foursomeGamesHeader" style="padding: 10px 16px; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <!-- Populated by game type -->
                </div>
                
                <!-- Game Results Content -->
                <div id="foursomeGamesContent" style="padding: 12px; background: white;">
                    <!-- Generated dynamically -->
                </div>
            </div>
            
            <!-- IHMC Publish Banner (shown when linked to IHMC event) -->
            <div id="ihmcPublishBanner" style="display: none; margin-top: 12px; background: linear-gradient(135deg, #1a3a2f 0%, #2d5a4a 100%); border-radius: 8px; padding: 16px; box-shadow: 0 2px 8px rgba(26, 58, 47, 0.2);">
                <div style="display: flex; align-items: center; justify-content: space-between; gap: 12px;">
                    <div style="flex: 1;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                            <span style="font-size: 16px;">🏌️‍♂️</span>
                            <span style="color: #c9a227; font-size: 11px; font-weight: 600; letter-spacing: 1px;">IHMC EVENT</span>
                        </div>
                        <div id="ihmcEventNameDisplay" style="color: white; font-size: 14px; font-weight: 600;"></div>
                    </div>
                    <button onclick="showPublishToIHMCModal()" style="padding: 10px 16px; background: #c9a227; color: #1a3a2f; border: none; border-radius: 6px; font-size: 13px; font-weight: 700; cursor: pointer; white-space: nowrap;">
                        📤 Publish Results
                    </button>
                </div>
            </div>
            
        </div>
    </div>

    <!-- Scorecard Modal -->
    <div id="scorecardModal" class="scorecard-modal">
        <div class="scorecard-content">
            <div class="scorecard-header">
                <h2 style="color: #1e3a5f; margin: 0; display: flex; align-items: center; gap: 8px;">⛳ Scorecards</h2>
                <button onclick="closeScorecardModal()" style="background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; padding: 8px 16px; font-weight: 600; cursor: pointer; font-size: 13px;">✕ Close</button>
            </div>
            <div style="padding: 20px; border-bottom: 1px solid #e2e8f0;">
                <label style="font-weight: 600; color: #1e3a5f; margin-bottom: 8px; display: block;">Select View:</label>
                <select id="scorecardViewSelect" onchange="updateScorecardView()" style="width: 100%; padding: 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; color: #1e3a5f;">
                    <option value="all-summary">All Players - Summary Table</option>
                    <option value="all-individual">All Players - Individual Cards</option>
                    <option disabled>─────────────────</option>
                </select>
            </div>
            <div class="scorecard-body" id="scorecardBody">
                <!-- Scorecard content will be populated here -->
            </div>
            <div class="scorecard-footer">
                <button onclick="openFullScorecardPreview()" class="btn btn-primary" style="background: #1e3a5f; margin: 0; border-radius: 4px;">👁️ Full Scorecard</button>
            </div>
        </div>
    </div>

    <!-- Printable Scorecard (Hidden, only shows when printing) -->
    <div id="printableScorecard" class="print-scorecard"></div>

    <!-- Auto-save Toast -->
    <div id="autoSaveToast" class="auto-save-toast">✓ Saved</div>

    <!-- Join Tournament Page -->
    <div id="joinPage" class="page">
        <div class="card">
            <div class="tournament-info-centered">
                <p style="font-size: 32px;">⛳</p>
                <h2 style="color: #1e3a5f;">Join Tournament</h2>
                <p id="joinTournamentInfo" style="margin-top: 8px; color: #6b7280;">Loading...</p>
            </div>

            <!-- Quick Add Section - Players to Claim or Watch -->
            <div id="joinExistingPlayers" style="margin-top: 24px; display: none;">
                <h3 style="color: #1e3a5f; font-size: 16px; margin-bottom: 8px; text-align: center;">Select Players</h3>
                <p style="color: #6b7280; font-size: 12px; margin-bottom: 16px; text-align: center;">Tap to claim (you'll score) or watch (view only)</p>
                <div id="existingPlayersList"></div>
                
                <!-- Selection Summary -->
                <div id="selectionSummary" style="display: none; margin-top: 16px; padding: 12px; background: rgba(212, 165, 116, 0.15); border: 2px solid rgba(180, 130, 80, 0.5); border-radius: 6px;">
                    <div style="font-size: 12px; color: #78350f;">
                        <span id="claimCount">0</span> to score • <span id="watchCount">0</span> watching
                    </div>
                </div>
            </div>

            <!-- Join Tournament Button (NOW ABOVE DIVIDER) -->
            <div id="joinTournamentBtnContainer" style="display: none; margin-top: 20px;">
                <button type="button" onclick="executeJoinTournament()" 
                    style="width: 100%; padding: 14px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">
                    🏌️‍♂️ Join Tournament
                </button>
            </div>

            <!-- Divider -->
            <div id="joinDivider" style="display: none; margin: 24px 0; text-align: center; position: relative;">
                <div style="position: absolute; top: 50%; left: 0; right: 0; height: 1px; background: linear-gradient(90deg, transparent, #d1d5db, transparent);"></div>
                <span style="position: relative; background: white; padding: 0 16px; color: #9ca3af; font-size: 12px; font-weight: 600;">OR</span>
            </div>

            <!-- Bottom Options -->
            <div id="joinBottomOptions" style="display: none;">
                <!-- Viewer Option -->
                <button type="button" id="viewerJoinBtn" onclick="joinAsViewer()"
                    style="width: 100%; padding: 14px 20px; margin-bottom: 12px; background: #f9fafb; border: 1px solid #d1d5db; border-radius: 6px; color: #374151; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px;">
                    <span style="font-size: 20px;">👁</span>
                    <span>Join as Viewer</span>
                </button>
                
                <!-- Add New Player (for players not in list) -->
                <button type="button" onclick="showAddNewPlayerForm()"
                    style="width: 100%; padding: 14px 20px; background: rgba(212, 165, 116, 0.2); border: 2px solid rgba(180, 130, 80, 0.5); border-radius: 6px; color: #78350f; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px;">
                    <span style="font-size: 20px;">➕</span>
                    <span>I'm Not Listed - Add Me</span>
                </button>
            </div>

            <!-- Cancel Button -->
            <div style="margin-top: 16px;">
                <button type="button" onclick="showGuestHomePage()" style="width: 100%; padding: 12px; background: transparent; color: #6b7280; border: none; font-size: 13px; cursor: pointer;">
                    Cancel
                </button>
            </div>
            
            <!-- Hidden form for adding new player -->
            <form id="joinTournamentForm" style="display: none; margin-top: 24px;">
                <h3 style="color: #1e3a5f; font-size: 16px; margin-bottom: 16px; text-align: center;">Add New Player</h3>
                
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 12px; margin-bottom: 16px;">
                    <div>
                        <label style="display: block; margin-bottom: 8px; color: #374151; font-weight: 600; font-size: 13px;">Your Name</label>
                        <input type="text" id="joinPlayerName" placeholder="Enter your name" required style="width: 100%; padding: 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; color: #111827;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 8px; color: #374151; font-weight: 600; font-size: 13px;">Handicap</label>
                        <input type="number" id="joinPlayerHandicap" min="-10" max="54" step="1" placeholder="0" required style="width: 100%; padding: 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; text-align: center; color: #111827;">
                    </div>
                </div>
                
                <input type="hidden" id="joinPlayerEmail" value="">
                <input type="hidden" id="joinPlayerPhone" value="">

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 16px;">
                    <button type="button" onclick="hideAddNewPlayerForm()" style="padding: 12px; background: #f9fafb; color: #374151; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer;">
                        Back
                    </button>
                    <button type="submit" style="padding: 12px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer;">
                        Add & Join
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Account Modal -->
    <div id="accountModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center; overflow-y: auto;">
        <div style="background: white; border-radius: 6px; padding: 24px; margin: 20px; max-width: 400px; width: 90%; box-shadow: 0 4px 12px rgba(0,0,0,0.2); max-height: 90vh; overflow-y: auto;">
            <div id="accountLoggedOut">
                <h3 style="color: #1e3a5f; margin-bottom: 8px; font-size: 20px; text-align: center;">👤 Account</h3>
                <p style="color: #64748b; font-size: 13px; text-align: center; margin-bottom: 20px;">Sign in to unlock multi-device scoring and unlimited players</p>
                
                <div id="authForm">
                    <div id="authError" style="display: none; color: #a51c30; font-size: 13px; margin-bottom: 12px; text-align: center; padding: 10px; background: #fef2f2; border-radius: 6px;"></div>
                    <div id="authSuccess" style="display: none; color: #166534; font-size: 13px; margin-bottom: 12px; text-align: center; padding: 10px; background: #f0fdf4; border-radius: 6px;"></div>
                    
                    <button type="button" onclick="showSignInModal()" style="width: 100%; padding: 14px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 8px;">Sign In</button>
                    <button type="button" onclick="showCreateAccountModal()" style="width: 100%; padding: 14px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">Create Account</button>
                </div>
            </div>
            
            <!-- Sign In Modal -->
            <div id="signInModal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 10000; align-items: center; justify-content: center; padding: 16px;">
                <div style="background: white; border-radius: 12px; max-width: 360px; width: 100%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
                    <div style="padding: 20px; border-bottom: 1px solid #e5e7eb;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <h3 style="margin: 0; color: #1e3a5f; font-size: 18px;">🔐 Sign In</h3>
                            <button type="button" onclick="closeSignInModal()" style="background: none; border: none; font-size: 24px; color: #64748b; cursor: pointer;">×</button>
                        </div>
                    </div>
                    <div style="padding: 20px;">
                        <div style="margin-bottom: 12px;">
                            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">Email</label>
                            <input type="email" id="signInEmail" placeholder="your@email.com" style="width: 100%; padding: 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 16px; box-sizing: border-box;">
                        </div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">Password</label>
                            <input type="password" id="signInPassword" placeholder="••••••••" style="width: 100%; padding: 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 16px; box-sizing: border-box;">
                        </div>
                        <div id="signInError" style="display: none; color: #a51c30; font-size: 13px; margin-bottom: 12px; text-align: center; padding: 8px; background: #fef2f2; border-radius: 6px;"></div>
                        <button type="button" onclick="doSignIn();" style="width: 100%; padding: 14px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 12px; touch-action: manipulation; -webkit-tap-highlight-color: rgba(30, 58, 95, 0.3);">Sign In</button>
                        <p style="text-align: center; margin: 0;">
                            <a href="#" onclick="closeSignInModal(); showForgotPasswordModal(); return false;" style="color: #1e3a5f; font-size: 13px; text-decoration: none;">Forgot password?</a>
                        </p>
                    </div>
                </div>
            </div>
            
            <!-- Create Account Modal -->
            <div id="createAccountModal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 10000; align-items: center; justify-content: center; padding: 16px;">
                <div style="background: white; border-radius: 12px; max-width: 360px; width: 100%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
                    <div style="padding: 20px; border-bottom: 1px solid #e5e7eb;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <h3 style="margin: 0; color: #1e3a5f; font-size: 18px;">✨ Create Account</h3>
                            <button type="button" onclick="closeCreateAccountModal()" style="background: none; border: none; font-size: 24px; color: #64748b; cursor: pointer;">×</button>
                        </div>
                    </div>
                    <div style="padding: 20px;">
                        <div style="margin-bottom: 12px;">
                            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">Email</label>
                            <input type="email" id="createEmail" placeholder="your@email.com" style="width: 100%; padding: 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 16px; box-sizing: border-box;">
                        </div>
                        <div style="margin-bottom: 12px;">
                            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">Password</label>
                            <input type="password" id="createPassword" placeholder="At least 6 characters" style="width: 100%; padding: 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 16px; box-sizing: border-box;">
                        </div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">Confirm Password</label>
                            <input type="password" id="createPasswordConfirm" placeholder="Re-enter password" style="width: 100%; padding: 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 16px; box-sizing: border-box;">
                        </div>
                        <div id="createError" style="display: none; color: #a51c30; font-size: 13px; margin-bottom: 12px; text-align: center; padding: 8px; background: #fef2f2; border-radius: 6px;"></div>
                        <button type="button" onclick="doCreateAccount();" style="width: 100%; padding: 14px; background: #166534; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer; touch-action: manipulation; -webkit-tap-highlight-color: rgba(22, 101, 52, 0.3);">Create Account</button>
                    </div>
                </div>
            </div>
            
            <!-- Forgot Password Modal -->
            <div id="forgotPasswordModal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 10000; align-items: center; justify-content: center; padding: 16px;">
                <div style="background: white; border-radius: 12px; max-width: 360px; width: 100%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
                    <div style="padding: 20px; border-bottom: 1px solid #e5e7eb;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <h3 style="margin: 0; color: #1e3a5f; font-size: 18px;">🔑 Reset Password</h3>
                            <button type="button" onclick="closeForgotPasswordModal()" style="background: none; border: none; font-size: 24px; color: #64748b; cursor: pointer;">×</button>
                        </div>
                    </div>
                    <div style="padding: 20px;">
                        <p style="color: #64748b; font-size: 13px; margin-bottom: 16px;">Enter your email and we'll send you a link to reset your password.</p>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">Email</label>
                            <input type="email" id="forgotEmail" placeholder="your@email.com" style="width: 100%; padding: 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 16px; box-sizing: border-box;">
                        </div>
                        <div id="forgotError" style="display: none; color: #a51c30; font-size: 13px; margin-bottom: 12px; text-align: center; padding: 8px; background: #fef2f2; border-radius: 6px;"></div>
                        <div id="forgotSuccess" style="display: none; color: #166534; font-size: 13px; margin-bottom: 12px; text-align: center; padding: 8px; background: #f0fdf4; border-radius: 6px;"></div>
                        <button type="button" onclick="doForgotPassword()" style="width: 100%; padding: 14px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">Send Reset Link</button>
                    </div>
                </div>
            </div>
            
            <div id="accountLoggedIn" style="display: none;">
                <h3 style="color: #1e3a5f; margin-bottom: 16px; font-size: 20px; text-align: center;">👤 My Account</h3>
                
                <!-- Compact User Info Card -->
                <div style="background: #f8fafc; border-radius: 6px; padding: 16px; margin-bottom: 16px; border: 1px solid #e2e8f0;">
                    <!-- Row 1: Username with settings/delete icons -->
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <p id="accountUsername" style="font-size: 18px; font-weight: 700; color: #1e3a5f; margin: 0;"></p>
                        </div>
                        <div style="display: flex; gap: 4px;">
                            <button type="button" onclick="showAccountSettingsMenu()" style="padding: 4px 8px; background: transparent; color: #64748b; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px; cursor: pointer;" title="Account Settings">⚙️</button>
                            <button type="button" onclick="showDeleteAccountConfirm()" style="padding: 4px 8px; background: transparent; color: #a51c30; border: 1px solid #a51c30; border-radius: 4px; font-size: 12px; cursor: pointer;" title="Delete Account">🗑️</button>
                        </div>
                    </div>
                    
                    <!-- Row 2: Email with verification badge -->
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                        <p id="accountEmail" style="font-size: 13px; color: #475569; margin: 0;"></p>
                        <span id="emailVerifiedBadge" style="display: none; font-size: 9px; padding: 2px 6px; border-radius: 4px; font-weight: 600;"></span>
                    </div>
                    <div id="verifyEmailPrompt" style="display: none; margin-bottom: 8px;">
                        <button type="button" onclick="sendVerificationEmail()" style="padding: 4px 10px; background: #fef3c7; color: #92400e; border: 1px solid #f59e0b; border-radius: 4px; font-size: 11px; font-weight: 600; cursor: pointer;">📧 Verify Email</button>
                        <p style="font-size: 10px; color: #92400e; margin: 4px 0 0 0;">Check spam/junk folder</p>
                    </div>
                    
                    <!-- Row 3: Subscription status with sync/upgrade button -->
                    <div id="subscriptionInfo" style="display: flex; align-items: center; justify-content: space-between;">
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <p id="subscriptionStatus" style="font-size: 14px; font-weight: 600; color: #166534; margin: 0;"></p>
                            <span id="subscriptionExpiry" style="font-size: 11px; color: #64748b;"></span>
                        </div>
                        <button type="button" onclick="restorePurchase()" id="syncSubBtn" style="padding: 4px 10px; background: #f1f5f9; color: #64748b; border: 1px solid #e2e8f0; border-radius: 4px; font-size: 11px; font-weight: 600; cursor: pointer;" title="Sync if subscription not showing">🔄 Sync</button>
                        <button type="button" onclick="showPaywall()" id="upgradeBtn" style="display: none; padding: 4px 10px; background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; border-radius: 4px; font-size: 11px; font-weight: 600; cursor: pointer;">⭐ Upgrade</button>
                    </div>
                </div>
                
                <!-- Account Settings Menu (hidden by default) -->
                <div id="accountSettingsMenu" style="display: none; background: #f8fafc; border: 1px solid #d1d5db; border-radius: 6px; padding: 12px; margin-bottom: 16px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <p style="font-size: 13px; font-weight: 600; color: #1e3a5f; margin: 0;">⚙️ Account Settings</p>
                        <button type="button" onclick="hideAccountSettingsMenu()" style="background: none; border: none; color: #64748b; cursor: pointer; font-size: 16px;">✕</button>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button type="button" onclick="hideAccountSettingsMenu(); showChangeUsernameForm();" style="flex: 1; padding: 8px 4px; background: white; color: #475569; border: 1px solid #d1d5db; border-radius: 4px; font-size: 11px; font-weight: 600; cursor: pointer;">✏️ Username</button>
                        <button type="button" onclick="hideAccountSettingsMenu(); showChangeEmailModal();" style="flex: 1; padding: 8px 4px; background: white; color: #475569; border: 1px solid #d1d5db; border-radius: 4px; font-size: 11px; font-weight: 600; cursor: pointer;">✏️ Email</button>
                        <button type="button" onclick="hideAccountSettingsMenu(); showChangePasswordModal();" style="flex: 1; padding: 8px 4px; background: white; color: #475569; border: 1px solid #d1d5db; border-radius: 4px; font-size: 11px; font-weight: 600; cursor: pointer;">✏️ Password</button>
                    </div>
                </div>
                
                <!-- Golf Identity Section -->
                <div style="background: #f8faf8; border: 2px solid #166534; border-radius: 6px; padding: 16px; margin-bottom: 16px;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <h4 style="font-size: 14px; font-weight: 700; color: #166534; margin: 0;">⛳ Golf Identity</h4>
                        <button type="button" onclick="toggleGolfIdentityEdit()" id="editGolfIdentityBtn" style="padding: 4px 8px; background: transparent; color: #64748b; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px; cursor: pointer;">⚙️</button>
                    </div>
                    
                    <!-- Display Mode -->
                    <div id="golfIdentityDisplay">
                        <div style="margin-bottom: 8px;">
                            <p style="font-size: 11px; color: #64748b; margin-bottom: 2px;">Name (for stat tracking)</p>
                            <p id="golfIdentityName" style="font-size: 16px; font-weight: 600; color: #1e3a5f; margin: 0;">Not set</p>
                        </div>
                        <div>
                            <p style="font-size: 11px; color: #64748b; margin-bottom: 2px;">Nicknames / Aliases</p>
                            <p id="golfIdentityAliases" style="font-size: 13px; color: #475569; margin: 0; font-style: italic;">None</p>
                        </div>
                    </div>
                    
                    <!-- Edit Mode (hidden by default) -->
                    <div id="golfIdentityEdit" style="display: none;">
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 11px; color: #64748b; display: block; margin-bottom: 4px;">Your Golf Name</label>
                            <input type="text" id="golfIdentityNameInput" placeholder="e.g., Otis Williams" style="width: 100%; padding: 10px; border: 1.5px solid #166534; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                        </div>
                        <div style="margin-bottom: 12px;">
                            <label style="font-size: 11px; color: #64748b; display: block; margin-bottom: 4px;">Nicknames (comma separated)</label>
                            <input type="text" id="golfIdentityAliasesInput" placeholder="e.g., Otis, OW, Big O" style="width: 100%; padding: 10px; border: 1.5px solid #166534; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button type="button" onclick="saveGolfIdentity()" style="flex: 1; padding: 8px; background: #166534; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">Save</button>
                        </div>
                    </div>
                    
                    <!-- Tracked Players Section -->
                    <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #166534;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                            <p style="font-size: 11px; color: #64748b; margin: 0;">Tracked Players</p>
                            <button type="button" onclick="showAddTrackedPlayerForm()" id="addTrackedPlayerBtn" style="padding: 2px 8px; background: transparent; color: #166534; border: 1px solid #166534; border-radius: 4px; font-size: 10px; font-weight: 600; cursor: pointer;">+ Add</button>
                        </div>
                        <div id="trackedPlayersList" style="display: flex; flex-direction: column; gap: 6px;">
                            <!-- Tracked players will be populated here -->
                            <p id="noTrackedPlayers" style="font-size: 12px; color: #94a3b8; font-style: italic; margin: 0;">No tracked players yet</p>
                        </div>
                        
                        <!-- Add Tracked Player Form (hidden by default) -->
                        <div id="addTrackedPlayerForm" style="display: none; margin-top: 10px; padding: 10px; background: white; border-radius: 6px;">
                            <input type="text" id="newTrackedPlayerName" placeholder="Player name to track" style="width: 100%; padding: 8px; border: 1.5px solid #166534; border-radius: 6px; font-size: 13px; margin-bottom: 8px; box-sizing: border-box;">
                            <div style="display: flex; gap: 6px;">
                                <button type="button" onclick="hideAddTrackedPlayerForm()" style="flex: 1; padding: 6px; background: #e2e8f0; color: #475569; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">Cancel</button>
                                <button type="button" onclick="addTrackedPlayer()" style="flex: 1; padding: 6px; background: #166534; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">Add</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Stats History Button -->
                <button type="button" onclick="openStatsHistoryFromProfile()" ontouchstart="" style="width: 100%; padding: 12px; background: #166534; color: white; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; margin-bottom: 12px; display: flex; align-items: center; justify-content: center; gap: 8px; -webkit-tap-highlight-color: transparent; touch-action: manipulation;">
                    📊 View Stats History
                </button>
                
                <button type="button" onclick="showSignOutConfirm()" style="width: 100%; padding: 14px; background: #a51c30; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 12px;">Sign Out</button>
                
                <!-- Sign Out Confirmation (hidden by default) -->
                <div id="signOutConfirm" style="display: none; background: #fef2f2; border: 1px solid #a51c30; border-radius: 6px; padding: 16px; margin-bottom: 12px;">
                    <p style="font-size: 14px; font-weight: 700; color: #991b1b; margin-bottom: 12px; text-align: center;">Sign out of your account?</p>
                    <div style="display: flex; gap: 8px;">
                        <button type="button" onclick="hideSignOutConfirm()" style="flex: 1; padding: 10px; background: #e2e8f0; color: #475569; border: none; border-radius: 4px; font-size: 13px; font-weight: 600; cursor: pointer;">Cancel</button>
                        <button type="button" onclick="signOutUser()" style="flex: 1; padding: 10px; background: #a51c30; color: white; border: none; border-radius: 4px; font-size: 13px; font-weight: 600; cursor: pointer;">Sign Out</button>
                    </div>
                </div>
                
                <!-- Delete Account Confirmation (hidden by default) -->
                <div id="deleteAccountConfirm" style="display: none; background: #fef2f2; border: 1px solid #a51c30; border-radius: 6px; padding: 16px; margin-bottom: 12px;">
                    <p style="font-size: 14px; font-weight: 700; color: #991b1b; margin-bottom: 8px;">⚠️ Delete Account Permanently?</p>
                    <p style="font-size: 12px; color: #7f1d1d; margin-bottom: 12px;">This will delete your account and all data. <strong>This cannot be undone.</strong></p>
                    <p style="font-size: 12px; color: #7f1d1d; margin-bottom: 8px;">Type your username <strong id="deleteUsernameHint"></strong> to confirm:</p>
                    <input type="text" id="deleteAccountUsername" placeholder="Type your username" style="width: 100%; padding: 10px; border: 1px solid #a51c30; border-radius: 4px; font-size: 14px; margin-bottom: 8px; box-sizing: border-box;" oninput="checkDeleteUsernameMatch()">
                    <div id="deleteAccountError" style="display: none; color: #a51c30; font-size: 12px; margin-bottom: 8px;"></div>
                    <div style="display: flex; gap: 8px;">
                        <button type="button" onclick="hideDeleteAccountConfirm()" style="flex: 1; padding: 10px; background: #e2e8f0; color: #475569; border: none; border-radius: 4px; font-size: 13px; font-weight: 600; cursor: pointer;">Cancel</button>
                        <button type="button" id="confirmDeleteBtn" onclick="deleteAccountWithUsername()" style="flex: 1; padding: 10px; background: #e57373; color: #991b1b; border: none; border-radius: 4px; font-size: 13px; font-weight: 600; cursor: not-allowed; opacity: 0.5;" disabled>Delete Forever</button>
                    </div>
                </div>
            </div>
            
            <button type="button" onclick="hideAccountModal()" style="width: 100%; padding: 12px; background: transparent; color: #1e3a5f; border: 1px solid #1e3a5f; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; margin-top: 12px;">Close</button>
        </div>
    </div>

    <!-- Paywall Modal -->
    <div id="paywallModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 10001; align-items: center; justify-content: center; overflow-y: auto;">
        <div style="background: white; border-radius: 6px; padding: 24px; margin: 20px; max-width: 400px; width: 90%; box-shadow: 0 12px 24px rgba(0,0,0,0.3);">
            <div style="text-align: center; margin-bottom: 20px;">
                <span style="font-size: 48px;">🏌️</span>
                <h3 style="color: #1e3a5f; margin: 8px 0; font-size: 22px;">Upgrade to Pro</h3>
                <p id="paywallReason" style="color: #64748b; font-size: 14px;">Unlock multi-device scoring and unlimited players</p>
            </div>
            
            <!-- Free Tier Info -->
            <div style="background: #f1f5f9; border-radius: 6px; padding: 12px; margin-bottom: 16px;">
                <p style="font-size: 12px; color: #64748b; margin: 0;"><strong>Free tier:</strong> 4 players max, single device, local only</p>
            </div>
            
            <!-- Pricing Options -->
            <div style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 16px;">
                <button type="button" onclick="selectPlan('day')" class="plan-btn" id="planDay" style="width: 100%; padding: 16px; background: white; border: 2px solid #166534; border-radius: 6px; cursor: pointer; text-align: left; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-size: 16px; font-weight: 600; color: #1e293b;">Day Pass</div>
                        <div style="font-size: 12px; color: #64748b;">24 hours • Perfect for one event</div>
                    </div>
                    <div style="font-size: 20px; font-weight: 700; color: #166534;">$4.99</div>
                </button>
                
                <button type="button" onclick="selectPlan('week')" class="plan-btn" id="planWeek" style="width: 100%; padding: 16px; background: white; border: 2px solid #1e3a5f; border-radius: 6px; cursor: pointer; text-align: left; display: flex; justify-content: space-between; align-items: center; position: relative;">
                    <div style="position: absolute; top: -8px; right: 12px; background: #1e3a5f; color: white; font-size: 10px; font-weight: 600; padding: 2px 8px; border-radius: 6px;">POPULAR</div>
                    <div>
                        <div style="font-size: 16px; font-weight: 600; color: #1e293b;">Week Pass</div>
                        <div style="font-size: 12px; color: #64748b;">7 days • Great for golf trips</div>
                    </div>
                    <div style="font-size: 20px; font-weight: 700; color: #1e3a5f;">$9.99</div>
                </button>
                
                <button type="button" onclick="selectPlan('season')" class="plan-btn" id="planSeason" style="width: 100%; padding: 16px; background: white; border: 2px solid #f59e0b; border-radius: 6px; cursor: pointer; text-align: left; display: flex; justify-content: space-between; align-items: center; position: relative;">
                    <div style="position: absolute; top: -8px; right: 12px; background: #d4b896; color: #1e3a5f; font-size: 10px; font-weight: 600; padding: 2px 8px; border-radius: 6px;">BEST VALUE</div>
                    <div>
                        <div style="font-size: 16px; font-weight: 600; color: #1e293b;">Season Pass</div>
                        <div style="font-size: 12px; color: #64748b;">1 year • Unlimited everything</div>
                    </div>
                    <div style="font-size: 20px; font-weight: 700; color: #f59e0b;">$49.99</div>
                </button>
            </div>
            
            <!-- Features List -->
            <div style="background: #f0fdf4; border-radius: 6px; padding: 12px; margin-bottom: 16px;">
                <p style="font-size: 13px; font-weight: 600; color: #166534; margin-bottom: 8px;">All paid plans include:</p>
                <div style="font-size: 12px; color: #166534;">
                    <p style="margin: 4px 0;">✅ Unlimited players</p>
                    <p style="margin: 4px 0;">✅ Multi-device scoring</p>
                    <p style="margin: 4px 0;">✅ Cloud sync & live leaderboard</p>
                    <p style="margin: 4px 0;">✅ Share via QR code or link</p>
                </div>
            </div>
            
            <!-- Purchase Button -->
            <button type="button" id="purchaseBtn" onclick="processPurchase()" style="width: 100%; padding: 16px; background: #166534; color: white; border: none; border-radius: 6px; font-size: 18px; font-weight: 700; cursor: pointer; margin-bottom: 8px;">
                Continue - $9.99
            </button>
            
            <button type="button" onclick="hidePaywall()" style="width: 100%; padding: 12px; background: transparent; color: #64748b; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">Maybe Later</button>
            
            <p style="text-align: center; font-size: 11px; color: #94a3b8; margin-top: 12px;">Secure payment powered by Stripe</p>
        </div>
    </div>

    <!-- Handicap Confirmation Dialog -->
    <div id="handicapConfirmDialog" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; border-radius: 6px; padding: 24px; margin: 20px; max-width: 400px; box-shadow: 0 8px 16px rgba(0,0,0,0.3);">
            <h3 style="color: #1e3a5f; margin-bottom: 12px; font-size: 20px;">Claim Player</h3>
            
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; color: #475569; font-weight: 600; font-size: 14px;">Player Name</label>
                <input type="text" id="claimPlayerNameInput" placeholder="Player Name" style="width: 100%; padding: 12px; border: 2px solid #166534; border-radius: 8px; font-size: 16px; font-weight: 600; box-sizing: border-box;">
                <input type="hidden" id="claimPlayerOriginalName">
            </div>
            
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; color: #475569; font-weight: 600; font-size: 14px;">Your Initials</label>
                <input type="text" id="initialsInput" maxlength="3" placeholder="ABC" style="width: 100%; padding: 12px; border: 2px solid #1e3a5f; border-radius: 8px; font-size: 18px; text-align: center; font-weight: 600; text-transform: uppercase; box-sizing: border-box;">
                <p style="font-size: 12px; color: #64748b; margin-top: 4px;">So the host knows who's scoring</p>
            </div>
            
            <!-- Tee Selection (hidden by default, shown when using GHIN Index) -->
            <div id="claimTeeSelectionDiv" style="margin-bottom: 16px; display: none;">
                <label style="display: block; margin-bottom: 8px; color: #475569; font-weight: 600; font-size: 14px;">Playing From</label>
                <div id="claimTeeButtons" style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <!-- Tee buttons will be populated dynamically -->
                </div>
                <p id="claimTeeDefault" style="font-size: 11px; color: #64748b; margin-top: 4px;"></p>
            </div>
            
            <!-- Handicap Input -->
            <div style="margin-bottom: 12px;">
                <label id="handicapInputLabel" style="display: block; margin-bottom: 8px; color: #475569; font-weight: 600; font-size: 14px;">Course Handicap</label>
                <input type="number" id="handicapConfirmInput" min="-10" max="54" step="0.1" placeholder="0" style="width: 100%; padding: 12px; border: 2px solid #1e3a5f; border-radius: 8px; font-size: 18px; text-align: center; font-weight: 600; box-sizing: border-box;" oninput="updateClaimCourseHcp()">
                <p id="claimCalculatedHcp" style="font-size: 13px; color: #166534; margin-top: 6px; font-weight: 600; text-align: center; display: none;"></p>
            </div>
            
            <!-- GHIN Index Checkbox -->
            <div style="margin-bottom: 16px;">
                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
                    <input type="checkbox" id="useGhinIndexCheckbox" onchange="toggleGhinIndexMode(this.checked)" style="width: 20px; height: 20px; cursor: pointer;">
                    <span style="color: #475569; font-weight: 600; font-size: 14px;">Use GHIN Handicap Index</span>
                </label>
                <p style="font-size: 11px; color: #64748b; margin-top: 4px; margin-left: 4px;">Check this if you know your official GHIN Index</p>
            </div>
            
            <div style="display: flex; gap: 12px;">
                <button type="button" id="handicapConfirmCancel" style="flex: 1; padding: 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 16px; font-weight: 600; cursor: pointer;">Cancel</button>
                <button type="button" id="handicapConfirmOk" style="flex: 1; padding: 12px; background: #1e3a5f; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">Claim & Score</button>
            </div>
        </div>
    </div>

    <!-- Claim Players List Modal -->
    <div id="claimPlayersModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center; overflow-y: auto; -webkit-overflow-scrolling: touch; touch-action: pan-y;">
        <div style="background: white; border-radius: 8px; padding: 24px; margin: 20px; max-width: 500px; max-height: 80vh; overflow-y: auto; box-shadow: 0 8px 16px rgba(0,0,0,0.3); -webkit-overflow-scrolling: touch; touch-action: manipulation;">
            <h3 style="color: #1e3a5f; margin-bottom: 16px; font-size: 20px;">Claim Additional Player</h3>
            <p style="color: #64748b; margin-bottom: 20px; font-size: 14px;">Select an unclaimed player to score for them</p>
            
            <div id="claimPlayersListContent" style="touch-action: manipulation;">
                <!-- Player list will be populated here -->
            </div>
            
            <button type="button" onclick="document.getElementById('claimPlayersModal').style.display='none'" style="width: 100%; padding: 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 16px; touch-action: manipulation; -webkit-tap-highlight-color: rgba(212, 184, 150, 0.3);">
                Cancel
            </button>
        </div>
    </div>

    <!-- Manage Tournament Page (for host) -->
    <div id="playerManagementPage" class="page" style="background: transparent !important;">
        <!-- Sticky Header -->
        <div style="position: sticky; top: 0; z-index: 100; background: white; border-radius: 6px; margin: 12px; padding: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <!-- Row 1: Title -->
            <div style="text-align: center; margin-bottom: 4px;">
                <span style="font-size: 20px;">⛳</span>
                <span style="color: #1e3a5f; font-size: 20px; font-weight: 700;">Let's Golf</span>
                <span style="font-size: 11px; color: #6b7280;">by Otis Williams</span>
                <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: #166534; margin-left: 4px;"></span>
            </div>
            
            <!-- Row 2: Tournament Info Line -->
            <div style="text-align: center; margin-bottom: 10px;">
                <p id="managementSmartInfo" style="font-size: 11px; color: #4b5563; font-weight: 500; margin: 0;"></p>
            </div>
            
            <!-- Row 3: Nav buttons - full width, no save button -->
            <div style="display: flex; justify-content: space-between; gap: 6px; margin-bottom: 10px;">
                <button type="button" onclick="confirmBackToHome()" style="flex: 1; height: 48px; border-radius: 6px; border: 1.5px solid #1e3a5f; background: white; font-size: 22px; cursor: pointer; display: flex; align-items: center; justify-content: center;">🏠</button>
                <button type="button" onclick="copyActiveTournamentLink()" style="flex: 1; height: 48px; border-radius: 6px; border: 1.5px solid #1e3a5f; background: white; font-size: 22px; cursor: pointer; display: flex; align-items: center; justify-content: center;">🔗</button>
                <button type="button" onclick="showQRCodeForActiveTournament()" style="flex: 1; height: 48px; border-radius: 6px; border: 1.5px solid #1e3a5f; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center;">
                    <svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="#1e3a5f" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7" rx="1"/>
                        <rect x="14" y="3" width="7" height="7" rx="1"/>
                        <rect x="3" y="14" width="7" height="7" rx="1"/>
                        <rect x="14" y="14" width="3" height="3"/>
                        <rect x="18" y="14" width="3" height="3"/>
                        <rect x="14" y="18" width="3" height="3"/>
                        <rect x="18" y="18" width="3" height="3"/>
                    </svg>
                </button>
                <button type="button" onclick="showPage('scoringPage')" style="flex: 1; height: 48px; border-radius: 6px; border: 1.5px solid #1e3a5f; background: white; font-size: 22px; cursor: pointer; display: flex; align-items: center; justify-content: center;">🏌️‍♂️</button>
                <button type="button" onclick="showPage('resultsPage')" style="flex: 1; height: 48px; border-radius: 6px; border: 1.5px solid #1e3a5f; background: white; font-size: 22px; cursor: pointer; display: flex; align-items: center; justify-content: center;">🏆</button>
            </div>
            
            <!-- Row 4: Host/Player Toggle - tan/beige when selected, white when not -->
            <div id="hostPlayerToggleRow" style="display: flex; justify-content: center;">
                <div style="display: flex; background: #f3f4f6; border-radius: 8px; padding: 4px;">
                    <button type="button" id="toggleHostMode" onclick="setHostViewMode('host')" style="padding: 12px 32px; font-size: 15px; font-weight: 600; border-radius: 6px; border: none; background: #d4b896; color: #1e3a5f; cursor: pointer;">👑 Host</button>
                    <button type="button" id="togglePlayerMode" onclick="setHostViewMode('player')" style="padding: 12px 32px; font-size: 15px; font-weight: 600; border-radius: 6px; border: none; background: white; color: #6b7280; cursor: pointer;">👤 Player</button>
                </div>
            </div>
        </div>
        
        <!-- Content area - navy gradient shows through -->
        <div id="hostContentArea" style="padding: 0 12px 12px 12px; background: transparent !important;">
            <!-- Hidden elements for JS compatibility -->
            <div id="managementConnectionStatus" style="display: none;"></div>
            <span id="managementConnectionDot" style="display: none;"></span>
            
            <!-- Reopen/Restart Buttons (for finished tournaments) -->
            <div id="finishedTournamentActions" style="display: none; background: white; border-radius: 6px; padding: 12px; margin-bottom: 10px;">
                <div style="text-align: center; margin-bottom: 10px;">
                    <span style="background: #e5e7eb; color: #374151; font-size: 11px; font-weight: 700; padding: 4px 10px; border-radius: 4px;">🏁 TOURNAMENT FINISHED</span>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button type="button" onclick="reopenTournament()" style="flex: 1; padding: 10px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">
                        🔓 Reopen
                    </button>
                    <button type="button" onclick="confirmRestartCurrentTournament()" style="flex: 1; padding: 10px; background: transparent; color: #a51c30; border: 1px solid #a51c30; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">
                        🔄 Restart
                    </button>
                </div>
            </div>
            
            <!-- BOX 1: Co-hosts - Standalone white box -->
            <div id="coHostsSection" style="background: white; border-radius: 6px; padding: 12px; margin-bottom: 10px; display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                    <h3 style="color: #1e3a5f; font-size: 12px; margin: 0;">👑 Co-hosts</h3>
                    <span style="font-size: 10px; color: #9ca3af;">Can manage tournament</span>
                </div>
                <div id="coHostsContent">
                    <p style="font-size: 11px; color: #9ca3af; margin: 0;">No other devices connected yet. Share the link to add co-hosts.</p>
                </div>
            </div>
            
            <!-- BOX 2: Players - Standalone white box -->
            <div style="background: white; border-radius: 6px; padding: 12px; margin-bottom: 10px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <h3 style="color: #1e3a5f; font-size: 12px; margin: 0;">👥 Players</h3>
                    <button type="button" onclick="showAddPlayerForm()" style="padding: 4px 10px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-size: 11px; font-weight: 600; cursor: pointer;">+ Add</button>
                </div>
                
                <!-- Add Player Form (hidden by default) -->
                <div id="addPlayerForm" style="display: none; background: #f5f5f5; border: 1px solid #d1d5db; border-radius: 6px; padding: 10px; margin-bottom: 8px;">
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        <input type="text" id="newPlayerName" placeholder="Name" style="flex: 2; min-width: 80px; padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;">
                        <input type="number" id="newPlayerHandicap" placeholder="HCP" style="flex: 1; min-width: 45px; max-width: 60px; padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;" value="0">
                        <button type="button" onclick="addNewPlayerFromManagement()" style="padding: 8px 12px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-size: 12px; font-weight: 600; cursor: pointer;">Add</button>
                        <button type="button" onclick="hideAddPlayerForm()" style="padding: 8px 10px; background: #e5e7eb; color: #6b7280; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">✕</button>
                    </div>
                </div>

                <div id="playerManagementContent">
                    <!-- Player list will be generated here -->
                </div>
            </div>
            
            <!-- BOX 3: Tournament Actions - Standalone white box -->
            <div style="background: white; border-radius: 6px; padding: 12px; margin-bottom: 10px;">
                <!-- Clear Scores row -->
                <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 6px; margin-bottom: 10px;">
                    <h3 style="color: #1e3a5f; font-size: 12px; margin: 0;">🔄 Clear Scores</h3>
                    <div style="display: flex; gap: 4px;">
                        <button type="button" onclick="clearAllScores()" style="padding: 6px 12px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-size: 11px; font-weight: 600; cursor: pointer;">All 18</button>
                        <button type="button" onclick="clearFront9Scores()" style="padding: 6px 12px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-size: 11px; font-weight: 600; cursor: pointer;">Front 9</button>
                        <button type="button" onclick="clearBack9Scores()" style="padding: 6px 12px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-size: 11px; font-weight: 600; cursor: pointer;">Back 9</button>
                    </div>
                </div>
                
                <!-- Edit & Finish buttons -->
                <div style="display: flex; gap: 8px;">
                    <button type="button" onclick="showEditTournamentModal()" style="flex: 1; padding: 12px; background: white; color: #1e3a5f; border: 1.5px solid #1e3a5f; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;">
                        ⚙️ Edit Tournament
                    </button>
                    <button type="button" id="finishTournamentBtn" onclick="confirmFinishTournament()" style="flex: 1; padding: 12px; background: transparent; color: #d4b896; border: 1.5px solid #d4b896; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;">
                        🏁 Finish Tournament
                    </button>
                </div>
            </div>
            
            <!-- Hidden sections for backward compatibility -->
            <div id="finishTournamentSection" style="display: none;"></div>
        </div>
    </div>



    <!-- My Players Page (Non-Host) -->
    <div id="myPlayersPage" class="page">
        <!-- Sticky Header -->
        <div style="position: sticky; top: 0; z-index: 100; background: white; border-radius: 6px; margin: 12px; padding: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <!-- Row 1: Title -->
            <div style="text-align: center; margin-bottom: 4px;">
                <span style="font-size: 20px;">⛳</span>
                <span style="color: #1e3a5f; font-size: 20px; font-weight: 700;">Let's Golf</span>
                <span style="font-size: 11px; color: #6b7280;">by Otis Williams</span>
                <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: #166534; margin-left: 4px;"></span>
            </div>
            
            <!-- Row 2: Tournament Info Line -->
            <div style="text-align: center; margin-bottom: 10px;">
                <p id="myPlayersSmartInfo" style="font-size: 11px; color: #4b5563; font-weight: 500; margin: 0;"></p>
            </div>
            
            <!-- Row 3: Nav buttons - full width -->
            <div style="display: flex; justify-content: space-between; gap: 6px; margin-bottom: 10px;">
                <button type="button" onclick="goToCorrectHomePage()" style="flex: 1; height: 48px; border-radius: 6px; border: 1.5px solid #1e3a5f; background: white; font-size: 22px; cursor: pointer; display: flex; align-items: center; justify-content: center;">🏠</button>
                <button type="button" onclick="copyActiveTournamentLink()" style="flex: 1; height: 48px; border-radius: 6px; border: 1.5px solid #1e3a5f; background: white; font-size: 22px; cursor: pointer; display: flex; align-items: center; justify-content: center;">🔗</button>
                <button type="button" onclick="showQRCodeForActiveTournament()" style="flex: 1; height: 48px; border-radius: 6px; border: 1.5px solid #1e3a5f; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center;">
                    <svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="#1e3a5f" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7" rx="1"/>
                        <rect x="14" y="3" width="7" height="7" rx="1"/>
                        <rect x="3" y="14" width="7" height="7" rx="1"/>
                        <rect x="14" y="14" width="3" height="3"/>
                        <rect x="18" y="14" width="3" height="3"/>
                        <rect x="14" y="18" width="3" height="3"/>
                        <rect x="18" y="18" width="3" height="3"/>
                    </svg>
                </button>
                <button type="button" onclick="showPage('scoringPage')" style="flex: 1; height: 48px; border-radius: 6px; border: 1.5px solid #1e3a5f; background: white; font-size: 22px; cursor: pointer; display: flex; align-items: center; justify-content: center;">🏌️‍♂️</button>
                <button type="button" onclick="showPage('resultsPage')" style="flex: 1; height: 48px; border-radius: 6px; border: 1.5px solid #1e3a5f; background: white; font-size: 22px; cursor: pointer; display: flex; align-items: center; justify-content: center;">🏆</button>
            </div>
            
            <!-- Row 4: Host/Player Toggle - tan/beige when selected, white when not -->
            <div id="myPlayersHostToggle" style="display: none; justify-content: center;">
                <div style="display: flex; background: #f3f4f6; border-radius: 8px; padding: 4px;">
                    <button type="button" id="myPlayersHostBtn" onclick="switchToHostMode()" style="padding: 12px 32px; font-size: 15px; font-weight: 600; border-radius: 6px; border: none; background: white; color: #6b7280; cursor: pointer;">👑 Host</button>
                    <button type="button" id="myPlayersPlayerBtn" style="padding: 12px 32px; font-size: 15px; font-weight: 600; border-radius: 6px; border: none; background: #d4b896; color: #1e3a5f; cursor: pointer;">👤 Player</button>
                </div>
            </div>
        </div>
        
        <!-- Content area - transparent background to show navy gradient -->
        <div style="padding: 0 12px 12px 12px; background: transparent;">
            <!-- Hidden elements for JS compatibility -->
            <div id="myPlayersConnectionStatus" style="display: none;"></div>
            <span id="myPlayersConnectionDot" style="display: none;"></span>
            <button type="button" id="notificationToggleBtn" onclick="toggleWatchedNotifications()" style="display: none;">🔔</button>
            
            <!-- My Players Content -->
            <div id="myPlayersPageContent">
                <!-- Dynamic content here -->
            </div>
        </div>
    </div>

    <!-- Guest Home Page (Non-Host) -->
    <!-- Unified Home Page -->
    <div id="guestHomePage" class="page" style="padding-top: 20px;">
        <!-- BOX 1: Header Section - Standalone white box -->
        <div style="background: white; border-radius: 6px; padding: 16px; margin-bottom: 10px; text-align: center; position: relative;">
            <!-- Top Left: Owner badge -->
            <div id="guestOwnerBadgeContainer" style="position: absolute; top: 10px; left: 10px; display: none;">
                <span id="guestOwnerBadge" style="background: rgba(254, 243, 199, 0.9); color: #92400e; font-size: 11px; font-weight: 600; padding: 4px 8px; border-radius: 4px; border: 1px solid rgba(251, 191, 36, 0.6);">👑 Owner</span>
            </div>
            
            <!-- Top Right: Profile/Settings button -->
            <div style="position: absolute; top: 10px; right: 10px; display: flex; flex-direction: column; align-items: flex-end; gap: 4px;">
                <!-- When NOT logged in: show "Connected as OW" -->
                <button id="guestDeviceCorner" onclick="showAccountModal()" style="display: inline-flex; align-items: center; gap: 4px; padding: 6px 10px; background: #d4b896; border: 1px solid #d4b896; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600; color: #1e3a5f;">
                    👤 <span id="guestDeviceInitials" style="font-weight: 600;">OW</span>
                </button>
                <!-- When logged in: show profile button -->
                <button id="guestProfileBtn" onclick="showAccountModal()" style="display: none; align-items: center; gap: 4px; padding: 6px 10px; background: #d4b896; border: 1px solid #d4b896; border-radius: 4px; cursor: pointer; font-size: 12px; color: #1e3a5f;">
                    👤 <span id="guestProfileName" style="font-weight: 600; color: #1e3a5f;">Profile</span>
                </button>
            </div>
            
            <!-- Header Content -->
            <div style="padding-top: 8px;">
                <span style="font-size: 40px;">⛳</span>
                <h1 style="color: #1e3a5f; font-size: 24px; font-weight: 700; margin: 8px 0 2px 0;">Let's Golf</h1>
                <p style="font-size: 14px; font-weight: 500; color: #9ca3af; margin: 0;">Golf Games and Tournaments</p>
            </div>
            
            <!-- Sign In Button (shown when not logged in) -->
            <button type="button" id="guestSignInBtn" onclick="showAccountModal()" style="margin: 16px auto 0 auto; padding: 8px 20px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 12px; font-weight: 600; cursor: pointer; display: inline-flex; align-items: center; gap: 6px;">
                👤 Sign In
            </button>
        </div>
        
        <!-- HOST | JOIN Buttons - No wrapper, float on navy -->
        <div style="display: flex; gap: 12px; margin-bottom: 10px;">
            <button type="button" onclick="startNewTournament()" style="flex: 1; display: flex; flex-direction: column; align-items: center; padding: 16px 12px; background: white; border: none; border-radius: 6px; cursor: pointer;">
                <span style="font-size: 24px; margin-bottom: 4px;">👑</span>
                <span style="font-size: 15px; font-weight: 700; color: #1e3a5f;">HOST</span>
                <span style="color: #1e3a5f; font-size: 11px; font-weight: 400; margin-top: 2px;">New Round</span>
            </button>
            <button type="button" onclick="showJoinByCodeModal()" style="flex: 1; display: flex; flex-direction: column; align-items: center; padding: 16px 12px; background: white; border: none; border-radius: 6px; cursor: pointer;">
                <span style="font-size: 24px; margin-bottom: 4px;">🏌️</span>
                <span style="font-size: 15px; font-weight: 700; color: #1e3a5f;">JOIN</span>
                <span style="color: #1e3a5f; font-size: 11px; font-weight: 400; margin-top: 2px;">By Code</span>
            </button>
        </div>
        
        <!-- BOX 3: Current Tournament (only shown when active) -->
        <div id="homeCurrentTournament" style="display: none; background: white; border-radius: 6px; padding: 14px; margin-bottom: 10px;">
            <h3 style="color: #1e3a5f; font-size: 13px; font-weight: 700; margin: 0 0 10px 0; text-align: center; padding-bottom: 10px; border-bottom: 1px solid #f0f0f0;">
                Current Round
            </h3>
            <div id="homeCurrentTournamentContent">
                <!-- Will be populated by JS -->
            </div>
        </div>
        
        <!-- BOX 4: Past Tournaments -->
        <div id="homePastTournaments" style="background: #f9fafb; border-radius: 6px; padding: 14px;">
            <h3 style="color: #1e3a5f; font-size: 13px; font-weight: 700; margin: 0 0 10px 0; text-align: center; padding-bottom: 10px; border-bottom: 1px solid #e5e7eb;">
                Previous Rounds
            </h3>
            <div id="homeRoundsList" style="display: flex; flex-direction: column; gap: 8px;">
                <!-- Past rounds will be populated here by JavaScript -->
                <p id="noRoundsMessage" style="color: #6b7280; font-size: 12px; text-align: center; padding: 12px 0;">No previous rounds yet</p>
            </div>
        </div>
        
        <!-- Hidden elements for compatibility with existing code -->
        <div id="guestSubscriptionBadge" style="display: none;"><span id="guestSubscriptionBadgeText"></span></div>
        <div id="enterTournamentCard" style="display: none;"></div>
        <div id="guestCurrentTournament" style="display: none;">
            <div id="guestTournamentTitle"></div>
            <span id="guestRoleBadge"></span>
            <h3 id="guestTournamentName"></h3>
            <p id="guestTournamentInfo"></p>
            <p id="guestHostInfo"><span id="guestHostName"></span></p>
            <div id="guestActiveButtons"></div>
            <span id="guestHomeManageBtnIcon"></span>
            <span id="guestHomeManageBtnText"></span>
            <button id="guestLeaveBtn" style="display: none;"></button>
            <div id="guestLastTournamentButtons"></div>
        </div>
        <div id="loadTournamentCard" style="display: none;"></div>
        <p id="historyCount" style="display: none;"></p>
        <button id="guestHomeConnectionStatus" style="display: none;"></button>
        <p id="guestLoggedInStatus" style="display: none;"><span id="guestLoggedInName"></span></p>
    </div>

    <!-- Host Home Page (kept for compatibility, same design as guest) -->
    <div id="hostHomePage" class="page" style="padding-top: 20px;">
        <!-- BOX 1: Header Section - Standalone white box -->
        <div style="background: white; border-radius: 6px; padding: 16px; margin-bottom: 10px; text-align: center; position: relative;">
            <!-- Top Left: Owner badge -->
            <div id="hostOwnerBadgeContainer" style="position: absolute; top: 10px; left: 10px; display: none;">
                <span id="hostOwnerBadge" style="background: rgba(254, 243, 199, 0.9); color: #92400e; font-size: 11px; font-weight: 600; padding: 4px 8px; border-radius: 4px; border: 1px solid rgba(251, 191, 36, 0.6);">👑 Owner</span>
            </div>
            
            <!-- Top Right: Profile/Settings button -->
            <div style="position: absolute; top: 10px; right: 10px; display: flex; flex-direction: column; align-items: flex-end; gap: 4px;">
                <!-- When NOT logged in: show "Connected as OW" -->
                <button id="hostDeviceCorner" onclick="showAccountModal()" style="display: inline-flex; align-items: center; gap: 4px; padding: 6px 10px; background: #d4b896; border: 1px solid #d4b896; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600; color: #1e3a5f;">
                    👤 <span id="hostDeviceInitials" style="font-weight: 600;">OW</span>
                </button>
                <!-- When logged in: show profile button -->
                <button id="hostProfileBtn" onclick="showAccountModal()" style="display: none; align-items: center; gap: 4px; padding: 6px 10px; background: #d4b896; border: 1px solid #d4b896; border-radius: 4px; cursor: pointer; font-size: 12px; color: #1e3a5f;">
                    👤 <span id="hostProfileName" style="font-weight: 600; color: #1e3a5f;">Profile</span>
                </button>
            </div>
            
            <!-- Header Content -->
            <div style="padding-top: 8px;">
                <span style="font-size: 40px;">⛳</span>
                <h1 style="color: #1e3a5f; font-size: 24px; font-weight: 700; margin: 8px 0 2px 0;">Let's Golf</h1>
                <p style="font-size: 14px; font-weight: 500; color: #9ca3af; margin: 0;">Golf Games and Tournaments</p>
            </div>
            
            <!-- Sign In Button (shown when not logged in) -->
            <button type="button" id="hostSignInBtn" onclick="showAccountModal()" style="margin: 16px auto 0 auto; padding: 8px 20px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 12px; font-weight: 600; cursor: pointer; display: inline-flex; align-items: center; gap: 6px;">
                👤 Sign In
            </button>
        </div>
        
        <!-- HOST | JOIN Buttons - No wrapper, float on navy -->
        <div style="display: flex; gap: 12px; margin-bottom: 10px;">
            <button type="button" onclick="startNewTournament()" style="flex: 1; display: flex; flex-direction: column; align-items: center; padding: 16px 12px; background: white; border: none; border-radius: 6px; cursor: pointer;">
                <span style="font-size: 24px; margin-bottom: 4px;">👑</span>
                <span style="font-size: 15px; font-weight: 700; color: #1e3a5f;">HOST</span>
                <span style="color: #1e3a5f; font-size: 11px; font-weight: 400; margin-top: 2px;">New Round</span>
            </button>
            <button type="button" onclick="showJoinByCodeModal()" style="flex: 1; display: flex; flex-direction: column; align-items: center; padding: 16px 12px; background: white; border: none; border-radius: 6px; cursor: pointer;">
                <span style="font-size: 24px; margin-bottom: 4px;">🏌️</span>
                <span style="font-size: 15px; font-weight: 700; color: #1e3a5f;">JOIN</span>
                <span style="color: #1e3a5f; font-size: 11px; font-weight: 400; margin-top: 2px;">By Code</span>
            </button>
        </div>
        
        <!-- BOX 3: Current Tournament (only shown when active) -->
        <div id="hostHomeCurrentTournament" style="display: none; background: white; border-radius: 6px; padding: 14px; margin-bottom: 10px;">
            <h3 style="color: #1e3a5f; font-size: 13px; font-weight: 700; margin: 0 0 10px 0; text-align: center; padding-bottom: 10px; border-bottom: 1px solid #f0f0f0;">
                Current Round
            </h3>
            <div id="hostHomeCurrentTournamentContent">
                <!-- Will be populated by JS -->
            </div>
        </div>
        
        <!-- BOX 4: Past Tournaments -->
        <div id="hostHomePastTournaments" style="background: #f9fafb; border-radius: 6px; padding: 14px;">
            <h3 style="color: #1e3a5f; font-size: 13px; font-weight: 700; margin: 0 0 10px 0; text-align: center; padding-bottom: 10px; border-bottom: 1px solid #e5e7eb;">
                Previous Rounds
            </h3>
            <div id="hostHomeRoundsList" style="display: flex; flex-direction: column; gap: 8px;">
                <!-- Past rounds will be populated here by JavaScript -->
                <p id="hostNoRoundsMessage" style="color: #6b7280; font-size: 12px; text-align: center; padding: 12px 0;">No previous rounds yet</p>
            </div>
        </div>
        
        <!-- Hidden elements for compatibility -->
        <div id="subscriptionBadge" style="display: none;"><span id="subscriptionBadgeText"></span></div>
        <div id="hostCurrentTournament" style="display: none;">
            <span id="hostTournamentBadge"></span>
            <h3 id="hostTournamentName"></h3>
            <p id="hostTournamentInfo"></p>
            <p id="hostPageHostInfo"><span id="hostPageHostName"></span></p>
            <span id="hostHomeManageBtnIcon"></span>
            <span id="hostHomeManageBtnText"></span>
        </div>
        <div id="hostLoadNewCard" style="display: none;"></div>
        <p id="hostHistoryCount" style="display: none;"></p>
        <button id="hostHomeConnectionStatus" style="display: none;"></button>
        <p id="hostLoggedInStatus" style="display: none;"><span id="hostLoggedInName"></span></p>
    </div>

    <!-- Live Leaderboard Page (for spectators) -->
    <div id="liveLeaderboardPage" class="page">
        <div class="card">
            <div class="tournament-info-centered">
                <p style="font-size: 32px;">🏆</p>
                <h2>Live Leaderboard</h2>
                <p id="liveLeaderboardInfo"></p>
            </div>

            <!-- Game Toggle Tabs -->
            <div id="gameToggleTabs" style="display: flex; gap: 4px; margin: 16px 0; overflow-x: auto; -webkit-overflow-scrolling: touch; flex-wrap: nowrap; justify-content: flex-end;">
                <!-- Tabs will be generated dynamically -->
            </div>

            <div id="liveLeaderboardContent" style="margin-top: 12px;">
                <!-- Leaderboard will be generated here -->
            </div>

            <div style="margin-top: 16px; padding: 12px; background: rgba(255,255,255,0.1); border-radius: 6px; text-align: center;">
                <p style="color: #6b7280; font-size: 12px; margin-bottom: 8px;">
                    <span id="lastUpdateTime">Just now</span> • <span id="activePlayersCount">0</span> players
                </p>
                <label style="display: flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="autoRefreshToggle" checked style="width: 18px; height: 18px;">
                    <span style="color: white; font-size: 12px;">Auto-refresh</span>
                </label>
            </div>

            <button type="button" id="leaderboardActionBtn" class="btn-primary" onclick="handleLeaderboardAction()" style="width: 100%; margin-top: 12px; padding: 12px; font-size: 14px; font-weight: 600; background: var(--green-600); border: none;">
                Start Scoring ⛳
            </button>
        </div>
    </div>

    <!-- Host Dashboard Page -->
    <div id="hostDashboardPage" class="page">
        <div class="card">
            <div class="tournament-info-centered">
                <p style="font-size: 32px;">🎮</p>
                <h2>Tournament Admin</h2>
                <p id="hostDashboardInfo"></p>
            </div>

            <div style="margin-top: 20px;">
                <h3 style="color: #1e3a5f; margin-bottom: 12px; font-size: 18px;">Players & Devices</h3>
                <div id="playerDeviceList">
                    <!-- Will be populated dynamically -->
                </div>
            </div>

            <div style="margin-top: 24px;">
                <h3 style="color: #1e3a5f; margin-bottom: 12px; font-size: 18px;">Tournament Controls</h3>
                
                <!-- Privacy Settings -->
                <div id="hostPrivacyControls" style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 6px; padding: 16px; margin-bottom: 16px;">
                    <div style="font-weight: 600; color: #1e293b; font-size: 14px; margin-bottom: 12px;">🔒 Privacy Settings</div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <div style="font-size: 13px; color: #475569;">Players can view leaderboard</div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="hostPrivacyViewLeaderboard" checked onchange="updateHostPrivacySetting('viewLeaderboard', this.checked)">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div id="hostSignedEarlySection" style="display: none; margin-left: 16px; margin-bottom: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="font-size: 13px; color: #475569;">Signed players can view early</div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="hostPrivacySignedEarly" onchange="updateHostPrivacySetting('signedEarly', this.checked)">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="font-size: 13px; color: #475569;">Players can watch others</div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="hostPrivacyWatchOthers" checked onchange="updateHostPrivacySetting('watchOthers', this.checked)">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                
                <button type="button" class="btn-secondary" onclick="addPlayerManually()" style="width: 100%; margin-bottom: 8px;">
                    ➕ Add Player Manually
                </button>
                <button type="button" class="btn-secondary" onclick="lockTournament(activeTournamentId)" style="width: 100%; margin-bottom: 8px;">
                    🔒 Lock Tournament (No More Joins)
                </button>
                <button type="button" class="btn-primary" onclick="endTournament(activeTournamentId)" style="width: 100%; margin-bottom: 8px; background: #a51c30;">
                    🏁 End Tournament
                </button>
            </div>

            <button type="button" class="btn-secondary" onclick="showPage('scoringPage')" style="width: 100%; margin-top: 16px;">
                Back to Scoring
            </button>
        </div>
    </div>

    <!-- Custom Confirmation Dialog (iOS-friendly) -->
    <div id="confirmDialog" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10100; align-items: center; justify-content: center;">
        <div style="background: white; border-radius: 6px; padding: 24px; margin: 20px; max-width: 400px; box-shadow: 0 8px 16px rgba(0,0,0,0.3);">
            <h3 id="confirmTitle" style="color: #1e3a5f; margin-bottom: 12px; font-size: 20px;">Confirm Action</h3>
            <p id="confirmMessage" style="color: #64748b; margin-bottom: 24px; font-size: 16px; line-height: 1.5;"></p>
            <div style="display: flex; gap: 12px;">
                <button type="button" id="confirmCancel" style="flex: 1; padding: 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 16px; font-weight: 600;">Cancel</button>
                <button type="button" id="confirmOk" style="flex: 1; padding: 12px; background: #a51c30; color: white; border: none; border-radius: 4px; font-size: 16px; font-weight: 600;">Confirm</button>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // FIREBASE CONFIGURATION & INITIALIZATION
        // ========================================
        
        // Wait for Firebase scripts to load
        function initializeFirebase() {
            if (typeof firebase === 'undefined') {
                console.error('⚠️ Firebase scripts not loaded! Retrying...');
                setTimeout(initializeFirebase, 500);
                return;
            }
            
            console.log('✅ Firebase scripts loaded successfully!');
            
            const firebaseConfig = {
                apiKey: "AIzaSyCD306J3LqJGqQ-j8mHj8ulUoX4BjJKn1g",
                authDomain: "u-lik-golf.firebaseapp.com",
                projectId: "u-lik-golf",
                storageBucket: "u-lik-golf.firebasestorage.app",
                messagingSenderId: "637984857306",
                appId: "1:637984857306:web:7d7ff315a360c3544b59e3"
            };

            // Initialize Firebase
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
            auth = firebase.auth();
            firebaseReady = true; // Mark Firebase as ready
            
            console.log('✅ Firebase initialized!');
            
            // Initialize IHMC Firebase as secondary app for tournament integration
            const ihmcFirebaseConfig = {
                apiKey: "AIzaSyDOZdQs6bVI2jfyU62oL_9CrjkBhZChRlU",
                authDomain: "ihmc-golf.firebaseapp.com",
                projectId: "ihmc-golf",
                storageBucket: "ihmc-golf.firebasestorage.app",
                messagingSenderId: "275902581629",
                appId: "1:275902581629:web:3074712090e0d745d6da14"
            };
            
            // Initialize as secondary app (won't conflict with main app)
            const ihmcApp = firebase.initializeApp(ihmcFirebaseConfig, 'ihmc');
            window.ihmcDb = ihmcApp.firestore();
            console.log('✅ IHMC Firebase initialized (secondary app)');
            console.log('   firebaseReady:', firebaseReady);
            
            // Enable offline persistence
            db.enablePersistence({synchronizeTabs: true})
                .catch((err) => {
                    if (err.code == 'failed-precondition') {
                        console.warn('Multiple tabs open, persistence only in one tab');
                    } else if (err.code == 'unimplemented') {
                        console.warn('Browser doesn\'t support persistence');
                    }
                });

            // Skip Firebase Auth - use direct Firestore with local IDs instead
            // This avoids the auth/configuration-not-found error on iOS
            console.log('🔐 Setting up device authentication (no Firebase Auth required)...');
            
            // Generate persistent user ID (stored in localStorage)
            if (!localStorage.getItem('persistentUserId')) {
                localStorage.setItem('persistentUserId', 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
            }
            currentUserId = localStorage.getItem('persistentUserId');
            
            // Generate persistent device ID (stored in localStorage)
            if (!localStorage.getItem('deviceId')) {
                localStorage.setItem('deviceId', 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
            }
            currentDeviceId = localStorage.getItem('deviceId');
            
            // Initialize device name and initials from localStorage
            deviceName = localStorage.getItem('deviceName') || 'My Device';
            deviceInitials = localStorage.getItem('deviceInitials') || '';
            
            authCompleted = true;
            console.log('✅ Device authenticated successfully (no Firebase Auth needed)!');
            console.log('   User ID:', currentUserId);
            console.log('   Device ID:', currentDeviceId);
            console.log('   Device Name:', deviceName);
            
            // Set up Firebase Auth state listener
            auth.onAuthStateChanged(async (user) => {
                console.log('🔐 Auth state changed:', user ? user.email : 'signed out');
                currentAuthUser = user;
                if (user) {
                    await loadUserSubscription(user.uid);
                    // Load and merge tournament history from Firebase
                    await loadTournamentHistoryFromFirebase();
                    // Load stats from Firebase
                    await loadPlayerStatsFromFirebase();
                    // Migrate any device-based claims to account-based claims
                    await migrateDeviceClaimsToAccount();
                } else {
                    userSubscription = { status: 'free', expiresAt: null, email: null };
                }
                updateAccountUI();
                // Refresh home page to show/hide tournaments based on auth state
                populateHomeRoundsList();
            });
        }
        
        // Migrate device-based claims to account-based claims
        // This runs when a signed-in user loads the app
        async function migrateDeviceClaimsToAccount() {
            if (!currentAuthUser || !activeTournamentId || !db) return;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const doc = await tournamentRef.get();
                if (!doc.exists) return;
                
                const tournament = doc.data();
                const userId = 'user_' + currentAuthUser.uid;
                let needsUpdate = false;
                
                // Check each player - if claimed by my deviceId, migrate to userId
                tournament.players.forEach(player => {
                    if (player.claimedBy === currentDeviceId) {
                        console.log(`🔄 Migrating claim for ${player.name} from device to account`);
                        player.claimedBy = userId;
                        needsUpdate = true;
                    }
                });
                
                if (needsUpdate) {
                    await tournamentRef.update({ players: tournament.players });
                    console.log('✅ Claims migrated to account');
                    // Update local data
                    if (tournamentData) {
                        tournamentData.players = tournament.players;
                    }
                }
            } catch (error) {
                console.error('Error migrating claims:', error);
            }
        }
        
        // ===== SUBSCRIPTION SYSTEM =====
        
        // Load user subscription from Firestore
        async function loadUserSubscription(userId) {
            try {
                const userDoc = await db.collection('users').doc(userId).get();
                if (userDoc.exists) {
                    const data = userDoc.data();
                    userSubscription = {
                        status: data.subscriptionStatus || 'free',
                        expiresAt: data.subscriptionExpiresAt ? data.subscriptionExpiresAt.toDate() : null,
                        email: data.email
                    };
                    
                    // Check if subscription has expired
                    if (userSubscription.expiresAt && userSubscription.expiresAt < new Date()) {
                        userSubscription.status = 'free';
                        // Update in Firestore
                        await db.collection('users').doc(userId).update({
                            subscriptionStatus: 'free'
                        });
                    }
                } else {
                    // Create user document if it doesn't exist
                    await db.collection('users').doc(userId).set({
                        email: currentAuthUser.email,
                        subscriptionStatus: 'free',
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    userSubscription = { status: 'free', expiresAt: null, email: currentAuthUser.email };
                }
                console.log('📋 Subscription loaded:', userSubscription);
            } catch (error) {
                console.error('Error loading subscription:', error);
                userSubscription = { status: 'free', expiresAt: null, email: null };
            }
        }
        
        // Check if user has active subscription
        function hasActiveSubscription() {
            // Developer/owner bypass - always has Pro access
            const ownerEmails = ['odub1281@gmail.com']; // Add your email(s) here
            if (currentAuthUser && ownerEmails.includes(currentAuthUser.email.toLowerCase())) {
                console.log('👑 Owner bypass active for:', currentAuthUser.email);
                return true;
            }
            
            if (userSubscription.status === 'free') return false;
            if (!userSubscription.expiresAt) return false;
            return userSubscription.expiresAt > new Date();
        }
        
        // Check if action is allowed (player count, cloud features)
        function canAddMorePlayers(currentCount) {
            if (hasActiveSubscription()) return true;
            return currentCount < FREE_PLAYER_LIMIT;  // Can add if under 4 (allows up to 4 total)
        }
        
        function canUseCloudFeatures() {
            return hasActiveSubscription();
        }
        
        // Gate check - show paywall if needed
        function requireSubscription(reason) {
            if (hasActiveSubscription()) return true;
            showPaywall(reason);
            return false;
        }
        
        // Update Account UI based on auth state
        function updateAccountUI() {
            // Old subscription badges - keep hidden, we use new owner badges in header now
            const badge = document.getElementById('subscriptionBadge');
            const guestBadge = document.getElementById('guestSubscriptionBadge');
            if (badge) badge.style.display = 'none';
            if (guestBadge) guestBadge.style.display = 'none';
            
            if (currentAuthUser) {
                // Use displayName (username) if set, otherwise fall back to email prefix
                const displayName = currentAuthUser.displayName || currentAuthUser.email.split('@')[0];
                
                // Update "Connected as" displays with username
                updateConnectedAsDisplays(displayName);
            } else {
                // Not logged in - show device initials
                updateConnectedAsDisplays(deviceInitials || 'Guest');
            }
            
            // Update home page login status (handles owner badge display)
            updateHomePageLoginStatus();
        }
        
        // Update all "Connected as" displays with username
        function updateConnectedAsDisplays(username) {
            const hostInitials = document.getElementById('hostDeviceInitials');
            const guestInitials = document.getElementById('guestDeviceInitials');
            
            if (hostInitials) hostInitials.textContent = username;
            if (guestInitials) guestInitials.textContent = username;
            
            // Update home page login status based on auth state
            updateHomePageLoginStatus();
        }
        
        // Update home page to show logged in status or sign in button
        function updateHomePageLoginStatus() {
            const isLoggedIn = !!currentAuthUser;
            
            // Guest home page elements
            const guestDeviceCorner = document.getElementById('guestDeviceCorner');
            const guestProfileBtn = document.getElementById('guestProfileBtn');
            const guestProfileName = document.getElementById('guestProfileName');
            const guestSignInBtn = document.getElementById('guestSignInBtn');
            const guestOwnerBadge = document.getElementById('guestOwnerBadge');
            
            // Host home page elements
            const hostDeviceCorner = document.getElementById('hostDeviceCorner');
            const hostProfileBtn = document.getElementById('hostProfileBtn');
            const hostProfileName = document.getElementById('hostProfileName');
            const hostSignInBtn = document.getElementById('hostSignInBtn');
            const hostOwnerBadge = document.getElementById('hostOwnerBadge');
            
            if (isLoggedIn) {
                const displayName = currentAuthUser.displayName || currentAuthUser.email.split('@')[0];
                
                // Check if owner
                const ownerEmails = ['odub1281@gmail.com'];
                const isOwner = ownerEmails.includes(currentAuthUser.email.toLowerCase());
                
                // Hide device corner and sign in button, show profile button
                if (guestDeviceCorner) guestDeviceCorner.style.display = 'none';
                if (guestSignInBtn) guestSignInBtn.style.display = 'none';
                if (guestProfileBtn) {
                    guestProfileBtn.style.display = 'inline-flex';
                    if (guestProfileName) guestProfileName.textContent = displayName;
                }
                if (guestOwnerBadge) guestOwnerBadge.style.display = isOwner ? 'inline-block' : 'none';
                
                if (hostDeviceCorner) hostDeviceCorner.style.display = 'none';
                if (hostSignInBtn) hostSignInBtn.style.display = 'none';
                if (hostProfileBtn) {
                    hostProfileBtn.style.display = 'inline-flex';
                    if (hostProfileName) hostProfileName.textContent = displayName;
                }
                if (hostOwnerBadge) hostOwnerBadge.style.display = isOwner ? 'inline-block' : 'none';
            } else {
                // Signed out: Only show Sign In button, hide everything else
                // Don't show device corner - it may contain stale username from localStorage
                if (guestDeviceCorner) guestDeviceCorner.style.display = 'none';
                if (guestSignInBtn) guestSignInBtn.style.display = 'inline-flex';
                if (guestProfileBtn) guestProfileBtn.style.display = 'none';
                if (guestOwnerBadge) guestOwnerBadge.style.display = 'none';
                
                if (hostDeviceCorner) hostDeviceCorner.style.display = 'none';
                if (hostSignInBtn) hostSignInBtn.style.display = 'inline-flex';
                if (hostProfileBtn) hostProfileBtn.style.display = 'none';
                if (hostOwnerBadge) hostOwnerBadge.style.display = 'none';
            }
        }
        
        // ============================================
        // GENERIC MODAL FUNCTIONS
        // ============================================
        
        // Show a generic modal dialog
        function showModal(title, content, buttons, showCloseX = true) {
            // Remove any existing generic modal
            const existingModal = document.getElementById('genericModal');
            if (existingModal) existingModal.remove();
            
            const modal = document.createElement('div');
            modal.id = 'genericModal';
            modal.style.cssText = `
                position: fixed;
                inset: 0;
                background: rgba(0,0,0,0.7);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 16px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 12px; max-width: 400px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
                    <div style="padding: 16px 20px; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center;">
                        <h3 style="margin: 0; color: #1e3a5f; font-size: 16px;">${title}</h3>
                        ${showCloseX ? '<button onclick="closeModal()" style="background: none; border: none; font-size: 24px; color: #64748b; cursor: pointer; padding: 0; line-height: 1;">×</button>' : ''}
                    </div>
                    <div style="padding: 20px;">
                        ${content}
                    </div>
                    ${buttons ? `<div style="padding: 0 20px 20px;">${buttons}</div>` : ''}
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close on backdrop click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeModal();
            });
        }
        
        // Close the generic modal
        function closeModal() {
            const modal = document.getElementById('genericModal');
            if (modal) modal.remove();
        }
        
        // Show/hide account modal
        function showAccountModal() {
            const modal = document.getElementById('accountModal');
            const loggedOut = document.getElementById('accountLoggedOut');
            const loggedIn = document.getElementById('accountLoggedIn');
            const emailEl = document.getElementById('accountEmail');
            const usernameEl = document.getElementById('accountUsername');
            const statusEl = document.getElementById('subscriptionStatus');
            const expiryEl = document.getElementById('subscriptionExpiry');
            const upgradeBtn = document.getElementById('upgradeBtn');
            const syncSubBtn = document.getElementById('syncSubBtn');
            const verifiedBadge = document.getElementById('emailVerifiedBadge');
            const verifyPrompt = document.getElementById('verifyEmailPrompt');
            
            // Hide all edit forms and menus
            hideChangeEmailForm();
            hideChangePasswordForm();
            hideChangeUsernameForm();
            hideDeleteAccountConfirm();
            hideAccountSettingsMenu();
            cancelGolfIdentityEdit();
            hideAddTrackedPlayerForm();
            hideSignOutConfirm();
            
            // Load and display golf identity
            loadGolfIdentity();
            
            if (currentAuthUser) {
                loggedOut.style.display = 'none';
                loggedIn.style.display = 'block';
                emailEl.textContent = currentAuthUser.email;
                
                // Show username (from displayName or generate from email)
                const username = currentAuthUser.displayName || currentAuthUser.email.split('@')[0];
                usernameEl.textContent = username;
                
                // Show email verification status
                if (currentAuthUser.emailVerified) {
                    verifiedBadge.textContent = '✓ Verified';
                    verifiedBadge.style.background = 'transparent';
                    verifiedBadge.style.color = '#166534';
                    verifiedBadge.style.border = '1px solid #166534';
                    verifiedBadge.style.display = 'inline-block';
                    verifyPrompt.style.display = 'none';
                } else {
                    verifiedBadge.textContent = 'Not verified';
                    verifiedBadge.style.background = '#fef3c7';
                    verifiedBadge.style.color = '#92400e';
                    verifiedBadge.style.display = 'inline-block';
                    verifyPrompt.style.display = 'block';
                }
                
                // Check if owner
                const ownerEmails = ['odub1281@gmail.com'];
                const isOwner = ownerEmails.includes(currentAuthUser.email.toLowerCase());
                
                if (isOwner) {
                    statusEl.textContent = '👑 Owner';
                    statusEl.style.color = '#166534';
                    expiryEl.textContent = '• Unlimited';
                    if (upgradeBtn) upgradeBtn.style.display = 'none';
                    if (syncSubBtn) syncSubBtn.style.display = 'inline-block';
                } else if (hasActiveSubscription()) {
                    const plan = PLAN_PRICES[userSubscription.status];
                    statusEl.textContent = plan ? `⭐ ${plan.label}` : '⭐ Pro';
                    statusEl.style.color = '#166534';
                    const expiry = userSubscription.expiresAt;
                    expiryEl.textContent = `• Exp ${expiry.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
                    if (upgradeBtn) upgradeBtn.style.display = 'none';
                    if (syncSubBtn) syncSubBtn.style.display = 'inline-block';
                } else {
                    statusEl.textContent = 'Free Plan';
                    statusEl.style.color = '#64748b';
                    expiryEl.textContent = '• 4 players max';
                    if (upgradeBtn) upgradeBtn.style.display = 'inline-block';
                    if (syncSubBtn) syncSubBtn.style.display = 'none';
                }
            } else {
                loggedOut.style.display = 'block';
                loggedIn.style.display = 'none';
                // Clear any error messages
                const authError = document.getElementById('authError');
                const authSuccess = document.getElementById('authSuccess');
                if (authError) authError.style.display = 'none';
                if (authSuccess) authSuccess.style.display = 'none';
            }
            
            modal.style.display = 'flex';
        }
        
        function hideAccountModal() {
            document.getElementById('accountModal').style.display = 'none';
        }
        
        // Account Settings Menu functions
        function showAccountSettingsMenu() {
            document.getElementById('accountSettingsMenu').style.display = 'block';
        }
        
        function hideAccountSettingsMenu() {
            const menu = document.getElementById('accountSettingsMenu');
            if (menu) menu.style.display = 'none';
        }
        
        // Delete account with username confirmation
        function checkDeleteUsernameMatch() {
            const input = document.getElementById('deleteAccountUsername');
            const confirmBtn = document.getElementById('confirmDeleteBtn');
            const username = currentAuthUser?.displayName || currentAuthUser?.email?.split('@')[0] || '';
            
            if (input.value === username) {
                confirmBtn.disabled = false;
                confirmBtn.style.opacity = '1';
                confirmBtn.style.cursor = 'pointer';
                confirmBtn.style.background = '#a51c30';
                confirmBtn.style.color = 'white';
            } else {
                confirmBtn.disabled = true;
                confirmBtn.style.opacity = '0.5';
                confirmBtn.style.cursor = 'not-allowed';
                confirmBtn.style.background = '#e57373';
                confirmBtn.style.color = '#991b1b';
            }
        }
        
        function showDeleteAccountConfirm() {
            const username = currentAuthUser?.displayName || currentAuthUser?.email?.split('@')[0] || '';
            document.getElementById('deleteUsernameHint').textContent = `"${username}"`;
            document.getElementById('deleteAccountUsername').value = '';
            document.getElementById('deleteAccountError').style.display = 'none';
            document.getElementById('confirmDeleteBtn').disabled = true;
            document.getElementById('confirmDeleteBtn').style.opacity = '0.5';
            document.getElementById('deleteAccountConfirm').style.display = 'block';
        }
        
        async function deleteAccountWithUsername() {
            const input = document.getElementById('deleteAccountUsername');
            const errorEl = document.getElementById('deleteAccountError');
            const username = currentAuthUser?.displayName || currentAuthUser?.email?.split('@')[0] || '';
            
            if (input.value !== username) {
                errorEl.textContent = 'Username does not match';
                errorEl.style.display = 'block';
                return;
            }
            
            try {
                // Delete user data from Firestore first
                if (db && currentAuthUser) {
                    await db.collection('userProfiles').doc(currentAuthUser.uid).delete().catch(() => {});
                }
                
                // Delete the auth account
                await currentAuthUser.delete();
                
                // Clear local data
                localStorage.removeItem('golfIdentity');
                localStorage.removeItem('linkedPlayers');
                
                hideAccountModal();
                showNotification('Account Deleted', 'Your account has been permanently deleted');
            } catch (error) {
                console.error('Delete account error:', error);
                if (error.code === 'auth/requires-recent-login') {
                    errorEl.textContent = 'Please sign out and sign back in, then try again';
                } else {
                    errorEl.textContent = error.message || 'Failed to delete account';
                }
                errorEl.style.display = 'block';
            }
        }
        
        // ============================================
        // GOLF IDENTITY & STATS TRACKING FUNCTIONS
        // ============================================
        
        // Golf identity data structure
        let golfIdentityData = {
            name: '',
            aliases: [],
            trackedPlayers: [] // { name: string, isPrimary: boolean }
        };
        
        // Load golf identity from localStorage/Firebase
        async function loadGolfIdentity() {
            // Try localStorage first
            const saved = localStorage.getItem('golfIdentity');
            if (saved) {
                try {
                    golfIdentityData = JSON.parse(saved);
                } catch (e) {
                    console.error('Error parsing golf identity:', e);
                }
            }
            
            // If logged in, try to load from Firebase
            if (currentAuthUser && db) {
                try {
                    const doc = await db.collection('userProfiles').doc(currentAuthUser.uid).get();
                    if (doc.exists && doc.data().golfIdentity) {
                        golfIdentityData = doc.data().golfIdentity;
                        // Also save to localStorage for offline access
                        localStorage.setItem('golfIdentity', JSON.stringify(golfIdentityData));
                    }
                } catch (e) {
                    console.error('Error loading golf identity from Firebase:', e);
                }
            }
            
            updateGolfIdentityDisplay();
        }
        
        // Save golf identity to localStorage and Firebase
        async function saveGolfIdentityToStorage() {
            // Always save to localStorage
            localStorage.setItem('golfIdentity', JSON.stringify(golfIdentityData));
            
            // If logged in, save to Firebase
            if (currentAuthUser && db) {
                try {
                    await db.collection('userProfiles').doc(currentAuthUser.uid).set({
                        golfIdentity: golfIdentityData,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });
                    console.log('✅ Golf identity saved to Firebase');
                } catch (e) {
                    console.error('Error saving golf identity to Firebase:', e);
                }
            }
        }
        
        // Update the display in account modal
        function updateGolfIdentityDisplay() {
            const nameEl = document.getElementById('golfIdentityName');
            const aliasesEl = document.getElementById('golfIdentityAliases');
            const listEl = document.getElementById('trackedPlayersList');
            const noPlayersEl = document.getElementById('noTrackedPlayers');
            const editEl = document.getElementById('golfIdentityEdit');
            const isEditMode = editEl && editEl.style.display !== 'none';
            
            if (nameEl) {
                nameEl.textContent = golfIdentityData.name || 'Not set';
            }
            
            if (aliasesEl) {
                if (golfIdentityData.aliases && golfIdentityData.aliases.length > 0) {
                    aliasesEl.textContent = golfIdentityData.aliases.join(', ');
                    aliasesEl.style.fontStyle = 'normal';
                } else {
                    aliasesEl.textContent = 'None';
                    aliasesEl.style.fontStyle = 'italic';
                }
            }
            
            // Update tracked players list
            if (listEl) {
                // Clear existing (except the "no players" message)
                const existingPlayers = listEl.querySelectorAll('.tracked-player-item');
                existingPlayers.forEach(el => el.remove());
                
                if (golfIdentityData.trackedPlayers && golfIdentityData.trackedPlayers.length > 0) {
                    if (noPlayersEl) noPlayersEl.style.display = 'none';
                    
                    golfIdentityData.trackedPlayers.forEach((player, index) => {
                        const playerEl = document.createElement('div');
                        playerEl.className = 'tracked-player-item';
                        playerEl.style.cssText = 'display: flex; align-items: center; justify-content: space-between; padding: 6px 10px; background: white; border-radius: 6px; font-size: 13px;';
                        
                        // Only show delete button in edit mode
                        const deleteBtn = isEditMode 
                            ? `<button type="button" onclick="removeTrackedPlayer(${index})" style="padding: 2px 6px; background: #fee2e2; color: #a51c30; border: none; border-radius: 4px; font-size: 10px; cursor: pointer;">✕</button>`
                            : '';
                        
                        playerEl.innerHTML = `
                            <span style="display: flex; align-items: center; gap: 6px;">
                                ${player.isPrimary ? '⭐' : '👤'} 
                                <span style="font-weight: ${player.isPrimary ? '600' : '400'}; color: #1e293b;">${player.name}</span>
                                ${player.isPrimary ? '<span style="font-size: 10px; color: #166534;">(Me)</span>' : ''}
                            </span>
                            ${deleteBtn}
                        `;
                        listEl.appendChild(playerEl);
                    });
                } else {
                    if (noPlayersEl) noPlayersEl.style.display = 'block';
                }
            }
        }
        
        // Toggle edit mode for golf identity
        function toggleGolfIdentityEdit() {
            const displayEl = document.getElementById('golfIdentityDisplay');
            const editEl = document.getElementById('golfIdentityEdit');
            const editBtn = document.getElementById('editGolfIdentityBtn');
            
            if (editEl.style.display === 'none') {
                // Switch to edit mode
                displayEl.style.display = 'none';
                editEl.style.display = 'block';
                editBtn.textContent = 'Cancel';
                editBtn.style.background = '#94a3b8';
                editBtn.style.color = 'white';
                
                // Populate inputs
                document.getElementById('golfIdentityNameInput').value = golfIdentityData.name || '';
                document.getElementById('golfIdentityAliasesInput').value = (golfIdentityData.aliases || []).join(', ');
                
                // Update tracked players to show delete buttons
                updateGolfIdentityDisplay();
            } else {
                // Switch to display mode
                cancelGolfIdentityEdit();
            }
        }
        
        // Cancel golf identity edit
        function cancelGolfIdentityEdit() {
            const displayEl = document.getElementById('golfIdentityDisplay');
            const editEl = document.getElementById('golfIdentityEdit');
            const editBtn = document.getElementById('editGolfIdentityBtn');
            
            displayEl.style.display = 'block';
            editEl.style.display = 'none';
            editBtn.textContent = '⚙️';
            editBtn.style.background = 'transparent';
            editBtn.style.color = '#166534';
            
            // Update tracked players to hide delete buttons
            updateGolfIdentityDisplay();
        }
        
        // Save golf identity
        async function saveGolfIdentity() {
            const nameInput = document.getElementById('golfIdentityNameInput').value.trim();
            const aliasesInput = document.getElementById('golfIdentityAliasesInput').value.trim();
            
            // Parse aliases
            const aliases = aliasesInput ? aliasesInput.split(',').map(a => a.trim()).filter(a => a) : [];
            
            // Update data
            golfIdentityData.name = nameInput;
            golfIdentityData.aliases = aliases;
            
            // If this is the first time setting a name, add as primary tracked player
            if (nameInput && (!golfIdentityData.trackedPlayers || golfIdentityData.trackedPlayers.length === 0)) {
                golfIdentityData.trackedPlayers = [{ name: nameInput, isPrimary: true }];
            } else if (nameInput) {
                // Update the primary player's name if it exists
                const primaryIndex = golfIdentityData.trackedPlayers.findIndex(p => p.isPrimary);
                if (primaryIndex >= 0) {
                    golfIdentityData.trackedPlayers[primaryIndex].name = nameInput;
                } else {
                    // Add as primary if none exists
                    golfIdentityData.trackedPlayers.unshift({ name: nameInput, isPrimary: true });
                }
            }
            
            // Save to storage
            await saveGolfIdentityToStorage();
            
            // Update display
            updateGolfIdentityDisplay();
            cancelGolfIdentityEdit();
            
            showNotification('Saved', 'Golf identity updated');
        }
        
        // Show add tracked player form
        function showAddTrackedPlayerForm() {
            document.getElementById('addTrackedPlayerForm').style.display = 'block';
            document.getElementById('addTrackedPlayerBtn').style.display = 'none';
            document.getElementById('newTrackedPlayerName').value = '';
            document.getElementById('newTrackedPlayerName').focus();
        }
        
        // Hide add tracked player form
        function hideAddTrackedPlayerForm() {
            document.getElementById('addTrackedPlayerForm').style.display = 'none';
            document.getElementById('addTrackedPlayerBtn').style.display = 'block';
        }
        
        // Add a tracked player
        async function addTrackedPlayer() {
            const nameInput = document.getElementById('newTrackedPlayerName').value.trim();
            
            if (!nameInput) {
                showNotification('Error', 'Please enter a player name');
                return;
            }
            
            // Check if already tracking
            if (golfIdentityData.trackedPlayers.some(p => p.name.toLowerCase() === nameInput.toLowerCase())) {
                showNotification('Already Tracking', 'You are already tracking this player');
                return;
            }
            
            // Check limit (1 primary + 4 others = 5 max)
            if (golfIdentityData.trackedPlayers.length >= 5) {
                showNotification('Limit Reached', 'You can track up to 5 players maximum');
                return;
            }
            
            // Add player (not primary)
            golfIdentityData.trackedPlayers.push({ name: nameInput, isPrimary: false });
            
            // Save
            await saveGolfIdentityToStorage();
            
            // Update display
            updateGolfIdentityDisplay();
            hideAddTrackedPlayerForm();
            
            showNotification('Added', `Now tracking ${nameInput}`);
        }
        
        // Remove a tracked player
        async function removeTrackedPlayer(index) {
            const player = golfIdentityData.trackedPlayers[index];
            
            if (player.isPrimary) {
                // Can't remove primary, but can clear it
                if (!confirm('This is your primary identity. Remove it?')) {
                    return;
                }
            }
            
            golfIdentityData.trackedPlayers.splice(index, 1);
            
            // Save
            await saveGolfIdentityToStorage();
            
            // Update display
            updateGolfIdentityDisplay();
            
            showNotification('Removed', `Stopped tracking ${player.name}`);
        }
        
        // Check if a player name matches any tracked identity
        function isTrackedPlayer(playerName) {
            if (!playerName || !golfIdentityData) return false;
            
            const nameLower = playerName.toLowerCase().trim();
            
            // Check primary name
            if (golfIdentityData.name && golfIdentityData.name.toLowerCase() === nameLower) {
                return { matched: true, isPrimary: true, trackedName: golfIdentityData.name };
            }
            
            // Check aliases
            if (golfIdentityData.aliases) {
                for (const alias of golfIdentityData.aliases) {
                    if (alias.toLowerCase() === nameLower) {
                        return { matched: true, isPrimary: true, trackedName: golfIdentityData.name };
                    }
                }
            }
            
            // Check other tracked players
            for (const tracked of (golfIdentityData.trackedPlayers || [])) {
                if (tracked.name.toLowerCase() === nameLower) {
                    return { matched: true, isPrimary: tracked.isPrimary, trackedName: tracked.name };
                }
            }
            
            return { matched: false };
        }
        
        // Fuzzy match for "Is this you?" prompt
        function findPotentialIdentityMatches(players) {
            const matches = [];
            
            if (!golfIdentityData || !players) return matches;
            
            const namesToCheck = [
                golfIdentityData.name,
                ...(golfIdentityData.aliases || []),
                ...(golfIdentityData.trackedPlayers || []).map(p => p.name)
            ].filter(n => n);
            
            for (const player of players) {
                if (!player.name) continue;
                
                const playerNameLower = player.name.toLowerCase().trim();
                
                for (const trackedName of namesToCheck) {
                    const trackedLower = trackedName.toLowerCase().trim();
                    
                    // Exact match
                    if (playerNameLower === trackedLower) {
                        matches.push({ player, trackedName, confidence: 'exact' });
                        break;
                    }
                    
                    // Starts with (e.g., "Otis" matches "Otis Williams")
                    if (playerNameLower.startsWith(trackedLower) || trackedLower.startsWith(playerNameLower)) {
                        matches.push({ player, trackedName, confidence: 'partial' });
                        break;
                    }
                    
                    // First name match
                    const playerFirst = playerNameLower.split(' ')[0];
                    const trackedFirst = trackedLower.split(' ')[0];
                    if (playerFirst === trackedFirst && playerFirst.length > 2) {
                        matches.push({ player, trackedName, confidence: 'firstName' });
                        break;
                    }
                }
            }
            
            return matches;
        }
        
        // Track which tournaments we've already prompted for (to avoid repeat prompts)
        let identityPromptedTournaments = new Set();
        
        // Check for identity matches and show prompt if found
        function checkAndPromptForIdentityMatch(callback) {
            // Skip if no golf identity set up
            if (!golfIdentityData || !golfIdentityData.trackedPlayers || golfIdentityData.trackedPlayers.length === 0) {
                callback();
                return;
            }
            
            // Skip if no tournament data
            if (!tournamentData || !tournamentData.players || tournamentData.players.length === 0) {
                callback();
                return;
            }
            
            // Skip if we already prompted for this tournament
            const tournamentKey = activeTournamentId || tournamentData.name || 'local';
            if (identityPromptedTournaments.has(tournamentKey)) {
                callback();
                return;
            }
            
            // Find potential matches
            const matches = findPotentialIdentityMatches(tournamentData.players);
            
            // If no matches found, continue
            if (matches.length === 0) {
                callback();
                return;
            }
            
            // Mark as prompted
            identityPromptedTournaments.add(tournamentKey);
            
            // Show the identity match modal
            showIdentityMatchModal(matches, callback);
        }
        
        // Show the "Is this you?" modal
        function showIdentityMatchModal(matches, callback) {
            const modal = document.createElement('div');
            modal.id = 'identityMatchModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.7); z-index: 10002;
                display: flex; align-items: center; justify-content: center;
                padding: 20px;
            `;
            
            // Build match list HTML
            const matchListHTML = matches.map((match, index) => {
                const isPrimary = golfIdentityData.trackedPlayers.find(p => p.name === match.trackedName && p.isPrimary);
                return `
                    <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: #f0fdf4; border: 2px solid #166534; border-radius: 6px; margin-bottom: 8px;">
                        <input type="checkbox" id="matchCheck${index}" checked 
                            style="width: 20px; height: 20px; accent-color: #166534;">
                        <div style="flex: 1;">
                            <div style="font-weight: 600; color: #1e293b;">"${match.player.name}"</div>
                            <div style="font-size: 12px; color: #64748b;">
                                → ${isPrimary ? '⭐ ' : ''}${match.trackedName} ${isPrimary ? '(Me)' : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 24px; max-width: 380px; width: 100%; box-shadow: 0 8px 24px rgba(0,0,0,0.3);">
                    <div style="text-align: center; margin-bottom: 16px;">
                        <div style="font-size: 40px; margin-bottom: 8px;">👋</div>
                        <h3 style="margin: 0 0 4px 0; color: #1e3a5f; font-size: 18px;">Is this you?</h3>
                        <p style="margin: 0; color: #64748b; font-size: 13px;">We found player${matches.length > 1 ? 's' : ''} matching your Golf Identity</p>
                    </div>
                    
                    <div style="margin-bottom: 16px;">
                        ${matchListHTML}
                    </div>
                    
                    <p style="font-size: 12px; color: #64748b; text-align: center; margin-bottom: 16px;">
                        📊 Confirming will track stats for your profile
                    </p>
                    
                    <div style="display: flex; gap: 10px;">
                        <button type="button" onclick="skipIdentityMatch()" 
                            style="flex: 1; padding: 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Skip
                        </button>
                        <button type="button" onclick="confirmIdentityMatch()" 
                            style="flex: 1; padding: 12px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Yes, that's me!
                        </button>
                    </div>
                </div>
            `;
            
            // Store callback and matches for later
            window._identityMatchCallback = callback;
            window._identityMatches = matches;
            
            document.body.appendChild(modal);
        }
        
        // Skip identity matching
        function skipIdentityMatch() {
            const modal = document.getElementById('identityMatchModal');
            if (modal) modal.remove();
            
            if (window._identityMatchCallback) {
                window._identityMatchCallback();
                window._identityMatchCallback = null;
            }
        }
        
        // Confirm identity match - link players for stat tracking
        function confirmIdentityMatch() {
            const matches = window._identityMatches || [];
            
            // Get checked matches
            const confirmedMatches = matches.filter((match, index) => {
                const checkbox = document.getElementById(`matchCheck${index}`);
                return checkbox && checkbox.checked;
            });
            
            // Store the linked players for this tournament
            if (confirmedMatches.length > 0) {
                // Save to localStorage which players are linked to tracked identities
                const linkedPlayers = JSON.parse(localStorage.getItem('linkedPlayers') || '{}');
                const tournamentKey = activeTournamentId || tournamentData.name || 'local';
                
                linkedPlayers[tournamentKey] = confirmedMatches.map(m => ({
                    playerName: m.player.name,
                    trackedName: m.trackedName,
                    linkedAt: new Date().toISOString()
                }));
                
                localStorage.setItem('linkedPlayers', JSON.stringify(linkedPlayers));
                
                console.log('✅ Linked players for stat tracking:', linkedPlayers[tournamentKey]);
                showNotification('Tracking Stats', `Tracking ${confirmedMatches.length} player${confirmedMatches.length > 1 ? 's' : ''} for your profile`);
            }
            
            // Close modal and continue
            const modal = document.getElementById('identityMatchModal');
            if (modal) modal.remove();
            
            if (window._identityMatchCallback) {
                window._identityMatchCallback();
                window._identityMatchCallback = null;
            }
            window._identityMatches = null;
        }
        
        // Check if a player is linked for stat tracking in current tournament
        function isPlayerLinkedForTracking(playerName) {
            const linkedPlayers = JSON.parse(localStorage.getItem('linkedPlayers') || '{}');
            const tournamentKey = activeTournamentId || tournamentData?.name || 'local';
            const links = linkedPlayers[tournamentKey] || [];
            
            return links.find(l => l.playerName === playerName);
        }
        
        // Toggle player tracking on/off
        function togglePlayerTracking(playerName) {
            // Check if user has golf identity set up
            if (!golfIdentityData || !golfIdentityData.trackedPlayers || golfIdentityData.trackedPlayers.length === 0) {
                // Prompt to set up golf identity
                const setup = confirm('To track stats, you need to set up your Golf Identity first.\n\nWould you like to set it up now?');
                if (setup) {
                    showAccountModal();
                }
                return;
            }
            
            const linkedPlayers = JSON.parse(localStorage.getItem('linkedPlayers') || '{}');
            const tournamentKey = activeTournamentId || tournamentData?.name || 'local';
            let links = linkedPlayers[tournamentKey] || [];
            
            // Check if this player is already linked
            const existingIndex = links.findIndex(l => l.playerName === playerName);
            
            if (existingIndex >= 0) {
                // Remove link (turning off tracking for this player)
                links.splice(existingIndex, 1);
                linkedPlayers[tournamentKey] = links;
                localStorage.setItem('linkedPlayers', JSON.stringify(linkedPlayers));
                showNotification('Tracking Off', `Stopped tracking ${playerName}`);
            } else {
                // Adding a link
                if (golfIdentityData.trackedPlayers.length === 1) {
                    // Only one tracked identity - REPLACE any existing link
                    const trackedName = golfIdentityData.trackedPlayers[0].name;
                    
                    // Clear all existing links for this identity (can only track one player per identity)
                    links = links.filter(l => l.trackedName !== trackedName);
                    
                    // Add new link
                    links.push({
                        playerName: playerName,
                        trackedName: trackedName,
                        linkedAt: new Date().toISOString()
                    });
                    linkedPlayers[tournamentKey] = links;
                    localStorage.setItem('linkedPlayers', JSON.stringify(linkedPlayers));
                    showNotification('Tracking On', `Now tracking ${playerName} as ${trackedName}`);
                } else {
                    // Multiple tracked players - show picker
                    showTrackingPickerModal(playerName);
                    return; // Don't re-render yet, modal will handle it
                }
            }
            
            // Re-render to update button state
            if (currentView === 'hole') {
                renderHoleView();
            } else {
                const savedIndex = currentCarouselIndex;
                renderCompactPlayerView(getPlayersToShow());
                currentCarouselIndex = savedIndex;
                setTimeout(() => updateCarouselPosition(), 50);
            }
        }
        
        // Show picker modal for choosing which tracked identity to link
        function showTrackingPickerModal(playerName) {
            const modal = document.createElement('div');
            modal.id = 'trackingPickerModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.7); z-index: 10002;
                display: flex; align-items: center; justify-content: center;
                padding: 20px;
            `;
            
            const optionsHTML = golfIdentityData.trackedPlayers.map((tp, index) => `
                <button onclick="linkPlayerToTracked('${playerName.replace(/'/g, "\\'")}', '${tp.name.replace(/'/g, "\\'")}')" 
                    style="width: 100%; padding: 12px; margin-bottom: 8px; background: ${tp.isPrimary ? '#f0fdf4' : 'white'}; border: 2px solid ${tp.isPrimary ? '#166534' : '#e2e8f0'}; border-radius: 8px; font-size: 14px; cursor: pointer; text-align: left;">
                    ${tp.isPrimary ? '⭐ ' : '👤 '}${tp.name} ${tp.isPrimary ? '(Me)' : ''}
                </button>
            `).join('');
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 24px; max-width: 340px; width: 100%;">
                    <h3 style="margin: 0 0 8px 0; color: #1e3a5f; font-size: 16px;">📊 Track as which player?</h3>
                    <p style="margin: 0 0 16px 0; color: #64748b; font-size: 13px;">Link "${playerName}" to one of your tracked identities:</p>
                    ${optionsHTML}
                    <button onclick="document.getElementById('trackingPickerModal').remove()" 
                        style="width: 100%; padding: 10px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 14px; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
        }
        
        // Link a tournament player to a tracked identity
        function linkPlayerToTracked(playerName, trackedName) {
            const linkedPlayers = JSON.parse(localStorage.getItem('linkedPlayers') || '{}');
            const tournamentKey = activeTournamentId || tournamentData?.name || 'local';
            let links = linkedPlayers[tournamentKey] || [];
            
            // CRITICAL: Clear any existing link for this tracked identity
            // Each identity can only track ONE player at a time
            links = links.filter(l => l.trackedName !== trackedName);
            
            links.push({
                playerName: playerName,
                trackedName: trackedName,
                linkedAt: new Date().toISOString()
            });
            
            linkedPlayers[tournamentKey] = links;
            localStorage.setItem('linkedPlayers', JSON.stringify(linkedPlayers));
            
            // Close modal
            const modal = document.getElementById('trackingPickerModal');
            if (modal) modal.remove();
            
            showNotification('Tracking On', `Now tracking ${playerName} as ${trackedName}`);
            
            // Re-render
            if (currentView === 'hole') {
                renderHoleView();
            } else {
                const savedIndex = currentCarouselIndex;
                renderCompactPlayerView(getPlayersToShow());
                currentCarouselIndex = savedIndex;
                setTimeout(() => updateCarouselPosition(), 50);
            }
        }

        // Auth functions
        async function signInUser() {
            // Legacy - redirect to new modal flow
            showSignInModal();
        }
        
        async function registerUser() {
            // Legacy - redirect to new modal flow
            showCreateAccountModal();
        }
        
        
        // Show sign out confirmation
        function showSignOutConfirm() {
            const el = document.getElementById('signOutConfirm');
            if (el) el.style.display = 'block';
        }
        
        // Hide sign out confirmation
        function hideSignOutConfirm() {
            const el = document.getElementById('signOutConfirm');
            if (el) el.style.display = 'none';
        }
        
        async function signOutUser() {
            hideSignOutConfirm();
            try {
                // Capture username before signing out to clear from localStorage
                const previousUsername = currentAuthUser?.displayName || currentAuthUser?.email?.split('@')[0] || '';
                
                await auth.signOut();
                currentAuthUser = null;
                userSubscription = { status: 'free', expiresAt: null, email: null };
                
                // Clear active tournament state on sign out
                activeTournamentId = null;
                tournamentData = null;
                isHost = false;
                isCoHost = false;
                hasJoinedTournament = false;
                claimedPlayers = [];
                tournamentMode = 'single';
                
                // Clear Firebase listener
                if (tournamentUnsubscribe) {
                    tournamentUnsubscribe();
                    tournamentUnsubscribe = null;
                }
                
                // Clear deviceInitials if it matches the signed-out user's name
                const storedInitials = localStorage.getItem('deviceInitials') || '';
                if (storedInitials && previousUsername && 
                    (storedInitials.toLowerCase() === previousUsername.toLowerCase() ||
                     storedInitials.toLowerCase().includes(previousUsername.toLowerCase().split(' ')[0]))) {
                    localStorage.removeItem('deviceInitials');
                    deviceInitials = '';
                }
                
                hideAccountModal();
                
                // Reset device initials display to "Guest"
                const guestInitialsSpan = document.getElementById('guestDeviceInitials');
                const hostInitialsSpan = document.getElementById('hostDeviceInitials');
                if (guestInitialsSpan) guestInitialsSpan.textContent = 'Guest';
                if (hostInitialsSpan) hostInitialsSpan.textContent = 'Guest';
                
                // Force hide profile buttons and show sign in buttons
                const guestProfileBtn = document.getElementById('guestProfileBtn');
                const hostProfileBtn = document.getElementById('hostProfileBtn');
                const guestSignInBtn = document.getElementById('guestSignInBtn');
                const hostSignInBtn = document.getElementById('hostSignInBtn');
                const guestDeviceCorner = document.getElementById('guestDeviceCorner');
                const hostDeviceCorner = document.getElementById('hostDeviceCorner');
                const guestOwnerBadge = document.getElementById('guestOwnerBadge');
                const hostOwnerBadge = document.getElementById('hostOwnerBadge');
                
                // Hide profile buttons and owner badges
                if (guestProfileBtn) guestProfileBtn.style.display = 'none';
                if (hostProfileBtn) hostProfileBtn.style.display = 'none';
                if (guestOwnerBadge) guestOwnerBadge.style.display = 'none';
                if (hostOwnerBadge) hostOwnerBadge.style.display = 'none';
                
                // Show sign-in button, hide device corner (since not logged in)
                if (guestSignInBtn) guestSignInBtn.style.display = 'inline-flex';
                if (hostSignInBtn) hostSignInBtn.style.display = 'inline-flex';
                if (guestDeviceCorner) guestDeviceCorner.style.display = 'none';
                if (hostDeviceCorner) hostDeviceCorner.style.display = 'none';
                
                // Force update the UI
                updateAccountUI();
                
                // Refresh home page to hide tournaments
                populateHomeRoundsList();
                
                // Navigate to guest home page
                showPage('guestHomePage');
                
                showNotification('Signed Out', 'See you next time!');
            } catch (error) {
                console.error('Sign out error:', error);
            }
        }
        
        async function sendPasswordReset() {
            // Legacy function - redirect to new modal
            showForgotPasswordModal();
        }
        
        // ============================================
        // AUTH MODAL FUNCTIONS
        // ============================================
        
        // Show Sign In Modal
        function showSignInModal() {
            const modal = document.getElementById('signInModal');
            if (modal) {
                modal.style.setProperty('display', 'flex', 'important');
                modal.style.visibility = 'visible';
                modal.style.opacity = '1';
                modal.style.pointerEvents = 'auto';
                document.getElementById('signInEmail').value = '';
                document.getElementById('signInPassword').value = '';
                document.getElementById('signInError').style.display = 'none';
                document.getElementById('signInEmail').focus();
            }
        }
        
        // Close Sign In Modal
        function closeSignInModal() {
            const modal = document.getElementById('signInModal');
            if (modal) {
                modal.style.setProperty('display', 'none', 'important');
                modal.style.visibility = 'hidden';
                modal.style.opacity = '0';
                modal.style.pointerEvents = 'none';
            }
        }
        
        // Show Create Account Modal
        function showCreateAccountModal() {
            const modal = document.getElementById('createAccountModal');
            if (modal) {
                modal.style.display = 'flex';
                document.getElementById('createEmail').value = '';
                document.getElementById('createPassword').value = '';
                document.getElementById('createPasswordConfirm').value = '';
                document.getElementById('createError').style.display = 'none';
                document.getElementById('createEmail').focus();
            }
        }
        
        // Close Create Account Modal
        function closeCreateAccountModal() {
            const modal = document.getElementById('createAccountModal');
            if (modal) modal.style.display = 'none';
        }
        
        // Show Forgot Password Modal
        function showForgotPasswordModal() {
            const modal = document.getElementById('forgotPasswordModal');
            if (modal) {
                modal.style.display = 'flex';
                document.getElementById('forgotEmail').value = '';
                document.getElementById('forgotError').style.display = 'none';
                document.getElementById('forgotSuccess').style.display = 'none';
                document.getElementById('forgotEmail').focus();
            }
        }
        
        // Close Forgot Password Modal
        function closeForgotPasswordModal() {
            const modal = document.getElementById('forgotPasswordModal');
            if (modal) modal.style.display = 'none';
        }
        
        // Do Sign In
        async function doSignIn() {
            const email = document.getElementById('signInEmail')?.value?.trim();
            const password = document.getElementById('signInPassword')?.value;
            const errorEl = document.getElementById('signInError');
            
            if (!email || !password) {
                if (errorEl) {
                    errorEl.textContent = 'Please enter email and password';
                    errorEl.style.display = 'block';
                }
                return;
            }
            
            try {
                if (errorEl) errorEl.style.display = 'none';
                
                await auth.signInWithEmailAndPassword(email, password);
                
                // Close modal FIRST using proper function
                closeSignInModal();
                
                // Small delay before updating UI to ensure modal is gone
                setTimeout(() => {
                    // Update UI
                    updateAccountUI();
                    updateHomePageLoginStatus();
                    populateHomeRoundsList();
                    
                    showNotification('✅ Signed In', 'Welcome back!');
                }, 100);
                
            } catch (error) {
                console.error('Sign in error:', error);
                if (errorEl) {
                    errorEl.textContent = getAuthErrorMessage(error.code);
                    errorEl.style.display = 'block';
                }
            }
        }
        
        // Do Create Account
        async function doCreateAccount() {
            const email = document.getElementById('createEmail').value.trim();
            const password = document.getElementById('createPassword').value;
            const confirmPassword = document.getElementById('createPasswordConfirm').value;
            const errorEl = document.getElementById('createError');
            
            if (!email || !password || !confirmPassword) {
                errorEl.textContent = 'Please fill in all fields';
                errorEl.style.display = 'block';
                return;
            }
            
            if (password !== confirmPassword) {
                errorEl.textContent = 'Passwords do not match';
                errorEl.style.display = 'block';
                return;
            }
            
            if (password.length < 6) {
                errorEl.textContent = 'Password must be at least 6 characters';
                errorEl.style.display = 'block';
                return;
            }
            
            try {
                errorEl.style.display = 'none';
                await auth.createUserWithEmailAndPassword(email, password);
                closeCreateAccountModal();
                showNotification('✅ Account Created', 'Welcome to Let\'s Golf!');
            } catch (error) {
                errorEl.textContent = getAuthErrorMessage(error.code);
                errorEl.style.display = 'block';
            }
        }
        
        // Do Forgot Password
        async function doForgotPassword() {
            const email = document.getElementById('forgotEmail').value.trim();
            const errorEl = document.getElementById('forgotError');
            const successEl = document.getElementById('forgotSuccess');
            
            if (!email) {
                errorEl.textContent = 'Please enter your email';
                errorEl.style.display = 'block';
                successEl.style.display = 'none';
                return;
            }
            
            try {
                errorEl.style.display = 'none';
                await auth.sendPasswordResetEmail(email);
                successEl.textContent = '✅ Reset link sent! Check your email (and spam folder).';
                successEl.style.display = 'block';
            } catch (error) {
                errorEl.textContent = getAuthErrorMessage(error.code);
                errorEl.style.display = 'block';
                successEl.style.display = 'none';
            }
        }
        
        function getAuthErrorMessage(code) {
            const messages = {
                'auth/email-already-in-use': 'Email already in use. Try signing in.',
                'auth/invalid-email': 'Invalid email address',
                'auth/user-not-found': 'No account found with this email',
                'auth/wrong-password': 'Incorrect password',
                'auth/weak-password': 'Password must be at least 6 characters',
                'auth/too-many-requests': 'Too many attempts. Try again later.',
                'auth/network-request-failed': 'Network error. Check your connection.',
                'auth/operation-not-allowed': 'Email/password sign-in not enabled. Contact support.',
                'auth/configuration-not-found': 'Auth not configured. Enable Email/Password in Firebase Console.',
                'auth/invalid-api-key': 'Invalid API key. Contact support.',
                'auth/app-deleted': 'App was deleted. Please refresh.',
                'auth/invalid-credential': 'Invalid email or password'
            };
            return messages[code] || `Error: ${code || 'Unknown'}. Please try again.`;
        }
        
        // Paywall functions
        function showPaywall(reason) {
            const modal = document.getElementById('paywallModal');
            const reasonEl = document.getElementById('paywallReason');
            
            if (reason) {
                reasonEl.textContent = reason;
            } else {
                reasonEl.textContent = 'Unlock multi-device scoring and unlimited players';
            }
            
            // Default to week plan
            selectPlan('week');
            modal.style.display = 'flex';
        }
        
        function hidePaywall() {
            document.getElementById('paywallModal').style.display = 'none';
        }
        
        function selectPlan(plan) {
            selectedPlan = plan;
            const price = PLAN_PRICES[plan].price;
            
            // Update button
            document.getElementById('purchaseBtn').textContent = `Continue - $${price.toFixed(2)}`;
            
            // Plan colors
            const planColors = {
                day: { border: '#166534', fill: '#f0fdf4', text: '#166534' },
                week: { border: '#1e3a5f', fill: '#eff6ff', text: '#1e3a5f' },
                season: { border: '#f59e0b', fill: '#fffbeb', text: '#f59e0b' }
            };
            
            // Update visual selection
            ['day', 'week', 'season'].forEach(p => {
                const btn = document.getElementById('plan' + p.charAt(0).toUpperCase() + p.slice(1));
                const colors = planColors[p];
                
                if (p === plan) {
                    // Selected - colored fill and thick border
                    btn.style.background = colors.fill;
                    btn.style.borderColor = colors.border;
                    btn.style.borderWidth = '3px';
                } else {
                    // Unselected - white fill, normal border
                    btn.style.background = 'white';
                    btn.style.borderColor = colors.border;
                    btn.style.borderWidth = '2px';
                }
            });
        }
        
        async function processPurchase() {
            // Check if user is logged in
            if (!currentAuthUser) {
                hidePaywall();
                showAccountModal();
                showNotification('Sign In Required', 'Please create an account or sign in to purchase');
                return;
            }
            
            const plan = PLAN_PRICES[selectedPlan];
            
            if (STRIPE_TEST_MODE) {
                // TEST MODE: Simulate purchase (for development/testing)
                try {
                    const expiresAt = new Date();
                    expiresAt.setDate(expiresAt.getDate() + plan.days);
                    
                    await db.collection('users').doc(currentAuthUser.uid).update({
                        subscriptionStatus: selectedPlan,
                        subscriptionExpiresAt: firebase.firestore.Timestamp.fromDate(expiresAt),
                        lastPurchase: {
                            plan: selectedPlan,
                            price: plan.price,
                            purchasedAt: firebase.firestore.FieldValue.serverTimestamp(),
                            testMode: true
                        }
                    });
                    
                    userSubscription = {
                        status: selectedPlan,
                        expiresAt: expiresAt,
                        email: currentAuthUser.email
                    };
                    
                    hidePaywall();
                    updateAccountUI();
                    showNotification('🎉 Test Purchase Complete!', `${plan.label} activated until ${expiresAt.toLocaleDateString()}`);
                    
                } catch (error) {
                    console.error('Purchase error:', error);
                    showNotification('Error', 'Purchase failed. Please try again.');
                }
            } else {
                // PRODUCTION MODE: Redirect to Stripe Payment Link
                const paymentLink = STRIPE_PAYMENT_LINKS[selectedPlan];
                
                if (!paymentLink || paymentLink.includes('YOUR_')) {
                    showNotification('Not Configured', 'Payment links not yet configured. Please contact support.');
                    return;
                }
                
                // Add user info to the payment link URL
                // Stripe will capture this in the custom field
                const uid = currentAuthUser.uid;
                const email = encodeURIComponent(currentAuthUser.email);
                
                // Construct the URL with prefilled email and client reference
                // Format: https://buy.stripe.com/xxx?prefilled_email=xxx&client_reference_id=xxx
                const separator = paymentLink.includes('?') ? '&' : '?';
                const fullUrl = `${paymentLink}${separator}prefilled_email=${email}&client_reference_id=${uid}`;
                
                // Store pending purchase info (will be verified when user returns)
                localStorage.setItem('pendingPurchase', JSON.stringify({
                    plan: selectedPlan,
                    uid: uid,
                    timestamp: Date.now()
                }));
                
                hidePaywall();
                
                // Open Stripe in new tab (or redirect)
                window.open(fullUrl, '_blank');
                
                showNotification('Opening Stripe', 'Complete your purchase in the new tab. Return here when done.');
            }
        }
        
        // Check for returning from Stripe payment
        function checkPaymentReturn() {
            const urlParams = new URLSearchParams(window.location.search);
            const paymentSuccess = urlParams.get('payment_success');
            const plan = urlParams.get('plan');
            
            if (paymentSuccess === 'true' && plan) {
                // Clear URL params
                window.history.replaceState({}, document.title, window.location.pathname);
                
                showNotification('🎉 Payment Received!', `Your ${PLAN_PRICES[plan]?.label || 'subscription'} is being activated...`);
                
                // Reload subscription status (webhook should have updated it)
                if (currentAuthUser) {
                    setTimeout(() => {
                        loadUserSubscription(currentAuthUser.uid);
                    }, 2000);
                }
            }
            
            // Also check for pending purchase on page load
            const pending = localStorage.getItem('pendingPurchase');
            if (pending && currentAuthUser) {
                const { plan, uid, timestamp } = JSON.parse(pending);
                // If purchase was less than 1 hour ago, check status
                if (Date.now() - timestamp < 3600000 && uid === currentAuthUser.uid) {
                    // Silently reload subscription to see if it was activated
                    loadUserSubscription(currentAuthUser.uid);
                }
                localStorage.removeItem('pendingPurchase');
            }
        }
        
        // Restore purchase - reload subscription from Firebase
        async function restorePurchase() {
            if (!currentAuthUser) {
                showNotification('Sign In Required', 'Please sign in to restore your purchase');
                return;
            }
            
            showNotification('Checking...', 'Looking for your subscription...');
            
            try {
                await loadUserSubscription(currentAuthUser.uid);
                updateAccountUI();
                
                if (hasActiveSubscription()) {
                    showNotification('✅ Restored!', `Your ${PLAN_PRICES[userSubscription.status]?.label || 'subscription'} is active`);
                } else {
                    showNotification('No Active Subscription', 'No subscription found. If you recently purchased, please wait a few minutes and try again.');
                }
            } catch (error) {
                console.error('Restore error:', error);
                showNotification('Error', 'Could not check subscription status. Please try again.');
            }
        }
        
        // Send email verification
        async function sendVerificationEmail() {
            if (!currentAuthUser) return;
            
            try {
                await currentAuthUser.sendEmailVerification();
                showNotification('📧 Email Sent', 'Check your inbox for verification link');
            } catch (error) {
                console.error('Verification email error:', error);
                if (error.code === 'auth/too-many-requests') {
                    showNotification('Please Wait', 'Verification email already sent. Check your inbox.');
                } else {
                    showNotification('Error', 'Could not send verification email. Try again later.');
                }
            }
        }
        
        // Show/hide change email form
        function showChangeEmailForm() {
            document.getElementById('changeEmailForm').style.display = 'block';
            document.getElementById('changePasswordForm').style.display = 'none';
            document.getElementById('newEmailInput').value = '';
            document.getElementById('currentPasswordForEmail').value = '';
            document.getElementById('changeEmailError').style.display = 'none';
        }
        
        function hideChangeEmailForm() {
            const form = document.getElementById('changeEmailForm');
            if (form) form.style.display = 'none';
            const modal = document.getElementById('changeEmailModal');
            if (modal) modal.remove();
        }
        
        // Show/hide change password form
        function showChangePasswordForm() {
            // Now using modal instead
            showChangePasswordModal();
        }
        
        function hideChangePasswordForm() {
            const form = document.getElementById('changePasswordForm');
            if (form) form.style.display = 'none';
            const modal = document.getElementById('changePasswordModal');
            if (modal) modal.remove();
        }
        
        // Show/hide change email form (legacy - now using modal)
        function showChangeEmailForm() {
            showChangeEmailModal();
        }
        
        // Update email
        async function updateEmail() {
            const newEmail = document.getElementById('newEmailInput').value.trim();
            const currentPassword = document.getElementById('currentPasswordForEmail').value;
            const errorEl = document.getElementById('changeEmailError');
            
            if (!newEmail) {
                errorEl.textContent = 'Please enter new email';
                errorEl.style.display = 'block';
                return;
            }
            
            if (!currentPassword) {
                errorEl.textContent = 'Please enter current password to confirm';
                errorEl.style.display = 'block';
                return;
            }
            
            try {
                // Re-authenticate user first
                const credential = firebase.auth.EmailAuthProvider.credential(
                    currentAuthUser.email,
                    currentPassword
                );
                await currentAuthUser.reauthenticateWithCredential(credential);
                
                // Update email
                await currentAuthUser.updateEmail(newEmail);
                
                // Send verification to new email
                await currentAuthUser.sendEmailVerification();
                
                hideChangeEmailForm();
                showNotification('✅ Email Updated', 'Verification sent to new email');
                
                // Refresh the modal display
                showAccountModal();
                
            } catch (error) {
                console.error('Update email error:', error);
                errorEl.textContent = getAuthErrorMessage(error.code);
                errorEl.style.display = 'block';
            }
        }
        
        // Update password
        async function updatePassword() {
            const currentPassword = document.getElementById('currentPasswordInput').value;
            const newPassword = document.getElementById('newPasswordInput').value;
            const errorEl = document.getElementById('changePasswordError');
            
            if (!currentPassword) {
                errorEl.textContent = 'Please enter current password';
                errorEl.style.display = 'block';
                return;
            }
            
            if (!newPassword || newPassword.length < 6) {
                errorEl.textContent = 'New password must be at least 6 characters';
                errorEl.style.display = 'block';
                return;
            }
            
            try {
                // Re-authenticate user first
                const credential = firebase.auth.EmailAuthProvider.credential(
                    currentAuthUser.email,
                    currentPassword
                );
                await currentAuthUser.reauthenticateWithCredential(credential);
                
                // Update password
                await currentAuthUser.updatePassword(newPassword);
                
                hideChangePasswordForm();
                showNotification('✅ Password Updated', 'Your password has been changed');
                
            } catch (error) {
                console.error('Update password error:', error);
                errorEl.textContent = getAuthErrorMessage(error.code);
                errorEl.style.display = 'block';
            }
        }
        
        // Show/hide change username form
        function showChangeUsernameForm() {
            // Create popup modal for username change
            const modal = document.createElement('div');
            modal.id = 'changeUsernameModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.7); z-index: 10003;
                display: flex; align-items: center; justify-content: center;
                padding: 20px;
            `;
            
            const currentUsername = currentAuthUser?.displayName || '';
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 20px; max-width: 340px; width: 100%;">
                    <h3 style="margin: 0 0 16px 0; color: #1e3a5f; font-size: 16px;">✏️ Change Username</h3>
                    <input type="text" id="newUsernameInput" placeholder="New username" maxlength="20" value="${currentUsername}"
                        style="width: 100%; padding: 12px; border: 1.5px solid #1e3a5f; border-radius: 8px; font-size: 14px; margin-bottom: 8px; box-sizing: border-box;">
                    <div id="changeUsernameError" style="display: none; color: #a51c30; font-size: 12px; margin-bottom: 8px;"></div>
                    <div style="display: flex; gap: 8px;">
                        <button type="button" onclick="document.getElementById('changeUsernameModal').remove()" 
                            style="flex: 1; padding: 10px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">Cancel</button>
                        <button type="button" onclick="updateUsername()" 
                            style="flex: 1; padding: 10px; background: #1e3a5f; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">Update</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
            document.getElementById('newUsernameInput').focus();
        }
        
        function hideChangeUsernameForm() {
            const modal = document.getElementById('changeUsernameModal');
            if (modal) modal.remove();
        }
        
        // Change Email popup modal
        function showChangeEmailModal() {
            const modal = document.createElement('div');
            modal.id = 'changeEmailModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.7); z-index: 10003;
                display: flex; align-items: center; justify-content: center;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 20px; max-width: 340px; width: 100%;">
                    <h3 style="margin: 0 0 16px 0; color: #1e3a5f; font-size: 16px;">✏️ Change Email</h3>
                    <input type="email" id="newEmailInput" placeholder="New email address"
                        style="width: 100%; padding: 12px; border: 1.5px solid #1e3a5f; border-radius: 8px; font-size: 14px; margin-bottom: 8px; box-sizing: border-box;">
                    <input type="password" id="currentPasswordForEmail" placeholder="Current password to confirm"
                        style="width: 100%; padding: 12px; border: 1.5px solid #e2e8f0; border-radius: 8px; font-size: 14px; margin-bottom: 8px; box-sizing: border-box;">
                    <div id="changeEmailError" style="display: none; color: #a51c30; font-size: 12px; margin-bottom: 8px;"></div>
                    <div style="display: flex; gap: 8px;">
                        <button type="button" onclick="document.getElementById('changeEmailModal').remove()" 
                            style="flex: 1; padding: 10px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">Cancel</button>
                        <button type="button" onclick="updateEmailFromModal()" 
                            style="flex: 1; padding: 10px; background: #1e3a5f; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">Update</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
            document.getElementById('newEmailInput').focus();
        }
        
        // Change Password popup modal
        function showChangePasswordModal() {
            const modal = document.createElement('div');
            modal.id = 'changePasswordModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.7); z-index: 10003;
                display: flex; align-items: center; justify-content: center;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 20px; max-width: 340px; width: 100%;">
                    <h3 style="margin: 0 0 16px 0; color: #1e3a5f; font-size: 16px;">🔒 Change Password</h3>
                    <input type="password" id="currentPasswordInput" placeholder="Current password"
                        style="width: 100%; padding: 12px; border: 1.5px solid #e2e8f0; border-radius: 8px; font-size: 14px; margin-bottom: 8px; box-sizing: border-box;">
                    <input type="password" id="newPasswordInput" placeholder="New password (min 6 chars)"
                        style="width: 100%; padding: 12px; border: 1.5px solid #1e3a5f; border-radius: 8px; font-size: 14px; margin-bottom: 8px; box-sizing: border-box;">
                    <div id="changePasswordError" style="display: none; color: #a51c30; font-size: 12px; margin-bottom: 8px;"></div>
                    <div style="display: flex; gap: 8px;">
                        <button type="button" onclick="document.getElementById('changePasswordModal').remove()" 
                            style="flex: 1; padding: 10px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">Cancel</button>
                        <button type="button" onclick="updatePasswordFromModal()" 
                            style="flex: 1; padding: 10px; background: #1e3a5f; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">Update</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
            document.getElementById('currentPasswordInput').focus();
        }
        
        // Update email from modal
        async function updateEmailFromModal() {
            const newEmail = document.getElementById('newEmailInput').value.trim();
            const password = document.getElementById('currentPasswordForEmail').value;
            const errorEl = document.getElementById('changeEmailError');
            
            if (!newEmail || !password) {
                errorEl.textContent = 'Please fill in all fields';
                errorEl.style.display = 'block';
                return;
            }
            
            try {
                // Re-authenticate
                const credential = firebase.auth.EmailAuthProvider.credential(currentAuthUser.email, password);
                await currentAuthUser.reauthenticateWithCredential(credential);
                
                // Update email
                await currentAuthUser.updateEmail(newEmail);
                
                document.getElementById('changeEmailModal').remove();
                showNotification('✅ Email Updated', 'Verification email sent to new address');
                showAccountModal();
            } catch (error) {
                console.error('Update email error:', error);
                if (error.code === 'auth/wrong-password') {
                    errorEl.textContent = 'Incorrect password';
                } else if (error.code === 'auth/email-already-in-use') {
                    errorEl.textContent = 'Email already in use';
                } else {
                    errorEl.textContent = error.message || 'Failed to update email';
                }
                errorEl.style.display = 'block';
            }
        }
        
        // Update password from modal
        async function updatePasswordFromModal() {
            const currentPassword = document.getElementById('currentPasswordInput').value;
            const newPassword = document.getElementById('newPasswordInput').value;
            const errorEl = document.getElementById('changePasswordError');
            
            if (!currentPassword || !newPassword) {
                errorEl.textContent = 'Please fill in all fields';
                errorEl.style.display = 'block';
                return;
            }
            
            if (newPassword.length < 6) {
                errorEl.textContent = 'Password must be at least 6 characters';
                errorEl.style.display = 'block';
                return;
            }
            
            try {
                // Re-authenticate
                const credential = firebase.auth.EmailAuthProvider.credential(currentAuthUser.email, currentPassword);
                await currentAuthUser.reauthenticateWithCredential(credential);
                
                // Update password
                await currentAuthUser.updatePassword(newPassword);
                
                document.getElementById('changePasswordModal').remove();
                showNotification('✅ Password Updated', 'Your password has been changed');
            } catch (error) {
                console.error('Update password error:', error);
                if (error.code === 'auth/wrong-password') {
                    errorEl.textContent = 'Incorrect current password';
                } else {
                    errorEl.textContent = error.message || 'Failed to update password';
                }
                errorEl.style.display = 'block';
            }
        }
        
        // Update username (now called from modal)
        async function updateUsername() {
            const newUsername = document.getElementById('newUsernameInput').value.trim();
            const errorEl = document.getElementById('changeUsernameError');
            
            if (!newUsername || newUsername.length < 2) {
                errorEl.textContent = 'Username must be at least 2 characters';
                errorEl.style.display = 'block';
                return;
            }
            
            if (newUsername.length > 20) {
                errorEl.textContent = 'Username must be 20 characters or less';
                errorEl.style.display = 'block';
                return;
            }
            
            try {
                await currentAuthUser.updateProfile({
                    displayName: newUsername
                });
                
                // Also save to localStorage as deviceInitials for compatibility
                localStorage.setItem('deviceInitials', newUsername);
                deviceInitials = newUsername;
                
                hideChangeUsernameForm();
                showNotification('✅ Username Updated', `Now showing as "${newUsername}"`);
                
                // Refresh the modal display
                showAccountModal();
                
                // Update the account button and Connected As displays
                updateAccountUI();
                
            } catch (error) {
                console.error('Update username error:', error);
                errorEl.textContent = 'Failed to update username. Try again.';
                errorEl.style.display = 'block';
            }
        }
        
        // Show/hide delete account confirmation
        function showDeleteAccountConfirmOld() {
            // Deprecated - now handled by showDeleteAccountConfirm in showAccountModal
        }
        
        function hideDeleteAccountConfirm() {
            const form = document.getElementById('deleteAccountConfirm');
            if (form) form.style.display = 'none';
        }
        
        // Delete account permanently
        async function deleteAccount() {
            const password = document.getElementById('deleteAccountPassword').value;
            const errorEl = document.getElementById('deleteAccountError');
            
            if (!password) {
                errorEl.textContent = 'Please enter your password to confirm';
                errorEl.style.display = 'block';
                return;
            }
            
            try {
                // Re-authenticate user first
                const credential = firebase.auth.EmailAuthProvider.credential(
                    currentAuthUser.email,
                    password
                );
                await currentAuthUser.reauthenticateWithCredential(credential);
                
                const uid = currentAuthUser.uid;
                
                // Delete user's subscription data from Firestore
                try {
                    await db.collection('subscriptions').doc(uid).delete();
                } catch (e) {
                    console.log('No subscription to delete or error:', e);
                }
                
                // Delete the Firebase Auth account
                await currentAuthUser.delete();
                
                // Clear local state
                currentAuthUser = null;
                userSubscription = { status: 'free', expiresAt: null, email: null };
                
                hideAccountModal();
                updateAccountUI();
                showNotification('Account Deleted', 'Your account has been permanently deleted');
                
            } catch (error) {
                console.error('Delete account error:', error);
                errorEl.textContent = getAuthErrorMessage(error.code);
                errorEl.style.display = 'block';
            }
        }
        
        // ===== END SUBSCRIPTION SYSTEM =====
        
        // Start initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeFirebase);
        } else {
            initializeFirebase();
        }

        // Global Firebase state
        let db = null;
        let auth = null;
        let currentUserId = null;
        let currentDeviceId = null;
        let deviceName = null;
        let deviceInitials = null;
        
        // Get the identifier to use for claiming players
        // If signed in, use userId (persists across refreshes/devices)
        // If guest, use deviceId (current behavior)
        function getClaimIdentifier() {
            if (currentAuthUser && currentAuthUser.uid) {
                return 'user_' + currentAuthUser.uid;
            }
            return currentDeviceId;
        }
        
        // Check if a player is claimed by the current user/device
        function isClaimedByMe(player) {
            if (!player || !player.claimedBy) return false;
            
            // Check if claimed by current user (account-based with user_ prefix)
            if (currentAuthUser && currentAuthUser.uid) {
                if (player.claimedBy === 'user_' + currentAuthUser.uid) return true;
                // Also check by display name (for backward compatibility)
                if (currentAuthUser.displayName && player.claimedBy === currentAuthUser.displayName) return true;
                // Also check by email prefix
                if (currentAuthUser.email) {
                    const emailPrefix = currentAuthUser.email.split('@')[0];
                    if (player.claimedBy === emailPrefix) return true;
                }
            }
            
            // Check if claimed by current device (legacy/guest)
            if (player.claimedBy === currentDeviceId) return true;
            
            // Check device initials
            if (deviceInitials && player.claimedBy === deviceInitials) return true;
            
            return false;
        }
        
        // Get display name for a claimedBy value
        function getClaimerDisplayName(claimedBy, tournament) {
            if (!claimedBy || claimedBy === 'null' || claimedBy === 'undefined') return null;
            
            // If it's a user_ ID, try to find display name from tournament devices
            if (claimedBy.startsWith('user_')) {
                // Check tournament devices for this user ID
                if (tournament && tournament.devices && tournament.devices[claimedBy]) {
                    const device = tournament.devices[claimedBy];
                    if (device.displayName) return device.displayName.substring(0, 8);
                    if (device.name) return device.name.substring(0, 8);
                    if (device.initials) return device.initials;
                }
                
                // If current user matches, use their display name
                if (currentAuthUser && claimedBy === 'user_' + currentAuthUser.uid) {
                    return currentAuthUser.displayName || currentAuthUser.email?.split('@')[0] || 'You';
                }
                
                // Fallback: don't show gibberish, just say "Player"
                return 'Player';
            }
            
            // If it's a device ID (starts with 'device_'), shorten it
            if (claimedBy.startsWith('device_')) {
                return 'Device';
            }
            
            // Otherwise it's initials or name - use first 8 chars
            return claimedBy.substring(0, 8);
        }
        
        // Subscription state
        let currentAuthUser = null;  // Firebase auth user
        let userSubscription = {
            status: 'free',  // 'free', 'day', 'week', 'season'
            expiresAt: null,
            email: null
        };
        let selectedPlan = 'week';  // Default selection in paywall
        
        // ===== STRIPE CONFIGURATION =====
        // TO SET UP STRIPE:
        // 1. Go to Stripe Dashboard > Payment Links
        // 2. Create 3 payment links (Day Pass $4.99, Week Pass $9.99, Season Pass $49.99)
        // 3. For each link, add a custom field to collect the user's Firebase UID:
        //    - Add "Custom field" > "Short answer" > Label: "User ID" > Required
        // 4. Set the success URL to your app URL with ?payment_success=true&plan=day (or week/season)
        // 5. Copy the payment link URLs below
        // 6. Set up a webhook in Stripe to listen for checkout.session.completed
        //    and update Firebase with the subscription info
        
        const STRIPE_PAYMENT_LINKS = {
            day: 'https://buy.stripe.com/YOUR_DAY_PASS_LINK',      // Replace with your actual link
            week: 'https://buy.stripe.com/YOUR_WEEK_PASS_LINK',    // Replace with your actual link
            season: 'https://buy.stripe.com/YOUR_SEASON_PASS_LINK' // Replace with your actual link
        };
        
        // For testing without real Stripe, set this to true
        // This will simulate purchases (writes directly to Firebase)
        const STRIPE_TEST_MODE = true;  // Set to false when you have real Stripe links
        
        const PLAN_PRICES = {
            day: { price: 4.99, label: 'Day Pass', days: 1 },
            week: { price: 9.99, label: 'Week Pass', days: 7 },
            season: { price: 49.99, label: 'Season Pass', days: 365 }
        };
        const FREE_PLAYER_LIMIT = 4;
        
        // Player order storage (per device)
        let playerOrder = {
            claimed: [],   // Player names in custom order
            watching: []   // Watched player names in custom order
        };
        
        // Results filter
        let currentResultsFilter = 'all'; // 'all' or 'mine'
        let unsubscribeFunctions = [];
        let authCompleted = false;
        let firebaseReady = false; // Track if Firebase is loaded and initialized

        // CRITICAL FALLBACK: Set timer immediately on page load
        // This creates persistent IDs if Firebase init fails
        console.log('⏰ Starting 3-second fallback timer...');
        setTimeout(() => {
            if (!authCompleted && !currentUserId) {
                console.warn('⏱️ Firebase initialization timeout');
                
                // Check if Firebase loaded
                if (typeof firebase !== 'undefined' && firebaseReady) {
                    console.log('Firebase loaded but auth not complete - creating device IDs');
                    authCompleted = true;
                    
                    // Generate persistent user ID (stored in localStorage)
                    if (!localStorage.getItem('persistentUserId')) {
                        localStorage.setItem('persistentUserId', 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
                    }
                    currentUserId = localStorage.getItem('persistentUserId');
                    
                    // Generate persistent device ID (stored in localStorage)
                    if (!localStorage.getItem('deviceId')) {
                        localStorage.setItem('deviceId', 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
                    }
                    currentDeviceId = localStorage.getItem('deviceId');
                    
                    // Initialize device name and initials
                    deviceName = localStorage.getItem('deviceName') || 'My Device';
                    deviceInitials = localStorage.getItem('deviceInitials') || '';
                    
                    console.log('✅ Device IDs created via fallback');
                    console.log('   User ID:', currentUserId);
                    console.log('   Device ID:', currentDeviceId);
                } else {
                    console.error('❌ Firebase not loaded - Multi-Device mode unavailable');
                    console.log('   Please use Single-Device mode or refresh the page');
                }
            } else {
                console.log('✓ Device IDs already set, no fallback needed');
            }
        }, 3000);

        // ========================================
        // COURSE DATA
        // ========================================
        
        // Course data with tee information for course handicap calculation
        const courses = {
            oak_quarry: {
                name: "Oak Quarry Golf Club",
                city: "Riverside",
                state: "CA",
                totalPar: 72,
                tees: {
                    tournament: { name: "Tournament", rating: 73.8, slope: 137, yardage: 7002 },
                    championship: { name: "Championship", rating: 71.8, slope: 131, yardage: 6600 },
                    regular: { name: "Regular", rating: 69.3, slope: 125, yardage: 6028 },
                    forward: { name: "Forward", rating: 71.9, slope: 122, yardage: 5408 }
                },
                defaultTee: "regular",
                holes: [
                    { number: 1, par: 4, handicap: 7 },
                    { number: 2, par: 4, handicap: 11 },
                    { number: 3, par: 4, handicap: 1 },
                    { number: 4, par: 4, handicap: 5 },
                    { number: 5, par: 5, handicap: 17 },
                    { number: 6, par: 4, handicap: 15 },
                    { number: 7, par: 3, handicap: 13 },
                    { number: 8, par: 4, handicap: 3 },
                    { number: 9, par: 3, handicap: 9 },
                    { number: 10, par: 4, handicap: 18 },
                    { number: 11, par: 4, handicap: 6 },
                    { number: 12, par: 3, handicap: 12 },
                    { number: 13, par: 4, handicap: 8 },
                    { number: 14, par: 5, handicap: 14 },
                    { number: 15, par: 4, handicap: 4 },
                    { number: 16, par: 4, handicap: 2 },
                    { number: 17, par: 3, handicap: 16 },
                    { number: 18, par: 5, handicap: 10 }
                ]
            },
            hidden_valley: {
                name: "Hidden Valley Golf Club",
                city: "Norco",
                state: "CA",
                totalPar: 72,
                tees: {
                    black: { name: "Black", rating: 74.0, slope: 140, yardage: 6880 },
                    blue: { name: "Blue", rating: 71.4, slope: 132, yardage: 6292 },
                    white: { name: "White", rating: 68.7, slope: 124, yardage: 5772 },
                    silver: { name: "Silver", rating: 66.6, slope: 117, yardage: 5330 },
                    red: { name: "Red", rating: 63.6, slope: 111, yardage: 4698 }
                },
                defaultTee: "white",
                holes: [
                    { number: 1, par: 5, handicap: 11 },
                    { number: 2, par: 4, handicap: 3 },
                    { number: 3, par: 4, handicap: 15 },
                    { number: 4, par: 4, handicap: 9 },
                    { number: 5, par: 3, handicap: 5 },
                    { number: 6, par: 5, handicap: 7 },
                    { number: 7, par: 4, handicap: 17 },
                    { number: 8, par: 3, handicap: 13 },
                    { number: 9, par: 4, handicap: 1 },
                    { number: 10, par: 4, handicap: 6 },
                    { number: 11, par: 5, handicap: 14 },
                    { number: 12, par: 4, handicap: 12 },
                    { number: 13, par: 3, handicap: 16 },
                    { number: 14, par: 4, handicap: 18 },
                    { number: 15, par: 5, handicap: 8 },
                    { number: 16, par: 3, handicap: 10 },
                    { number: 17, par: 4, handicap: 4 },
                    { number: 18, par: 4, handicap: 2 }
                ]
            },
            indian_hills: {
                name: "Indian Hills Golf Club",
                city: "Riverside",
                state: "CA",
                totalPar: 70,
                tees: {
                    blue: { name: "Blue", rating: 70.1, slope: 125, yardage: 6125 },
                    white: { name: "White", rating: 68.8, slope: 122, yardage: 5829 },
                    gold: { name: "Gold", rating: 67.5, slope: 118, yardage: 5502 }
                },
                defaultTee: "white",
                holes: [
                    { number: 1, par: 4, handicap: 5 },
                    { number: 2, par: 4, handicap: 15 },
                    { number: 3, par: 3, handicap: 7 },
                    { number: 4, par: 4, handicap: 3 },
                    { number: 5, par: 3, handicap: 11 },
                    { number: 6, par: 4, handicap: 9 },
                    { number: 7, par: 4, handicap: 17 },
                    { number: 8, par: 5, handicap: 13 },
                    { number: 9, par: 4, handicap: 1 },
                    { number: 10, par: 4, handicap: 8 },
                    { number: 11, par: 3, handicap: 16 },
                    { number: 12, par: 4, handicap: 18 },
                    { number: 13, par: 4, handicap: 12 },
                    { number: 14, par: 4, handicap: 6 },
                    { number: 15, par: 3, handicap: 14 },
                    { number: 16, par: 4, handicap: 4 },
                    { number: 17, par: 4, handicap: 2 },
                    { number: 18, par: 5, handicap: 10 }
                ]
            },
            jurupa_hills: {
                name: "Jurupa Hills Country Club",
                city: "Riverside",
                state: "CA",
                totalPar: 70,
                tees: {
                    blue: { name: "Blue", rating: 69.1, slope: 122, yardage: 6124 },
                    white: { name: "White", rating: 67.8, slope: 119, yardage: 5846 },
                    gold: { name: "Gold", rating: 71.3, slope: 119, yardage: 5405 }
                },
                defaultTee: "white",
                holes: [
                    { number: 1, par: 4, handicap: 4 },
                    { number: 2, par: 4, handicap: 2 },
                    { number: 3, par: 3, handicap: 16 },
                    { number: 4, par: 4, handicap: 10 },
                    { number: 5, par: 4, handicap: 14 },
                    { number: 6, par: 4, handicap: 8 },
                    { number: 7, par: 5, handicap: 6 },
                    { number: 8, par: 3, handicap: 18 },
                    { number: 9, par: 4, handicap: 12 },
                    { number: 10, par: 4, handicap: 7 },
                    { number: 11, par: 4, handicap: 1 },
                    { number: 12, par: 4, handicap: 13 },
                    { number: 13, par: 4, handicap: 3 },
                    { number: 14, par: 3, handicap: 17 },
                    { number: 15, par: 5, handicap: 11 },
                    { number: 16, par: 4, handicap: 9 },
                    { number: 17, par: 4, handicap: 5 },
                    { number: 18, par: 3, handicap: 15 }
                ]
            },
            green_river: {
                name: "Green River Golf Club",
                city: "Corona",
                state: "CA",
                totalPar: 71,
                tees: {
                    black: { name: "Black", rating: 73.3, slope: 130, yardage: 6827 },
                    blue: { name: "Blue", rating: 71.9, slope: 127, yardage: 6487 },
                    white: { name: "White", rating: 69.8, slope: 122, yardage: 6030 },
                    gold: { name: "Gold", rating: 67.9, slope: 117, yardage: 5545 }
                },
                defaultTee: "white",
                holes: [
                    { number: 1, par: 4, handicap: 9 },
                    { number: 2, par: 3, handicap: 15 },
                    { number: 3, par: 5, handicap: 7 },
                    { number: 4, par: 3, handicap: 13 },
                    { number: 5, par: 5, handicap: 3 },
                    { number: 6, par: 4, handicap: 5 },
                    { number: 7, par: 5, handicap: 1 },
                    { number: 8, par: 3, handicap: 17 },
                    { number: 9, par: 4, handicap: 11 },
                    { number: 10, par: 4, handicap: 4 },
                    { number: 11, par: 4, handicap: 18 },
                    { number: 12, par: 4, handicap: 8 },
                    { number: 13, par: 3, handicap: 16 },
                    { number: 14, par: 4, handicap: 12 },
                    { number: 15, par: 4, handicap: 10 },
                    { number: 16, par: 3, handicap: 14 },
                    { number: 17, par: 5, handicap: 2 },
                    { number: 18, par: 4, handicap: 6 }
                ]
            },
            shandin_hills: {
                name: "Shandin Hills Golf Club",
                city: "San Bernardino",
                state: "CA",
                totalPar: 72,
                tees: {
                    black: { name: "Black", rating: 70.5, slope: 127, yardage: 6517 },
                    white: { name: "White", rating: 69.1, slope: 124, yardage: 6202 },
                    red: { name: "Red", rating: 66.3, slope: 113, yardage: 5592 }
                },
                defaultTee: "white",
                holes: [
                    { number: 1, par: 5, handicap: 17 },
                    { number: 2, par: 4, handicap: 3 },
                    { number: 3, par: 3, handicap: 11 },
                    { number: 4, par: 4, handicap: 9 },
                    { number: 5, par: 4, handicap: 1 },
                    { number: 6, par: 4, handicap: 5 },
                    { number: 7, par: 3, handicap: 15 },
                    { number: 8, par: 5, handicap: 7 },
                    { number: 9, par: 4, handicap: 13 },
                    { number: 10, par: 4, handicap: 4 },
                    { number: 11, par: 3, handicap: 10 },
                    { number: 12, par: 4, handicap: 18 },
                    { number: 13, par: 4, handicap: 16 },
                    { number: 14, par: 5, handicap: 12 },
                    { number: 15, par: 3, handicap: 8 },
                    { number: 16, par: 4, handicap: 2 },
                    { number: 17, par: 5, handicap: 6 },
                    { number: 18, par: 4, handicap: 14 }
                ]
            }
        };
        
        // Favorite courses stored in localStorage
        let favoriteCourses = JSON.parse(localStorage.getItem('golf_favorite_courses') || '[]');
        
        // Custom courses added by users (also stored in localStorage)
        let customCourses = JSON.parse(localStorage.getItem('golf_custom_courses') || '{}');
        
        // Currently selected tee for tournament
        let selectedTee = null;

        let courseData = null; // No default course - user must select

        let currentPlayerCount = 1;
        let nextPlayerId = 2;
        const maxPlayers = 40;

        // Swipe-to-delete functionality
        let touchStartX = 0;
        let touchStartY = 0;
        let touchCurrentX = 0;
        let swipingRow = null;
        let isScrolling = null;

        // Initialize autocomplete, quick add, and swipe after page loads
        window.addEventListener('load', function() {
            // Set today's date as default
            const dateInput = document.getElementById('tournamentDate');
            if (dateInput) {
                dateInput.valueAsDate = new Date();
            }
            
            initializeAutocomplete();
            renderQuickAddButtons();
            initializeSwipeGestures();
            
            // Check for shared tournament in URL
            loadTournamentFromURL();
        });

        // Global swipe state - outside function to prevent closure issues
        let swipeState = {
            startX: 0,
            currentX: 0,
            activeRow: null,
            wasSwipedOpen: false,
            isTracking: false
        };

        function initializeSwipeGestures() {
            const playerList = document.getElementById('playerList');
            if (!playerList) return;
            
            // Prevent duplicate initialization
            if (playerList.dataset.swipeInit === 'true') {
                return;
            }
            playerList.dataset.swipeInit = 'true';

            playerList.addEventListener('touchstart', function(e) {
                const row = e.target.closest('.player-row');
                if (!row) return;
                
                // Only block if input is focused
                if (e.target.tagName === 'INPUT' && document.activeElement === e.target) {
                    return;
                }
                
                // Close any other open rows
                document.querySelectorAll('.player-row.swiped').forEach(r => {
                    if (r !== row) {
                        r.classList.remove('swiped');
                        r.style.transform = 'translateX(0)';
                    }
                });
                
                swipeState.startX = e.touches[0].clientX;
                swipeState.currentX = swipeState.startX;
                swipeState.activeRow = row;
                swipeState.wasSwipedOpen = row.classList.contains('swiped');
                swipeState.isTracking = true;
                row.style.transition = 'none';
            }, { passive: true });

            playerList.addEventListener('touchmove', function(e) {
                if (!swipeState.isTracking || !swipeState.activeRow) return;

                swipeState.currentX = e.touches[0].clientX;
                const diffX = swipeState.startX - swipeState.currentX;
                
                let offset;
                if (swipeState.wasSwipedOpen) {
                    offset = Math.max(-80, Math.min(0, -80 - diffX));
                } else {
                    offset = Math.max(-80, Math.min(0, -diffX));
                }
                
                swipeState.activeRow.style.transform = `translateX(${offset}px)`;
            }, { passive: true });

            playerList.addEventListener('touchend', function(e) {
                if (!swipeState.isTracking || !swipeState.activeRow) return;
                
                swipeState.activeRow.style.transition = 'transform 0.2s ease-out';
                const diffX = swipeState.startX - swipeState.currentX;
                
                let shouldOpen;
                if (swipeState.wasSwipedOpen) {
                    shouldOpen = diffX > -10;
                } else {
                    shouldOpen = diffX > 10;
                }
                
                if (shouldOpen) {
                    swipeState.activeRow.classList.add('swiped');
                    swipeState.activeRow.style.transform = 'translateX(-80px)';
                } else {
                    swipeState.activeRow.classList.remove('swiped');
                    swipeState.activeRow.style.transform = 'translateX(0)';
                }

                // Reset state
                swipeState.activeRow = null;
                swipeState.startX = 0;
                swipeState.currentX = 0;
                swipeState.wasSwipedOpen = false;
                swipeState.isTracking = false;
            }, { passive: true });
            
            // Handle touchcancel
            playerList.addEventListener('touchcancel', function(e) {
                if (swipeState.activeRow) {
                    swipeState.activeRow.style.transition = 'transform 0.2s ease-out';
                    if (swipeState.wasSwipedOpen) {
                        swipeState.activeRow.style.transform = 'translateX(-80px)';
                    } else {
                        swipeState.activeRow.style.transform = 'translateX(0)';
                    }
                }
                swipeState.activeRow = null;
                swipeState.isTracking = false;
            }, { passive: true });

            // Click on delete button
            playerList.addEventListener('click', function(e) {
                if (e.target.classList.contains('player-row-delete')) {
                    const wrapper = e.target.closest('.player-row-wrapper');
                    const row = wrapper ? wrapper.querySelector('.player-row') : null;
                    if (row) {
                        const playerId = row.getAttribute('data-player');
                        deletePlayerRow(playerId);
                    }
                }
            });
        }
        
        // Close swiped rows when tapping elsewhere
        document.addEventListener('touchstart', function(e) {
            if (!e.target.closest('.player-row-wrapper')) {
                document.querySelectorAll('.player-row.swiped').forEach(row => {
                    row.classList.remove('swiped');
                    row.style.transition = 'transform 0.2s ease-out';
                    row.style.transform = 'translateX(0)';
                });
            }
        }, { passive: true });
        
        // No longer needed - kept for compatibility
        function initSetupPlayerSwipe(wrapper) {
            // Handled by initializeSwipeGestures
        }

        // Delete player row with animation
        function deletePlayerRow(playerId) {
            const row = document.querySelector(`.player-row[data-player="${playerId}"]`);
            if (!row) return;
            
            const wrapper = row.closest('.player-row-wrapper');
            
            // Don't allow deleting if only 1 player remains
            if (currentPlayerCount <= 1) {
                alert('You must have at least one player');
                row.classList.remove('swiped');
                row.style.transform = 'translateX(0)';
                return;
            }
            
            // Add deleting animation
            row.classList.add('deleting');
            
            // Remove after animation
            setTimeout(() => {
                if (wrapper) {
                    wrapper.remove();
                } else {
                    row.remove();
                }
                currentPlayerCount--;
                
                // Re-enable Add button if was at max
                if (currentPlayerCount < maxPlayers) {
                    document.getElementById('addPlayerBtn').disabled = false;
                    document.getElementById('addPlayerBtn').innerHTML = '<span style="font-size: 16px; font-weight: 700;">+</span> Add Player';
                }
            }, 300);
        }

        // Render quick add buttons for frequent players
        function renderQuickAddButtons() {
            const quickAddBtn = document.getElementById('quickAddBtn');
            
            // Safety check - this element only exists on setup page
            if (!quickAddBtn) {
                return;
            }
            
            // Get all players from history
            const allPlayers = Object.values(playerHistory)
                .sort((a, b) => b.usageCount - a.usageCount);
            
            if (allPlayers.length === 0) {
                quickAddBtn.style.display = 'none';
                return;
            }
            
            quickAddBtn.style.display = 'flex';
        }
        
        // Show Quick Add Modal
        function showQuickAddModal() {
            const allPlayers = Object.values(playerHistory)
                .sort((a, b) => b.usageCount - a.usageCount);
            
            if (allPlayers.length === 0) {
                showNotification('No Players', 'Add players manually to build your roster');
                return;
            }
            
            // Get currently added player names to pre-check them
            const currentPlayers = [];
            document.querySelectorAll('.player-name-input').forEach(input => {
                if (input.value.trim()) {
                    currentPlayers.push(input.value.trim().toLowerCase());
                }
            });
            
            const modal = document.createElement('div');
            modal.id = 'quickAddModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            let playerListHtml = allPlayers.map((player, index) => {
                const isAlreadyAdded = currentPlayers.includes(player.name.toLowerCase());
                return `
                    <label style="display: flex; align-items: center; gap: 12px; padding: 12px; background: ${isAlreadyAdded ? '#f0fdf4' : '#f8fafc'}; border: 2px solid ${isAlreadyAdded ? '#166534' : '#e2e8f0'}; border-radius: 6px; cursor: pointer;">
                        <input type="checkbox" name="quickAddPlayer" value="${index}" ${isAlreadyAdded ? 'checked disabled' : ''} 
                            style="width: 20px; height: 20px; accent-color: #1e3a5f;">
                        <div style="flex: 1;">
                            <div style="font-weight: 600; color: #1e293b; font-size: 15px;">${player.name}</div>
                            <div style="font-size: 12px; color: #64748b;">HCP Index: ${player.handicap}</div>
                        </div>
                        ${isAlreadyAdded ? '<span style="font-size: 11px; color: #166534; font-weight: 600;">Added</span>' : ''}
                    </label>
                `;
            }).join('');
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 6px; max-width: 400px; width: 100%; max-height: 85vh; display: flex; flex-direction: column;">
                    <div style="padding: 16px 20px; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center;">
                        <h2 style="color: #1e3a5f; font-size: 18px; margin: 0; display: flex; align-items: center; gap: 8px;">
                            <span>👥</span> Quick Add Players
                        </h2>
                        <button onclick="closeQuickAddModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b; line-height: 1;">✕</button>
                    </div>
                    
                    <div style="padding: 16px 20px; overflow-y: auto; flex: 1;">
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            ${playerListHtml}
                        </div>
                    </div>
                    
                    <div style="padding: 16px 20px; border-top: 1px solid #e2e8f0; display: flex; gap: 10px;">
                        <button onclick="selectAllQuickAdd()" style="flex: 1; padding: 12px; background: #d4b896; border: none; border-radius: 4px; color: #1e3a5f; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Select All
                        </button>
                        <button onclick="addSelectedPlayers()" style="flex: 1; padding: 12px; background: #1e3a5f; border: none; border-radius: 4px; color: white; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Add Selected
                        </button>
                    </div>
                    
                    <div style="padding: 0 20px 16px 20px;">
                        <button onclick="showManageRosterModal()" style="width: 100%; padding: 10px; background: transparent; border: none; color: #64748b; font-size: 13px; cursor: pointer; text-decoration: underline;">
                            Manage Roster
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeQuickAddModal();
            };
        }
        
        function closeQuickAddModal() {
            const modal = document.getElementById('quickAddModal');
            if (modal) modal.remove();
        }
        
        function selectAllQuickAdd() {
            const checkboxes = document.querySelectorAll('#quickAddModal input[name="quickAddPlayer"]:not(:disabled)');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            checkboxes.forEach(cb => cb.checked = !allChecked);
        }
        
        function addSelectedPlayers() {
            const allPlayers = Object.values(playerHistory).sort((a, b) => b.usageCount - a.usageCount);
            const checkboxes = document.querySelectorAll('#quickAddModal input[name="quickAddPlayer"]:checked:not(:disabled)');
            
            let addedCount = 0;
            checkboxes.forEach(cb => {
                const player = allPlayers[parseInt(cb.value)];
                if (player) {
                    quickAddPlayer(player.name, player.handicap);
                    addedCount++;
                }
            });
            
            closeQuickAddModal();
            
            if (addedCount > 0) {
                showNotification('Added', `${addedCount} player${addedCount !== 1 ? 's' : ''} added`);
            }
        }
        
        // Show Manage Roster Modal
        function showManageRosterModal() {
            closeQuickAddModal();
            
            const allPlayers = Object.values(playerHistory).sort((a, b) => a.name.localeCompare(b.name));
            
            const modal = document.createElement('div');
            modal.id = 'manageRosterModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            let playerListHtml = allPlayers.length > 0 ? allPlayers.map((player, idx) => `
                <div class="roster-edit-row" data-original-name="${player.name.replace(/"/g, '&quot;')}" style="display: flex; align-items: center; gap: 8px; padding: 10px; background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 6px;">
                    <input type="text" class="roster-name-edit" value="${player.name.replace(/"/g, '&quot;')}" 
                        style="flex: 1; min-width: 0; padding: 8px 10px; border: 1px solid #cbd5e1; border-radius: 6px; font-size: 14px; font-weight: 600; color: #1e293b;">
                    <input type="text" class="roster-hcp-edit" value="${player.handicap}" inputmode="decimal" pattern="-?[0-9.]*"
                        style="width: 60px; padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; font-size: 14px; text-align: center; color: #1e293b;">
                    <button onclick="deleteQuickAddPlayer('${player.name.replace(/'/g, "\\'")}')" 
                        style="padding: 8px 10px; background: #fee2e2; border: none; border-radius: 8px; color: #a51c30; font-size: 14px; cursor: pointer; flex-shrink: 0;">
                        🗑️
                    </button>
                </div>
            `).join('') : '<p style="text-align: center; color: #64748b; padding: 20px;">No players in roster yet</p>';
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 6px; max-width: 400px; width: 100%; max-height: 85vh; display: flex; flex-direction: column;">
                    <div style="padding: 16px 20px; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center;">
                        <h2 style="color: #1e3a5f; font-size: 18px; margin: 0;">⚙️ Manage Roster</h2>
                        <button onclick="closeManageRosterModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b; line-height: 1;">✕</button>
                    </div>
                    
                    <!-- Column headers for edit mode -->
                    <div style="padding: 8px 20px 0 20px; display: flex; gap: 8px;">
                        <div style="flex: 1; font-size: 11px; color: #64748b; font-weight: 600; text-transform: uppercase; padding-left: 10px;">Name</div>
                        <div style="width: 60px; font-size: 11px; color: #64748b; font-weight: 600; text-transform: uppercase; text-align: center;">HCP</div>
                        <div style="width: 46px;"></div>
                    </div>
                    
                    <div style="padding: 8px 20px 16px 20px; overflow-y: auto; flex: 1;">
                        <div id="rosterEditList" style="display: flex; flex-direction: column; gap: 8px;">
                            ${playerListHtml}
                        </div>
                    </div>
                    
                    <div style="padding: 16px 20px; border-top: 1px solid #e2e8f0; display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="saveRosterEdits()" style="width: 100%; padding: 12px; background: #1e3a5f; border: none; border-radius: 4px; color: white; font-size: 14px; font-weight: 600; cursor: pointer;">
                            ✓ Save Changes
                        </button>
                        <button onclick="closeManageRosterModal(); showQuickAddModal();" style="width: 100%; padding: 12px; background: #d4b896; border: none; border-radius: 4px; color: #1e3a5f; font-size: 14px; font-weight: 600; cursor: pointer;">
                            ← Back to Quick Add
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeManageRosterModal();
            };
        }
        
        // Save roster edits from Manage Roster modal
        function saveRosterEdits() {
            const rows = document.querySelectorAll('#rosterEditList .roster-edit-row');
            let changes = 0;
            
            rows.forEach(row => {
                const originalName = row.getAttribute('data-original-name');
                const nameInput = row.querySelector('.roster-name-edit');
                const hcpInput = row.querySelector('.roster-hcp-edit');
                
                if (!nameInput || !hcpInput) return;
                
                const newName = nameInput.value.trim();
                const newHcp = parseFloat(hcpInput.value) || 0;
                
                if (!newName) return; // Skip empty names
                
                // Check if name changed
                if (originalName !== newName) {
                    // Create new entry with new name
                    const oldData = playerHistory[originalName];
                    if (oldData) {
                        playerHistory[newName] = {
                            name: newName,
                            handicap: newHcp,
                            usageCount: oldData.usageCount,
                            lastUsed: oldData.lastUsed
                        };
                        delete playerHistory[originalName];
                        changes++;
                    }
                } else if (playerHistory[originalName] && playerHistory[originalName].handicap !== newHcp) {
                    // Just update handicap
                    playerHistory[originalName].handicap = newHcp;
                    changes++;
                }
            });
            
            if (changes > 0) {
                localStorage.setItem('indianHillsPlayerHistory', JSON.stringify(playerHistory));
                showNotification('Saved', `${changes} player${changes !== 1 ? 's' : ''} updated`);
            }
            
            closeManageRosterModal();
            showQuickAddModal();
        }
        
        function closeManageRosterModal() {
            const modal = document.getElementById('manageRosterModal');
            if (modal) modal.remove();
        }
        
        // Delete a player from quick-add history
        function deleteQuickAddPlayer(playerName) {
            if (confirm(`Remove ${playerName} from roster?`)) {
                delete playerHistory[playerName];
                localStorage.setItem('indianHillsPlayerHistory', JSON.stringify(playerHistory));
                renderQuickAddButtons();
                // Refresh the manage roster modal if it's open
                const manageModal = document.getElementById('manageRosterModal');
                if (manageModal) {
                    closeManageRosterModal();
                    showManageRosterModal();
                }
                showNotification('Removed', `${playerName} removed from roster`);
            }
        }

        // Quick add a player to the first empty row or create new row
        function quickAddPlayer(name, handicap) {
            // Find first empty player row
            const playerRows = document.querySelectorAll('.player-row');
            let emptyRow = null;
            
            for (let row of playerRows) {
                const playerId = row.getAttribute('data-player');
                const nameInput = document.getElementById(`player${playerId}`);
                if (nameInput && nameInput.value.trim() === '') {
                    emptyRow = { row, playerId };
                    break;
                }
            }
            
            if (emptyRow) {
                // Fill empty row
                document.getElementById(`player${emptyRow.playerId}`).value = name;
                document.getElementById(`hcp${emptyRow.playerId}`).value = handicap;
                updateCourseHandicap(emptyRow.playerId);
                updateSetupCourseHcp(emptyRow.playerId);
            } else {
                // Add new row
                if (currentPlayerCount >= maxPlayers) {
                    alert(`Maximum of ${maxPlayers} players reached`);
                    return;
                }
                
                addPlayerRow();
                // Fill the newly added row
                document.getElementById(`player${nextPlayerId - 1}`).value = name;
                document.getElementById(`hcp${nextPlayerId - 1}`).value = handicap;
                updateCourseHandicap(nextPlayerId - 1);
                updateSetupCourseHcp(nextPlayerId - 1);
            }
            
            // Refresh team setup if team game is selected
            refreshTeamSetupIfNeeded();
        }

        // Warn before page refresh if there's active data
        // Initialize autocomplete on all player name inputs
        function initializeAutocomplete() {
            const playerList = document.getElementById('playerList');
            if (!playerList) return;

            playerList.addEventListener('input', function(e) {
                // Refresh team setup if player name or handicap changes
                if (e.target.classList.contains('player-name-input') || e.target.classList.contains('player-hcp-input')) {
                    refreshTeamSetupIfNeeded();
                }
                
                if (!e.target.classList.contains('player-name-input')) return;
                
                const input = e.target;
                const row = input.closest('.player-row');
                if (!row) return;
                
                const query = input.value;
                
                // Remove existing suggestions
                const existingSuggestions = row.querySelector('.autocomplete-suggestions');
                if (existingSuggestions) {
                    existingSuggestions.remove();
                }
                
                if (!query || query.length < 1) {
                    row.classList.remove('has-suggestions');
                    return;
                }
                
                const suggestions = getPlayerSuggestions(query);
                if (suggestions.length === 0) {
                    row.classList.remove('has-suggestions');
                    return;
                }
                
                // Create suggestions dropdown
                const suggestionsDiv = document.createElement('div');
                suggestionsDiv.className = 'autocomplete-suggestions show';
                
                suggestions.forEach(player => {
                    const item = document.createElement('div');
                    item.className = 'suggestion-item';
                    item.innerHTML = `
                        <span class="suggestion-name">${player.name}</span>
                        <span class="suggestion-hcp">HCP: ${player.handicap}</span>
                    `;
                    
                    item.addEventListener('click', function(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        input.value = player.name;
                        
                        // Auto-fill handicap
                        const playerId = row.getAttribute('data-player');
                        const hcpInput = document.getElementById(`hcp${playerId}`);
                        if (hcpInput) {
                            hcpInput.value = player.handicap;
                            // Update course HCP display
                            updateSetupCourseHcp(playerId);
                        }
                        
                        suggestionsDiv.remove();
                        row.classList.remove('has-suggestions');
                        
                        // Refresh team setup
                        refreshTeamSetupIfNeeded();
                    });
                    
                    suggestionsDiv.appendChild(item);
                });
                
                row.appendChild(suggestionsDiv);
                row.classList.add('has-suggestions');
            });
            
            // Close suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.classList.contains('player-name-input') && 
                    !e.target.closest('.autocomplete-suggestions')) {
                    document.querySelectorAll('.autocomplete-suggestions').forEach(s => s.remove());
                    document.querySelectorAll('.player-row').forEach(r => r.classList.remove('has-suggestions'));
                }
            });
        }


        // Add new player row
        function addPlayerRow() {
            console.log('addPlayerRow called, currentPlayerCount:', currentPlayerCount, 'FREE_PLAYER_LIMIT:', FREE_PLAYER_LIMIT);
            
            if (currentPlayerCount >= maxPlayers) {
                alert(`Maximum of ${maxPlayers} players reached`);
                return;
            }
            
            // Gate check: Free tier limited to 4 players
            // currentPlayerCount is BEFORE adding, so check if adding one more would exceed limit
            if (!hasActiveSubscription() && currentPlayerCount >= FREE_PLAYER_LIMIT) {
                showPaywall(`Free plan allows ${FREE_PLAYER_LIMIT} players. Upgrade for unlimited players!`);
                return;
            }

            currentPlayerCount++;
            const playerList = document.getElementById('playerList');
            
            // Check current GHIN mode
            const useGhin = document.getElementById('setupUseGhinCheckbox')?.checked || false;
            const placeholder = useGhin ? 'H.I.' : 'HCP';
            const step = useGhin ? '0.1' : '1';
            const ghinModeClass = useGhin ? ' ghin-mode' : '';
            const courseHcpDisplay = useGhin ? 'block' : 'none';
            
            const wrapper = document.createElement('div');
            wrapper.className = 'player-row-wrapper';
            
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'player-row-delete';
            deleteBtn.textContent = 'Delete';
            deleteBtn.onclick = () => removePlayer(nextPlayerId);
            
            const newRow = document.createElement('div');
            newRow.className = 'player-row' + ghinModeClass;
            newRow.setAttribute('data-player', nextPlayerId);
            newRow.innerHTML = `
                <input type="text" class="player-name-input" placeholder="Player Name" id="player${nextPlayerId}">
                <input type="text" class="player-hcp-input" placeholder="${placeholder}" id="hcp${nextPlayerId}" pattern="-?[0-9.]*" inputmode="decimal" step="${step}" oninput="updateSetupCourseHcp(${nextPlayerId})">
                <span class="player-course-hcp" id="courseHcp${nextPlayerId}" style="display: ${courseHcpDisplay};"></span>
            `;
            
            wrapper.appendChild(deleteBtn);
            wrapper.appendChild(newRow);
            playerList.appendChild(wrapper);
            nextPlayerId++;
            
            // Disable button if at max
            if (currentPlayerCount >= maxPlayers) {
                document.getElementById('addPlayerBtn').disabled = true;
                document.getElementById('addPlayerBtn').textContent = `Maximum ${maxPlayers} Players`;
            }
        }
        
        // Remove a player row (wrapper for deletePlayerRow)
        function removePlayer(playerId) {
            deletePlayerRow(playerId);
        }
        
        // Toggle GHIN mode on setup page
        function toggleSetupGhinMode(useGhin) {
            const header = document.getElementById('setupHcpHeader');
            const hint = document.getElementById('setupGhinHint');
            const columnHeaders = document.getElementById('setupColumnHeaders');
            const courseHcpHeader = document.getElementById('setupCourseHcpHeader');
            
            // IMPORTANT: Scope to setup page player list only
            const playerList = document.getElementById('playerList');
            if (!playerList) return;
            
            const hcpInputs = playerList.querySelectorAll('.player-hcp-input');
            const courseHcpSpans = playerList.querySelectorAll('.player-course-hcp');
            const playerRows = playerList.querySelectorAll('.player-row');
            
            if (useGhin) {
                if (header) header.textContent = 'H.I.';
                if (hint) hint.textContent = 'Enter GHIN Index';
                if (columnHeaders) columnHeaders.style.gridTemplateColumns = '1fr 55px 45px';
                if (courseHcpHeader) courseHcpHeader.style.display = 'block';
                
                hcpInputs.forEach(input => {
                    input.placeholder = 'H.I.';
                    input.step = '0.1';
                });
                courseHcpSpans.forEach(span => {
                    span.style.display = 'block';
                });
                playerRows.forEach(row => {
                    row.classList.add('ghin-mode');
                });
                
                // Calculate course HCP for all existing players
                updateAllSetupCourseHcps();
            } else {
                if (header) header.textContent = 'HCP';
                if (hint) hint.textContent = 'Enter Course HCP';
                if (columnHeaders) columnHeaders.style.gridTemplateColumns = '1fr 70px';
                if (courseHcpHeader) courseHcpHeader.style.display = 'none';
                
                hcpInputs.forEach(input => {
                    input.placeholder = 'HCP';
                    input.step = '1';
                });
                courseHcpSpans.forEach(span => {
                    span.style.display = 'none';
                });
                playerRows.forEach(row => {
                    row.classList.remove('ghin-mode');
                });
            }
        }
        
        // Update course HCP for a single player on setup page
        function updateSetupCourseHcp(playerId) {
            const useGhin = document.getElementById('setupUseGhinCheckbox')?.checked;
            if (!useGhin) return;
            
            const input = document.getElementById(`hcp${playerId}`);
            const courseHcpSpan = document.getElementById(`courseHcp${playerId}`);
            
            if (!input || !courseHcpSpan) {
                console.log(`⚠️ updateSetupCourseHcp(${playerId}): Missing input or span`);
                return;
            }
            
            const index = parseFloat(input.value);
            if (isNaN(index) || input.value.trim() === '') {
                courseHcpSpan.textContent = '';
                return;
            }
            
            // Get tee data for calculation
            if (courseData && courseData.tees && selectedTee) {
                const teeData = courseData.tees[selectedTee];
                if (teeData && teeData.slope && teeData.rating) {
                    const courseHcp = calculateCourseHandicap(index, teeData.slope, teeData.rating, courseData.totalPar || 72);
                    courseHcpSpan.textContent = courseHcp;
                    return;
                }
            }
            
            // Fallback - just round the index (always show something)
            courseHcpSpan.textContent = Math.round(index);
        }
        
        // Update all course HCPs on setup page
        function updateAllSetupCourseHcps() {
            const playerList = document.getElementById('playerList');
            if (!playerList) return;
            
            const playerRows = playerList.querySelectorAll('.player-row');
            playerRows.forEach(row => {
                const playerId = row.getAttribute('data-player');
                if (playerId) {
                    updateSetupCourseHcp(playerId);
                }
            });
        }
        
        // Swipe-to-delete DISABLED - causing issues with page scrolling
        // Using visible delete button instead
        let swipeStartX = 0;
        let swipeStartY = 0;
        let swipeCurrentX = 0;
        let swipedWrapper = null;
        let isSwipeActive = false;
        let swipeDirection = null;
        
        function initSwipeToDelete() {
            // DISABLED - swipe functionality removed
            // Delete buttons are now always visible in player rows
        }
        
        function handleSwipeStart(e) {
            // DISABLED
        }
        
        function handleSwipeMove(e) {
            // DISABLED
        }
        
        function handleSwipeEnd(e) {
            // DISABLED
        }
        
        // Initialize swipe on page load - DISABLED
        // document.addEventListener('DOMContentLoaded', initSwipeToDelete);
        
        // Update privacy toggles UI
        function updatePrivacyToggles() {
            const viewLeaderboard = document.getElementById('privacyViewLeaderboard')?.checked;
            const signedEarlySection = document.getElementById('privacySignedEarlySection');
            
            if (signedEarlySection) {
                signedEarlySection.style.display = viewLeaderboard ? 'none' : 'block';
            }
        }
        
        // Get current tournament privacy settings
        function getTournamentPrivacy() {
            // Default to all allowed
            const defaults = {
                viewLeaderboard: true,
                signedEarly: false,
                watchOthers: true
            };
            
            if (tournamentData && tournamentData.privacy) {
                return { ...defaults, ...tournamentData.privacy };
            }
            return defaults;
        }
        
        // Check if current user can view leaderboard/results/other players
        function canViewLeaderboard() {
            // Host can always view UNLESS in player mode
            if (isHost && !isHostInPlayerMode()) return true;
            
            const privacy = getTournamentPrivacy();
            
            // If leaderboard viewing is enabled, everyone can see
            if (privacy.viewLeaderboard) return true;
            
            // Check if signed early viewing is enabled
            if (privacy.signedEarly) {
                // Check if all claimed players have signed their scorecards
                const signedCards = getSignedScorecards(); // Returns object { playerName: signatureData }
                
                if (claimedPlayers.length === 0) {
                    return false;
                }
                
                const allClaimedSigned = claimedPlayers.every(playerName => {
                    return signedCards[playerName] != null;
                });
                
                if (allClaimedSigned) return true;
            }
            
            // Check if all players have signed (tournament complete)
            if (tournamentData && tournamentData.players) {
                const signedCards = getSignedScorecards();
                const allSigned = tournamentData.players.every(player => {
                    return signedCards[player.name] != null; // Check if key exists in object
                });
                if (allSigned) return true;
            }
            
            // Check if tournament is ended
            if (tournamentData && tournamentData.status === 'completed') return true;
            
            return false;
        }
        
        // Check if current user can watch other players
        function canWatchOthers() {
            // Host can always watch UNLESS in player mode
            if (isHost && !isHostInPlayerMode()) return true;
            
            const privacy = getTournamentPrivacy();
            return privacy.watchOthers;
        }
        
        // Show privacy blocked message
        function showPrivacyBlockedMessage(type) {
            let title, message;
            
            if (type === 'leaderboard') {
                title = '🔒 Leaderboard Hidden';
                message = 'The host has hidden the leaderboard until all scorecards are signed.';
            } else if (type === 'watch') {
                title = '🔒 Watching Disabled';
                message = 'The host has disabled watching other players.';
            } else {
                title = '🔒 Not Available';
                message = 'This feature is restricted by the host.';
            }
            
            showNotification(title, message);
        }
        
        // Update UI based on privacy settings
        function updatePrivacyUI() {
            const canView = canViewLeaderboard();
            const canWatch = canWatchOthers();
            
            // Update "All Players" button in settings card only (not header - that's deprecated)
            const allBtn = document.getElementById('resultsToggleAll');
            
            if (allBtn) {
                if (canView) {
                    allBtn.style.display = '';
                    allBtn.disabled = false;
                    allBtn.style.opacity = '1';
                    allBtn.innerHTML = 'All Players';
                } else {
                    // Show as locked
                    allBtn.innerHTML = '🔒 All Players';
                    allBtn.style.opacity = '0.6';
                }
            }
            
            // If current filter is 'all' but we can't view, switch to 'mine'
            if (!canView && currentResultsFilter === 'all') {
                setResultsFilter('mine');
            }
            
            // Update host privacy controls if we're the host (and in host mode)
            if (isHost && !isHostInPlayerMode()) {
                syncHostPrivacyControls();
            }
        }
        
        // Sync host privacy controls with current tournament settings
        function syncHostPrivacyControls() {
            const privacy = getTournamentPrivacy();
            
            const viewToggle = document.getElementById('hostPrivacyViewLeaderboard');
            const signedEarlyToggle = document.getElementById('hostPrivacySignedEarly');
            const watchToggle = document.getElementById('hostPrivacyWatchOthers');
            const signedEarlySection = document.getElementById('hostSignedEarlySection');
            
            if (viewToggle) viewToggle.checked = privacy.viewLeaderboard;
            if (signedEarlyToggle) signedEarlyToggle.checked = privacy.signedEarly;
            if (watchToggle) watchToggle.checked = privacy.watchOthers;
            if (signedEarlySection) {
                signedEarlySection.style.display = privacy.viewLeaderboard ? 'none' : 'block';
            }
        }
        
        // Update host privacy setting and sync to Firebase
        async function updateHostPrivacySetting(setting, value) {
            if (!isHost || !activeTournamentId) return;
            
            // Update local tournamentData
            if (!tournamentData.privacy) {
                tournamentData.privacy = {
                    viewLeaderboard: true,
                    signedEarly: false,
                    watchOthers: true
                };
            }
            tournamentData.privacy[setting] = value;
            
            // Show/hide signed early section
            if (setting === 'viewLeaderboard') {
                const signedEarlySection = document.getElementById('hostSignedEarlySection');
                if (signedEarlySection) {
                    signedEarlySection.style.display = value ? 'none' : 'block';
                }
            }
            
            // Sync to Firebase
            try {
                await db.collection('tournaments').doc(activeTournamentId).update({
                    privacy: tournamentData.privacy
                });
                console.log('✅ Privacy setting updated:', setting, '=', value);
                
                // Update local UI
                updatePrivacyUI();
            } catch (error) {
                console.error('Error updating privacy setting:', error);
                showNotification('Error', 'Failed to update privacy setting');
            }
        }

        // Delete player row with animation

        let tournamentData = {
            id: '',
            date: '',
            gameType: '',
            course: '',
            players: [],
            teams: []
        };

        // Generate unique tournament ID
        function generateTournamentId() {
            return 'T' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }

        // ===== UI ENHANCEMENT FUNCTIONS =====
        
        // Generate player avatar color based on name
        function getPlayerColor(playerName) {
            const colors = [
                '#1e3a5f', // Blue
                '#166534', // Green
                '#f59e0b', // Orange
                '#8b5cf6', // Purple
                '#a51c30', // Red
                '#06b6d4', // Cyan
                '#ec4899', // Pink
                '#f97316', // Deep Orange
                '#14b8a6', // Teal
                '#a855f7'  // Violet
            ];
            
            // Hash the name to get consistent color
            let hash = 0;
            for (let i = 0; i < playerName.length; i++) {
                hash = playerName.charCodeAt(i) + ((hash << 5) - hash);
            }
            return colors[Math.abs(hash) % colors.length];
        }

        // Get player initials
        function getPlayerInitials(playerName) {
            const words = playerName.trim().split(' ');
            if (words.length === 1) {
                return words[0].substring(0, 2).toUpperCase();
            }
            return (words[0][0] + words[words.length - 1][0]).toUpperCase();
        }

        // Create player avatar HTML
        function createPlayerAvatar(playerName, large = false) {
            const initials = getPlayerInitials(playerName);
            const color = getPlayerColor(playerName);
            const sizeClass = large ? 'player-avatar-large' : 'player-avatar';
            return `<span class="player-avatar ${sizeClass}" style="background: ${color};">${initials}</span>`;
        }

        // Get score color class based on par
        function getScoreClass(score, par) {
            if (score === 0) return 'score-par';
            const diff = score - par;
            if (diff <= -2) return 'score-eagle';
            if (diff === -1) return 'score-birdie';
            if (diff === 0) return 'score-par';
            if (diff === 1) return 'score-bogey';
            return 'score-double';
        }

        // Trigger confetti animation
        function showConfetti() {
            const colors = ['#fbbf24', '#1e3a5f', '#166534', '#a51c30', '#8b5cf6'];
            const confettiCount = 50;
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
                confetti.style.animationDelay = (Math.random() * 0.5) + 's';
                confetti.style.animation = 'confetti-fall linear forwards';
                
                document.body.appendChild(confetti);
                
                setTimeout(() => confetti.remove(), 5000);
            }
        }

        // Add pulse animation to element
        function pulseElement(element) {
            element.classList.add('score-changed');
            setTimeout(() => element.classList.remove('score-changed'), 300);
        }

        // Calculate tournament progress
        function getTournamentProgress() {
            if (!tournamentData.players || tournamentData.players.length === 0) return 0;
            
            let totalHoles = 0;
            let completedHoles = 0;
            
            tournamentData.players.forEach(player => {
                player.scores.forEach(score => {
                    totalHoles++;
                    if (score > 0) completedHoles++;
                });
            });
            
            return totalHoles > 0 ? (completedHoles / totalHoles) * 100 : 0;
        }
        
        // Current hole for hole view
        let currentHole = 0; // 0-17 (holes 1-18)
        let currentView = 'hole'; // 'player' or 'hole' - default to hole view

        // Format date from YYYY-MM-DD string without timezone issues
        function formatDateDisplay(dateString) {
            if (!dateString) return '';
            const [year, month, day] = dateString.split('-');
            const date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
        }

        // Player history for auto-complete and handicap memory
        let playerHistory = JSON.parse(localStorage.getItem('indianHillsPlayerHistory') || '{}');
        // Format: { "PlayerName": { name: "PlayerName", handicap: 10, lastUsed: timestamp, usageCount: 5 } }

        // Save player history
        function savePlayerHistory() {
            localStorage.setItem('indianHillsPlayerHistory', JSON.stringify(playerHistory));
        }

        // Update player in history
        function updatePlayerHistory(name, handicap) {
            if (!name || name.trim() === '') return;
            
            const normalizedName = name.trim();
            if (!playerHistory[normalizedName]) {
                playerHistory[normalizedName] = {
                    name: normalizedName,
                    handicap: handicap || 0,
                    lastUsed: Date.now(),
                    usageCount: 1
                };
            } else {
                playerHistory[normalizedName].handicap = handicap || playerHistory[normalizedName].handicap;
                playerHistory[normalizedName].lastUsed = Date.now();
                playerHistory[normalizedName].usageCount++;
            }
            savePlayerHistory();
        }

        // Get player suggestions sorted by usage and recency
        function getPlayerSuggestions(query) {
            query = query.toLowerCase().trim();
            if (!query) {
                // Return most recent players
                return Object.values(playerHistory)
                    .sort((a, b) => b.lastUsed - a.lastUsed)
                    .slice(0, 5);
            }
            
            // Filter and sort by match quality
            return Object.values(playerHistory)
                .filter(p => p.name.toLowerCase().includes(query))
                .sort((a, b) => {
                    // Exact match first
                    const aExact = a.name.toLowerCase() === query ? 1 : 0;
                    const bExact = b.name.toLowerCase() === query ? 1 : 0;
                    if (aExact !== bExact) return bExact - aExact;
                    
                    // Then by usage count
                    if (a.usageCount !== b.usageCount) return b.usageCount - a.usageCount;
                    
                    // Then by recency
                    return b.lastUsed - a.lastUsed;
                })
                .slice(0, 5);
        }

        // Update course when selection changes
        function updateCourse() {
            const selectedCourse = document.getElementById('courseSelect').value;
            const teeSection = document.getElementById('teeSelectionSection');
            
            // Handle special options
            if (selectedCourse === 'search_course') {
                document.getElementById('courseSelect').value = '';
                showCourseSearchModal();
                return;
            }
            
            if (selectedCourse === 'custom_course') {
                document.getElementById('courseSelect').value = '';
                showCustomCourseModal();
                return;
            }
            
            // Handle favorite course selection (fav_xxx format)
            if (selectedCourse && selectedCourse.startsWith('fav_')) {
                const favId = selectedCourse.replace('fav_', '');
                
                // First check if this is a built-in course (even if not in favorites list)
                if (courses[favId]) {
                    courseData = courses[favId];
                    if (courseData && courseData.tees) {
                        teeSection.style.display = 'block';
                        renderTeeButtons(favId);
                    }
                    updateFavoriteButton();
                    return;
                }
                
                // Check if it's a custom course
                if (customCourses[favId]) {
                    courseData = customCourses[favId];
                    if (courseData && courseData.tees) {
                        teeSection.style.display = 'block';
                        renderTeeButtons(favId);
                    }
                    updateFavoriteButton();
                    return;
                }
                
                // Check if we already have this course loaded as API course
                const apiKey = 'api_' + favId;
                if (customCourses[apiKey]) {
                    courseData = customCourses[apiKey];
                    if (courseData && courseData.tees) {
                        teeSection.style.display = 'block';
                        renderTeeButtons(apiKey);
                    }
                    updateFavoriteButton();
                    return;
                }
                
                // Check favorites array for API course info
                const favorite = favoriteCourses.find(f => String(f.id) === favId);
                if (favorite) {
                    // Need to fetch from API
                    showNotification('Loading...', `Fetching ${favorite.name} data`);
                    selectSearchedCourse(favId);
                }
                return;
            }
            
            if (selectedCourse) {
                // Get course from built-in or custom courses
                courseData = courses[selectedCourse] || customCourses[selectedCourse];
                
                if (courseData && courseData.tees) {
                    // Show tee selection
                    teeSection.style.display = 'block';
                    renderTeeButtons(selectedCourse);
                } else {
                    teeSection.style.display = 'none';
                    selectedTee = null;
                }
            } else {
                courseData = null;
                teeSection.style.display = 'none';
                selectedTee = null;
            }
            
            // Update the favorite star button
            updateFavoriteButton();
            
            // Update all course handicaps when course changes
            updateAllCourseHandicaps();
            // Also update setup page course HCPs if in GHIN mode
            updateAllSetupCourseHcps();
        }
        
        // Render tee selection buttons
        // Format tee name for display (shorten combo tees to 3 letters each)
        function formatTeeName(teeName) {
            if (!teeName) return '';
            
            // Check if it's a combo tee (contains / or -)
            if (teeName.includes('/') || teeName.includes('-')) {
                const separator = teeName.includes('/') ? '/' : '-';
                const parts = teeName.split(separator);
                const shortened = parts.map(part => {
                    const trimmed = part.trim().toUpperCase();
                    // Common abbreviations
                    if (trimmed === 'BLACK') return 'BLK';
                    if (trimmed === 'BLUE') return 'BLU';
                    if (trimmed === 'WHITE') return 'WHT';
                    if (trimmed === 'GOLD') return 'GLD';
                    if (trimmed === 'RED') return 'RED';
                    if (trimmed === 'GREEN') return 'GRN';
                    if (trimmed === 'SILVER') return 'SLV';
                    // Default: first 3 characters
                    return trimmed.substring(0, 3);
                });
                return shortened.join('/');
            }
            
            return teeName;
        }
        
        function renderTeeButtons(courseKey) {
            const course = courses[courseKey] || customCourses[courseKey];
            const container = document.getElementById('teeButtons');
            const infoDiv = document.getElementById('teeInfo');
            
            if (!course || !course.tees) {
                container.innerHTML = '';
                infoDiv.innerHTML = '';
                return;
            }
            
            const teeColors = {
                black: '#1e293b',
                blue: '#1e3a5f',
                white: '#e2e8f0',
                gold: '#fbbf24',
                silver: '#94a3b8',
                red: '#a51c30',
                green: '#166534',
                // Oak Quarry style tees
                tournament: '#1e293b',
                championship: '#1e3a5f',
                regular: '#64748b',
                forward: '#fbbf24'
            };
            
            let html = '';
            const teeKeys = Object.keys(course.tees);
            
            teeKeys.forEach((teeKey, index) => {
                const tee = course.tees[teeKey];
                const isDefault = teeKey === course.defaultTee;
                const bgColor = teeColors[teeKey] || '#64748b';
                const textColor = (teeKey === 'white' || teeKey === 'gold' || teeKey === 'silver' || teeKey === 'forward') ? '#1e293b' : 'white';
                // For white tee, use gray border when not selected so it's visible
                const defaultBorderColor = (teeKey === 'white' || teeKey === 'forward') ? '#cbd5e1' : bgColor;
                const isSelected = selectedTee === teeKey || (!selectedTee && isDefault);
                
                // Format the display name (shorten combos)
                const displayName = formatTeeName(tee.name);
                
                // Double border effect: white inner, blue outer when selected
                const selectedStyle = isSelected 
                    ? 'border: 3px solid white; box-shadow: 0 0 0 3px #1e3a5f;' 
                    : `border: 3px solid ${defaultBorderColor};`;
                
                html += `
                    <button type="button" onclick="selectTee('${teeKey}')" id="teeBtn_${teeKey}"
                        style="flex: 1; min-width: 60px; padding: 10px 6px; ${selectedStyle}
                        background: ${bgColor}; color: ${textColor}; border-radius: 6px; font-size: 11px; font-weight: 600; 
                        cursor: pointer; text-align: center; display: flex; align-items: center; justify-content: center;"
                        title="${tee.name}">
                        ${displayName}
                    </button>
                `;
                
                // Auto-select default tee
                if (isSelected && !selectedTee) {
                    selectedTee = teeKey;
                }
            });
            
            container.innerHTML = html;
            updateTeeInfo();
        }
        
        // Select a tee
        function selectTee(teeKey) {
            selectedTee = teeKey;
            let courseKey = document.getElementById('courseSelect').value;
            // Strip fav_ prefix if present
            if (courseKey.startsWith('fav_')) {
                courseKey = courseKey.substring(4);
            }
            renderTeeButtons(courseKey);
            // Recalculate all course handicaps with new tee
            updateAllCourseHandicaps();
            // Also update setup page course HCPs if in GHIN mode
            updateAllSetupCourseHcps();
        }
        
        // Update tee info display
        function updateTeeInfo() {
            const infoDiv = document.getElementById('teeInfo');
            let courseKey = document.getElementById('courseSelect').value;
            // Strip fav_ prefix if present
            if (courseKey.startsWith('fav_')) {
                courseKey = courseKey.substring(4);
            }
            const course = courses[courseKey] || customCourses[courseKey];
            
            if (!course || !selectedTee || !course.tees[selectedTee]) {
                infoDiv.innerHTML = '';
                return;
            }
            
            const tee = course.tees[selectedTee];
            infoDiv.innerHTML = `
                <span style="font-weight: 600;">${tee.yardage} yds</span> • 
                Rating: <span style="font-weight: 600;">${tee.rating}</span> • 
                Slope: <span style="font-weight: 600;">${tee.slope}</span>
            `;
        }
        
        // Calculate course handicap from index
        function calculateCourseHandicap(handicapIndex, slope, rating, par) {
            if (handicapIndex === null || handicapIndex === undefined || isNaN(handicapIndex)) return null;
            // USGA Formula: Course Handicap = Handicap Index × (Slope Rating ÷ 113) + (Course Rating - Par)
            const courseHcp = handicapIndex * (slope / 113) + (rating - par);
            return Math.round(courseHcp);
        }
        
        // Update course handicap display for a single player
        // Calculate Playing Handicap from Handicap Index
        function calculatePlayingHandicap(playerId) {
            const indexInput = document.getElementById(`hcp${playerId}`);
            const phInput = document.getElementById(`ph${playerId}`);
            
            if (!indexInput || !phInput) return;
            
            const indexValue = parseFloat(indexInput.value);
            
            if (!isNaN(indexValue)) {
                // Get the selected tee's slope and rating
                const selectedTee = document.querySelector('.tee-btn.selected');
                let playingHcp;
                
                if (selectedTee && courseData && courseData.tees) {
                    const teeId = selectedTee.getAttribute('data-tee');
                    const teeData = courseData.tees[teeId];
                    
                    if (teeData && teeData.slope && teeData.rating && courseData.totalPar) {
                        // Use proper USGA formula: P.H. = H.I. × (Slope / 113) + (Course Rating - Par)
                        playingHcp = calculateCourseHandicap(indexValue, teeData.slope, teeData.rating, courseData.totalPar);
                    } else {
                        // Fallback: just round the index
                        playingHcp = Math.round(indexValue);
                    }
                } else {
                    // No tee selected or no course data - just round
                    playingHcp = Math.round(indexValue);
                }
                
                phInput.value = playingHcp;
                phInput.title = 'Playing handicap for this round';
            } else if (indexInput.value === '') {
                // H.I. cleared but don't clear P.H. (user might have entered it manually)
            }
        }
        
        // Update all playing handicaps when tee selection changes
        function updateAllPlayingHandicaps() {
            const playerRows = document.querySelectorAll('.player-row');
            playerRows.forEach(row => {
                const playerId = row.getAttribute('data-player');
                if (playerId) {
                    calculatePlayingHandicap(playerId);
                }
            });
        }
        
        // Legacy function name for compatibility
        function updateCourseHandicap(playerId) {
            calculatePlayingHandicap(playerId);
        }
        
        function updateAllCourseHandicaps() {
            updateAllPlayingHandicaps();
        }
        
        // Show course search modal
        function showCourseSearchModal() {
            // Remove existing modal if any
            const existingModal = document.getElementById('courseSearchModal');
            if (existingModal) existingModal.remove();
            
            const modal = document.createElement('div');
            modal.id = 'courseSearchModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 6px; padding: 20px; max-width: 400px; width: 95%; max-height: 80vh; overflow-y: auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h2 style="color: #1e3a5f; font-size: 18px; margin: 0;">🔍 Search Courses</h2>
                        <button onclick="closeCourseSearchModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">✕</button>
                    </div>
                    
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <input type="text" id="courseSearchInput" placeholder="Course name or city..." 
                            style="flex: 1; padding: 12px; border: 1.5px solid #1e3a5f; border-radius: 4px; font-size: 14px;"
                            onkeypress="if(event.key === 'Enter') searchCourses();">
                        <button onclick="searchCourses()" style="padding: 12px 16px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-weight: 700; cursor: pointer;">
                            Search
                        </button>
                    </div>
                    
                    <!-- GPS Nearby button hidden for now - waiting for paid API
                    <div style="display: flex; justify-content: center; margin-bottom: 16px;">
                        <button onclick="searchNearbyCourses()" style="padding: 10px 20px; background: #166534; color: white; border: none; border-radius: 20px; font-weight: 600; cursor: pointer; font-size: 14px;">
                            📍 Find Nearby Courses
                        </button>
                    </div>
                    -->
                    
                    <div id="courseSearchResults" style="min-height: 100px;">
                        <p style="text-align: center; color: #94a3b8; font-size: 14px; padding: 24px;">
                            Enter a course name or city to search
                        </p>
                    </div>
                    
                    <button onclick="closeCourseSearchModal()" style="width: 100%; margin-top: 16px; padding: 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeCourseSearchModal();
            };
            
            document.getElementById('courseSearchInput').focus();
        }
        
        // Close course search modal
        function closeCourseSearchModal() {
            const modal = document.getElementById('courseSearchModal');
            if (modal) modal.remove();
        }
        
        // Hardcoded API key for Golf Course API (primary)
        const GOLF_API_KEY = 'WYX3P2U672HYTIWKZ223YGFNNI';
        
        // RapidAPI keys (secondary fallback)
        const RAPIDAPI_KEY = '00d735f3c4msh99ba09db9d5f561p15fcc8jsnf99c23fc89f9';
        const RAPIDAPI_COURSES_HOST = 'golf-courses-api.p.rapidapi.com';
        const RAPIDAPI_FINDER_HOST = 'golf-course-finder.p.rapidapi.com';
        
        // Search courses via multiple APIs
        async function searchCourses() {
            const searchTerm = document.getElementById('courseSearchInput').value.trim();
            const resultsDiv = document.getElementById('courseSearchResults');
            
            if (!searchTerm) {
                resultsDiv.innerHTML = '<p style="text-align: center; color: #a51c30; font-size: 14px; padding: 24px;">Please enter a course name or city</p>';
                return;
            }
            
            resultsDiv.innerHTML = '<p style="text-align: center; color: #1e3a5f; font-size: 14px; padding: 24px;">🔄 Searching...</p>';
            
            try {
                let allCourses = [];
                const searchLower = searchTerm.toLowerCase();
                
                // === STEP 0: Search built-in courses first ===
                Object.keys(courses).forEach(key => {
                    const course = courses[key];
                    if (course.name.toLowerCase().includes(searchLower) || 
                        course.city?.toLowerCase().includes(searchLower)) {
                        allCourses.push({
                            id: key,
                            club_name: course.name,
                            location: { city: course.city, state: course.state },
                            _source: 'builtin',
                            _builtin: true
                        });
                    }
                });
                
                // Also search custom courses
                Object.keys(customCourses).forEach(key => {
                    const course = customCourses[key];
                    if (course.name.toLowerCase().includes(searchLower) || 
                        course.city?.toLowerCase().includes(searchLower)) {
                        allCourses.push({
                            id: key,
                            club_name: course.name,
                            location: { city: course.city, state: course.state },
                            _source: 'custom',
                            _builtin: true
                        });
                    }
                });
                
                // === STEP 1: Try GolfCourseAPI.com (primary) ===
                const searchVariations = [
                    searchTerm,
                    searchTerm.replace(/golf club|golf course|gc|cc/gi, '').trim(),
                    searchTerm.split(' ').slice(0, 2).join(' ')
                ].filter((v, i, arr) => v && arr.indexOf(v) === i);
                
                for (const term of searchVariations) {
                    if (allCourses.length >= 8) break;
                    
                    try {
                        const response = await fetch(`https://api.golfcourseapi.com/v1/search?search_query=${encodeURIComponent(term)}`, {
                            headers: { 'Authorization': `Key ${GOLF_API_KEY}` }
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            if (data.courses && data.courses.length > 0) {
                                data.courses.forEach(course => {
                                    if (!allCourses.some(c => c.id === course.id)) {
                                        course._source = 'golfcourseapi';
                                        allCourses.push(course);
                                    }
                                });
                            }
                        }
                    } catch (e) {
                        console.log('GolfCourseAPI search failed:', term, e);
                    }
                }
                
                // === STEP 2: Try RapidAPI Golf Courses API (fallback) ===
                if (allCourses.length < 5) {
                    resultsDiv.innerHTML = '<p style="text-align: center; color: #1e3a5f; font-size: 14px; padding: 24px;">🔄 Searching additional sources...</p>';
                    
                    try {
                        const rapidResponse = await fetch(`https://${RAPIDAPI_COURSES_HOST}/Courses?name=${encodeURIComponent(searchTerm)}`, {
                            headers: {
                                'X-RapidAPI-Key': RAPIDAPI_KEY,
                                'X-RapidAPI-Host': RAPIDAPI_COURSES_HOST
                            }
                        });
                        
                        if (rapidResponse.ok) {
                            const rapidData = await rapidResponse.json();
                            // RapidAPI may return array directly or in a wrapper
                            const courses = Array.isArray(rapidData) ? rapidData : (rapidData.courses || rapidData.data || []);
                            
                            courses.forEach(course => {
                                // Normalize RapidAPI response to our format
                                const normalizedCourse = {
                                    id: 'rapid_' + (course.id || course.course_id || Math.random().toString(36).substr(2, 9)),
                                    club_name: course.name || course.courseName || course.club_name,
                                    course_name: course.name || course.courseName,
                                    location: {
                                        city: course.city || '',
                                        state: course.state || ''
                                    },
                                    _source: 'rapidapi',
                                    _rawData: course
                                };
                                
                                // Avoid duplicates by name
                                const name = normalizedCourse.club_name?.toLowerCase();
                                if (name && !allCourses.some(c => (c.club_name || c.course_name)?.toLowerCase() === name)) {
                                    allCourses.push(normalizedCourse);
                                }
                            });
                        }
                    } catch (e) {
                        console.log('RapidAPI search failed:', e);
                    }
                }
                
                // === STEP 3: Display results ===
                if (allCourses.length === 0) {
                    resultsDiv.innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <p style="color: #94a3b8; font-size: 14px; margin-bottom: 16px;">No courses found for "${searchTerm}"</p>
                            <p style="color: #64748b; font-size: 12px; margin-bottom: 16px;">
                                <strong>Search tips:</strong><br>
                                • Try just the course name (e.g., "Oak Quarry")<br>
                                • Try the city name (e.g., "Riverside")<br>
                                • Use 📍 Nearby to find courses near you
                            </p>
                            <button onclick="showManualCourseEntry('${searchTerm.replace(/'/g, "\\'")}')" 
                                style="padding: 12px 20px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                                ➕ Enter Course Manually
                            </button>
                            <p style="margin-top: 12px;">
                                <a href="https://ncrdb.usga.org/" target="_blank" style="color: #1e3a5f; font-size: 12px;">
                                    🔗 Look up slope/rating on USGA.org
                                </a>
                            </p>
                        </div>
                    `;
                    return;
                }
                
                let html = '';
                allCourses.slice(0, 10).forEach(course => {
                    const courseName = course.club_name || course.course_name || 'Unknown Course';
                    const city = course.location?.city || course.city || '';
                    const state = course.location?.state || course.state || '';
                    const isFavorite = favoriteCourses.some(f => String(f.id) === String(course.id));
                    const isBuiltin = course._builtin === true;
                    const sourceIcon = isBuiltin ? ' ✓' : (course._source === 'rapidapi' ? ' 🌐' : '');
                    const selectFn = isBuiltin ? `selectBuiltinCourse('${course.id}')` : `selectSearchedCourse('${course.id}')`;
                    
                    html += `
                        <div style="background: ${isBuiltin ? '#f0fdf4' : '#f8fafc'}; border: 1px solid ${isBuiltin ? '#bbf7d0' : '#e2e8f0'}; border-radius: 6px; padding: 12px; margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; color: #1e293b; font-size: 14px;">${courseName}${sourceIcon}</div>
                                    <div style="font-size: 12px; color: #64748b;">${city}${city && state ? ', ' : ''}${state}</div>
                                </div>
                                <button onclick="toggleFavorite('${course.id}', '${courseName.replace(/'/g, "\\'")}', '${city}', '${state}')" 
                                    style="background: none; border: none; font-size: 20px; cursor: pointer;">
                                    ${isFavorite ? '⭐' : '☆'}
                                </button>
                            </div>
                            <button onclick="${selectFn}" 
                                style="width: 100%; margin-top: 8px; padding: 8px; background: #166534; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                                Select Course
                            </button>
                        </div>
                    `;
                });
                
                // Add manual entry option at the bottom
                html += `
                    <div style="text-align: center; margin-top: 16px; padding-top: 16px; border-top: 1px solid #e2e8f0;">
                        <p style="color: #64748b; font-size: 12px; margin-bottom: 8px;">Don't see your course?</p>
                        <button onclick="showManualCourseEntry('${searchTerm.replace(/'/g, "\\'")}')" 
                            style="padding: 10px 16px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 13px;">
                            ➕ Enter Manually
                        </button>
                        <p style="margin-top: 8px;">
                            <a href="https://ncrdb.usga.org/" target="_blank" style="color: #1e3a5f; font-size: 11px;">
                                🔗 USGA Course Database
                            </a>
                        </p>
                    </div>
                `;
                
                resultsDiv.innerHTML = html;
                
            } catch (error) {
                console.error('Course search error:', error);
                resultsDiv.innerHTML = `
                    <div style="text-align: center; padding: 20px;">
                        <p style="color: #a51c30; font-size: 14px; margin-bottom: 16px;">
                            Error: ${error.message}
                        </p>
                        <button onclick="showManualCourseEntry('${searchTerm.replace(/'/g, "\\'")}')" 
                            style="padding: 12px 20px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                            ➕ Enter Course Manually
                        </button>
                    </div>
                `;
            }
        }
        
        // Search for nearby courses using GPS
        async function searchNearbyCourses() {
            const resultsDiv = document.getElementById('courseSearchResults');
            
            // Check if geolocation is supported
            if (!navigator.geolocation) {
                resultsDiv.innerHTML = `
                    <div style="text-align: center; padding: 20px;">
                        <p style="color: #a51c30; font-size: 14px;">📍 Location not supported by your browser</p>
                        <p style="color: #64748b; font-size: 12px; margin-top: 8px;">Try searching by course name or city instead</p>
                    </div>
                `;
                return;
            }
            
            resultsDiv.innerHTML = `
                <div style="text-align: center; padding: 30px;">
                    <p style="color: #1e3a5f; font-size: 14px;">📍 Getting your location...</p>
                    <p style="color: #64748b; font-size: 12px; margin-top: 8px;">Please allow location access when prompted</p>
                </div>
            `;
            
            try {
                // Get user's position
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 300000 // 5 minutes cache
                    });
                });
                
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                
                resultsDiv.innerHTML = `
                    <div style="text-align: center; padding: 30px;">
                        <p style="color: #1e3a5f; font-size: 14px;">🔄 Searching courses within 15 miles...</p>
                    </div>
                `;
                
                // Call RapidAPI Golf Course Finder
                const response = await fetch(`https://${RAPIDAPI_FINDER_HOST}/api/golf-clubs/?miles=15&latitude=${lat}&longitude=${lng}`, {
                    headers: {
                        'X-RapidAPI-Key': RAPIDAPI_KEY,
                        'X-RapidAPI-Host': RAPIDAPI_FINDER_HOST
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch nearby courses');
                }
                
                const data = await response.json();
                const courses = Array.isArray(data) ? data : (data.courses || data.data || []);
                
                if (courses.length === 0) {
                    resultsDiv.innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <p style="color: #94a3b8; font-size: 14px; margin-bottom: 16px;">No courses found within 15 miles</p>
                            <p style="color: #64748b; font-size: 12px; margin-bottom: 16px;">Try searching by name instead</p>
                            <button onclick="showManualCourseEntry()" 
                                style="padding: 12px 20px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                                ➕ Enter Course Manually
                            </button>
                        </div>
                    `;
                    return;
                }
                
                // Calculate distance for each course and sort by distance
                courses.forEach(course => {
                    if (course.latitude && course.longitude) {
                        course._distance = calculateDistance(lat, lng, parseFloat(course.latitude), parseFloat(course.longitude));
                    } else {
                        course._distance = 999;
                    }
                });
                courses.sort((a, b) => a._distance - b._distance);
                
                let html = `<p style="color: #166534; font-size: 13px; font-weight: 600; margin-bottom: 12px; text-align: center;">📍 ${courses.length} course${courses.length !== 1 ? 's' : ''} found nearby</p>`;
                
                courses.slice(0, 15).forEach(course => {
                    const courseName = course.club_name || course.name || course.courseName || 'Unknown Course';
                    const city = course.city || '';
                    const state = course.state || '';
                    const distanceText = course._distance < 999 ? `${course._distance.toFixed(1)} mi` : '';
                    
                    // Create a normalized course object for selection
                    const normalizedId = 'nearby_' + (course.id || Math.random().toString(36).substr(2, 9));
                    
                    html += `
                        <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 6px; padding: 12px; margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; color: #1e293b; font-size: 14px;">${courseName}</div>
                                    <div style="font-size: 12px; color: #64748b;">${city}${city && state ? ', ' : ''}${state}</div>
                                </div>
                                ${distanceText ? `<span style="background: #dcfce7; color: #166534; padding: 4px 8px; border-radius: 12px; font-size: 11px; font-weight: 600;">${distanceText}</span>` : ''}
                            </div>
                            <button onclick="selectNearbyCourse('${normalizedId}', '${courseName.replace(/'/g, "\\'")}', '${city}', '${state}')" 
                                style="width: 100%; margin-top: 8px; padding: 8px; background: #166534; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                                Select Course
                            </button>
                        </div>
                    `;
                });
                
                // Add manual entry option
                html += `
                    <div style="text-align: center; margin-top: 16px; padding-top: 16px; border-top: 1px solid #e2e8f0;">
                        <p style="color: #64748b; font-size: 12px; margin-bottom: 8px;">Don't see your course?</p>
                        <button onclick="showManualCourseEntry()" 
                            style="padding: 10px 16px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 13px;">
                            ➕ Enter Manually
                        </button>
                    </div>
                `;
                
                resultsDiv.innerHTML = html;
                
            } catch (error) {
                console.error('Nearby search error:', error);
                let errorMsg = 'Unable to get your location';
                
                // Check for geolocation errors
                if (error.code === 1) errorMsg = 'Location access denied. Please enable location permissions in your browser settings.';
                else if (error.code === 2) errorMsg = 'Location unavailable. Please try again.';
                else if (error.code === 3) errorMsg = 'Location request timed out. Please try again.';
                // Check for network/API errors
                else if (error.message && error.message.includes('fetch')) errorMsg = 'Network error. Please check your connection.';
                else if (error.message && error.message.includes('Failed to fetch')) errorMsg = 'Could not reach course database. Try searching by name.';
                else if (error.message) errorMsg = error.message;
                
                resultsDiv.innerHTML = `
                    <div style="text-align: center; padding: 20px;">
                        <p style="color: #a51c30; font-size: 14px; margin-bottom: 12px;">📍 ${errorMsg}</p>
                        <p style="color: #64748b; font-size: 12px; margin-bottom: 16px;">Try searching by course name above</p>
                        <button onclick="showManualCourseEntry()" 
                            style="padding: 12px 20px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                            ➕ Enter Course Manually
                        </button>
                    </div>
                `;
            }
        }
        
        /* ZIP/LOCATION SEARCH - HIDDEN FOR NOW (waiting for paid API)
        // Search courses by zip code or city name (geocode then search nearby)
        async function searchByLocation() {
            const input = document.getElementById('locationFallbackInput');
            const location = input?.value?.trim();
            const resultsDiv = document.getElementById('courseSearchResults');
            
            if (!location) {
                alert('Please enter a zip code or city name');
                return;
            }
            
            resultsDiv.innerHTML = `
                <div style="text-align: center; padding: 30px;">
                    <p style="color: #1e3a5f; font-size: 14px;">🔄 Looking up "${location}"...</p>
                </div>
            `;
            
            try {
                // Use a free geocoding API to convert location to lat/lng
                const geocodeResponse = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(location)}&countrycodes=us&limit=1`, {
                    headers: {
                        'User-Agent': 'LetsGolf/1.0'
                    }
                });
                
                if (!geocodeResponse.ok) {
                    throw new Error('Could not look up location');
                }
                
                const geocodeData = await geocodeResponse.json();
                
                if (!geocodeData || geocodeData.length === 0) {
                    resultsDiv.innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <p style="color: #a51c30; font-size: 14px; margin-bottom: 12px;">Location "${location}" not found</p>
                            <p style="color: #64748b; font-size: 12px; margin-bottom: 16px;">Try a different zip code or city name</p>
                            <button onclick="showManualCourseEntry()" 
                                style="padding: 12px 20px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                                ➕ Enter Course Manually
                            </button>
                        </div>
                    `;
                    return;
                }
                
                const lat = parseFloat(geocodeData[0].lat);
                const lng = parseFloat(geocodeData[0].lon);
                const locationName = geocodeData[0].display_name.split(',').slice(0, 2).join(',');
                
                // Extract city name for fallback search
                const addressParts = geocodeData[0].display_name.split(',');
                const cityName = addressParts[0]?.trim() || location;
                
                resultsDiv.innerHTML = `
                    <div style="text-align: center; padding: 30px;">
                        <p style="color: #1e3a5f; font-size: 14px;">🔄 Found ${locationName}</p>
                        <p style="color: #64748b; font-size: 12px;">Searching courses...</p>
                    </div>
                `;
                
                let courses = [];
                
                // Try RapidAPI Golf Course Finder first (location-based)
                try {
                    const response = await fetch(`https://${RAPIDAPI_FINDER_HOST}/api/golf-clubs/?miles=15&latitude=${lat}&longitude=${lng}`, {
                        headers: {
                            'X-RapidAPI-Key': RAPIDAPI_KEY,
                            'X-RapidAPI-Host': RAPIDAPI_FINDER_HOST
                        }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        courses = Array.isArray(data) ? data : (data.courses || data.data || []);
                    }
                } catch (e) {
                    console.log('RapidAPI Finder failed, trying name search:', e);
                }
                
                // Fallback: Search by city name using the name-based APIs
                if (courses.length === 0) {
                    resultsDiv.innerHTML = `
                        <div style="text-align: center; padding: 30px;">
                            <p style="color: #1e3a5f; font-size: 14px;">🔄 Searching courses in ${cityName}...</p>
                        </div>
                    `;
                    
                    // Try GolfCourseAPI.com with city name
                    try {
                        const golfApiResponse = await fetch(`https://api.golfcourseapi.com/v1/search?search_query=${encodeURIComponent(cityName)}`, {
                            headers: { 'Authorization': `Key ${GOLF_API_KEY}` }
                        });
                        
                        if (golfApiResponse.ok) {
                            const golfData = await golfApiResponse.json();
                            if (golfData.courses && golfData.courses.length > 0) {
                                golfData.courses.forEach(course => {
                                    course._source = 'golfcourseapi';
                                    // Calculate distance if we have coordinates
                                    if (course.location?.latitude && course.location?.longitude) {
                                        course._distance = calculateDistance(lat, lng, 
                                            parseFloat(course.location.latitude), 
                                            parseFloat(course.location.longitude));
                                    } else {
                                        course._distance = 999; // No coordinates = unknown distance
                                    }
                                    courses.push(course);
                                });
                            }
                        }
                    } catch (e) {
                        console.log('GolfCourseAPI city search failed:', e);
                    }
                    
                    // Also try RapidAPI name search
                    try {
                        const rapidResponse = await fetch(`https://${RAPIDAPI_COURSES_HOST}/Courses?name=${encodeURIComponent(cityName)}`, {
                            headers: {
                                'X-RapidAPI-Key': RAPIDAPI_KEY,
                                'X-RapidAPI-Host': RAPIDAPI_COURSES_HOST
                            }
                        });
                        
                        if (rapidResponse.ok) {
                            const rapidData = await rapidResponse.json();
                            const rapidCourses = Array.isArray(rapidData) ? rapidData : (rapidData.courses || rapidData.data || []);
                            rapidCourses.forEach(course => {
                                const normalizedCourse = {
                                    id: 'rapid_' + (course.id || Math.random().toString(36).substr(2, 9)),
                                    club_name: course.name || course.courseName || course.club_name,
                                    location: { 
                                        city: course.city || '', 
                                        state: course.state || '',
                                        latitude: course.latitude,
                                        longitude: course.longitude
                                    },
                                    _source: 'rapidapi',
                                    _distance: 999 // Assume far unless we have coords
                                };
                                // Calculate distance if we have coordinates
                                if (course.latitude && course.longitude) {
                                    normalizedCourse._distance = calculateDistance(lat, lng,
                                        parseFloat(course.latitude),
                                        parseFloat(course.longitude));
                                }
                                if (!courses.some(c => (c.club_name || c.course_name)?.toLowerCase() === normalizedCourse.club_name?.toLowerCase())) {
                                    courses.push(normalizedCourse);
                                }
                            });
                        }
                    } catch (e) {
                        console.log('RapidAPI name search failed:', e);
                    }
                }
                
                // Filter to only courses within 30 miles (or without distance = unknown)
                const maxDistance = 30;
                const nearbyCourses = courses.filter(c => c._distance && c._distance <= maxDistance);
                
                // Sort by distance
                nearbyCourses.sort((a, b) => (a._distance || 999) - (b._distance || 999));
                
                if (nearbyCourses.length === 0) {
                    resultsDiv.innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <p style="color: #94a3b8; font-size: 14px; margin-bottom: 8px;">No courses found within 30 miles of ${cityName}</p>
                            <p style="color: #64748b; font-size: 12px; margin-bottom: 16px;">
                                The course database may not have complete coverage for this area.<br>
                                Try searching by course name above, or enter manually.
                            </p>
                            <button onclick="showManualCourseEntry()" 
                                style="padding: 12px 20px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                                ➕ Enter Course Manually
                            </button>
                        </div>
                    `;
                    return;
                }
                
                let html = `<p style="color: #166534; font-size: 13px; font-weight: 600; margin-bottom: 12px; text-align: center;">📍 ${nearbyCourses.length} course${nearbyCourses.length !== 1 ? 's' : ''} within 30 mi of ${cityName}</p>`;
                
                nearbyCourses.slice(0, 15).forEach(course => {
                    const courseName = course.club_name || course.course_name || course.name || course.courseName || 'Unknown Course';
                    const city = course.location?.city || course.city || '';
                    const state = course.location?.state || course.state || '';
                    const distanceText = course._distance && course._distance < 999 ? `${course._distance.toFixed(1)} mi` : '';
                    const normalizedId = 'loc_' + (course.id || Math.random().toString(36).substr(2, 9));
                    
                    html += `
                        <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 6px; padding: 12px; margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; color: #1e293b; font-size: 14px;">${courseName}</div>
                                    <div style="font-size: 12px; color: #64748b;">${city}${city && state ? ', ' : ''}${state}</div>
                                </div>
                                ${distanceText ? `<span style="background: #dcfce7; color: #166534; padding: 4px 8px; border-radius: 12px; font-size: 11px; font-weight: 600;">${distanceText}</span>` : ''}
                            </div>
                            <button onclick="selectNearbyCourse('${normalizedId}', '${courseName.replace(/'/g, "\\'")}', '${city}', '${state}')" 
                                style="width: 100%; margin-top: 8px; padding: 8px; background: #166534; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                                Select Course
                            </button>
                        </div>
                    `;
                });
                
                html += `
                    <div style="text-align: center; margin-top: 16px; padding-top: 16px; border-top: 1px solid #e2e8f0;">
                        <p style="color: #64748b; font-size: 12px; margin-bottom: 8px;">Don't see your course?</p>
                        <button onclick="showManualCourseEntry()" 
                            style="padding: 10px 16px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 13px;">
                            ➕ Enter Manually
                        </button>
                    </div>
                `;
                
                resultsDiv.innerHTML = html;
                
            } catch (error) {
                console.error('Location search error:', error);
                resultsDiv.innerHTML = `
                    <div style="text-align: center; padding: 20px;">
                        <p style="color: #a51c30; font-size: 14px; margin-bottom: 12px;">Error searching location: ${error.message}</p>
                        <p style="color: #64748b; font-size: 12px; margin-bottom: 16px;">Try searching by course name instead</p>
                        <button onclick="showManualCourseEntry()" 
                            style="padding: 12px 20px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                            ➕ Enter Course Manually
                        </button>
                    </div>
                `;
            }
        }
        END OF ZIP/LOCATION SEARCH - HIDDEN FOR NOW */
        
        // Calculate distance between two lat/lng points in miles
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 3959; // Earth's radius in miles
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Select a nearby course (creates manual entry since we don't have full data)
        function selectNearbyCourse(id, name, city, state) {
            // For nearby courses, we need to create a manual entry since the API doesn't provide full course data
            showManualCourseEntry(name);
            
            // Pre-fill city and state
            setTimeout(() => {
                const cityInput = document.getElementById('manualCourseCity');
                const stateInput = document.getElementById('manualCourseState');
                if (cityInput && city) cityInput.value = city;
                if (stateInput && state) stateInput.value = state;
            }, 100);
        }
        
        // Show manual course entry form
        function showManualCourseEntry(prefillName = '') {
            const resultsDiv = document.getElementById('courseSearchResults');
            const searchInput = document.getElementById('courseSearchInput');
            const nameToPreFill = prefillName || searchInput?.value || '';
            
            resultsDiv.innerHTML = `
                <div style="padding: 8px;">
                    <h4 style="color: #1e3a5f; margin: 0 0 12px 0; font-size: 15px;">Enter Course Details</h4>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">Course Name *</label>
                        <input type="text" id="manualCourseName" placeholder="e.g., Oak Quarry Golf Club" value="${nameToPreFill.replace(/"/g, '&quot;')}"
                            style="width: 100%; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                        <div>
                            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">City</label>
                            <input type="text" id="manualCourseCity" placeholder="Riverside" 
                                style="width: 100%; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                        </div>
                        <div>
                            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">State</label>
                            <input type="text" id="manualCourseState" placeholder="CA" maxlength="2"
                                style="width: 100%; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; box-sizing: border-box; text-transform: uppercase;">
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                        <div>
                            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">Slope Rating</label>
                            <input type="number" id="manualCourseSlope" placeholder="113" min="55" max="155"
                                style="width: 100%; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                        </div>
                        <div>
                            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">Course Rating</label>
                            <input type="number" id="manualCourseRating" placeholder="72.0" step="0.1" min="60" max="80"
                                style="width: 100%; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                        </div>
                    </div>
                    
                    <p style="font-size: 11px; color: #64748b; margin-bottom: 12px;">
                        💡 Find slope/rating on the course scorecard or website. Default pars will be used (4-4-3-4-5-4-3-4-5...).
                    </p>
                    
                    <div style="display: flex; gap: 8px;">
                        <button onclick="document.getElementById('courseSearchResults').innerHTML = '<p style=\\'text-align: center; color: #64748b; font-size: 14px; padding: 24px;\\'>Search for a course above</p>';" 
                            style="flex: 1; padding: 12px; background: #e2e8f0; color: #475569; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                            ← Back
                        </button>
                        <button onclick="saveManualCourse()" 
                            style="flex: 2; padding: 12px; background: #166534; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                            Save & Select Course
                        </button>
                    </div>
                </div>
            `;
            
            document.getElementById('manualCourseName').focus();
        }
        
        // Save manually entered course
        function saveManualCourse() {
            const name = document.getElementById('manualCourseName').value.trim();
            const city = document.getElementById('manualCourseCity').value.trim();
            const state = document.getElementById('manualCourseState').value.trim().toUpperCase();
            const slope = parseInt(document.getElementById('manualCourseSlope').value) || 113;
            const rating = parseFloat(document.getElementById('manualCourseRating').value) || 72.0;
            
            if (!name) {
                alert('Please enter a course name');
                return;
            }
            
            // Create course ID
            const courseId = 'manual_' + name.toLowerCase().replace(/[^a-z0-9]/g, '_') + '_' + Date.now();
            
            // Default pars for 18 holes
            const defaultPars = [4, 4, 3, 4, 5, 4, 3, 4, 5, 4, 4, 3, 4, 5, 4, 3, 4, 4];
            const holes = defaultPars.map((par, i) => ({
                number: i + 1,
                par: par,
                handicap: i + 1
            }));
            
            // Create course object
            const courseData = {
                name: name,
                city: city,
                state: state,
                totalPar: 72,
                holes: holes,
                tees: {
                    default: {
                        name: 'Default',
                        slope: slope,
                        rating: rating,
                        yardage: 6200,
                        par: 72
                    }
                },
                defaultTee: 'default',
                isManual: true
            };
            
            // Save to customCourses
            customCourses[courseId] = courseData;
            
            // Save to localStorage for persistence
            try {
                const savedCustom = JSON.parse(localStorage.getItem('letsgolf_custom_courses') || '{}');
                savedCustom[courseId] = courseData;
                localStorage.setItem('letsgolf_custom_courses', JSON.stringify(savedCustom));
            } catch (e) {
                console.error('Error saving custom course:', e);
            }
            
            // Add to course select dropdown
            const select = document.getElementById('courseSelect');
            const option = document.createElement('option');
            option.value = courseId;
            option.textContent = `${name} (${city || 'Custom'})`;
            select.appendChild(option);
            
            // Select the new course
            select.value = courseId;
            updateCourseDetails(courseId);
            
            // Close modal
            closeCourseSearchModal();
            
            showNotification('✅ Course Added', `${name} saved successfully`);
        }
        
        // Toggle favorite for currently selected course
        function toggleCurrentCourseFavorite() {
            const select = document.getElementById('courseSelect');
            const selectedValue = select.value;
            
            if (!selectedValue || selectedValue === 'search_course' || selectedValue === 'custom_course') {
                return;
            }
            
            // Get course info
            let courseId, courseName, city, state;
            
            if (selectedValue.startsWith('api_')) {
                // API course
                courseId = selectedValue.replace('api_', '');
                const course = customCourses[selectedValue];
                courseName = course?.name || 'Unknown';
                city = course?.city || '';
                state = course?.state || '';
            } else if (selectedValue.startsWith('custom_')) {
                // Custom course
                courseId = selectedValue;
                const course = customCourses[selectedValue];
                courseName = course?.name || 'Unknown';
                city = course?.city || '';
                state = course?.state || '';
            } else {
                // Built-in course
                courseId = selectedValue;
                const course = courses[selectedValue];
                courseName = course?.name || 'Unknown';
                city = course?.city || '';
                state = course?.state || '';
            }
            
            // Toggle favorite
            const index = favoriteCourses.findIndex(f => String(f.id) === String(courseId));
            
            if (index >= 0) {
                favoriteCourses.splice(index, 1);
                showNotification('Removed', `${courseName} removed from favorites`);
            } else {
                favoriteCourses.push({ id: courseId, name: courseName, city, state });
                showNotification('Favorited ⭐', `${courseName} added to favorites`);
            }
            
            localStorage.setItem('golf_favorite_courses', JSON.stringify(favoriteCourses));
            updateFavoritesDropdown();
            updateFavoriteButton();
        }
        
        // Update the favorite button star based on current selection
        function updateFavoriteButton() {
            const select = document.getElementById('courseSelect');
            const btn = document.getElementById('favoriteBtn');
            const selectedValue = select.value;
            
            if (!btn) return;
            
            // Hide for special options or no selection
            if (!selectedValue || selectedValue === 'search_course' || selectedValue === 'custom_course' || selectedValue.startsWith('fav_')) {
                btn.style.display = 'none';
                return;
            }
            
            btn.style.display = 'flex';
            btn.style.alignItems = 'center';
            btn.style.justifyContent = 'center';
            
            // Check if current course is favorited
            let courseId = selectedValue;
            if (selectedValue.startsWith('api_')) {
                courseId = selectedValue.replace('api_', '');
            }
            
            const isFavorite = favoriteCourses.some(f => String(f.id) === String(courseId));
            btn.textContent = isFavorite ? '⭐' : '☆';
            btn.style.borderColor = isFavorite ? '#fbbf24' : '#e2e8f0';
            btn.style.background = isFavorite ? '#fef3c7' : 'white';
            btn.title = isFavorite ? 'Remove from favorites' : 'Add to favorites';
        }
        
        // Toggle favorite course (from search results)
        function toggleFavorite(courseId, name, city, state) {
            const index = favoriteCourses.findIndex(f => String(f.id) === String(courseId));
            
            if (index >= 0) {
                favoriteCourses.splice(index, 1);
            } else {
                favoriteCourses.push({ id: courseId, name, city, state });
            }
            
            localStorage.setItem('golf_favorite_courses', JSON.stringify(favoriteCourses));
            updateFavoritesDropdown();
            updateFavoriteButton();
            
            // Refresh search results if modal is open
            const resultsDiv = document.getElementById('courseSearchResults');
            if (resultsDiv && document.getElementById('courseSearchInput')?.value) {
                searchCourses();
            }
        }
        
        // Update favorites in dropdown
        function updateFavoritesDropdown() {
            const optgroup = document.getElementById('favoritesOptgroup');
            if (!optgroup) return;
            
            if (favoriteCourses.length === 0) {
                optgroup.style.display = 'none';
                optgroup.innerHTML = '';
                // Show hint
                const hint = document.getElementById('noFavoritesHint');
                if (hint) hint.style.display = 'block';
                return;
            }
            
            // Hide hint
            const hint = document.getElementById('noFavoritesHint');
            if (hint) hint.style.display = 'none';
            
            optgroup.style.display = 'block';
            optgroup.innerHTML = favoriteCourses.map(fav => 
                `<option value="fav_${fav.id}">${fav.name}</option>`
            ).join('');
        }
        
        // Select a built-in or custom course (no API call needed)
        function selectBuiltinCourse(courseKey) {
            const select = document.getElementById('courseSelect');
            const course = courses[courseKey] || customCourses[courseKey];
            
            if (!course) {
                showNotification('Error', 'Course not found');
                return;
            }
            
            // Add to favorites if not already
            if (!favoriteCourses.some(f => String(f.id) === String(courseKey))) {
                favoriteCourses.push({ id: courseKey, name: course.name, city: course.city || '', state: course.state || '' });
                localStorage.setItem('golf_favorite_courses', JSON.stringify(favoriteCourses));
                updateFavoritesDropdown();
            }
            
            // Hide hint
            const hint = document.getElementById('noFavoritesHint');
            if (hint) hint.style.display = 'none';
            
            // Select using the fav_ prefix to match dropdown options
            select.value = `fav_${courseKey}`;
            closeCourseSearchModal();
            updateCourse();
            
            showNotification('Course Selected', `${course.name}`);
        }
        
        // Select a searched course
        async function selectSearchedCourse(courseId) {
            // Show loading state
            const resultsDiv = document.getElementById('courseSearchResults');
            if (resultsDiv) {
                resultsDiv.innerHTML = '<p style="text-align: center; color: #1e3a5f; font-size: 14px; padding: 24px;">🔄 Loading course data...</p>';
            }
            
            try {
                // Fetch full course details
                const response = await fetch(`https://api.golfcourseapi.com/v1/courses/${courseId}`, {
                    headers: {
                        'Authorization': `Key ${GOLF_API_KEY}`
                    }
                });
                
                if (!response.ok) throw new Error('Failed to fetch course details');
                
                const data = await response.json();
                const course = data.course || data; // Handle both {course: {...}} and direct object
                
                console.log('API Course Data:', course);
                
                // Convert to our format and save as custom course
                const courseKey = 'api_' + courseId;
                const convertedCourse = {
                    name: course.club_name || course.course_name,
                    city: course.location?.city || '',
                    state: course.location?.state || '',
                    totalPar: 72, // Will be set from tee data
                    tees: {},
                    holes: []
                };
                
                // Convert tees - API returns {male: [...], female: [...]}
                // We'll use male tees by default (most common for men's clubs)
                let teesArray = [];
                if (course.tees) {
                    if (course.tees.male && Array.isArray(course.tees.male)) {
                        teesArray = course.tees.male;
                    } else if (course.tees.female && Array.isArray(course.tees.female)) {
                        teesArray = course.tees.female;
                    } else if (Array.isArray(course.tees)) {
                        // Fallback if it's just an array
                        teesArray = course.tees;
                    }
                }
                
                console.log('Tees array:', teesArray);
                
                // Process each tee
                let holesFromTee = null;
                teesArray.forEach(tee => {
                    const teeKey = tee.tee_name?.toLowerCase().replace(/\s+/g, '_') || 'default';
                    convertedCourse.tees[teeKey] = {
                        name: tee.tee_name || 'Default',
                        rating: parseFloat(tee.course_rating) || 72,
                        slope: parseInt(tee.slope_rating) || 113,
                        yardage: parseInt(tee.total_yards) || 6000,
                        par: parseInt(tee.par_total) || 72
                    };
                    
                    // Get total par from first tee with par_total
                    if (tee.par_total && !convertedCourse.totalPar) {
                        convertedCourse.totalPar = parseInt(tee.par_total);
                    }
                    
                    // Get holes data from first tee that has it
                    if (!holesFromTee && tee.holes && Array.isArray(tee.holes) && tee.holes.length > 0) {
                        holesFromTee = tee.holes;
                    }
                });
                
                // If no tees, create a default
                if (Object.keys(convertedCourse.tees).length === 0) {
                    convertedCourse.tees.default = { name: 'Default', rating: 72, slope: 113, yardage: 6000, par: 72 };
                }
                convertedCourse.defaultTee = Object.keys(convertedCourse.tees)[0];
                
                // Convert holes from tee data
                if (holesFromTee && holesFromTee.length > 0) {
                    convertedCourse.holes = holesFromTee.map((h, i) => ({
                        number: i + 1,
                        par: parseInt(h.par) || 4,
                        handicap: parseInt(h.handicap) || (i + 1)
                    }));
                    // Calculate totalPar from holes if not set
                    if (!convertedCourse.totalPar) {
                        convertedCourse.totalPar = convertedCourse.holes.reduce((sum, h) => sum + h.par, 0);
                    }
                } else {
                    // Create default 18 holes based on par 72
                    const defaultPars = [4,4,3,4,5,4,3,4,5,4,4,3,4,5,4,3,4,4];
                    for (let i = 0; i < 18; i++) {
                        convertedCourse.holes.push({ 
                            number: i + 1, 
                            par: defaultPars[i] || 4, 
                            handicap: i + 1 
                        });
                    }
                }
                
                console.log('Converted course:', convertedCourse);
                
                // Save to custom courses
                customCourses[courseKey] = convertedCourse;
                localStorage.setItem('golf_custom_courses', JSON.stringify(customCourses));
                
                // Add option to dropdown and select it
                const select = document.getElementById('courseSelect');
                const existingOption = select.querySelector(`option[value="${courseKey}"]`);
                if (!existingOption) {
                    const option = document.createElement('option');
                    option.value = courseKey;
                    option.textContent = convertedCourse.name;
                    // Add to Favorites optgroup
                    const favOptgroup = select.querySelector('#favoritesOptgroup');
                    if (favOptgroup) {
                        favOptgroup.style.display = 'block';
                        favOptgroup.appendChild(option);
                    }
                    // Also add to favoriteCourses
                    if (!favoriteCourses.some(f => f.id === courseKey)) {
                        favoriteCourses.push({ id: courseKey, name: convertedCourse.name, city: convertedCourse.city, state: convertedCourse.state });
                        localStorage.setItem('golf_favorite_courses', JSON.stringify(favoriteCourses));
                    }
                    // Hide hint
                    const hint = document.getElementById('noFavoritesHint');
                    if (hint) hint.style.display = 'none';
                }
                
                select.value = courseKey;
                closeCourseSearchModal();
                updateCourse();
                
                // Show success with tee count
                const teeCount = Object.keys(convertedCourse.tees).length;
                const teeNames = Object.values(convertedCourse.tees).map(t => t.name).join(', ');
                showNotification('Course Added', `${convertedCourse.name} (${teeCount} tees: ${teeNames})`);
                
            } catch (error) {
                console.error('Error selecting course:', error);
                alert('Failed to load course details. Please try again.');
            }
        }
        
        // Show custom course modal
        function showCustomCourseModal() {
            const existingModal = document.getElementById('customCourseModal');
            if (existingModal) existingModal.remove();
            
            const modal = document.createElement('div');
            modal.id = 'customCourseModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 6px; padding: 20px; max-width: 400px; width: 95%; max-height: 80vh; overflow-y: auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h2 style="color: #1e3a5f; font-size: 18px; margin: 0;">✏️ Add Custom Course</h2>
                        <button onclick="closeCustomCourseModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">✕</button>
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Course Name *</label>
                        <input type="text" id="customCourseName" placeholder="e.g., Pine Valley Golf Club" 
                            style="width: 100%; padding: 10px; border: 1.5px solid #e2e8f0; border-radius: 4px; font-size: 14px;">
                    </div>
                    
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <div style="flex: 1;">
                            <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Par *</label>
                            <input type="number" id="customCoursePar" placeholder="72" value="72"
                                style="width: 100%; padding: 10px; border: 1.5px solid #e2e8f0; border-radius: 4px; font-size: 14px;">
                        </div>
                        <div style="flex: 1;">
                            <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Slope *</label>
                            <input type="number" id="customCourseSlope" placeholder="113" value="113"
                                style="width: 100%; padding: 10px; border: 1.5px solid #e2e8f0; border-radius: 4px; font-size: 14px;">
                        </div>
                        <div style="flex: 1;">
                            <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Rating *</label>
                            <input type="number" id="customCourseRating" placeholder="72.0" value="72.0" step="0.1"
                                style="width: 100%; padding: 10px; border: 1.5px solid #e2e8f0; border-radius: 4px; font-size: 14px;">
                        </div>
                    </div>
                    
                    <p style="font-size: 11px; color: #94a3b8; margin-bottom: 16px; text-align: center;">
                        💡 Find slope & rating on the course scorecard or website
                    </p>
                    
                    <div style="display: flex; gap: 8px;">
                        <button onclick="closeCustomCourseModal()" style="flex: 1; padding: 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                        <button onclick="saveCustomCourse()" style="flex: 1; padding: 12px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">
                            Add Course
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeCustomCourseModal();
            };
            
            document.getElementById('customCourseName').focus();
        }
        
        // Close custom course modal
        function closeCustomCourseModal() {
            const modal = document.getElementById('customCourseModal');
            if (modal) modal.remove();
        }
        
        // Save custom course
        function saveCustomCourse() {
            const name = document.getElementById('customCourseName').value.trim();
            const par = parseInt(document.getElementById('customCoursePar').value) || 72;
            const slope = parseInt(document.getElementById('customCourseSlope').value) || 113;
            const rating = parseFloat(document.getElementById('customCourseRating').value) || 72.0;
            
            if (!name) {
                alert('Please enter a course name');
                return;
            }
            
            const courseKey = 'custom_' + Date.now();
            
            // Create default holes based on par
            const holes = [];
            const parDistribution = par <= 70 ? [4,4,3,4,3,4,4,5,4,4,3,4,4,4,3,4,4,5] : 
                                    par <= 72 ? [4,4,3,4,3,5,4,5,4,4,3,4,4,4,3,4,5,5] :
                                    [5,4,3,5,3,5,4,5,4,5,4,4,4,4,3,4,5,5];
            
            for (let i = 0; i < 18; i++) {
                holes.push({
                    number: i + 1,
                    par: parDistribution[i] || 4,
                    handicap: i + 1
                });
            }
            
            const customCourse = {
                name: name,
                totalPar: par,
                tees: {
                    default: { name: 'Default', rating: rating, slope: slope, yardage: 6000 }
                },
                defaultTee: 'default',
                holes: holes
            };
            
            customCourses[courseKey] = customCourse;
            localStorage.setItem('golf_custom_courses', JSON.stringify(customCourses));
            
            // Add to dropdown and favorites
            const select = document.getElementById('courseSelect');
            const option = document.createElement('option');
            option.value = courseKey;
            option.textContent = name;
            
            // Add to Favorites optgroup
            const favOptgroup = select.querySelector('#favoritesOptgroup');
            if (favOptgroup) {
                favOptgroup.style.display = 'block';
                favOptgroup.appendChild(option);
            }
            
            // Also add to favoriteCourses
            if (!favoriteCourses.some(f => f.id === courseKey)) {
                favoriteCourses.push({ id: courseKey, name: name, city: '', state: '' });
                localStorage.setItem('golf_favorite_courses', JSON.stringify(favoriteCourses));
            }
            
            // Hide hint
            const hint = document.getElementById('noFavoritesHint');
            if (hint) hint.style.display = 'none';
            
            select.value = courseKey;
            closeCustomCourseModal();
            updateCourse();
            
            showNotification('Course Added', `${name} is ready to use`);
        }
        
        // Initialize favorites dropdown on page load
        function initializeCourseDropdown() {
            updateFavoritesDropdown();
            
            // Add custom courses to Favorites optgroup
            const select = document.getElementById('courseSelect');
            const favOptgroup = select.querySelector('#favoritesOptgroup');
            
            Object.keys(customCourses).forEach(key => {
                const course = customCourses[key];
                // Check if already in favorites
                if (!favoriteCourses.some(f => f.id === key)) {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = course.name;
                    if (favOptgroup) {
                        favOptgroup.style.display = 'block';
                        favOptgroup.appendChild(option);
                    }
                }
            });
        }

        // Handle game type changes to show/hide team setup
        // Best Ball setup configuration
        let bestBallConfig = {
            playersPerTeam: 2,
            scoresPerHole: 1,
            format: 'stroke' // 'stroke' or 'match'
        };
        
        // Wolf game configuration
        let wolfConfig = {
            playerOrder: [],      // Array of player names in tee order
            allowBlindWolf: true, // 3x points
            allowPig: false,      // Partner rejection (2x)
            lastPlaceFinal: true  // Last place is Wolf on 17 & 18
        };
        
        // Wolf game state (per-hole tracking)
        let wolfGameState = {
            holeResults: [],      // Array of { hole, wolfPlayer, partner, isLoneWolf, isBlindWolf, isPig, winner, points }
            playerPoints: {}      // { playerName: totalPoints }
        };
        
        // Wolf point values
        const WOLF_POINTS = {
            WOLF_PARTNER_WIN: 2,      // Each gets 2 points
            NON_WOLF_WIN: 3,          // Each gets 3 points  
            LONE_WOLF_WIN: 4,         // Wolf gets 4 points
            LONE_WOLF_LOSE: 1,        // Each opponent gets 1 point
            BLIND_WOLF_MULTIPLIER: 3, // 3x the lone wolf points
            PIG_MULTIPLIER: 2         // 2x when pig is called
        };
        
        // ============================================
        // VEGAS GAME CONFIGURATION & LOGIC
        // ============================================
        let vegasConfig = {
            teamA: [],            // Array of 2 player names
            teamB: [],            // Array of 2 player names
            flipRule: true        // Birdie flips opponent's number
        };
        
        let vegasGameState = {
            holeResults: [],      // Array of { hole, teamAScore, teamBScore, teamANum, teamBNum, flipped, pointsAwarded, winner }
            teamAPoints: 0,
            teamBPoints: 0
        };
        
        // Render Vegas team setup
        function renderVegasTeamSetup() {
            const teamAContainer = document.getElementById('vegasTeamA');
            const teamBContainer = document.getElementById('vegasTeamB');
            if (!teamAContainer || !teamBContainer) return;
            
            // Get current player names
            const playerNames = [];
            const playerRows = document.querySelectorAll('.player-row');
            playerRows.forEach((row) => {
                const nameInput = row.querySelector('.player-name-input');
                if (nameInput && nameInput.value.trim()) {
                    playerNames.push(nameInput.value.trim());
                }
            });
            
            // Require exactly 4 players
            if (playerNames.length !== 4) {
                teamAContainer.innerHTML = `<div style="text-align: center; color: #dc2626; font-size: 11px; padding: 10px;">Vegas requires exactly 4 players</div>`;
                teamBContainer.innerHTML = '';
                return;
            }
            
            // Auto-assign if empty
            if (vegasConfig.teamA.length === 0 && vegasConfig.teamB.length === 0) {
                vegasConfig.teamA = [playerNames[0], playerNames[1]];
                vegasConfig.teamB = [playerNames[2], playerNames[3]];
            }
            
            // Render team A
            teamAContainer.innerHTML = vegasConfig.teamA.map((name, idx) => `
                <div style="background: white; padding: 6px 8px; border-radius: 4px; margin-bottom: 4px; font-size: 12px; font-weight: 600; color: #dc2626; display: flex; justify-content: space-between; align-items: center;">
                    <span>${name}</span>
                    <button onclick="swapVegasPlayer('A', ${idx})" style="background: none; border: none; cursor: pointer; font-size: 10px;">↔️</button>
                </div>
            `).join('');
            
            // Render team B
            teamBContainer.innerHTML = vegasConfig.teamB.map((name, idx) => `
                <div style="background: white; padding: 6px 8px; border-radius: 4px; margin-bottom: 4px; font-size: 12px; font-weight: 600; color: #2563eb; display: flex; justify-content: space-between; align-items: center;">
                    <span>${name}</span>
                    <button onclick="swapVegasPlayer('B', ${idx})" style="background: none; border: none; cursor: pointer; font-size: 10px;">↔️</button>
                </div>
            `).join('');
        }
        
        // Swap a Vegas player between teams
        function swapVegasPlayer(fromTeam, playerIdx) {
            const toTeam = fromTeam === 'A' ? 'B' : 'A';
            const fromArr = fromTeam === 'A' ? vegasConfig.teamA : vegasConfig.teamB;
            const toArr = fromTeam === 'A' ? vegasConfig.teamB : vegasConfig.teamA;
            
            // Swap with first player of other team
            const temp = fromArr[playerIdx];
            fromArr[playerIdx] = toArr[0];
            toArr[0] = temp;
            
            renderVegasTeamSetup();
        }
        
        // Calculate Vegas score for a hole
        function calculateVegasHoleScore(holeIndex) {
            if (!tournamentData?.players || !courseData?.holes) return null;
            
            const hole = courseData.holes[holeIndex];
            
            // Get gross scores for each team
            const getScore = (name) => {
                const player = tournamentData.players.find(p => p.name === name);
                return player?.scores?.[holeIndex] || 0;
            };
            
            const teamAScores = vegasConfig.teamA.map(getScore).filter(s => s > 0).sort((a, b) => a - b);
            const teamBScores = vegasConfig.teamB.map(getScore).filter(s => s > 0).sort((a, b) => a - b);
            
            if (teamAScores.length !== 2 || teamBScores.length !== 2) return null;
            
            // Combine into numbers (lower score first)
            let teamANum = parseInt(`${teamAScores[0]}${teamAScores[1]}`);
            let teamBNum = parseInt(`${teamBScores[0]}${teamBScores[1]}`);
            
            // Check for flip rule (birdie or better flips opponent's number)
            let flipped = { teamA: false, teamB: false };
            if (vegasConfig.flipRule) {
                const par = hole.par;
                // Check if Team A has a birdie
                if (teamAScores.some(s => s < par)) {
                    // Flip Team B's number
                    teamBNum = parseInt(`${teamBScores[1]}${teamBScores[0]}`);
                    flipped.teamB = true;
                }
                // Check if Team B has a birdie
                if (teamBScores.some(s => s < par)) {
                    // Flip Team A's number
                    teamANum = parseInt(`${teamAScores[1]}${teamAScores[0]}`);
                    flipped.teamA = true;
                }
            }
            
            // Calculate point difference
            const diff = Math.abs(teamANum - teamBNum);
            const winner = teamANum < teamBNum ? 'A' : teamBNum < teamANum ? 'B' : 'tie';
            
            return {
                hole: holeIndex + 1,
                teamAScores,
                teamBScores,
                teamANum,
                teamBNum,
                flipped,
                diff,
                winner
            };
        }
        
        // Initialize Vegas game
        function initVegasGame() {
            vegasConfig.flipRule = document.getElementById('vegasFlipRule')?.checked ?? true;
            vegasGameState = {
                holeResults: [],
                teamAPoints: 0,
                teamBPoints: 0
            };
            console.log('🎰 Vegas game initialized:', vegasConfig);
        }
        
        // ============================================
        // SIXES (ROUND ROBIN) GAME CONFIGURATION & LOGIC
        // ============================================
        let sixesConfig = {
            players: { A: null, B: null, C: null, D: null }  // Player names assigned to positions
        };
        
        let sixesGameState = {
            holeResults: [],      // Array of { hole, segment, teams, winner, points }
            playerPoints: {}      // { playerName: totalPoints }
        };
        
        // Get Sixes team pairing for a given hole
        function getSixesTeamsForHole(holeIndex) {
            // Holes 1-6 (0-5): A+B vs C+D
            // Holes 7-12 (6-11): A+C vs B+D
            // Holes 13-18 (12-17): A+D vs B+C
            const p = sixesConfig.players;
            
            if (holeIndex < 6) {
                return {
                    segment: 1,
                    team1: [p.A, p.B],
                    team2: [p.C, p.D],
                    label: 'A+B vs C+D'
                };
            } else if (holeIndex < 12) {
                return {
                    segment: 2,
                    team1: [p.A, p.C],
                    team2: [p.B, p.D],
                    label: 'A+C vs B+D'
                };
            } else {
                return {
                    segment: 3,
                    team1: [p.A, p.D],
                    team2: [p.B, p.C],
                    label: 'A+D vs B+C'
                };
            }
        }
        
        // Render Sixes player setup
        function renderSixesPlayerSetup() {
            const container = document.getElementById('sixesPlayerSetup');
            if (!container) return;
            
            // Get current player names
            const playerNames = [];
            const playerRows = document.querySelectorAll('.player-row');
            playerRows.forEach((row) => {
                const nameInput = row.querySelector('.player-name-input');
                if (nameInput && nameInput.value.trim()) {
                    playerNames.push(nameInput.value.trim());
                }
            });
            
            // Require exactly 4 players
            if (playerNames.length !== 4) {
                container.innerHTML = `<div style="text-align: center; color: #16a34a; font-size: 12px; padding: 10px;">⚠️ Sixes requires exactly 4 players</div>`;
                return;
            }
            
            // Auto-assign if empty
            if (!sixesConfig.players.A) {
                sixesConfig.players = {
                    A: playerNames[0],
                    B: playerNames[1],
                    C: playerNames[2],
                    D: playerNames[3]
                };
            }
            
            const positions = ['A', 'B', 'C', 'D'];
            const colors = { A: '#dc2626', B: '#2563eb', C: '#16a34a', D: '#b45309' };
            
            container.innerHTML = positions.map((pos, idx) => `
                <div style="display: flex; align-items: center; gap: 8px; padding: 8px 10px; background: white; border-radius: 4px; border: 2px solid ${colors[pos]};">
                    <span style="font-weight: 700; color: ${colors[pos]}; width: 24px;">${pos}:</span>
                    <span style="flex: 1; font-weight: 600; color: #374151;">${sixesConfig.players[pos]}</span>
                    <div style="display: flex; gap: 4px;">
                        <button type="button" onclick="moveSixesPlayer('${pos}', -1)" ${idx === 0 ? 'disabled' : ''} 
                            style="width: 24px; height: 24px; border: 1px solid #d1d5db; background: ${idx === 0 ? '#f5f5f5' : 'white'}; border-radius: 3px; cursor: ${idx === 0 ? 'not-allowed' : 'pointer'}; font-size: 12px;">↑</button>
                        <button type="button" onclick="moveSixesPlayer('${pos}', 1)" ${idx === 3 ? 'disabled' : ''}
                            style="width: 24px; height: 24px; border: 1px solid #d1d5db; background: ${idx === 3 ? '#f5f5f5' : 'white'}; border-radius: 3px; cursor: ${idx === 3 ? 'not-allowed' : 'pointer'}; font-size: 12px;">↓</button>
                    </div>
                </div>
            `).join('');
        }
        
        // Move Sixes player position
        function moveSixesPlayer(pos, direction) {
            const positions = ['A', 'B', 'C', 'D'];
            const currentIdx = positions.indexOf(pos);
            const newIdx = currentIdx + direction;
            
            if (newIdx < 0 || newIdx > 3) return;
            
            const newPos = positions[newIdx];
            
            // Swap players
            const temp = sixesConfig.players[pos];
            sixesConfig.players[pos] = sixesConfig.players[newPos];
            sixesConfig.players[newPos] = temp;
            
            renderSixesPlayerSetup();
        }
        
        // Calculate Sixes hole result
        function calculateSixesHoleResult(holeIndex) {
            if (!tournamentData?.players || !courseData?.holes) return null;
            
            const hole = courseData.holes[holeIndex];
            const teams = getSixesTeamsForHole(holeIndex);
            
            // Get net scores
            const getNetScore = (name) => {
                const player = tournamentData.players.find(p => p.name === name);
                if (!player || !player.scores || !player.scores[holeIndex]) return 999;
                
                const gross = player.scores[holeIndex];
                const hcp = player.handicap || 0;
                const strokesOnHole = Math.floor(hcp / 18) + (hole.handicap <= (hcp % 18) ? 1 : 0);
                return gross - strokesOnHole;
            };
            
            // Best ball for each team
            const team1Best = Math.min(...teams.team1.map(getNetScore));
            const team2Best = Math.min(...teams.team2.map(getNetScore));
            
            let winner = 'tie';
            if (team1Best < team2Best) winner = 'team1';
            else if (team2Best < team1Best) winner = 'team2';
            
            return {
                hole: holeIndex + 1,
                segment: teams.segment,
                teams,
                team1Best,
                team2Best,
                winner
            };
        }
        
        // Initialize Sixes game
        function initSixesGame() {
            sixesGameState = {
                holeResults: [],
                playerPoints: {}
            };
            
            // Initialize all player points to 0
            Object.values(sixesConfig.players).forEach(name => {
                if (name) sixesGameState.playerPoints[name] = 0;
            });
            
            console.log('🔄 Sixes game initialized:', sixesConfig);
        }
        
        // ============================================
        // DOTS (TRASH/GARBAGE) GAME CONFIGURATION & LOGIC
        // ============================================
        let dotsConfig = {
            enabledDots: {
                birdie: true,    // +1 for birdie
                eagle: true,     // +2 for eagle
                sandy: true,     // +1 for par or better out of bunker
                greenie: true,   // +1 for closest on par 3, make par or better
                poley: true,     // +1 for 1-putt from outside flag length
                threePutt: true  // -1 for 3-putt
            }
        };
        
        let dotsGameState = {
            playerDots: {},      // { playerName: { total: 0, birdie: 0, eagle: 0, sandy: 0, greenie: 0, poley: 0, threePutt: 0 } }
            holeAwards: []       // { hole, awards: [{ player, type, points }] }
        };
        
        // Dot point values
        const DOT_POINTS = {
            birdie: 1,
            eagle: 2,
            sandy: 1,
            greenie: 1,
            poley: 1,
            threePutt: -1
        };
        
        // Initialize Dots game
        function initDotsGame() {
            // Read config from UI
            dotsConfig.enabledDots = {
                birdie: document.getElementById('dotsBirdie')?.checked ?? true,
                eagle: document.getElementById('dotsEagle')?.checked ?? true,
                sandy: document.getElementById('dotsSandy')?.checked ?? true,
                greenie: document.getElementById('dotsGreenie')?.checked ?? true,
                poley: document.getElementById('dotsPoley')?.checked ?? true,
                threePutt: document.getElementById('dots3Putt')?.checked ?? true
            };
            
            dotsGameState = {
                playerDots: {},
                holeAwards: []
            };
            
            // Initialize all players
            if (tournamentData?.players) {
                tournamentData.players.forEach(p => {
                    dotsGameState.playerDots[p.name] = {
                        total: 0,
                        birdie: 0,
                        eagle: 0,
                        sandy: 0,
                        greenie: 0,
                        poley: 0,
                        threePutt: 0
                    };
                });
            }
            
            console.log('🔵 Dots game initialized:', dotsConfig);
        }
        
        // Award a dot to a player
        function awardDot(playerName, dotType) {
            if (!dotsConfig.enabledDots[dotType]) return false;
            if (!dotsGameState.playerDots[playerName]) return false;
            
            const points = DOT_POINTS[dotType];
            dotsGameState.playerDots[playerName][dotType] += 1;
            dotsGameState.playerDots[playerName].total += points;
            
            console.log(`🔵 ${playerName} awarded ${dotType} (${points > 0 ? '+' : ''}${points})`);
            return true;
        }
        
        // Calculate automatic dots for a hole (birdie, eagle, 3-putt)
        function calculateAutoDots(holeIndex) {
            if (!tournamentData?.players || !courseData?.holes) return [];
            
            const hole = courseData.holes[holeIndex];
            const par = hole.par;
            const awards = [];
            
            tournamentData.players.forEach(player => {
                const score = player.scores?.[holeIndex];
                if (!score || score <= 0) return;
                
                const scoreToPar = score - par;
                
                // Eagle (-2 or better)
                if (scoreToPar <= -2 && dotsConfig.enabledDots.eagle) {
                    awardDot(player.name, 'eagle');
                    awards.push({ player: player.name, type: 'eagle', points: DOT_POINTS.eagle });
                }
                // Birdie (-1)
                else if (scoreToPar === -1 && dotsConfig.enabledDots.birdie) {
                    awardDot(player.name, 'birdie');
                    awards.push({ player: player.name, type: 'birdie', points: DOT_POINTS.birdie });
                }
                
                // 3-putt check (requires putt tracking)
                const putts = playerStats[player.name]?.putts?.[holeIndex];
                if (putts >= 3 && dotsConfig.enabledDots.threePutt) {
                    awardDot(player.name, 'threePutt');
                    awards.push({ player: player.name, type: 'threePutt', points: DOT_POINTS.threePutt });
                }
            });
            
            if (awards.length > 0) {
                dotsGameState.holeAwards[holeIndex] = { hole: holeIndex + 1, awards };
            }
            
            return awards;
        }
        
        // Get Dots standings
        function getDotsStandings() {
            const standings = [];
            for (const [name, dots] of Object.entries(dotsGameState.playerDots)) {
                standings.push({
                    name,
                    total: dots.total,
                    breakdown: dots
                });
            }
            return standings.sort((a, b) => b.total - a.total);
        }
        
        // ============================================
        // FOURSOME GAMES RESULTS RENDERING
        // ============================================
        
        // Check if current game is a foursome game
        function isFoursomeGame() {
            const gameType = tournamentData?.gameType;
            return ['Wolf', 'Vegas', 'Sixes', 'Dots'].includes(gameType);
        }
        
        // Render foursome game results on results page
        function renderFoursomeGameResults() {
            const card = document.getElementById('foursomeGamesCard');
            const header = document.getElementById('foursomeGamesHeader');
            const content = document.getElementById('foursomeGamesContent');
            
            if (!card || !header || !content) return;
            
            if (!isFoursomeGame()) {
                card.style.display = 'none';
                return;
            }
            
            card.style.display = 'block';
            
            const gameType = tournamentData.gameType;
            
            // Set header based on game type
            const headerConfig = {
                'Wolf': { bg: 'linear-gradient(135deg, #92400e 0%, #b45309 100%)', emoji: '🐺', title: 'WOLF STANDINGS' },
                'Vegas': { bg: 'linear-gradient(135deg, #dc2626 0%, #b91c1c 100%)', emoji: '🎰', title: 'VEGAS RESULTS' },
                'Sixes': { bg: 'linear-gradient(135deg, #16a34a 0%, #15803d 100%)', emoji: '🔄', title: 'SIXES STANDINGS' },
                'Dots': { bg: 'linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%)', emoji: '🔵', title: 'DOTS LEADERBOARD' }
            };
            
            const config = headerConfig[gameType];
            header.style.background = config.bg;
            header.innerHTML = `
                <span style="font-size: 18px;">${config.emoji}</span>
                <span style="font-size: 14px; font-weight: 700; color: white; text-transform: uppercase; letter-spacing: 1px;">${config.title}</span>
                <span style="font-size: 18px;">${config.emoji}</span>
            `;
            
            // Render game-specific content
            if (gameType === 'Wolf') {
                content.innerHTML = renderWolfResults();
            } else if (gameType === 'Vegas') {
                content.innerHTML = renderVegasResults();
            } else if (gameType === 'Sixes') {
                content.innerHTML = renderSixesResults();
            } else if (gameType === 'Dots') {
                content.innerHTML = renderDotsResults();
            }
        }
        
        // Render Wolf game results
        function renderWolfResults() {
            const standings = getWolfStandings();
            
            if (standings.length === 0) {
                return '<div style="text-align: center; color: #6b7280; padding: 20px;">No Wolf results yet</div>';
            }
            
            let html = '<div style="display: flex; flex-direction: column; gap: 8px;">';
            
            standings.forEach((player, idx) => {
                const isLeader = idx === 0 && player.points > 0;
                const medal = idx === 0 ? '🥇' : idx === 1 ? '🥈' : idx === 2 ? '🥉' : '';
                
                html += `
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: ${isLeader ? 'linear-gradient(135deg, #fef3c7, #fde68a)' : '#f9fafb'}; border-radius: 8px; border: ${isLeader ? '2px solid #b45309' : '1px solid #e5e7eb'};">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 18px;">${medal || '🐺'}</span>
                            <span style="font-weight: 600; color: #1e3a5f;">${player.name}</span>
                        </div>
                        <div style="font-size: 20px; font-weight: 700; color: #92400e;">${player.points} pts</div>
                    </div>
                `;
            });
            
            html += '</div>';
            
            // Add settlement info
            if (standings.length >= 2 && standings[0].points > 0) {
                const leader = standings[0];
                html += `
                    <div style="margin-top: 16px; padding: 12px; background: #f0fdf4; border-radius: 8px; border: 1px solid #86efac;">
                        <div style="font-size: 11px; color: #166534; font-weight: 600; margin-bottom: 8px; text-align: center;">SETTLEMENT (per point)</div>
                        <div style="font-size: 12px; color: #15803d; line-height: 1.6;">
                `;
                
                for (let i = 1; i < standings.length; i++) {
                    const diff = leader.points - standings[i].points;
                    if (diff > 0) {
                        html += `<div>${standings[i].name} owes ${leader.name}: <strong>${diff} pts</strong></div>`;
                    }
                }
                
                html += '</div></div>';
            }
            
            return html;
        }
        
        // Render Vegas game results
        function renderVegasResults() {
            const teamA = vegasConfig.teamA;
            const teamB = vegasConfig.teamB;
            
            if (teamA.length !== 2 || teamB.length !== 2) {
                return '<div style="text-align: center; color: #6b7280; padding: 20px;">Vegas requires 4 players in 2 teams</div>';
            }
            
            // Calculate running totals
            let teamATotalPts = 0;
            let teamBTotalPts = 0;
            let holesHtml = '';
            
            for (let h = 0; h < 18; h++) {
                const result = calculateVegasHoleScore(h);
                if (!result) continue;
                
                if (result.winner === 'A') {
                    teamATotalPts += result.diff;
                } else if (result.winner === 'B') {
                    teamBTotalPts += result.diff;
                }
                
                holesHtml += `
                    <div style="display: grid; grid-template-columns: 50px 1fr 50px 1fr 60px; gap: 4px; padding: 6px 0; border-bottom: 1px solid #f3f4f6; font-size: 11px; align-items: center;">
                        <div style="font-weight: 600; color: #6b7280;">H${h + 1}</div>
                        <div style="color: #dc2626; ${result.flipped.teamA ? 'text-decoration: line-through;' : ''}">${result.teamAScores.join('-')}</div>
                        <div style="font-weight: 700; color: #dc2626;">${result.teamANum}</div>
                        <div style="color: #2563eb; ${result.flipped.teamB ? 'text-decoration: line-through;' : ''}">${result.teamBScores.join('-')}</div>
                        <div style="font-weight: 700; color: #2563eb;">${result.teamBNum}</div>
                    </div>
                `;
            }
            
            const netDiff = Math.abs(teamATotalPts - teamBTotalPts);
            const leader = teamATotalPts > teamBTotalPts ? 'A' : teamBTotalPts > teamATotalPts ? 'B' : 'Tie';
            
            return `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
                    <div style="background: ${leader === 'A' ? '#fef2f2' : '#f9fafb'}; border: 2px solid ${leader === 'A' ? '#dc2626' : '#e5e7eb'}; border-radius: 8px; padding: 12px; text-align: center;">
                        <div style="font-size: 12px; color: #dc2626; font-weight: 600; margin-bottom: 4px;">TEAM A</div>
                        <div style="font-size: 11px; color: #991b1b; margin-bottom: 8px;">${teamA.join(' & ')}</div>
                        <div style="font-size: 24px; font-weight: 700; color: #dc2626;">${teamATotalPts}</div>
                    </div>
                    <div style="background: ${leader === 'B' ? '#eff6ff' : '#f9fafb'}; border: 2px solid ${leader === 'B' ? '#2563eb' : '#e5e7eb'}; border-radius: 8px; padding: 12px; text-align: center;">
                        <div style="font-size: 12px; color: #2563eb; font-weight: 600; margin-bottom: 4px;">TEAM B</div>
                        <div style="font-size: 11px; color: #1e40af; margin-bottom: 8px;">${teamB.join(' & ')}</div>
                        <div style="font-size: 24px; font-weight: 700; color: #2563eb;">${teamBTotalPts}</div>
                    </div>
                </div>
                ${leader !== 'Tie' ? `
                    <div style="text-align: center; padding: 10px; background: #f0fdf4; border-radius: 6px; margin-bottom: 12px;">
                        <span style="font-size: 13px; color: #166534; font-weight: 600;">Team ${leader} leads by ${netDiff} points</span>
                    </div>
                ` : ''}
                <details style="margin-top: 8px;">
                    <summary style="font-size: 12px; color: #6b7280; cursor: pointer; padding: 8px;">View Hole-by-Hole</summary>
                    <div style="margin-top: 8px; max-height: 200px; overflow-y: auto;">
                        ${holesHtml}
                    </div>
                </details>
            `;
        }
        
        // Render Sixes game results
        function renderSixesResults() {
            const p = sixesConfig.players;
            if (!p.A || !p.B || !p.C || !p.D) {
                return '<div style="text-align: center; color: #6b7280; padding: 20px;">Sixes requires 4 players</div>';
            }
            
            // Calculate results for each segment
            const segments = [
                { name: 'Holes 1-6', range: [0, 5], team1: [p.A, p.B], team2: [p.C, p.D], color: '#16a34a' },
                { name: 'Holes 7-12', range: [6, 11], team1: [p.A, p.C], team2: [p.B, p.D], color: '#2563eb' },
                { name: 'Holes 13-18', range: [12, 17], team1: [p.A, p.D], team2: [p.B, p.C], color: '#b45309' }
            ];
            
            let playerPoints = { [p.A]: 0, [p.B]: 0, [p.C]: 0, [p.D]: 0 };
            let segmentHtml = '';
            
            segments.forEach(seg => {
                let team1Pts = 0;
                let team2Pts = 0;
                
                for (let h = seg.range[0]; h <= seg.range[1]; h++) {
                    const result = calculateSixesHoleResult(h);
                    if (!result) continue;
                    
                    if (result.winner === 'team1') {
                        team1Pts++;
                        seg.team1.forEach(name => playerPoints[name]++);
                    } else if (result.winner === 'team2') {
                        team2Pts++;
                        seg.team2.forEach(name => playerPoints[name]++);
                    }
                }
                
                segmentHtml += `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: #f9fafb; border-radius: 6px; border-left: 4px solid ${seg.color};">
                        <div style="font-size: 11px; color: #6b7280;">${seg.name}</div>
                        <div style="display: flex; gap: 16px; font-size: 12px;">
                            <span style="color: ${seg.color};">${seg.team1[0][0]}+${seg.team1[1][0]}: <strong>${team1Pts}</strong></span>
                            <span style="color: #6b7280;">vs</span>
                            <span style="color: ${seg.color};">${seg.team2[0][0]}+${seg.team2[1][0]}: <strong>${team2Pts}</strong></span>
                        </div>
                    </div>
                `;
            });
            
            // Sort players by points
            const standings = Object.entries(playerPoints).sort((a, b) => b[1] - a[1]);
            
            return `
                <div style="margin-bottom: 16px;">
                    <div style="font-size: 11px; color: #6b7280; font-weight: 600; margin-bottom: 8px; text-align: center;">INDIVIDUAL STANDINGS</div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;">
                        ${standings.map(([name, pts], idx) => `
                            <div style="text-align: center; padding: 10px; background: ${idx === 0 ? '#f0fdf4' : '#f9fafb'}; border-radius: 6px; border: ${idx === 0 ? '2px solid #16a34a' : '1px solid #e5e7eb'};">
                                <div style="font-size: 11px; color: #6b7280;">${name}</div>
                                <div style="font-size: 20px; font-weight: 700; color: #16a34a;">${pts}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 6px;">
                    ${segmentHtml}
                </div>
            `;
        }
        
        // Render Dots game results
        function renderDotsResults() {
            const standings = getDotsStandings();
            
            if (standings.length === 0) {
                return '<div style="text-align: center; color: #6b7280; padding: 20px;">No Dots recorded yet</div>';
            }
            
            const dotEmojis = {
                birdie: '🐦',
                eagle: '🦅',
                sandy: '🏖️',
                greenie: '🎯',
                poley: '🏌️',
                threePutt: '😬'
            };
            
            let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';
            
            standings.forEach((player, idx) => {
                const isLeader = idx === 0 && player.total > 0;
                const medal = idx === 0 ? '🥇' : idx === 1 ? '🥈' : idx === 2 ? '🥉' : '';
                
                // Build breakdown string
                const breakdown = [];
                if (player.breakdown.eagle > 0) breakdown.push(`${dotEmojis.eagle}${player.breakdown.eagle}`);
                if (player.breakdown.birdie > 0) breakdown.push(`${dotEmojis.birdie}${player.breakdown.birdie}`);
                if (player.breakdown.sandy > 0) breakdown.push(`${dotEmojis.sandy}${player.breakdown.sandy}`);
                if (player.breakdown.greenie > 0) breakdown.push(`${dotEmojis.greenie}${player.breakdown.greenie}`);
                if (player.breakdown.poley > 0) breakdown.push(`${dotEmojis.poley}${player.breakdown.poley}`);
                if (player.breakdown.threePutt > 0) breakdown.push(`${dotEmojis.threePutt}${player.breakdown.threePutt}`);
                
                html += `
                    <div style="padding: 12px; background: ${isLeader ? 'linear-gradient(135deg, #eff6ff, #dbeafe)' : '#f9fafb'}; border-radius: 8px; border: ${isLeader ? '2px solid #2563eb' : '1px solid #e5e7eb'};">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 16px;">${medal || '🔵'}</span>
                                <span style="font-weight: 600; color: #1e3a5f;">${player.name}</span>
                            </div>
                            <div style="font-size: 22px; font-weight: 700; color: #2563eb;">${player.total}</div>
                        </div>
                        ${breakdown.length > 0 ? `
                            <div style="font-size: 12px; color: #6b7280; display: flex; gap: 8px; flex-wrap: wrap;">
                                ${breakdown.join(' ')}
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            html += '</div>';
            return html;
        }
        
        // Initialize foursome game based on game type
        function initFoursomeGameIfNeeded() {
            if (!tournamentData) return;
            
            const gameType = tournamentData.gameType;
            console.log('🎮 Checking if foursome game init needed:', gameType);
            
            if (gameType === 'Wolf') {
                initWolfGame();
            } else if (gameType === 'Vegas') {
                initVegasGame();
            } else if (gameType === 'Sixes') {
                initSixesGame();
            } else if (gameType === 'Dots') {
                initDotsGame();
            }
        }
        
        
        // Render Wolf player order in setup
        function renderWolfPlayerOrder() {
            const container = document.getElementById('wolfPlayerOrder');
            if (!container) return;
            
            // Get current player names from the player list
            const playerNames = [];
            const playerRows = document.querySelectorAll('.player-row');
            playerRows.forEach((row) => {
                const nameInput = row.querySelector('.player-name-input');
                if (nameInput && nameInput.value.trim()) {
                    playerNames.push(nameInput.value.trim());
                }
            });
            
            // Initialize or update wolf player order
            if (wolfConfig.playerOrder.length === 0 || 
                !playerNames.every(p => wolfConfig.playerOrder.includes(p))) {
                wolfConfig.playerOrder = [...playerNames];
            }
            
            // Filter out any players no longer in the list
            wolfConfig.playerOrder = wolfConfig.playerOrder.filter(p => playerNames.includes(p));
            
            // Add any new players
            playerNames.forEach(p => {
                if (!wolfConfig.playerOrder.includes(p)) {
                    wolfConfig.playerOrder.push(p);
                }
            });
            
            if (wolfConfig.playerOrder.length < 3) {
                container.innerHTML = `
                    <div style="text-align: center; color: #92400e; font-size: 12px; padding: 10px;">
                        ⚠️ Wolf requires 3-5 players. Add more players above.
                    </div>
                `;
                return;
            }
            
            container.innerHTML = wolfConfig.playerOrder.map((name, idx) => `
                <div class="wolf-player-order-item" data-player="${name}" data-index="${idx}"
                    style="display: flex; align-items: center; gap: 8px; padding: 8px 10px; background: white; border-radius: 4px; border: 1px solid #d4a373; cursor: move;">
                    <span style="font-size: 14px; color: #92400e;">☰</span>
                    <span style="font-weight: 600; color: #78350f; flex: 1;">${idx + 1}. ${name}</span>
                    <div style="display: flex; gap: 4px;">
                        <button type="button" onclick="moveWolfPlayer(${idx}, -1)" ${idx === 0 ? 'disabled' : ''} 
                            style="width: 24px; height: 24px; border: 1px solid #d4a373; background: ${idx === 0 ? '#f5f5f5' : '#fef3c7'}; border-radius: 3px; cursor: ${idx === 0 ? 'not-allowed' : 'pointer'}; font-size: 12px;">↑</button>
                        <button type="button" onclick="moveWolfPlayer(${idx}, 1)" ${idx === wolfConfig.playerOrder.length - 1 ? 'disabled' : ''}
                            style="width: 24px; height: 24px; border: 1px solid #d4a373; background: ${idx === wolfConfig.playerOrder.length - 1 ? '#f5f5f5' : '#fef3c7'}; border-radius: 3px; cursor: ${idx === wolfConfig.playerOrder.length - 1 ? 'not-allowed' : 'pointer'}; font-size: 12px;">↓</button>
                    </div>
                </div>
            `).join('');
        }
        
        // Move wolf player up or down in order
        function moveWolfPlayer(index, direction) {
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= wolfConfig.playerOrder.length) return;
            
            // Swap players
            const temp = wolfConfig.playerOrder[index];
            wolfConfig.playerOrder[index] = wolfConfig.playerOrder[newIndex];
            wolfConfig.playerOrder[newIndex] = temp;
            
            renderWolfPlayerOrder();
        }
        
        // Get Wolf player for a given hole (0-indexed)
        function getWolfForHole(holeIndex) {
            const numPlayers = wolfConfig.playerOrder.length;
            if (numPlayers < 3) return null;
            
            // Check if we should use last place for holes 17 & 18
            if (wolfConfig.lastPlaceFinal && holeIndex >= 16) {
                const standings = getWolfStandings();
                if (standings.length > 0) {
                    // Hole 17 (index 16): last place player
                    // Hole 18 (index 17): second to last place player
                    const lastPlaceIdx = holeIndex === 16 ? standings.length - 1 : standings.length - 2;
                    if (lastPlaceIdx >= 0) {
                        return standings[lastPlaceIdx].name;
                    }
                }
            }
            
            // Normal rotation: Wolf rotates through players
            // On hole 1, player 1 is wolf, hole 2 player 2, etc.
            const wolfIndex = holeIndex % numPlayers;
            return wolfConfig.playerOrder[wolfIndex];
        }
        
        // Get Wolf standings sorted by points (highest first)
        function getWolfStandings() {
            const standings = [];
            for (const name of wolfConfig.playerOrder) {
                standings.push({
                    name: name,
                    points: wolfGameState.playerPoints[name] || 0
                });
            }
            return standings.sort((a, b) => b.points - a.points);
        }
        
        // Initialize Wolf game state for a new round
        function initWolfGame() {
            // Read options from UI
            wolfConfig.allowBlindWolf = document.getElementById('wolfAllowBlind')?.checked ?? true;
            wolfConfig.allowPig = document.getElementById('wolfAllowPig')?.checked ?? false;
            wolfConfig.lastPlaceFinal = document.getElementById('wolfLastPlaceFinal')?.checked ?? true;
            
            // Initialize game state
            wolfGameState.holeResults = [];
            wolfGameState.playerPoints = {};
            
            // Initialize all player points to 0
            for (const name of wolfConfig.playerOrder) {
                wolfGameState.playerPoints[name] = 0;
            }
            
            console.log('🐺 Wolf game initialized:', wolfConfig);
        }
        
        // Record Wolf hole result
        function recordWolfHoleResult(holeIndex, wolfPlayer, partner, isLoneWolf, isBlindWolf, isPig, winningTeam) {
            // winningTeam: 'wolf' or 'other'
            const result = {
                hole: holeIndex + 1,
                wolfPlayer: wolfPlayer,
                partner: partner,
                isLoneWolf: isLoneWolf,
                isBlindWolf: isBlindWolf,
                isPig: isPig,
                winningTeam: winningTeam,
                pointsAwarded: {}
            };
            
            // Calculate points
            const otherPlayers = wolfConfig.playerOrder.filter(p => p !== wolfPlayer && p !== partner);
            
            if (isLoneWolf || isBlindWolf) {
                // Lone Wolf or Blind Wolf scenario
                const multiplier = isBlindWolf ? WOLF_POINTS.BLIND_WOLF_MULTIPLIER : 1;
                
                if (winningTeam === 'wolf') {
                    // Wolf wins
                    const points = WOLF_POINTS.LONE_WOLF_WIN * multiplier;
                    result.pointsAwarded[wolfPlayer] = points;
                    wolfGameState.playerPoints[wolfPlayer] += points;
                } else {
                    // Wolf loses - each opponent gets points
                    const pointsEach = WOLF_POINTS.LONE_WOLF_LOSE * multiplier;
                    otherPlayers.forEach(p => {
                        result.pointsAwarded[p] = pointsEach;
                        wolfGameState.playerPoints[p] += pointsEach;
                    });
                    // Partner also gets points if not lone wolf
                    if (partner) {
                        result.pointsAwarded[partner] = pointsEach;
                        wolfGameState.playerPoints[partner] += pointsEach;
                    }
                }
            } else if (isPig) {
                // Pig scenario - partner rejected and plays alone
                const multiplier = WOLF_POINTS.PIG_MULTIPLIER;
                
                if (winningTeam === 'wolf') {
                    // Original Wolf wins against pig + others
                    const points = WOLF_POINTS.LONE_WOLF_WIN * multiplier;
                    result.pointsAwarded[wolfPlayer] = points;
                    wolfGameState.playerPoints[wolfPlayer] += points;
                } else {
                    // Pig or others win
                    const pointsEach = WOLF_POINTS.LONE_WOLF_LOSE * multiplier;
                    // All non-wolf players get points
                    [...otherPlayers, partner].forEach(p => {
                        if (p) {
                            result.pointsAwarded[p] = pointsEach;
                            wolfGameState.playerPoints[p] += pointsEach;
                        }
                    });
                }
            } else {
                // Standard Wolf + Partner scenario
                if (winningTeam === 'wolf') {
                    // Wolf team wins
                    result.pointsAwarded[wolfPlayer] = WOLF_POINTS.WOLF_PARTNER_WIN;
                    result.pointsAwarded[partner] = WOLF_POINTS.WOLF_PARTNER_WIN;
                    wolfGameState.playerPoints[wolfPlayer] += WOLF_POINTS.WOLF_PARTNER_WIN;
                    wolfGameState.playerPoints[partner] += WOLF_POINTS.WOLF_PARTNER_WIN;
                } else {
                    // Non-wolf team wins
                    otherPlayers.forEach(p => {
                        result.pointsAwarded[p] = WOLF_POINTS.NON_WOLF_WIN;
                        wolfGameState.playerPoints[p] += WOLF_POINTS.NON_WOLF_WIN;
                    });
                }
            }
            
            // Store result
            wolfGameState.holeResults[holeIndex] = result;
            
            console.log('🐺 Wolf hole result:', result);
            return result;
        }
        
        // Determine winning team for a Wolf hole based on scores
        function determineWolfWinner(holeIndex, wolfPlayer, partner, isLoneWolf) {
            if (!tournamentData?.players || !courseData?.holes) return null;
            
            const hole = courseData.holes[holeIndex];
            
            // Get net scores for all players
            const getNetScore = (playerName) => {
                const player = tournamentData.players.find(p => p.name === playerName);
                if (!player || !player.scores || !player.scores[holeIndex]) return 999;
                
                const gross = player.scores[holeIndex];
                const hcp = player.handicap || 0;
                // Simple net calculation - full handicap strokes on applicable holes
                const strokesOnHole = Math.floor(hcp / 18) + (hole.handicap <= (hcp % 18) ? 1 : 0);
                return gross - strokesOnHole;
            };
            
            if (isLoneWolf) {
                // Wolf vs best ball of others
                const wolfScore = getNetScore(wolfPlayer);
                const otherPlayers = wolfConfig.playerOrder.filter(p => p !== wolfPlayer);
                const bestOtherScore = Math.min(...otherPlayers.map(p => getNetScore(p)));
                
                if (wolfScore < bestOtherScore) return 'wolf';
                if (bestOtherScore < wolfScore) return 'other';
                return 'tie';
            } else {
                // Wolf + Partner best ball vs Other team best ball
                const wolfTeamScore = Math.min(getNetScore(wolfPlayer), getNetScore(partner));
                const otherPlayers = wolfConfig.playerOrder.filter(p => p !== wolfPlayer && p !== partner);
                const otherTeamScore = Math.min(...otherPlayers.map(p => getNetScore(p)));
                
                if (wolfTeamScore < otherTeamScore) return 'wolf';
                if (otherTeamScore < wolfTeamScore) return 'other';
                return 'tie';
            }
        }
        
        // Current Wolf decision state
        let currentWolfDecision = {
            holeIndex: 0,
            wolfPlayer: null,
            partner: null,
            isLoneWolf: false,
            isBlindWolf: false,
            isPig: false,
            decided: false
        };
        
        // Show Wolf decision modal at start of hole
        function showWolfDecisionModal(holeIndex) {
            const modal = document.getElementById('wolfDecisionModal');
            if (!modal) return;
            
            const wolfPlayer = getWolfForHole(holeIndex);
            if (!wolfPlayer) return;
            
            // Reset decision state
            currentWolfDecision = {
                holeIndex: holeIndex,
                wolfPlayer: wolfPlayer,
                partner: null,
                isLoneWolf: false,
                isBlindWolf: false,
                isPig: false,
                decided: false
            };
            
            // Update modal content
            document.getElementById('wolfDecisionHoleInfo').textContent = `Hole ${holeIndex + 1}`;
            document.getElementById('wolfDecisionWolfName').textContent = `🐺 ${wolfPlayer} is the Wolf`;
            
            // Show/hide blind wolf option based on config
            const blindOption = document.getElementById('wolfBlindOption');
            if (blindOption) {
                blindOption.style.display = wolfConfig.allowBlindWolf ? 'block' : 'none';
            }
            
            // Populate partner options (other players)
            const partnerContainer = document.getElementById('wolfPartnerOptions');
            const otherPlayers = wolfConfig.playerOrder.filter(p => p !== wolfPlayer);
            
            partnerContainer.innerHTML = otherPlayers.map(name => `
                <button onclick="selectWolfPartner('${name}')" 
                    style="padding: 12px 16px; background: white; border: 2px solid #d4a373; border-radius: 8px; font-size: 14px; font-weight: 600; color: #78350f; cursor: pointer; text-align: left; display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 18px;">👤</span>
                    <span>Partner with ${name}</span>
                </button>
            `).join('');
            
            modal.style.display = 'flex';
        }
        
        // Close Wolf decision modal
        function closeWolfDecisionModal() {
            const modal = document.getElementById('wolfDecisionModal');
            if (modal) modal.style.display = 'none';
        }
        
        // Declare Blind Wolf (3x points)
        function declareBlindWolf() {
            currentWolfDecision.isBlindWolf = true;
            currentWolfDecision.isLoneWolf = true;
            currentWolfDecision.decided = true;
            
            closeWolfDecisionModal();
            showNotification('🐺 BLIND WOLF!', `${currentWolfDecision.wolfPlayer} goes alone for 3x points!`);
        }
        
        // Declare Lone Wolf (2x points - after seeing shots)
        function declareLoneWolf() {
            currentWolfDecision.isLoneWolf = true;
            currentWolfDecision.decided = true;
            
            closeWolfDecisionModal();
            showNotification('🐺 Lone Wolf', `${currentWolfDecision.wolfPlayer} plays alone!`);
        }
        
        // Select a partner
        function selectWolfPartner(partnerName) {
            currentWolfDecision.partner = partnerName;
            currentWolfDecision.decided = true;
            
            closeWolfDecisionModal();
            showNotification('🐺 Wolf', `${currentWolfDecision.wolfPlayer} + ${partnerName} vs the field`);
        }
        
        // Process Wolf hole completion (called when all scores are in)
        function processWolfHoleCompletion(holeIndex) {
            if (tournamentData.gameType !== 'Wolf') return;
            
            // Check if we have a decision for this hole
            if (!currentWolfDecision.decided || currentWolfDecision.holeIndex !== holeIndex) {
                // No decision made - default to lone wolf
                currentWolfDecision.holeIndex = holeIndex;
                currentWolfDecision.wolfPlayer = getWolfForHole(holeIndex);
                currentWolfDecision.isLoneWolf = true;
                currentWolfDecision.decided = true;
            }
            
            // Determine winner
            const winner = determineWolfWinner(
                holeIndex,
                currentWolfDecision.wolfPlayer,
                currentWolfDecision.partner,
                currentWolfDecision.isLoneWolf
            );
            
            if (winner === 'tie') {
                // Ties - no points awarded
                showWolfResultModal(holeIndex, 'tie', {});
                return;
            }
            
            // Record the result
            const result = recordWolfHoleResult(
                holeIndex,
                currentWolfDecision.wolfPlayer,
                currentWolfDecision.partner,
                currentWolfDecision.isLoneWolf,
                currentWolfDecision.isBlindWolf,
                currentWolfDecision.isPig,
                winner
            );
            
            // Show result modal
            showWolfResultModal(holeIndex, winner, result.pointsAwarded);
        }
        
        // Show Wolf hole result modal
        function showWolfResultModal(holeIndex, winner, pointsAwarded) {
            const modal = document.getElementById('wolfResultModal');
            if (!modal) return;
            
            document.getElementById('wolfResultHoleInfo').textContent = `Hole ${holeIndex + 1} Result`;
            
            const content = document.getElementById('wolfResultContent');
            
            if (winner === 'tie') {
                content.innerHTML = `
                    <div style="font-size: 32px; margin-bottom: 12px;">🤝</div>
                    <div style="font-size: 18px; font-weight: 700; color: #78350f; margin-bottom: 8px;">TIE - No Points</div>
                    <div style="font-size: 13px; color: #92400e;">The hole is halved</div>
                `;
            } else {
                const winnerEmoji = winner === 'wolf' ? '🐺' : '🐑';
                const winnerText = winner === 'wolf' ? 
                    (currentWolfDecision.isLoneWolf ? `${currentWolfDecision.wolfPlayer} (Lone Wolf)` : `${currentWolfDecision.wolfPlayer} & ${currentWolfDecision.partner}`) :
                    'The Field';
                
                let pointsHtml = Object.entries(pointsAwarded).map(([name, pts]) => 
                    `<div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #f3f4f6;">
                        <span>${name}</span>
                        <span style="font-weight: 700; color: #166534;">+${pts}</span>
                    </div>`
                ).join('');
                
                content.innerHTML = `
                    <div style="font-size: 32px; margin-bottom: 12px;">${winnerEmoji}</div>
                    <div style="font-size: 18px; font-weight: 700; color: #78350f; margin-bottom: 4px;">${winnerText} Wins!</div>
                    ${currentWolfDecision.isBlindWolf ? '<div style="color: #dc2626; font-weight: 600; margin-bottom: 8px;">BLIND WOLF (3x)</div>' : ''}
                    <div style="background: #f9fafb; border-radius: 8px; padding: 12px; margin-top: 12px; text-align: left;">
                        <div style="font-size: 11px; color: #6b7280; margin-bottom: 8px; text-align: center;">Points Awarded</div>
                        ${pointsHtml}
                    </div>
                `;
            }
            
            modal.style.display = 'flex';
        }
        
        // Close Wolf result modal
        function closeWolfResultModal() {
            const modal = document.getElementById('wolfResultModal');
            if (modal) modal.style.display = 'none';
        }
        
        // Get Wolf game summary for results page
        function getWolfGameSummary() {
            const standings = getWolfStandings();
            return {
                standings: standings,
                holeResults: wolfGameState.holeResults,
                totalHolesPlayed: wolfGameState.holeResults.filter(r => r).length
            };
        }
        
        
        
        function handleGameTypeChange() {
            const gameType = document.getElementById('gameType').value;
            const teamSection = document.getElementById('teamSetupSection');
            const bestBallSection = document.getElementById('bestBallSetupSection');
            const wolfSection = document.getElementById('wolfSetupSection');
            const vegasSection = document.getElementById('vegasSetupSection');
            const sixesSection = document.getElementById('sixesSetupSection');
            const dotsSection = document.getElementById('dotsSetupSection');
            
            // Hide all special sections first
            if (bestBallSection) bestBallSection.style.display = 'none';
            if (wolfSection) wolfSection.style.display = 'none';
            if (vegasSection) vegasSection.style.display = 'none';
            if (sixesSection) sixesSection.style.display = 'none';
            if (dotsSection) dotsSection.style.display = 'none';
            teamSection.style.display = 'none';
            
            if (gameType === 'Best Ball') {
                // Show Best Ball setup options
                if (bestBallSection) bestBallSection.style.display = 'block';
                teamSection.style.display = 'block';
                renderTeamSetup(gameType);
            } else if (gameType === 'Wolf') {
                // Show Wolf setup options
                if (wolfSection) wolfSection.style.display = 'block';
                renderWolfPlayerOrder();
            } else if (gameType === 'Vegas') {
                // Show Vegas setup options
                if (vegasSection) vegasSection.style.display = 'block';
                renderVegasTeamSetup();
            } else if (gameType === 'Sixes') {
                // Show Sixes setup options
                if (sixesSection) sixesSection.style.display = 'block';
                renderSixesPlayerSetup();
            } else if (gameType === 'Dots') {
                // Show Dots setup options
                if (dotsSection) dotsSection.style.display = 'block';
            }
        }
        
        // Set Best Ball option
        function setBestBallOption(field, value) {
            bestBallConfig[field] = value;
            
            // Update button styles
            const buttons = document.querySelectorAll(`.bestball-option-btn[data-field="${field}"]`);
            buttons.forEach(btn => {
                const btnValue = btn.dataset.value;
                const isSelected = (field === 'format') ? btnValue === value : parseInt(btnValue) === value;
                
                if (isSelected) {
                    btn.style.background = '#166534';
                    btn.style.borderColor = '#166534';
                    btn.style.color = 'white';
                } else {
                    btn.style.background = 'white';
                    btn.style.borderColor = '#d1d5db';
                    btn.style.color = '#475569';
                }
            });
            
            // Update team setup to reflect new players per team
            if (field === 'playersPerTeam') {
                renderTeamSetup('Best Ball');
            }
        }

        // Refresh team setup if a team game is currently selected
        function refreshTeamSetupIfNeeded() {
            const gameType = document.getElementById('gameType').value;
            if (gameType === 'Best Ball') {
                renderTeamSetup(gameType);
            }
        }

        // Render team setup based on game type
        function renderTeamSetup(gameType) {
            const content = document.getElementById('teamSetupContent');
            
            // Use bestBallConfig for players per team
            const playersPerTeam = bestBallConfig.playersPerTeam;
            
            // Get current player names from the player list
            const playerNames = [];
            const playerRows = document.querySelectorAll('.player-row');
            playerRows.forEach((row, index) => {
                const nameInput = row.querySelector('.player-name-input');
                const hcpInput = row.querySelector('.player-hcp-input');
                if (nameInput && nameInput.value.trim()) {
                    playerNames.push({
                        index: index,
                        name: nameInput.value.trim(),
                        handicap: hcpInput ? hcpInput.value : '0'
                    });
                }
            });
            
            // Calculate number of teams based on player count
            const totalPlayers = playerNames.length;
            const numTeams = totalPlayers > 0 ? Math.ceil(totalPlayers / playersPerTeam) : 2;
            
            content.innerHTML = '';
            
            if (totalPlayers === 0) {
                content.innerHTML = '<p style="color: #64748b; font-size: 14px; padding: 12px;">Add players first to create teams</p>';
                return;
            }
            
            // Create team selection dropdowns
            for (let t = 0; t < numTeams; t++) {
                const teamDiv = document.createElement('div');
                teamDiv.className = 'team-container';
                
                let teamHtml = `<div class="team-header">Team ${t + 1}</div>`;
                
                for (let p = 0; p < playersPerTeam; p++) {
                    teamHtml += `
                        <select class="team-member-select" id="team${t}_player${p}">
                            <option value="">Select Player ${p + 1}</option>
                    `;
                    
                    // Add options for each added player
                    playerNames.forEach(player => {
                        teamHtml += `<option value="${player.index}">${player.name} (${player.handicap})</option>`;
                    });
                    
                    teamHtml += `</select>`;
                }
                
                teamDiv.innerHTML = teamHtml;
                content.appendChild(teamDiv);
            }
        }

        // Auto-save functionality
        function saveToLocalStorage() {
            try {
                const data = {
                    ...tournamentData,
                    _activeTournamentId: activeTournamentId,
                    _tournamentMode: tournamentMode,
                    _isHost: isHost,
                    _hostForTournament: activeTournamentId ? activeTournamentId : null, // Tie host to specific tournament
                    _hasJoinedTournament: hasJoinedTournament, // Track if user has joined
                    _hostViewMode: hostViewMode, // Host's current view mode
                    _scoreTimestamps: scoreTimestamps, // NEWEST WINS: Save score timestamps
                    _deletedPlayers: deletedPlayers, // Tombstones for deleted players
                    _lastSaved: new Date().toISOString()
                };
                
                const jsonData = JSON.stringify(data);
                
                // Track save time for conflict resolution
                localStorage.setItem('_lastLocalSaveTime', Date.now().toString());
                
                // Save to localStorage
                localStorage.setItem('indianHillsScoring', jsonData);
                
                // VERIFY save worked by reading it back
                const verification = localStorage.getItem('indianHillsScoring');
                
                if (!verification) {
                    console.error('❌ SAVE VERIFICATION FAILED - localStorage returned null');
                    throw new Error('Save verification failed');
                }
                
                if (verification !== jsonData) {
                    console.error('❌ SAVE VERIFICATION FAILED - Data mismatch');
                    throw new Error('Save data mismatch');
                }
                
                console.log('✅ Data saved and verified successfully');
                showSaveIndicator();
                return true;
                
            } catch (error) {
                console.error('❌ SAVE ERROR:', error);
                
                // Retry once
                try {
                    console.log('🔄 Retrying save...');
                    const retryData = {
                        ...tournamentData,
                        _activeTournamentId: activeTournamentId,
                        _tournamentMode: tournamentMode,
                        _isHost: isHost,
                        _hostForTournament: activeTournamentId ? activeTournamentId : null,
                        _hasJoinedTournament: hasJoinedTournament,
                        _hostViewMode: hostViewMode,
                        _scoreTimestamps: scoreTimestamps,
                        _deletedPlayers: deletedPlayers,
                        _lastSaved: new Date().toISOString()
                    };
                    localStorage.setItem('indianHillsScoring', JSON.stringify(retryData));
                    console.log('✅ Retry successful');
                    showSaveIndicator();
                    return true;
                } catch (retryError) {
                    console.error('❌ RETRY FAILED:', retryError);
                    showSaveError();
                    return false;
                }
            }
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('indianHillsScoring');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    activeTournamentId = data._activeTournamentId || null;
                    tournamentMode = data._tournamentMode || 'single';
                    
                    // IMPROVED HOST RESTORATION: Only restore host if it matches the tournament
                    const savedHostForTournament = data._hostForTournament || null;
                    if (savedHostForTournament && savedHostForTournament === activeTournamentId) {
                        isHost = data._isHost || false;
                        console.log('🔑 Host status restored for tournament:', activeTournamentId);
                    } else if (data._isHost && activeTournamentId) {
                        // Fallback for old data format
                        isHost = data._isHost;
                        console.log('🔑 Host status restored (legacy format)');
                    } else {
                        isHost = false;
                    }
                    
                    // Restore join status and host view mode
                    hasJoinedTournament = data._hasJoinedTournament || false;
                    hostViewMode = data._hostViewMode || 'host';
                    
                    // NEWEST WINS: Restore score timestamps and tombstones
                    scoreTimestamps = data._scoreTimestamps || {};
                    deletedPlayers = data._deletedPlayers || {};
                    
                    // AUTO-FIX: If there's a Firebase tournament ID, it MUST be multi-device mode
                    // Firebase IDs look like T1768522029360yc63i0 (T + 13-digit timestamp + random)
                    // Local IDs look like Tmkhhwu1sfr3ql (T + base36 timestamp, shorter)
                    const isFirebaseIdLoad = activeTournamentId && /^T\d{13}/.test(activeTournamentId);
                    if (isFirebaseIdLoad && tournamentMode !== 'multi') {
                        console.log('🔧 AUTO-FIX: Detected Firebase tournament ID, forcing multi-device mode');
                        tournamentMode = 'multi';
                        isHost = true;
                    }
                    
                    // ADDITIONAL CHECK: Verify host status from tournament devices data itself
                    if (data.devices && data.devices[currentDeviceId] && data.devices[currentDeviceId].isHost) {
                        isHost = true;
                        console.log('🔑 Host status confirmed from tournament devices data');
                    }
                    
                    // Hosts are always considered joined
                    if (isHost) {
                        hasJoinedTournament = true;
                    }
                    
                    delete data._activeTournamentId;
                    delete data._tournamentMode;
                    delete data._isHost;
                    delete data._hostForTournament;
                    delete data._hasJoinedTournament;
                    delete data._hostViewMode;
                    delete data._scoreTimestamps;
                    delete data._deletedPlayers;
                    delete data._lastSaved;
                    tournamentData = data;
                    console.log('✅ Loaded tournament data from localStorage');
                    console.log('📊 Mode:', tournamentMode, '| Host:', isHost, '| TournamentID:', activeTournamentId);
                    console.log('📊 HasJoined:', hasJoinedTournament, '| HostViewMode:', hostViewMode);
                    console.log('📊 ScoreTimestamps:', Object.keys(scoreTimestamps).length, '| DeletedPlayers:', Object.keys(deletedPlayers).length);
                    return true;
                } catch (error) {
                    console.error('❌ Error parsing saved data:', error);
                    return false;
                }
            }
            return false;
        }
        
        // Visual save indicator
        function showSaveIndicator() {
            // Remove any existing indicator
            let indicator = document.getElementById('saveIndicator');
            if (indicator) {
                indicator.remove();
            }
            
            // Create new indicator
            indicator = document.createElement('div');
            indicator.id = 'saveIndicator';
            indicator.innerHTML = '✓ Saved';
            indicator.style.cssText = `
                position: fixed;
                top: 70px;
                right: 20px;
                background: #166534;
                color: white;
                padding: 8px 16px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 600;
                z-index: 10000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                animation: slideIn 0.3s ease-out;
            `;
            
            document.body.appendChild(indicator);
            
            // Remove after 1 second
            setTimeout(() => {
                if (indicator && indicator.parentNode) {
                    indicator.style.animation = 'slideOut 0.3s ease-out';
                    setTimeout(() => {
                        if (indicator && indicator.parentNode) {
                            indicator.remove();
                        }
                    }, 300);
                }
            }, 1000);
        }
        
        function showSaveError() {
            // Remove any existing indicator
            let indicator = document.getElementById('saveIndicator');
            if (indicator) {
                indicator.remove();
            }
            
            // Create error indicator
            indicator = document.createElement('div');
            indicator.id = 'saveIndicator';
            indicator.innerHTML = '⚠️ Save Failed!';
            indicator.style.cssText = `
                position: fixed;
                top: 70px;
                right: 20px;
                background: #a51c30;
                color: white;
                padding: 8px 16px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 600;
                z-index: 10000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            `;
            
            document.body.appendChild(indicator);
            
            // Keep it visible longer
            setTimeout(() => {
                if (indicator && indicator.parentNode) {
                    indicator.remove();
                }
            }, 3000);
        }
        
        // Verify that a specific score was saved correctly
        async function verifyScoreSaved(playerIndex, holeIndex, expectedScore) {
            try {
                // Longer delay for iOS to ensure localStorage write completes
                await new Promise(resolve => setTimeout(resolve, 150));
                
                const saved = localStorage.getItem('indianHillsScoring');
                if (!saved) {
                    console.error('❌ VERIFY: No saved data found in localStorage');
                    return false;
                }
                
                const data = JSON.parse(saved);
                const actualScore = data.players[playerIndex].scores[holeIndex];
                
                if (actualScore === expectedScore) {
                    console.log('✅ VERIFY: Score verified -', 
                        data.players[playerIndex].name, 
                        'Hole', holeIndex + 1, 
                        '=', actualScore);
                    return true;
                } else {
                    console.error('❌ VERIFY: Score mismatch!', 
                        'Expected:', expectedScore, 
                        'Got:', actualScore);
                    return false;
                }
            } catch (error) {
                console.error('❌ VERIFY: Error during verification:', error);
                return false;
            }
        }

        // ========================================
        // FIREBASE TOURNAMENT MANAGEMENT SYSTEM
        // ========================================
        
        // Current tournament state
        let activeTournamentId = null;
        let isHost = false;
        let isCoHost = false; // True if current device is a co-host
        let isGuestUser = false; // True if joined via invite link (no home access)
        let hasJoinedTournament = false; // True if user has claimed/watched players or joined as viewer
        let hostViewMode = 'host'; // 'host' or 'player' - for hosts to toggle their view
        let claimedPlayers = []; // Players this device can edit
        let tournamentUnsubscribe = null;
        let lastFirebaseWriteTime = 0; // Track when we last wrote to Firebase
        
        // Helper function to check if current device can manage tournament
        function canManageTournament() {
            return isHost || isCoHost;
        }
        
        // Helper function to check if host/co-host is in player view mode
        function isHostInPlayerMode() {
            return (isHost || canManageTournament()) && hostViewMode === 'player';
        }
        
        // NEWEST-WINS SYNC: Track score timestamps and deletion tombstones
        let scoreTimestamps = {}; // { "playerName-holeIndex": timestamp }
        let deletedPlayers = {}; // { "playerName": deletedAtTimestamp } - tombstones to prevent zombies
        
        // STATS TRACKER: Track which stats are enabled and player stats data
        let statsTrackerConfig = {
            putts: false,
            dots: false,
            fir: false,  // Fairway in Regulation (not on par 3s)
            gir: false   // Green in Regulation
        };
        
        // AUTO-ADVANCE: Always enabled - advances to next hole when all scores (and enabled stats) are entered
        let autoAdvanceEnabled = true; // Always enabled
        let autoAdvanceTimer = null;
        let autoAdvanceCountdown = 3; // seconds
        
        // No longer need to load/save setting - always on
        function loadAutoAdvanceSetting() {
            // Auto-advance is always enabled
            autoAdvanceEnabled = true;
        }
        
        // No longer need to save setting
        function saveAutoAdvanceSetting() {
            // Auto-advance is always enabled, no need to save
        }
        
        // Keep function for compatibility but it does nothing now
        function toggleAutoAdvance() {
            // Auto-advance is always enabled, cannot be toggled
        }
        
        // Check if all players have completed the current hole (scores + enabled stats)
        function isHoleComplete(holeIndex) {
            if (!tournamentData || !tournamentData.players) return false;
            
            // Get players we're tracking (claimed + watched for non-hosts, all for hosts)
            let playersToCheck = [];
            
            if (tournamentMode === 'multi' && (!canManageTournament() || isHostInPlayerMode())) {
                // Non-host: only check claimed players (not watched - we don't control their stats)
                playersToCheck = tournamentData.players.filter(p => isClaimedByMe(p));
            } else {
                // Host: check all players
                playersToCheck = tournamentData.players;
            }
            
            if (playersToCheck.length === 0) return false;
            
            for (const player of playersToCheck) {
                // Check score
                const score = player.scores ? player.scores[holeIndex] : null;
                if (!score || score === 0) {
                    return false;
                }
                
                // Check enabled stats
                const stats = playerStats[player.name];
                
                // Check putts if enabled
                if (statsTrackerConfig.putts) {
                    const putts = stats?.putts?.[holeIndex];
                    if (putts === null || putts === undefined) {
                        return false;
                    }
                }
                
                // Check dots if enabled
                if (statsTrackerConfig.dots) {
                    const dots = stats?.dots?.[holeIndex];
                    if (dots === null || dots === undefined) {
                        return false;
                    }
                }
                
                // Check FIR if enabled (skip par 3s)
                if (statsTrackerConfig.fir) {
                    const holePar = courseData?.holes?.[holeIndex]?.par || 4;
                    if (holePar > 3) { // Only check FIR on non-par-3s
                        const fir = stats?.fir?.[holeIndex];
                        if (fir === null || fir === undefined) {
                            return false;
                        }
                    }
                }
                
                // Check GIR if enabled
                if (statsTrackerConfig.gir) {
                    const gir = stats?.gir?.[holeIndex];
                    if (gir === null || gir === undefined) {
                        return false;
                    }
                }
            }
            
            return true;
        }
        
        // Check and trigger auto-advance if hole is complete
        function checkAutoAdvance() {
            if (!autoAdvanceEnabled) return;
            if (currentHole === undefined) return;
            if (autoAdvanceTimer) return; // Already counting down
            
            // Only check in hole view
            const holeViewContent = document.getElementById('holeViewContent');
            if (!holeViewContent || !holeViewContent.innerHTML) return;
            
            if (isHoleComplete(currentHole)) {
                // Don't auto-advance from hole 18
                if (currentHole === 17) {
                    showNotification('🏁 Round Complete!', 'All scores entered for hole 18');
                    return;
                }
                
                startAutoAdvanceCountdown();
            }
        }
        
        // Start countdown for auto-advance
        function startAutoAdvanceCountdown() {
            let countdown = autoAdvanceCountdown;
            const nextHole = currentHole + 2; // Display as 1-indexed
            
            // Show countdown toast
            showAutoAdvanceToast(countdown, nextHole);
            
            autoAdvanceTimer = setInterval(() => {
                countdown--;
                
                if (countdown <= 0) {
                    clearInterval(autoAdvanceTimer);
                    autoAdvanceTimer = null;
                    hideAutoAdvanceToast();
                    
                    // Actually advance to next hole
                    goToNextHole();
                    showNotification('⛳', `Now on Hole ${nextHole}`);
                } else {
                    updateAutoAdvanceToast(countdown);
                }
            }, 1000);
        }
        
        // Cancel auto-advance countdown
        function cancelAutoAdvance() {
            if (autoAdvanceTimer) {
                clearInterval(autoAdvanceTimer);
                autoAdvanceTimer = null;
            }
            hideAutoAdvanceToast();
        }
        
        // Show auto-advance toast
        function showAutoAdvanceToast(seconds, nextHole) {
            // Remove existing toast if any
            hideAutoAdvanceToast();
            
            const toast = document.createElement('div');
            toast.id = 'autoAdvanceToast';
            toast.style.cssText = `
                position: fixed;
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #166534 0%, #166534 100%);
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 10002;
                display: flex;
                align-items: center;
                gap: 12px;
                font-size: 14px;
                font-weight: 600;
                animation: slideUp 0.3s ease;
            `;
            
            toast.innerHTML = `
                <span>✅ Hole complete! Next hole in <span id="autoAdvanceSeconds">${seconds}</span>...</span>
                <button onclick="cancelAutoAdvance()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 6px 12px; border-radius: 6px; font-weight: 600; cursor: pointer;">
                    Stay
                </button>
            `;
            
            document.body.appendChild(toast);
        }
        
        // Update countdown in toast
        function updateAutoAdvanceToast(seconds) {
            const secondsEl = document.getElementById('autoAdvanceSeconds');
            if (secondsEl) {
                secondsEl.textContent = seconds;
            }
        }
        
        // Hide auto-advance toast
        function hideAutoAdvanceToast() {
            const toast = document.getElementById('autoAdvanceToast');
            if (toast) toast.remove();
        }
        
        // Player stats data: { "playerName": { putts: [hole1, hole2...], dots: [...], fir: [...], gir: [...] } }
        let playerStats = {};
        
        // Load stats config from localStorage
        function loadStatsConfig() {
            const saved = localStorage.getItem('statsTrackerConfig');
            if (saved) {
                try {
                    statsTrackerConfig = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading stats config:', e);
                }
            }
        }
        
        // Save stats config to localStorage
        function saveStatsConfig() {
            localStorage.setItem('statsTrackerConfig', JSON.stringify(statsTrackerConfig));
        }
        
        // Toggle a stat on/off
        function toggleStat(statName) {
            statsTrackerConfig[statName] = !statsTrackerConfig[statName];
            saveStatsConfig();
            showMyPlayersPage(); // Refresh the page to update UI
        }
        
        // Initialize player stats for a player if not exists
        function initPlayerStats(playerName) {
            if (!playerStats[playerName]) {
                playerStats[playerName] = {
                    putts: new Array(18).fill(null),
                    dots: new Array(18).fill(null),
                    fir: new Array(18).fill(null),
                    gir: new Array(18).fill(null)
                };
            }
        }
        
        // Update a stat for a player on a specific hole
        function updatePlayerStat(playerName, statType, holeIndex, value) {
            initPlayerStats(playerName);
            playerStats[playerName][statType][holeIndex] = value;
            savePlayerStatsToLocalStorage();
            
            // Check if hole is complete for auto-advance
            setTimeout(() => checkAutoAdvance(), 500);
        }
        
        // Save player stats to localStorage (and Firebase if signed in)
        function savePlayerStatsToLocalStorage() {
            localStorage.setItem('playerStats', JSON.stringify(playerStats));
            // Also sync to Firebase if signed in
            if (currentAuthUser) {
                savePlayerStatsToFirebase();
            }
        }
        
        // Load player stats from localStorage
        function loadPlayerStatsFromLocalStorage() {
            const saved = localStorage.getItem('playerStats');
            if (saved) {
                try {
                    playerStats = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading player stats:', e);
                    playerStats = {};
                }
            }
        }
        
        // Load player stats from Firebase (for signed-in users)
        async function loadPlayerStatsFromFirebase() {
            if (!currentAuthUser || !db) return;
            
            try {
                const userDoc = await db.collection('users').doc(currentAuthUser.uid).get();
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    const firebaseStats = userData.playerStats || {};
                    
                    if (Object.keys(firebaseStats).length > 0) {
                        // Merge with local stats (Firebase takes priority)
                        const localStats = playerStats || {};
                        playerStats = { ...localStats, ...firebaseStats };
                        
                        // Save merged stats back to localStorage
                        localStorage.setItem('playerStats', JSON.stringify(playerStats));
                        console.log('📥 Player stats loaded from Firebase');
                    }
                }
            } catch (error) {
                console.error('Error loading player stats from Firebase:', error);
            }
        }
        
        // Save player stats to Firebase (for signed-in users)
        async function savePlayerStatsToFirebase() {
            if (!currentAuthUser || !db) return;
            
            try {
                await db.collection('users').doc(currentAuthUser.uid).set({
                    playerStats: playerStats,
                    lastStatsSync: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
                console.log('📤 Player stats saved to Firebase');
            } catch (error) {
                console.error('Error saving player stats to Firebase:', error);
            }
        }
        
        // Get stat totals for a player
        function getPlayerStatTotals(playerName) {
            initPlayerStats(playerName);
            const stats = playerStats[playerName];
            
            // Calculate putts total
            const puttsTotal = stats.putts.reduce((sum, val) => sum + (val || 0), 0);
            const puttsHoles = stats.putts.filter(v => v !== null).length;
            
            // Calculate dots total
            const dotsTotal = stats.dots.reduce((sum, val) => sum + (val || 0), 0);
            
            // Calculate FIR (only count non-par-3 holes)
            let firHit = 0, firTotal = 0;
            if (courseData && courseData.holes) {
                courseData.holes.forEach((hole, i) => {
                    if (hole.par !== 3 && stats.fir[i] !== null) {
                        firTotal++;
                        if (stats.fir[i]) firHit++;
                    }
                });
            }
            
            // Calculate GIR
            let girHit = 0, girTotal = 0;
            stats.gir.forEach(val => {
                if (val !== null) {
                    girTotal++;
                    if (val) girHit++;
                }
            });
            
            return { puttsTotal, puttsHoles, dotsTotal, firHit, firTotal, girHit, girTotal };
        }
        
        // ==================== STATS HISTORY SYSTEM ====================
        
        const MAX_STATS_HISTORY = 50; // Keep last 50 rounds of stats
        
        // Get stats history from localStorage
        function getStatsHistory() {
            try {
                const history = localStorage.getItem('statsHistory');
                return history ? JSON.parse(history) : [];
            } catch (error) {
                console.error('Error reading stats history:', error);
                return [];
            }
        }
        
        // Save stats history to localStorage
        function saveStatsHistory(history) {
            try {
                localStorage.setItem('statsHistory', JSON.stringify(history));
            } catch (error) {
                console.error('Error saving stats history:', error);
            }
        }
        
        // Save current round stats to history
        function saveStatsToHistory() {
            if (!tournamentData || !tournamentData.players) return;
            
            const history = getStatsHistory();
            
            // Create stats entry for this round
            const roundStats = {
                id: activeTournamentId || `local_${Date.now()}`,
                date: tournamentData.date || new Date().toISOString().split('T')[0],
                course: tournamentData.course || 'Unknown',
                courseName: getCourseDisplayName(tournamentData.course),
                gameType: tournamentData.gameType || 'Stroke Play',
                savedAt: Date.now(),
                pars: courseData && courseData.pars ? [...courseData.pars] : null, // Store pars for par average calculations
                players: {}
            };
            
            // Save each player's stats and scores
            tournamentData.players.forEach(player => {
                const stats = playerStats[player.name] || {
                    putts: new Array(18).fill(null),
                    dots: new Array(18).fill(null),
                    fir: new Array(18).fill(null),
                    gir: new Array(18).fill(null)
                };
                
                // Calculate totals
                const totals = getPlayerStatTotals(player.name);
                const totalScore = player.scores ? player.scores.reduce((sum, s) => sum + (s || 0), 0) : 0;
                const holesPlayed = player.scores ? player.scores.filter(s => s > 0).length : 0;
                
                roundStats.players[player.name] = {
                    scores: [...(player.scores || [])],
                    handicap: player.handicap || 0,
                    handicapIndex: player.handicapIndex || null,
                    totalScore: totalScore,
                    holesPlayed: holesPlayed,
                    putts: [...stats.putts],
                    dots: [...stats.dots],
                    fir: [...stats.fir],
                    gir: [...stats.gir],
                    totals: totals
                };
            });
            
            // Remove existing entry for same tournament ID if present
            const filteredHistory = history.filter(h => h.id !== roundStats.id);
            
            // Add new entry at the beginning
            filteredHistory.unshift(roundStats);
            
            // Keep only last N rounds
            const trimmedHistory = filteredHistory.slice(0, MAX_STATS_HISTORY);
            
            saveStatsHistory(trimmedHistory);
            console.log('✅ Stats saved to history:', roundStats.id);
            
            return roundStats;
        }
        
        // Get aggregated stats for a specific player across all rounds
        function getPlayerAggregateStats(playerName, dateFilter = 'all') {
            let history = getStatsHistory();
            
            // Apply date filter
            if (dateFilter !== 'all') {
                const now = new Date();
                let cutoffDate;
                
                switch (dateFilter) {
                    case '7d':
                        cutoffDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                        break;
                    case '30d':
                        cutoffDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                        break;
                    case '90d':
                        cutoffDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
                        break;
                    case 'ytd':
                        cutoffDate = new Date(now.getFullYear(), 0, 1); // Jan 1 of current year
                        break;
                    default:
                        cutoffDate = null;
                }
                
                if (cutoffDate) {
                    history = history.filter(round => {
                        const roundDate = new Date(round.date + 'T00:00:00');
                        return roundDate >= cutoffDate;
                    });
                }
            }
            
            let totalRounds = 0;
            let totalPutts = 0;
            let totalPuttsHoles = 0;
            let firHit = 0;
            let firTotal = 0;
            let girHit = 0;
            let girTotal = 0;
            let totalStrokes = 0;
            let totalHolesPlayed = 0;
            let rounds = [];
            
            // Par averages tracking
            let par3Scores = [];
            let par4Scores = [];
            let par5Scores = [];
            
            history.forEach(round => {
                // Handle both formats:
                // 1. Old format: round.players[playerName] 
                // 2. New format: round.playerName matches directly
                let playerData = null;
                let scores = null;
                let pars = round.pars || null;
                
                if (round.players && round.players[playerName]) {
                    // Old format with players object
                    playerData = round.players[playerName];
                    scores = playerData.scores;
                } else if (round.playerName === playerName) {
                    // New format - data is directly on round
                    playerData = {
                        totalScore: round.totalScore,
                        holesPlayed: round.holesPlayed,
                        totals: round.totals
                    };
                    scores = round.scores;
                }
                
                if (playerData && playerData.holesPlayed > 0) {
                    totalRounds++;
                    
                    // Scores
                    totalStrokes += playerData.totalScore || 0;
                    totalHolesPlayed += playerData.holesPlayed || 0;
                    
                    // Putts
                    if (playerData.totals) {
                        if (playerData.totals.puttsHoles > 0) {
                            totalPutts += playerData.totals.puttsTotal || 0;
                            totalPuttsHoles += playerData.totals.puttsHoles || 0;
                        }
                        
                        // FIR
                        firHit += playerData.totals.firHit || 0;
                        firTotal += playerData.totals.firTotal || 0;
                        
                        // GIR
                        girHit += playerData.totals.girHit || 0;
                        girTotal += playerData.totals.girTotal || 0;
                    }
                    
                    // Calculate par averages if we have hole-by-hole data and pars
                    if (scores && pars) {
                        for (let i = 0; i < scores.length; i++) {
                            const score = scores[i];
                            const par = pars[i];
                            if (score > 0 && par) {
                                if (par === 3) par3Scores.push(score);
                                else if (par === 4) par4Scores.push(score);
                                else if (par === 5) par5Scores.push(score);
                            }
                        }
                    }
                    
                    // Add to rounds list
                    rounds.push({
                        date: round.date,
                        course: round.courseName || round.course,
                        score: playerData.totalScore,
                        holes: playerData.holesPlayed,
                        putts: playerData.totals?.puttsTotal || 0,
                        puttsHoles: playerData.totals?.puttsHoles || 0,
                        fir: playerData.totals?.firHit || 0,
                        firTotal: playerData.totals?.firTotal || 0,
                        gir: playerData.totals?.girHit || 0,
                        girTotal: playerData.totals?.girTotal || 0
                    });
                }
            });
            
            // Sort rounds by score to find best rounds (18-hole only)
            const fullRounds = rounds.filter(r => r.holes === 18);
            const bestRounds = [...fullRounds].sort((a, b) => a.score - b.score).slice(0, 3);
            
            // Calculate par averages
            const par3Avg = par3Scores.length > 0 ? (par3Scores.reduce((a, b) => a + b, 0) / par3Scores.length).toFixed(2) : '--';
            const par4Avg = par4Scores.length > 0 ? (par4Scores.reduce((a, b) => a + b, 0) / par4Scores.length).toFixed(2) : '--';
            const par5Avg = par5Scores.length > 0 ? (par5Scores.reduce((a, b) => a + b, 0) / par5Scores.length).toFixed(2) : '--';
            
            return {
                totalRounds,
                avgScore: totalHolesPlayed > 0 ? (totalStrokes / totalHolesPlayed * 18).toFixed(1) : '--',
                avgPutts: totalPuttsHoles > 0 ? (totalPutts / totalPuttsHoles * 18).toFixed(1) : '--',
                puttsPerHole: totalPuttsHoles > 0 ? (totalPutts / totalPuttsHoles).toFixed(2) : '--',
                par3Avg,
                par4Avg,
                par5Avg,
                firPct: firTotal > 0 ? ((firHit / firTotal) * 100).toFixed(0) + '%' : '--',
                girPct: girTotal > 0 ? ((girHit / girTotal) * 100).toFixed(0) + '%' : '--',
                bestRounds: bestRounds,
                rounds: rounds.slice(0, 10) // Last 10 rounds
            };
        }
        
        // ==================== SIGN SCORECARD SYSTEM ====================
        
        // Storage key for signed scorecards
        function getSignedScorecardsKey() {
            return activeTournamentId ? `signedScorecards_${activeTournamentId}` : 'signedScorecards_local';
        }
        
        // Get signed scorecards for current tournament
        function getSignedScorecards() {
            try {
                const data = localStorage.getItem(getSignedScorecardsKey());
                return data ? JSON.parse(data) : {};
            } catch (error) {
                console.error('Error reading signed scorecards:', error);
                return {};
            }
        }
        
        // Save signed scorecards
        function saveSignedScorecards(data) {
            try {
                localStorage.setItem(getSignedScorecardsKey(), JSON.stringify(data));
            } catch (error) {
                console.error('Error saving signed scorecards:', error);
            }
        }
        
        // Check if player's scorecard is signed
        function isScorecardSigned(playerName) {
            const signed = getSignedScorecards();
            return signed[playerName] || null;
        }
        
        // Show Sign Scorecard modal
        function showSignScorecardModal(playerName, handicap, playerIndex) {
            const player = tournamentData.players[playerIndex];
            if (!player || !courseData) {
                showNotification('Error', 'Could not load player data');
                return;
            }
            
            // Check if already signed
            const existingSignature = isScorecardSigned(playerName);
            if (existingSignature) {
                showSignedScorecardInfo(playerName, existingSignature);
                return;
            }
            
            // Calculate scores
            const scores = player.scores || [];
            const holesPlayed = scores.filter(s => s > 0).length;
            const grossTotal = scores.reduce((sum, s) => sum + (s || 0), 0);
            const toPar = grossTotal - courseData.totalPar;
            const toParText = grossTotal === 0 ? '-' : (toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar));
            
            // Calculate net score
            let netTotal = 0;
            for (let i = 0; i < 18; i++) {
                const score = scores[i] || 0;
                if (score > 0) {
                    const hole = courseData.holes[i];
                    netTotal += getNetScore(score, handicap, hole.handicap, 'full');
                }
            }
            const netToPar = netTotal - courseData.totalPar;
            const netToParText = netTotal === 0 ? '-' : (netToPar === 0 ? 'E' : (netToPar > 0 ? `+${netToPar}` : netToPar));
            
            // Calculate GHIN posting score (Net Double Bogey adjusted) - Front 9, Back 9, Total
            let ghinFront9 = 0;
            let ghinBack9 = 0;
            let adjustedHoles = [];
            for (let i = 0; i < 18; i++) {
                const score = scores[i] || 0;
                if (score > 0) {
                    const hole = courseData.holes[i];
                    let strokesReceived = 0;
                    if (handicap > 0) {
                        if (hole.handicap <= handicap) strokesReceived = 1;
                        if (hole.handicap <= handicap - 18) strokesReceived = 2;
                    } else if (handicap < 0) {
                        if (hole.handicap <= Math.abs(handicap)) strokesReceived = -1;
                    }
                    const maxScore = hole.par + 2 + strokesReceived;
                    const adjustedScore = Math.min(score, maxScore);
                    if (adjustedScore < score) {
                        adjustedHoles.push(hole.number);
                    }
                    if (i < 9) {
                        ghinFront9 += adjustedScore;
                    } else {
                        ghinBack9 += adjustedScore;
                    }
                }
            }
            const ghinTotal = ghinFront9 + ghinBack9;
            
            // Build adjusted holes note
            const adjustedNote = adjustedHoles.length > 0 
                ? `<p style="color: #a51c30; font-size: 11px; margin: 8px 0 0 0;">⚠️ Adjusted holes: ${adjustedHoles.join(', ')} (Net Double Bogey cap)</p>`
                : `<p style="color: #166534; font-size: 11px; margin: 8px 0 0 0;">✓ No adjustments needed</p>`;
            
            // Check if this player is linked for tracking
            const trackingLink = isPlayerLinkedForTracking(playerName);
            const isLinked = !!trackingLink;
            const trackedName = trackingLink ? trackingLink.trackedName : null;
            
            const modal = document.createElement('div');
            modal.id = 'signScorecardModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.85); z-index: 10002;
                display: flex; align-items: center; justify-content: center; padding: 20px;
                overflow-y: auto;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 6px; padding: 24px; max-width: 340px; width: 100%; margin: auto;">
                    <div style="text-align: center; margin-bottom: 16px;">
                        <div style="font-size: 36px; margin-bottom: 8px;">✍️</div>
                        <h2 style="color: #1e3a5f; font-size: 18px; margin: 0;">Sign Scorecard</h2>
                        <p style="color: #64748b; font-size: 13px; margin: 4px 0 0 0;">${playerName}</p>
                    </div>
                    
                    <!-- Score Summary -->
                    <div style="background: #f8fafc; border-radius: 4px; padding: 16px; margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span style="color: #64748b; font-weight: 600;">Gross Score</span>
                            <span style="color: #1e293b; font-weight: 700;">${grossTotal > 0 ? grossTotal : '-'} (${toParText})</span>
                        </div>
                        ${handicap !== 0 ? `
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span style="color: #64748b; font-weight: 600;">Net Score</span>
                            <span style="color: #1e293b; font-weight: 700;">${netTotal > 0 ? netTotal : '-'} (${netToParText})</span>
                        </div>
                        ` : ''}
                        <div style="display: flex; justify-content: space-between; padding-top: 8px; border-top: 1px solid #e2e8f0;">
                            <span style="color: #64748b; font-weight: 600;">Holes Played</span>
                            <span style="color: #1e293b; font-weight: 700;">${holesPlayed}</span>
                        </div>
                    </div>
                    
                    <!-- Save Stats Option (only if linked) -->
                    ${isLinked ? `
                    <div style="background: #f0fdf4; border: 1px solid #86efac; border-radius: 4px; padding: 12px; margin-bottom: 16px;">
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                            <input type="checkbox" id="saveStatsCheckbox" checked style="width: 20px; height: 20px; cursor: pointer;">
                            <div>
                                <div style="font-weight: 600; color: #166534; font-size: 14px;">Save to Stats History</div>
                                <div style="font-size: 12px; color: #15803d;">Linked to: ${trackedName}</div>
                            </div>
                        </label>
                    </div>
                    ` : ''}
                    
                    <!-- GHIN Posting Scores -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-size: 13px; font-weight: 600; color: #475569; margin-bottom: 8px;">GHIN Posting Scores (optional)</label>
                        <p style="font-size: 11px; color: #64748b; margin: 0 0 10px 0;">Net Double Bogey adjusted - edit if needed</p>
                        <div style="display: flex; gap: 8px;">
                            <div style="flex: 1; text-align: center;">
                                <label style="display: block; font-size: 11px; color: #64748b; margin-bottom: 4px;">Front 9</label>
                                <input type="number" id="ghinFront9Input" value="${ghinFront9 > 0 ? ghinFront9 : ''}" placeholder="-"
                                    style="width: 100%; padding: 10px; border: 1.5px solid #e2e8f0; border-radius: 4px; font-size: 16px; text-align: center; box-sizing: border-box;"
                                    onchange="updateGhinTotal()">
                            </div>
                            <div style="flex: 1; text-align: center;">
                                <label style="display: block; font-size: 11px; color: #64748b; margin-bottom: 4px;">Back 9</label>
                                <input type="number" id="ghinBack9Input" value="${ghinBack9 > 0 ? ghinBack9 : ''}" placeholder="-"
                                    style="width: 100%; padding: 10px; border: 1.5px solid #e2e8f0; border-radius: 4px; font-size: 16px; text-align: center; box-sizing: border-box;"
                                    onchange="updateGhinTotal()">
                            </div>
                            <div style="flex: 1; text-align: center;">
                                <label style="display: block; font-size: 11px; color: #64748b; margin-bottom: 4px;">Total</label>
                                <input type="number" id="ghinTotalInput" value="${ghinTotal > 0 ? ghinTotal : ''}" placeholder="-"
                                    style="width: 100%; padding: 10px; border: 1.5px solid #1e3a5f; border-radius: 4px; font-size: 16px; text-align: center; box-sizing: border-box; background: #eff6ff; font-weight: 700;" readonly>
                            </div>
                        </div>
                        ${adjustedNote}
                    </div>
                    
                    <!-- Action Buttons -->
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="proceedToSignature('${playerName.replace(/'/g, "\\'")}', ${playerIndex}, ${isLinked})" 
                            style="padding: 14px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Sign Scorecard
                        </button>
                        <button onclick="closeSignScorecardModal()" 
                            style="padding: 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.onclick = (e) => { if (e.target === modal) closeSignScorecardModal(); };
        }
        
        // Close the sign scorecard modal
        function closeSignScorecardModal() {
            document.getElementById('signScorecardModal')?.remove();
        }
        
        // Update GHIN total when front/back change
        function updateGhinTotal() {
            const front9 = parseInt(document.getElementById('ghinFront9Input')?.value) || 0;
            const back9 = parseInt(document.getElementById('ghinBack9Input')?.value) || 0;
            const totalInput = document.getElementById('ghinTotalInput');
            if (totalInput) {
                totalInput.value = (front9 + back9) > 0 ? (front9 + back9) : '';
            }
        }
        
        // Proceed to signature input
        function proceedToSignature(playerName, playerIndex, isLinked) {
            const ghinFront9 = document.getElementById('ghinFront9Input')?.value || null;
            const ghinBack9 = document.getElementById('ghinBack9Input')?.value || null;
            const ghinTotal = document.getElementById('ghinTotalInput')?.value || null;
            const saveStats = isLinked && document.getElementById('saveStatsCheckbox')?.checked;
            
            // Store in global for completeSignature to access
            window.pendingSignature = {
                playerName,
                playerIndex,
                saveStats,
                ghinScores: { front9: ghinFront9, back9: ghinBack9, total: ghinTotal }
            };
            
            // Show signature input
            const modal = document.getElementById('signScorecardModal');
            if (!modal) return;
            
            modal.querySelector('div').innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 24px; max-width: 340px; width: 100%;">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <div style="font-size: 36px; margin-bottom: 8px;">✍️</div>
                        <h2 style="color: #1e3a5f; font-size: 18px; margin: 0;">Sign Your Name</h2>
                        <p style="color: #64748b; font-size: 13px; margin: 4px 0 0 0;">Signing for ${playerName}</p>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-size: 13px; font-weight: 600; color: #475569; margin-bottom: 6px;">First Name</label>
                        <input type="text" id="signFirstName" placeholder="First name" autocomplete="given-name"
                            style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; box-sizing: border-box; margin-bottom: 10px;">
                        <label style="display: block; font-size: 13px; font-weight: 600; color: #475569; margin-bottom: 6px;">Last Name</label>
                        <input type="text" id="signLastName" placeholder="Last name" autocomplete="family-name"
                            style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; box-sizing: border-box;">
                    </div>
                    
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="completeSignature()" 
                            style="padding: 14px; background: #166534; color: white; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            ✓ Complete Signature
                        </button>
                        <button onclick="closeSignScorecardModal()" 
                            style="padding: 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            // Focus first name input
            setTimeout(() => document.getElementById('signFirstName')?.focus(), 100);
        }
        
        // Complete the signature
        function completeSignature() {
            if (!window.pendingSignature) {
                showNotification('Error', 'Signature data not found');
                return;
            }
            
            const { playerName, playerIndex, saveStats, ghinScores } = window.pendingSignature;
            const firstName = document.getElementById('signFirstName')?.value.trim();
            const lastName = document.getElementById('signLastName')?.value.trim();
            
            if (!firstName || !lastName) {
                showNotification('Name Required', 'Please enter your first and last name');
                return;
            }
            
            const signedBy = `${firstName} ${lastName}`;
            const player = tournamentData.players[playerIndex];
            
            // Save the signature
            const signed = getSignedScorecards();
            signed[playerName] = {
                signedBy: signedBy,
                signedAt: new Date().toISOString(),
                ghinFront9: ghinScores.front9 ? parseInt(ghinScores.front9) : null,
                ghinBack9: ghinScores.back9 ? parseInt(ghinScores.back9) : null,
                ghinTotal: ghinScores.total ? parseInt(ghinScores.total) : null,
                grossScore: player.scores.reduce((sum, s) => sum + (s || 0), 0),
                holesPlayed: player.scores.filter(s => s > 0).length
            };
            saveSignedScorecards(signed);
            
            // Save stats if opted in
            if (saveStats) {
                savePlayerStatsToHistory(playerName, playerIndex);
            }
            
            // Clear pending signature
            window.pendingSignature = null;
            
            closeSignScorecardModal();
            showNotification('Scorecard Signed', `Signed by ${signedBy}`);
            
            // Re-render to show signed status
            if (currentView === 'hole') {
                renderHoleView();
            } else {
                renderCompactPlayerView(getPlayersToShow());
            }
            
            // Also update leaderboard if on results page
            updateResultsDisplay();
        }
        
        // Save a specific player's stats to history (for linked players)
        function savePlayerStatsToHistory(playerName, playerIndex) {
            const player = tournamentData.players[playerIndex];
            if (!player) return;
            
            const trackingLink = isPlayerLinkedForTracking(playerName);
            if (!trackingLink) return;
            
            const trackedName = trackingLink.trackedName;
            const history = getStatsHistory();
            
            // Create unique ID for this round + tracked player
            const roundId = `${activeTournamentId || 'local'}_${trackedName}_${tournamentData.date || new Date().toISOString().split('T')[0]}`;
            
            const stats = playerStats[playerName] || {
                putts: new Array(18).fill(null),
                dots: new Array(18).fill(null),
                fir: new Array(18).fill(null),
                gir: new Array(18).fill(null)
            };
            
            const totals = getPlayerStatTotals(playerName);
            const totalScore = player.scores ? player.scores.reduce((sum, s) => sum + (s || 0), 0) : 0;
            const holesPlayed = player.scores ? player.scores.filter(s => s > 0).length : 0;
            
            const roundStats = {
                id: roundId,
                date: tournamentData.date || new Date().toISOString().split('T')[0],
                course: tournamentData.course || 'Unknown',
                courseName: getCourseDisplayName(tournamentData.course),
                gameType: tournamentData.gameType || 'Stroke Play',
                tournamentName: tournamentData.name || 'Round',
                savedAt: Date.now(),
                playerName: trackedName, // The tracked identity name
                tournamentPlayerName: playerName, // The name in the tournament
                scores: [...(player.scores || [])],
                pars: courseData && courseData.pars ? [...courseData.pars] : null, // Store pars for par average calculations
                handicap: player.handicap || 0,
                handicapIndex: player.handicapIndex || null,
                totalScore: totalScore,
                holesPlayed: holesPlayed,
                putts: [...stats.putts],
                dots: [...stats.dots],
                fir: [...stats.fir],
                gir: [...stats.gir],
                totals: totals
            };
            
            // Remove existing entry for same round ID if present (allows re-signing to update)
            const filteredHistory = history.filter(h => h.id !== roundId);
            
            // Add new entry at the beginning
            filteredHistory.unshift(roundStats);
            
            // Keep only last N rounds
            const trimmedHistory = filteredHistory.slice(0, MAX_STATS_HISTORY);
            
            saveStatsHistory(trimmedHistory);
            console.log('✅ Player stats saved to history:', roundId, trackedName);
        }
        
        // Show info about already-signed scorecard
        function showSignedScorecardInfo(playerName, signature) {
            const signedDate = new Date(signature.signedAt);
            const formattedDate = signedDate.toLocaleDateString() + ' ' + signedDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            
            // Build GHIN display - support both old format (ghinPostingScore) and new format (ghinFront9/Back9/Total)
            let ghinDisplay = '';
            if (signature.ghinTotal || signature.ghinFront9 || signature.ghinBack9) {
                ghinDisplay = `
                    <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #bbf7d0;">
                        <span style="color: #64748b; font-size: 12px;">GHIN Posting Scores</span>
                        <div style="display: flex; justify-content: space-between; margin-top: 4px;">
                            <div style="text-align: center;">
                                <div style="font-size: 10px; color: #64748b;">Front</div>
                                <div style="color: #166534; font-weight: 600;">${signature.ghinFront9 || '-'}</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 10px; color: #64748b;">Back</div>
                                <div style="color: #166534; font-weight: 600;">${signature.ghinBack9 || '-'}</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 10px; color: #64748b;">Total</div>
                                <div style="color: #166534; font-weight: 700;">${signature.ghinTotal || '-'}</div>
                            </div>
                        </div>
                    </div>
                `;
            } else if (signature.ghinPostingScore) {
                // Old format fallback
                ghinDisplay = `
                    <div style="margin-top: 8px;">
                        <span style="color: #64748b; font-size: 12px;">GHIN Posting Score</span>
                        <div style="color: #166534; font-weight: 600;">${signature.ghinPostingScore}</div>
                    </div>
                `;
            }
            
            const modal = document.createElement('div');
            modal.id = 'signedInfoModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.85); z-index: 10002;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 24px; max-width: 320px; width: 100%; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 12px;">✓</div>
                    <h2 style="color: #166534; font-size: 18px; margin: 0 0 8px 0;">Scorecard Signed</h2>
                    <p style="color: #1e293b; font-size: 15px; font-weight: 600; margin: 0 0 4px 0;">${playerName}</p>
                    
                    <div style="background: #f0fdf4; border-radius: 6px; padding: 16px; margin: 16px 0; text-align: left;">
                        <div style="margin-bottom: 8px;">
                            <span style="color: #64748b; font-size: 12px;">Signed by</span>
                            <div style="color: #166534; font-weight: 600;">${signature.signedBy}</div>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <span style="color: #64748b; font-size: 12px;">Date & Time</span>
                            <div style="color: #166534; font-weight: 600;">${formattedDate}</div>
                        </div>
                        <div>
                            <span style="color: #64748b; font-size: 12px;">Gross Score</span>
                            <div style="color: #166534; font-weight: 600;">${signature.grossScore} (${signature.holesPlayed} holes)</div>
                        </div>
                        ${ghinDisplay}
                    </div>
                    
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="confirmUnsignScorecard('${playerName.replace(/'/g, "\\'")}')" 
                            style="padding: 12px; background: #fee2e2; color: #a51c30; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Unsign Scorecard
                        </button>
                        <button onclick="document.getElementById('signedInfoModal')?.remove()" 
                            style="padding: 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Close
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
        }
        
        // Confirm unsign scorecard
        function confirmUnsignScorecard(playerName) {
            document.getElementById('signedInfoModal')?.remove();
            
            const modal = document.createElement('div');
            modal.id = 'unsignConfirmModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.85); z-index: 10003;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 24px; max-width: 300px; width: 100%; text-align: center;">
                    <div style="font-size: 36px; margin-bottom: 12px;">⚠️</div>
                    <h2 style="color: #a51c30; font-size: 16px; margin: 0 0 8px 0;">Unsign Scorecard?</h2>
                    <p style="color: #64748b; font-size: 13px; margin: 0 0 20px 0;">This will unlock the scorecard for editing. Stats will remain in history and can be updated when re-signed.</p>
                    
                    <div style="display: flex; gap: 10px;">
                        <button onclick="document.getElementById('unsignConfirmModal')?.remove()" 
                            style="flex: 1; padding: 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                        <button onclick="unsignScorecard('${playerName.replace(/'/g, "\\'")}')" 
                            style="flex: 1; padding: 12px; background: #a51c30; color: white; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Unsign
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Unsign a scorecard
        function unsignScorecard(playerName) {
            document.getElementById('unsignConfirmModal')?.remove();
            
            const signed = getSignedScorecards();
            delete signed[playerName];
            saveSignedScorecards(signed);
            
            showNotification('Unsigned', `${playerName}'s scorecard is now editable`);
            
            // Re-render
            if (currentView === 'hole') {
                renderHoleView();
            } else {
                renderCompactPlayerView(getPlayersToShow());
            }
            updateResultsDisplay();
        }

        // Wrapper to open stats history from profile
        function openStatsHistoryFromProfile() {
            console.log('📊 Opening stats history from profile...');
            console.log('📊 golfIdentityData:', golfIdentityData);
            showStatsHistoryModal();
        }

        // Show stats history modal
        function showStatsHistoryModal(playerName = null, dateFilter = 'all') {
            console.log('🔍 showStatsHistoryModal called, playerName:', playerName, 'dateFilter:', dateFilter);
            
            // Remove any existing stats modal first
            const existingModal = document.getElementById('statsHistoryModal');
            if (existingModal) {
                console.log('🗑️ Removing existing stats modal');
                existingModal.remove();
            }
            
            const history = getStatsHistory();
            console.log('📈 Stats history loaded, entries:', history.length);
            console.log('📈 golfIdentityData at modal time:', golfIdentityData);
            
            // Create modal
            const modal = document.createElement('div');
            modal.id = 'statsHistoryModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.85); z-index: 10005;
                display: flex; align-items: center; justify-content: center;
                padding: 20px;
            `;
            
            // Check if user has no tracked players set up
            if (!golfIdentityData || !golfIdentityData.trackedPlayers || golfIdentityData.trackedPlayers.length === 0) {
                console.log('⚠️ No golf identity or tracked players');
                modal.innerHTML = `
                    <div style="background: white; border-radius: 6px; padding: 24px; max-width: 400px; width: 100%; text-align: center;">
                        <h3 style="margin: 0 0 16px 0; color: #1e3a5f;">📊 Stats History</h3>
                        <div style="font-size: 48px; margin-bottom: 12px;">⛳</div>
                        <p style="color: #1e293b; font-weight: 600; margin-bottom: 8px;">Set Up Your Golf Identity</p>
                        <p style="color: #64748b; margin-bottom: 20px; font-size: 14px;">To track your stats, first set up your Golf Identity in your Account settings.</p>
                        <button onclick="document.getElementById('statsHistoryModal').remove();" 
                            style="padding: 12px 24px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; margin-bottom: 8px; width: 100%;">
                            ⛳ Set Up Golf Identity
                        </button>
                        <button onclick="document.getElementById('statsHistoryModal').remove()" 
                            style="padding: 10px 24px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; width: 100%;">
                            Close
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);
                console.log('✅ Modal appended (no identity)');
                return;
            }
            
            // Get unique players from history
            const allPlayersInHistory = new Set();
            history.forEach(round => {
                // Handle old format (round.players object) and new format (round.playerName string)
                if (round.players && typeof round.players === 'object') {
                    Object.keys(round.players).forEach(name => allPlayersInHistory.add(name));
                }
                if (round.playerName) {
                    allPlayersInHistory.add(round.playerName);
                }
            });
            
            // Only show tracked players - stats are private
            let playersToShow = new Set();
            
            if (golfIdentityData && golfIdentityData.trackedPlayers && golfIdentityData.trackedPlayers.length > 0) {
                // Only show players that are in BOTH tracked list AND history
                for (const tracked of golfIdentityData.trackedPlayers) {
                    // Check exact match
                    if (allPlayersInHistory.has(tracked.name)) {
                        playersToShow.add(tracked.name);
                    }
                    // Also check aliases for primary player
                    if (tracked.isPrimary && golfIdentityData.aliases) {
                        for (const alias of golfIdentityData.aliases) {
                            if (allPlayersInHistory.has(alias)) {
                                playersToShow.add(alias);
                            }
                        }
                    }
                }
                // Also check the main identity name
                if (golfIdentityData.name && allPlayersInHistory.has(golfIdentityData.name)) {
                    playersToShow.add(golfIdentityData.name);
                }
            }
            // No fallback - if no tracked players, show empty state
            
            // If no player specified, use first tracked player or primary identity
            if (!playerName && playersToShow.size > 0) {
                // Try to use primary identity first
                if (golfIdentityData && golfIdentityData.name && playersToShow.has(golfIdentityData.name)) {
                    playerName = golfIdentityData.name;
                } else if (golfIdentityData && golfIdentityData.trackedPlayers) {
                    // Try primary tracked player
                    const primary = golfIdentityData.trackedPlayers.find(p => p.isPrimary);
                    if (primary && playersToShow.has(primary.name)) {
                        playerName = primary.name;
                    }
                }
                // Fallback to first player
                if (!playerName) {
                    playerName = Array.from(playersToShow)[0];
                }
            }
            
            // Check if no stats found for tracked players
            if (playersToShow.size === 0) {
                console.log('⚠️ No stats for tracked players');
                modal.innerHTML = `
                    <div style="background: white; border-radius: 6px; padding: 24px; max-width: 400px; width: 100%; text-align: center;">
                        <h3 style="margin: 0 0 16px 0; color: #1e3a5f;">📊 Stats History</h3>
                        <div style="font-size: 48px; margin-bottom: 12px;">🏌️</div>
                        <p style="color: #1e293b; font-weight: 600; margin-bottom: 8px;">No Stats Yet</p>
                        <p style="color: #64748b; margin-bottom: 20px; font-size: 14px;">Play some rounds with stat tracking enabled to see your history here!</p>
                        <button onclick="document.getElementById('statsHistoryModal').remove()" 
                            style="padding: 12px 24px; background: #1e3a5f; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
                            Got It
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);
                console.log('✅ Modal appended (no stats)');
                return;
            }
            
            // Store current filter state for updates
            window.statsHistoryDateFilter = dateFilter;
            
            const stats = getPlayerAggregateStats(playerName, dateFilter);
            
            // Player selector dropdown - only tracked players
            const playerOptions = Array.from(playersToShow).map(name => {
                const isPrimary = golfIdentityData?.trackedPlayers?.find(p => p.name === name && p.isPrimary);
                const label = isPrimary ? `⭐ ${name} (Me)` : name;
                return `<option value="${name}" ${name === playerName ? 'selected' : ''}>${label}</option>`;
            }).join('');
            
            // Date filter options
            const dateFilters = [
                { value: 'all', label: 'All Time' },
                { value: '7d', label: 'Last 7 Days' },
                { value: '30d', label: 'Last 30 Days' },
                { value: '90d', label: 'Last 90 Days' },
                { value: 'ytd', label: 'This Year' }
            ];
            const dateFilterOptions = dateFilters.map(f => 
                `<option value="${f.value}" ${f.value === dateFilter ? 'selected' : ''}>${f.label}</option>`
            ).join('');
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; max-width: 500px; width: 100%; max-height: 85vh; overflow-y: auto;">
                    <div style="padding: 20px; border-bottom: 1px solid #e2e8f0; position: sticky; top: 0; background: white; border-radius: 8px 8px 0 0; z-index: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <h3 style="margin: 0; color: #1e3a5f;">📊 Stats History</h3>
                            <button onclick="document.getElementById('statsHistoryModal').remove()" 
                                style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">×</button>
                        </div>
                        
                        <!-- Tabs -->
                        <div style="display: flex; gap: 4px; margin-bottom: 12px; background: #f3f4f6; border-radius: 6px; padding: 4px;">
                            <button type="button" id="statsTabOverview" onclick="switchStatsTab('overview')" 
                                style="flex: 1; padding: 8px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-size: 12px; font-weight: 600; cursor: pointer;">
                                Overview
                            </button>
                            <button type="button" id="statsTabCourse" onclick="switchStatsTab('course')" 
                                style="flex: 1; padding: 8px; background: transparent; color: #64748b; border: none; border-radius: 4px; font-size: 12px; font-weight: 600; cursor: pointer;">
                                By Course
                            </button>
                        </div>
                        
                        <!-- Filters (shown for Overview tab) -->
                        <div id="statsOverviewFilters" style="display: flex; gap: 8px;">
                            <select id="statsPlayerSelect" onchange="updateStatsHistoryPlayer(this.value)" 
                                style="flex: 1; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; color: #1e3a5f;">
                                ${playerOptions}
                            </select>
                            <select id="statsDateFilter" onchange="updateStatsHistoryDateFilter(this.value)" 
                                style="flex: 1; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; color: #64748b;">
                                ${dateFilterOptions}
                            </select>
                        </div>
                        
                        <!-- Course selector (shown for Course tab) -->
                        <div id="statsCourseFilters" style="display: none;">
                            <select id="statsCourseSelect" onchange="updateCourseHistoryView(this.value)" 
                                style="width: 100%; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; color: #1e3a5f;">
                                ${getCourseOptions(playerName)}
                            </select>
                        </div>
                    </div>
                    
                    <div id="statsHistoryContent" style="padding: 20px;">
                        ${renderStatsHistoryContent(playerName, stats)}
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
        }
        
        // Update stats history when player selection changes
        function updateStatsHistoryPlayer(playerName) {
            const dateFilter = window.statsHistoryDateFilter || 'all';
            const stats = getPlayerAggregateStats(playerName, dateFilter);
            const content = document.getElementById('statsHistoryContent');
            if (content) {
                content.innerHTML = renderStatsHistoryContent(playerName, stats);
            }
        }
        
        // Update stats history when date filter changes
        function updateStatsHistoryDateFilter(dateFilter) {
            window.statsHistoryDateFilter = dateFilter;
            const playerSelect = document.getElementById('statsPlayerSelect');
            const playerName = playerSelect ? playerSelect.value : null;
            if (playerName) {
                const stats = getPlayerAggregateStats(playerName, dateFilter);
                const content = document.getElementById('statsHistoryContent');
                if (content) {
                    content.innerHTML = renderStatsHistoryContent(playerName, stats);
                }
            }
        }
        
        // Helper function to color par averages
        function getParAvgColor(avg, par) {
            if (avg === '--') return '#64748b';
            const numAvg = parseFloat(avg);
            if (isNaN(numAvg)) return '#64748b';
            if (numAvg < par) return '#166534'; // Under par - green
            if (numAvg <= par + 1) return '#1e3a5f'; // Par to bogey - navy
            return '#a51c30'; // Over bogey - red
        }
        
        // Render stats history content
        function renderStatsHistoryContent(playerName, stats) {
            if (stats.totalRounds === 0) {
                return `<p style="text-align: center; color: #64748b;">No rounds found for ${playerName}</p>`;
            }
            
            // Best rounds HTML
            let bestRoundsHtml = '';
            if (stats.bestRounds && stats.bestRounds.length > 0) {
                stats.bestRounds.forEach((round, idx) => {
                    const medal = idx === 0 ? '🥇' : idx === 1 ? '🥈' : '🥉';
                    bestRoundsHtml += `
                        <div style="display: flex; align-items: center; gap: 10px; padding: 8px 0; ${idx < stats.bestRounds.length - 1 ? 'border-bottom: 1px solid #f1f5f9;' : ''}">
                            <span style="font-size: 18px;">${medal}</span>
                            <div style="flex: 1;">
                                <div style="font-weight: 600; color: #1e293b; font-size: 13px;">${round.course}</div>
                                <div style="font-size: 11px; color: #64748b;">${formatDate(round.date)}</div>
                            </div>
                            <div style="font-weight: 700; color: #166534; font-size: 18px;">${round.score}</div>
                        </div>
                    `;
                });
            } else {
                bestRoundsHtml = '<p style="text-align: center; color: #94a3b8; font-size: 12px;">Play 18-hole rounds to see your best scores</p>';
            }
            
            // Recent rounds HTML
            let roundsHtml = '';
            stats.rounds.forEach((round, idx) => {
                roundsHtml += `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; ${idx < stats.rounds.length - 1 ? 'border-bottom: 1px solid #f1f5f9;' : ''}">
                        <div>
                            <div style="font-weight: 600; color: #1e293b; font-size: 13px;">${round.course}</div>
                            <div style="font-size: 11px; color: #64748b;">${formatDate(round.date)}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-weight: 700; color: #1e3a5f; font-size: 16px;">${round.score}</div>
                            <div style="font-size: 10px; color: #94a3b8;">${round.holes} holes</div>
                        </div>
                    </div>
                `;
            });
            
            return `
                <!-- Aggregate Stats -->
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px;">
                    <div style="background: white; border: 2px solid #1e3a5f; border-radius: 6px; padding: 14px; text-align: center;">
                        <div style="font-size: 11px; color: #1e3a5f; font-weight: 600; margin-bottom: 4px;">Rounds</div>
                        <div style="font-size: 24px; font-weight: 700; color: #1e3a5f;">${stats.totalRounds}</div>
                    </div>
                    <div style="background: white; border: 2px solid #1e3a5f; border-radius: 6px; padding: 14px; text-align: center;">
                        <div style="font-size: 11px; color: #1e3a5f; font-weight: 600; margin-bottom: 4px;">Avg Score</div>
                        <div style="font-size: 24px; font-weight: 700; color: #1e3a5f;">${stats.avgScore}</div>
                    </div>
                    <div style="background: white; border: 2px solid #1e3a5f; border-radius: 6px; padding: 14px; text-align: center;">
                        <div style="font-size: 11px; color: #1e3a5f; font-weight: 600; margin-bottom: 4px;">Avg Putts</div>
                        <div style="font-size: 24px; font-weight: 700; color: #1e3a5f;">${stats.avgPutts}</div>
                    </div>
                </div>
                
                <!-- Par Averages -->
                <div style="background: #f8fafc; border-radius: 6px; padding: 16px; margin-bottom: 16px;">
                    <div style="font-weight: 600; color: #1e3a5f; margin-bottom: 12px; font-size: 14px;">Par Averages</div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                        <div style="text-align: center; background: white; padding: 12px; border-radius: 6px; border: 1px solid #e2e8f0;">
                            <div style="font-size: 11px; color: #64748b; margin-bottom: 4px;">Par 3s</div>
                            <div style="font-size: 20px; font-weight: 700; color: ${getParAvgColor(stats.par3Avg, 3)};">${stats.par3Avg}</div>
                        </div>
                        <div style="text-align: center; background: white; padding: 12px; border-radius: 6px; border: 1px solid #e2e8f0;">
                            <div style="font-size: 11px; color: #64748b; margin-bottom: 4px;">Par 4s</div>
                            <div style="font-size: 20px; font-weight: 700; color: ${getParAvgColor(stats.par4Avg, 4)};">${stats.par4Avg}</div>
                        </div>
                        <div style="text-align: center; background: white; padding: 12px; border-radius: 6px; border: 1px solid #e2e8f0;">
                            <div style="font-size: 11px; color: #64748b; margin-bottom: 4px;">Par 5s</div>
                            <div style="font-size: 20px; font-weight: 700; color: ${getParAvgColor(stats.par5Avg, 5)};">${stats.par5Avg}</div>
                        </div>
                    </div>
                </div>
                
                <!-- Performance Stats -->
                <div style="background: #f8fafc; border-radius: 6px; padding: 16px; margin-bottom: 16px;">
                    <div style="font-weight: 600; color: #1e3a5f; margin-bottom: 12px; font-size: 14px;">Performance</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: #64748b; font-size: 13px;">Putts/Hole:</span>
                            <span style="font-weight: 600; color: #1e3a5f;">${stats.puttsPerHole}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: #64748b; font-size: 13px;">FIR %:</span>
                            <span style="font-weight: 600; color: #1e3a5f;">${stats.firPct}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: #64748b; font-size: 13px;">GIR %:</span>
                            <span style="font-weight: 600; color: #1e3a5f;">${stats.girPct}</span>
                        </div>
                    </div>
                </div>
                
                <!-- Best Rounds -->
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; color: #1e3a5f; margin-bottom: 12px; font-size: 14px;">🏆 Best Rounds</div>
                    <div style="background: white; border: 1px solid #e2e8f0; border-radius: 6px; padding: 12px;">
                        ${bestRoundsHtml}
                    </div>
                </div>
                
                <!-- Recent Rounds -->
                <div>
                    <div style="font-weight: 600; color: #1e293b; margin-bottom: 12px; font-size: 14px;">Recent Rounds</div>
                    <div style="background: white; border: 1px solid #e2e8f0; border-radius: 6px; padding: 12px;">
                        ${roundsHtml || '<p style="text-align: center; color: #94a3b8; font-size: 13px;">No rounds yet</p>'}
                    </div>
                </div>
                
                <!-- Clear History Button -->
                <button onclick="confirmClearStatsHistory()" 
                    style="width: 100%; margin-top: 20px; padding: 12px; background: transparent; color: #a51c30; border: 1px solid #a51c30; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 13px;">
                    🗑️ Clear Stats History
                </button>
            `;
        }
        
        // Format date helper
        function formatDate(dateStr) {
            try {
                const date = new Date(dateStr + 'T00:00:00');
                return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            } catch {
                return dateStr;
            }
        }
        
        // Confirm clear stats history
        function confirmClearStatsHistory() {
            if (confirm('Are you sure you want to clear all stats history? This cannot be undone.')) {
                saveStatsHistory([]);
                document.getElementById('statsHistoryModal').remove();
                showNotification('Cleared', 'Stats history has been cleared');
            }
        }
        
        // Get unique courses from history for a player
        function getCourseOptions(playerName) {
            const history = getStatsHistory();
            const courses = new Map(); // course key -> display name
            
            history.forEach(round => {
                if (round.players && round.players[playerName]) {
                    const key = round.course || 'Unknown';
                    const displayName = round.courseName || getCourseDisplayName(key) || key;
                    if (!courses.has(key)) {
                        courses.set(key, displayName);
                    }
                }
            });
            
            if (courses.size === 0) {
                return '<option value="">No courses played</option>';
            }
            
            // Sort by display name
            const sorted = Array.from(courses.entries()).sort((a, b) => a[1].localeCompare(b[1]));
            return sorted.map(([key, name]) => `<option value="${key}">${name}</option>`).join('');
        }
        
        // Switch between stats tabs
        function switchStatsTab(tab) {
            const overviewBtn = document.getElementById('statsTabOverview');
            const courseBtn = document.getElementById('statsTabCourse');
            const overviewFilters = document.getElementById('statsOverviewFilters');
            const courseFilters = document.getElementById('statsCourseFilters');
            const content = document.getElementById('statsHistoryContent');
            
            if (tab === 'overview') {
                overviewBtn.style.background = '#1e3a5f';
                overviewBtn.style.color = 'white';
                courseBtn.style.background = 'transparent';
                courseBtn.style.color = '#64748b';
                overviewFilters.style.display = 'flex';
                courseFilters.style.display = 'none';
                
                // Render overview content
                const playerSelect = document.getElementById('statsPlayerSelect');
                const playerName = playerSelect ? playerSelect.value : null;
                const dateFilter = window.statsHistoryDateFilter || 'all';
                if (playerName) {
                    const stats = getPlayerAggregateStats(playerName, dateFilter);
                    content.innerHTML = renderStatsHistoryContent(playerName, stats);
                }
            } else {
                overviewBtn.style.background = 'transparent';
                overviewBtn.style.color = '#64748b';
                courseBtn.style.background = '#1e3a5f';
                courseBtn.style.color = 'white';
                overviewFilters.style.display = 'none';
                courseFilters.style.display = 'block';
                
                // Render course content
                const courseSelect = document.getElementById('statsCourseSelect');
                const courseKey = courseSelect ? courseSelect.value : null;
                if (courseKey) {
                    updateCourseHistoryView(courseKey);
                }
            }
        }
        
        // Update course history view
        function updateCourseHistoryView(courseKey) {
            const content = document.getElementById('statsHistoryContent');
            if (!content) return;
            
            const playerSelect = document.getElementById('statsPlayerSelect');
            const playerName = playerSelect ? playerSelect.value : null;
            
            content.innerHTML = renderCourseHistoryContent(courseKey, playerName);
        }
        
        // Render course history content
        function renderCourseHistoryContent(courseKey, playerName) {
            const history = getStatsHistory();
            
            // Get all rounds at this course for this player
            const courseRounds = history
                .filter(r => r.course === courseKey && r.players && r.players[playerName])
                .map(r => ({
                    date: r.date,
                    score: r.players[playerName].totalScore,
                    holes: r.players[playerName].holesPlayed || 18,
                    putts: r.players[playerName].totals?.putts || '--',
                    fir: r.players[playerName].totals?.fir || '--',
                    gir: r.players[playerName].totals?.gir || '--'
                }))
                .filter(r => r.score > 0);
            
            if (courseRounds.length === 0) {
                return `<p style="text-align: center; color: #64748b; padding: 40px;">No rounds recorded at this course</p>`;
            }
            
            // Calculate stats
            const fullRounds = courseRounds.filter(r => r.holes >= 18);
            const scores = fullRounds.map(r => r.score);
            const bestScore = scores.length > 0 ? Math.min(...scores) : '--';
            const avgScore = scores.length > 0 ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length) : '--';
            const worstScore = scores.length > 0 ? Math.max(...scores) : '--';
            
            // Get course display name
            const courseName = getCourseDisplayName(courseKey) || courseKey;
            
            // Build rounds list
            let roundsHtml = courseRounds.map((round, idx) => {
                const isBest = round.score === bestScore && round.holes >= 18;
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; ${idx < courseRounds.length - 1 ? 'border-bottom: 1px solid #f1f5f9;' : ''} ${isBest ? 'background: #f0fdf4;' : ''}">
                        <div>
                            <div style="font-weight: 600; color: #1e293b; font-size: 13px;">${formatDate(round.date)} ${isBest ? '🏆' : ''}</div>
                            <div style="font-size: 11px; color: #64748b;">${round.holes} holes</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-weight: 700; color: ${isBest ? '#166534' : '#1e3a5f'}; font-size: 18px;">${round.score}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            return `
                <!-- Course Name -->
                <div style="text-align: center; margin-bottom: 16px;">
                    <div style="font-size: 18px; font-weight: 700; color: #1e3a5f;">${courseName}</div>
                    <div style="font-size: 12px; color: #64748b;">${courseRounds.length} round${courseRounds.length > 1 ? 's' : ''} played</div>
                </div>
                
                <!-- Stats Summary -->
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px;">
                    <div style="background: #f0fdf4; border: 2px solid #166534; border-radius: 6px; padding: 14px; text-align: center;">
                        <div style="font-size: 10px; color: #166534; font-weight: 600; margin-bottom: 4px;">BEST</div>
                        <div style="font-size: 24px; font-weight: 700; color: #166534;">${bestScore}</div>
                    </div>
                    <div style="background: #f8fafc; border: 2px solid #64748b; border-radius: 6px; padding: 14px; text-align: center;">
                        <div style="font-size: 10px; color: #64748b; font-weight: 600; margin-bottom: 4px;">AVERAGE</div>
                        <div style="font-size: 24px; font-weight: 700; color: #374151;">${avgScore}</div>
                    </div>
                    <div style="background: #fef2f2; border: 2px solid #dc2626; border-radius: 6px; padding: 14px; text-align: center;">
                        <div style="font-size: 10px; color: #dc2626; font-weight: 600; margin-bottom: 4px;">WORST</div>
                        <div style="font-size: 24px; font-weight: 700; color: #dc2626;">${worstScore}</div>
                    </div>
                </div>
                
                <!-- Trend Chart (simple visual) -->
                ${scores.length >= 2 ? `
                    <div style="background: #f8fafc; border-radius: 6px; padding: 16px; margin-bottom: 16px;">
                        <div style="font-weight: 600; color: #1e3a5f; margin-bottom: 12px; font-size: 14px;">📈 Score Trend</div>
                        <div style="display: flex; align-items: end; gap: 4px; height: 60px;">
                            ${courseRounds.slice(-10).map((r, i) => {
                                const min = Math.min(...courseRounds.slice(-10).map(x => x.score));
                                const max = Math.max(...courseRounds.slice(-10).map(x => x.score));
                                const range = max - min || 1;
                                const height = 20 + ((max - r.score) / range) * 40;
                                const isBest = r.score === bestScore;
                                return `<div style="flex: 1; height: ${height}px; background: ${isBest ? '#166534' : '#1e3a5f'}; border-radius: 2px;" title="${r.score}"></div>`;
                            }).join('')}
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 4px;">
                            <span style="font-size: 9px; color: #94a3b8;">Older</span>
                            <span style="font-size: 9px; color: #94a3b8;">Recent</span>
                        </div>
                    </div>
                ` : ''}
                
                <!-- All Rounds -->
                <div>
                    <div style="font-weight: 600; color: #1e293b; margin-bottom: 12px; font-size: 14px;">All Rounds</div>
                    <div style="background: white; border: 1px solid #e2e8f0; border-radius: 6px; overflow: hidden;">
                        ${roundsHtml}
                    </div>
                </div>
            `;
        }
        
        // ==================== END STATS HISTORY ====================
        
        // Show stat popup for putts/dots (numeric input)
        function showStatPopup(playerName, statType, holeIndex) {
            initPlayerStats(playerName);
            const currentVal = playerStats[playerName][statType][holeIndex];
            
            const modal = document.createElement('div');
            modal.id = 'statPopupModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            const title = statType === 'putts' ? '⛳ Putts' : '<span style="color: #166534;">●</span> Dots';
            
            // Build buttons for 0-4
            let buttonsRow1 = '';
            for (let i = 0; i <= 4; i++) {
                const isSelected = currentVal === i;
                buttonsRow1 += `
                    <button onclick="setStatValue('${playerName}', '${statType}', ${holeIndex}, ${i})" 
                        style="width: 52px; height: 52px; border-radius: 6px; border: 2px solid ${isSelected ? '#1e3a5f' : '#e2e8f0'}; 
                        background: ${isSelected ? '#1e3a5f' : 'white'}; color: ${isSelected ? 'white' : '#1e293b'}; 
                        font-size: 22px; font-weight: 700; cursor: pointer;">${i}</button>
                `;
            }
            
            // Check if current value is 5+
            const isManualSelected = currentVal !== null && currentVal >= 5;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 24px; max-width: 340px; width: 90%; text-align: center;">
                    <h2 style="color: #1e3a5f; margin-bottom: 8px; font-size: 20px;">${title}</h2>
                    <p style="color: #64748b; font-size: 13px; margin-bottom: 16px;">Hole ${holeIndex + 1} • ${playerName}</p>
                    <div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 12px;">
                        ${buttonsRow1}
                    </div>
                    <div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 20px;">
                        <button onclick="showManualStatInput('${playerName}', '${statType}', ${holeIndex})" 
                            style="width: 80px; height: 52px; border-radius: 6px; border: 2px solid ${isManualSelected ? '#1e3a5f' : '#e2e8f0'}; 
                            background: ${isManualSelected ? '#1e3a5f' : 'white'}; color: ${isManualSelected ? 'white' : '#1e293b'}; 
                            font-size: 20px; font-weight: 700; cursor: pointer;">${isManualSelected ? currentVal : '#'}</button>
                    </div>
                    <div style="display: flex; gap: 12px;">
                        <button onclick="clearStatValue('${playerName}', '${statType}', ${holeIndex})" 
                            style="flex: 1; padding: 12px; background: #fee2e2; color: #a51c30; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Clear
                        </button>
                        <button onclick="closeStatPopup()" 
                            style="flex: 1; padding: 12px; background: #e2e8f0; color: #64748b; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeStatPopup();
            };
        }
        
        // Show manual input for stat values 5+
        function showManualStatInput(playerName, statType, holeIndex) {
            const currentVal = playerStats[playerName]?.[statType]?.[holeIndex];
            const defaultVal = currentVal >= 5 ? currentVal : 5;
            
            const input = prompt(`Enter ${statType} count:`, defaultVal);
            if (input !== null) {
                const val = parseInt(input);
                if (!isNaN(val) && val >= 0) {
                    setStatValue(playerName, statType, holeIndex, val);
                }
            }
        }
        
        // Set stat value and close popup
        function setStatValue(playerName, statType, holeIndex, value) {
            updatePlayerStat(playerName, statType, holeIndex, value);
            closeStatPopup();
            renderHoleView(); // Refresh the view
        }
        
        // Clear stat value
        function clearStatValue(playerName, statType, holeIndex) {
            updatePlayerStat(playerName, statType, holeIndex, null);
            closeStatPopup();
            renderHoleView();
        }
        
        // Close stat popup
        function closeStatPopup() {
            const modal = document.getElementById('statPopupModal');
            if (modal) modal.remove();
        }
        
        // Toggle boolean stat (FIR/GIR) - cycles through null -> true -> false -> null
        function toggleBooleanStat(playerName, statType, holeIndex) {
            initPlayerStats(playerName);
            const currentVal = playerStats[playerName][statType][holeIndex];
            
            let newVal;
            if (currentVal === null || currentVal === undefined) {
                newVal = true; // First tap = hit
            } else if (currentVal === true) {
                newVal = false; // Second tap = miss
            } else {
                newVal = null; // Third tap = clear
            }
            
            updatePlayerStat(playerName, statType, holeIndex, newVal);
            renderHoleView();
        }
        
        // ==================== JOIN CODE FUNCTIONS ====================
        
        // Generate a random join code (4 letters + 2 numbers, e.g., GOLF42)
        function generateJoinCode() {
            const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ'; // Excluded I and O to avoid confusion
            const numbers = '0123456789';
            
            let code = '';
            for (let i = 0; i < 4; i++) {
                code += letters.charAt(Math.floor(Math.random() * letters.length));
            }
            for (let i = 0; i < 2; i++) {
                code += numbers.charAt(Math.floor(Math.random() * numbers.length));
            }
            
            return code;
        }
        
        // Check if a join code is already in use
        async function isJoinCodeTaken(code) {
            try {
                const snapshot = await db.collection('tournaments')
                    .where('joinCode', '==', code.toUpperCase())
                    .limit(1)
                    .get();
                return !snapshot.empty;
            } catch (error) {
                console.error('Error checking join code:', error);
                return true; // Assume taken on error to be safe
            }
        }
        
        // Generate a unique join code (retry if taken)
        async function generateUniqueJoinCode() {
            let code = generateJoinCode();
            let attempts = 0;
            const maxAttempts = 10;
            
            while (await isJoinCodeTaken(code) && attempts < maxAttempts) {
                code = generateJoinCode();
                attempts++;
            }
            
            if (attempts >= maxAttempts) {
                console.warn('Could not generate unique code after max attempts, using timestamp fallback');
                code = generateJoinCode() + Date.now().toString().slice(-2);
            }
            
            return code;
        }
        
        // Generate host code for co-host access (6 alphanumeric characters)
        function generateHostCode() {
            // Generate host code in same format as join code: 4 letters + 2 numbers
            const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ'; // Excluded I and O to avoid confusion
            const numbers = '0123456789';
            
            let code = '';
            for (let i = 0; i < 4; i++) {
                code += letters.charAt(Math.floor(Math.random() * letters.length));
            }
            for (let i = 0; i < 2; i++) {
                code += numbers.charAt(Math.floor(Math.random() * numbers.length));
            }
            
            return code;
        }
        
        // Look up tournament by join code (supports both Let's Golf and IHMC codes)
        async function findTournamentByCode(code) {
            try {
                const normalizedCode = code.toUpperCase().trim();
                
                // Check if this is an IHMC code format: IHMC-MMDD-H### or IHMC-MMDD-P###
                if (isIHMCCodeFormat(normalizedCode)) {
                    return await findIHMCEventByCode(normalizedCode);
                }
                
                // Validate format: 4 letters + 2 numbers (standard Let's Golf code)
                if (!/^[A-Z]{4}[0-9]{2}$/.test(normalizedCode)) {
                    return { success: false, error: 'Invalid code format. Use 4 letters + 2 numbers (e.g., GOLF42) or IHMC code' };
                }
                
                const snapshot = await db.collection('tournaments')
                    .where('joinCode', '==', normalizedCode)
                    .limit(1)
                    .get();
                
                if (snapshot.empty) {
                    return { success: false, error: 'Tournament not found. Check the code and try again.' };
                }
                
                const tournamentDoc = snapshot.docs[0];
                const tournament = tournamentDoc.data();
                
                if (tournament.status === 'ended') {
                    return { success: false, error: 'This tournament has ended.' };
                }
                
                return { success: true, tournamentId: tournamentDoc.id, tournament: tournament };
            } catch (error) {
                console.error('Error finding tournament by code:', error);
                return { success: false, error: 'Failed to look up tournament. Please try again.' };
            }
        }
        
        // Check if code matches IHMC format: IHMC-MMDD-H### or IHMC-MMDD-P###
        function isIHMCCodeFormat(code) {
            return /^IHMC-\d{4}-[HP][A-Z0-9]{3}$/i.test(code.trim());
        }
        
        // Find IHMC event by code (queries IHMC Firebase)
        async function findIHMCEventByCode(code) {
            try {
                const normalizedCode = code.toUpperCase().trim();
                
                if (!window.ihmcDb) {
                    console.error('IHMC Firebase not initialized');
                    return { success: false, error: 'IHMC connection not available. Please try again.' };
                }
                
                // Determine if this is a host code or player code
                const isHostCode = normalizedCode.includes('-H');
                const codeField = isHostCode ? 'hostCode' : 'playerCode';
                
                console.log(`🔍 Searching IHMC events for ${codeField}: ${normalizedCode}`);
                
                const snapshot = await window.ihmcDb.collection('events')
                    .where(codeField, '==', normalizedCode)
                    .limit(1)
                    .get();
                
                if (snapshot.empty) {
                    return { success: false, error: 'IHMC event not found. Check the code and try again.' };
                }
                
                const eventDoc = snapshot.docs[0];
                const event = eventDoc.data();
                
                // Check if event date has passed (event is over)
                const eventDate = new Date(event.date + 'T23:59:59');
                const now = new Date();
                if (eventDate < now) {
                    return { success: false, error: 'This IHMC event has already ended.' };
                }
                
                console.log('✅ Found IHMC event:', event.name);
                
                // Log registered players if available
                if (event.registeredPlayers && event.registeredPlayers.length > 0) {
                    console.log(`📋 IHMC event has ${event.registeredPlayers.length} registered players with handicaps`);
                }
                
                // Return in a format compatible with Let's Golf tournament system
                return { 
                    success: true, 
                    tournamentId: null, // Will create new tournament
                    isIHMCEvent: true,
                    ihmcEventId: eventDoc.id,
                    ihmcEvent: event,
                    isHostCode: isHostCode,
                    tournament: {
                        name: event.name,
                        date: event.date,
                        format: event.format || 'Stroke Play',
                        teamSize: event.teamSize || 4,
                        scoringSettings: event.scoringSettings || { allowPlayerSelfJoin: true, allowGuestScoring: true },
                        ihmcEventId: eventDoc.id,
                        ihmcHostCode: event.hostCode,
                        ihmcPlayerCode: event.playerCode,
                        registeredPlayers: event.registeredPlayers || [] // Players with handicaps from IHMC
                    }
                };
            } catch (error) {
                console.error('Error finding IHMC event by code:', error);
                return { success: false, error: 'Failed to look up IHMC event. Please try again.' };
            }
        }
        
        // Validate join code format (4 letters + 2 numbers OR IHMC format)
        function isValidJoinCodeFormat(code) {
            const trimmed = code.trim();
            // Standard Let's Golf format: 4 letters + 2 numbers
            if (/^[A-Za-z]{4}[0-9]{2}$/.test(trimmed)) return true;
            // IHMC format: IHMC-MMDD-H### or IHMC-MMDD-P###
            if (/^IHMC-\d{4}-[HP][A-Za-z0-9]{3}$/i.test(trimmed)) return true;
            return false;
        }
        
        // Update join code for a tournament (host only)
        async function updateJoinCode(tournamentId, newCode) {
            try {
                const normalizedCode = newCode.toUpperCase().trim();
                
                // Validate format
                if (!isValidJoinCodeFormat(normalizedCode)) {
                    return { success: false, error: 'Invalid format. Use 4 letters + 2 numbers (e.g., GOLF42)' };
                }
                
                // Check if code is already taken by another tournament
                const snapshot = await db.collection('tournaments')
                    .where('joinCode', '==', normalizedCode)
                    .limit(1)
                    .get();
                
                if (!snapshot.empty && snapshot.docs[0].id !== tournamentId) {
                    return { success: false, error: 'This code is already in use. Try another.' };
                }
                
                // Update the tournament
                await db.collection('tournaments').doc(tournamentId).update({
                    joinCode: normalizedCode,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                return { success: true, code: normalizedCode };
            } catch (error) {
                console.error('Error updating join code:', error);
                return { success: false, error: 'Failed to update code. Please try again.' };
            }
        }
        
        // ==================== END JOIN CODE FUNCTIONS ====================
        
        // ==================== IHMC EVENT INTEGRATION ====================
        
        // Store current IHMC event data for reference
        let currentIHMCEvent = null;
        
        // Show IHMC event join screen
        function showIHMCJoinScreen(result) {
            currentIHMCEvent = result;
            const event = result.ihmcEvent;
            const isHost = result.isHostCode;
            
            // Format the date nicely
            const eventDate = new Date(event.date + 'T00:00:00');
            const dateStr = eventDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });
            
            // Create or update modal
            let modal = document.getElementById('ihmcJoinModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'ihmcJoinModal';
                modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 9999; padding: 20px;';
                document.body.appendChild(modal);
            }
            
            const roleLabel = isHost ? '🎯 Host Access' : '⛳ Player Access';
            const roleColor = isHost ? '#166534' : '#1e3a5f';
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 12px; max-width: 400px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
                    <!-- IHMC Header -->
                    <div style="background: linear-gradient(135deg, #1a3a2f 0%, #2d5a4a 100%); padding: 20px; border-radius: 12px 12px 0 0; text-align: center;">
                        <div style="font-size: 32px; margin-bottom: 8px;">🏌️‍♂️</div>
                        <div style="color: #c9a227; font-size: 12px; font-weight: 600; letter-spacing: 2px;">INDIAN HILLS MEN'S CLUB</div>
                    </div>
                    
                    <!-- Event Info -->
                    <div style="padding: 24px;">
                        <h2 style="color: #1a3a2f; font-size: 22px; margin-bottom: 8px; text-align: center;">${event.name}</h2>
                        <p style="color: #6b7280; text-align: center; margin-bottom: 16px;">${dateStr}</p>
                        
                        <!-- Role Badge -->
                        <div style="background: ${roleColor}15; border: 1px solid ${roleColor}40; border-radius: 8px; padding: 10px; text-align: center; margin-bottom: 20px;">
                            <span style="color: ${roleColor}; font-weight: 600;">${roleLabel}</span>
                        </div>
                        
                        <!-- Event Details -->
                        <div style="background: #f9fafb; border-radius: 8px; padding: 16px; margin-bottom: 20px;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 14px;">
                                <div><span style="color: #6b7280;">Format:</span> <strong>${event.format || 'Stroke Play'}</strong></div>
                                <div><span style="color: #6b7280;">Team Size:</span> <strong>${event.teamSize || 4}</strong></div>
                                <div><span style="color: #6b7280;">Time:</span> <strong>${event.time || 'TBD'}</strong></div>
                                <div><span style="color: #6b7280;">Entry:</span> <strong>$${event.entryFee || 0}</strong></div>
                            </div>
                        </div>
                        
                        <!-- Description if exists -->
                        ${event.description ? `<p style="color: #6b7280; font-size: 14px; margin-bottom: 20px; text-align: center; font-style: italic;">${event.description}</p>` : ''}
                        
                        <!-- Actions -->
                        <button onclick="startIHMCScoring()" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #1a3a2f 0%, #2d5a4a 100%); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 12px;">
                            ⛳ Start Scoring
                        </button>
                        
                        <button onclick="closeIHMCJoinModal()" style="width: 100%; padding: 12px; background: white; color: #6b7280; border: 1px solid #d1d5db; border-radius: 8px; font-size: 14px; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            modal.style.display = 'flex';
        }
        
        // Close IHMC join modal
        function closeIHMCJoinModal() {
            const modal = document.getElementById('ihmcJoinModal');
            if (modal) {
                modal.style.display = 'none';
            }
            currentIHMCEvent = null;
        }
        
        // Start scoring for IHMC event (goes to setup page with pre-filled info)
        function startIHMCScoring() {
            if (!currentIHMCEvent) {
                showNotification('Error', 'No IHMC event data found');
                return;
            }
            
            const event = currentIHMCEvent.ihmcEvent;
            const tournament = currentIHMCEvent.tournament;
            
            // Store IHMC event reference for later publishing
            localStorage.setItem('currentIHMCEvent', JSON.stringify({
                eventId: currentIHMCEvent.ihmcEventId,
                eventName: event.name,
                eventDate: event.date,
                hostCode: event.hostCode,
                playerCode: event.playerCode,
                isHostAccess: currentIHMCEvent.isHostCode
            }));
            
            // Close modal
            closeIHMCJoinModal();
            
            // Pre-select game type based on event format
            const formatMap = {
                'Stroke Play': 'Stroke Play',
                'Best Ball': 'Best Ball',
                'Scramble': 'Scramble',
                '2-Man Shamble': '2-Man Shamble',
                'Stableford': 'Stableford'
            };
            const gameTypeSelect = document.getElementById('gameType');
            if (gameTypeSelect && formatMap[event.format]) {
                gameTypeSelect.value = formatMap[event.format];
                // Trigger change event
                gameTypeSelect.dispatchEvent(new Event('change'));
            }
            
            // Set date
            const dateInput = document.getElementById('tournamentDate');
            if (dateInput && event.date) {
                dateInput.value = event.date;
            }
            
            // Set tournament name
            const nameInput = document.getElementById('tournamentName');
            if (nameInput && event.name) {
                nameInput.value = event.name;
            }
            
            // Go to setup page first so DOM is ready
            showPage('setupPage');
            
            // Pre-populate players from IHMC registered players
            const registeredPlayers = tournament?.registeredPlayers || event.registeredPlayers || [];
            if (registeredPlayers.length > 0) {
                console.log(`📋 Loading ${registeredPlayers.length} players from IHMC event`);
                
                // Small delay to ensure DOM is ready
                setTimeout(() => {
                    populatePlayersFromIHMC(registeredPlayers);
                    showNotification('IHMC Event Loaded', `${registeredPlayers.length} players loaded from ${event.name}`);
                }, 100);
            } else {
                showNotification('IHMC Event Loaded', `Ready to score: ${event.name}`);
            }
        }
        
        // Populate setup page with IHMC registered players
        function populatePlayersFromIHMC(registeredPlayers) {
            if (!registeredPlayers || registeredPlayers.length === 0) return;
            
            const playerList = document.getElementById('playerList');
            if (!playerList) return;
            
            // Clear existing player rows
            playerList.innerHTML = '';
            
            // Enable GHIN mode since IHMC sends handicap indexes
            const ghinCheckbox = document.getElementById('setupUseGhinCheckbox');
            if (ghinCheckbox) {
                ghinCheckbox.checked = true;
                toggleSetupGhinMode(true);
            }
            
            // Add each registered player
            registeredPlayers.forEach((player, index) => {
                const playerId = index + 1;
                const handicapValue = player.handicap || player.handicapIndex || 0;
                
                const wrapper = document.createElement('div');
                wrapper.className = 'player-row-wrapper';
                wrapper.innerHTML = `
                    <div class="player-row-delete" onclick="removePlayer(${playerId})">Delete</div>
                    <div class="player-row ghin-mode" data-player="${playerId}">
                        <input type="text" class="player-name-input" placeholder="Player Name" id="player${playerId}" value="${player.name || ''}">
                        <input type="text" class="player-hcp-input" placeholder="H.I." id="hcp${playerId}" value="${handicapValue}" pattern="-?[0-9.]*" inputmode="decimal" step="0.1" oninput="updateSetupCourseHcp(${playerId})">
                        <span class="player-course-hcp" id="courseHcp${playerId}" style="display: block;"></span>
                    </div>
                `;
                playerList.appendChild(wrapper);
            });
            
            // Update the global player count
            window.playerCount = registeredPlayers.length;
            window.nextPlayerId = registeredPlayers.length + 1;
            
            // Calculate course HCPs after a short delay (to let course/tee be selected)
            setTimeout(() => {
                updateAllSetupCourseHcps();
            }, 200);
            
            console.log(`✅ Populated ${registeredPlayers.length} players from IHMC`);
        }
        
        // Publish results to IHMC (called after round ends)
        async function publishResultsToIHMC() {
            const ihmcEventStr = localStorage.getItem('currentIHMCEvent');
            if (!ihmcEventStr) {
                showNotification('Error', 'No IHMC event linked to this round');
                return false;
            }
            
            const ihmcEvent = JSON.parse(ihmcEventStr);
            
            if (!window.ihmcDb) {
                showNotification('Error', 'IHMC connection not available');
                return false;
            }
            
            try {
                // Gather results data
                const results = {
                    eventId: ihmcEvent.eventId,
                    eventName: ihmcEvent.eventName,
                    eventDate: ihmcEvent.eventDate,
                    submittedAt: new Date().toISOString(),
                    submittedBy: deviceName || 'Unknown Device',
                    course: courseData?.name || document.getElementById('courseSelect')?.value || 'Unknown',
                    gameType: document.getElementById('gameType')?.value || 'Stroke Play',
                    players: tournamentData.players.map(p => ({
                        name: p.name,
                        handicap: p.handicap,
                        scores: p.scores || [],
                        totalGross: (p.scores || []).reduce((sum, s) => sum + (s || 0), 0),
                        totalNet: calculateNetScore(p)
                    })),
                    teams: tournamentData.teams || [],
                    letsgolfTournamentId: activeTournamentId || null
                };
                
                // Save to IHMC Firebase
                await window.ihmcDb.collection('tournamentResults').add(results);
                
                console.log('✅ Results published to IHMC:', results);
                showNotification('Published!', 'Results sent to IHMC');
                
                // Clear the IHMC event link
                localStorage.removeItem('currentIHMCEvent');
                
                return true;
            } catch (error) {
                console.error('Error publishing to IHMC:', error);
                showNotification('Error', 'Failed to publish results');
                return false;
            }
        }
        
        // Helper to calculate net score for a player
        function calculateNetScore(player) {
            if (!player.scores || !courseData) return 0;
            const gross = player.scores.reduce((sum, s) => sum + (s || 0), 0);
            // Simple net calculation - can be enhanced
            return gross - (player.handicap || 0);
        }
        
        // Check if current round is linked to IHMC event
        function isIHMCLinkedRound() {
            return !!localStorage.getItem('currentIHMCEvent');
        }
        
        // Get IHMC event info for display
        function getIHMCEventInfo() {
            const data = localStorage.getItem('currentIHMCEvent');
            return data ? JSON.parse(data) : null;
        }
        
        // Update IHMC banner visibility on results page
        function updateIHMCBanner() {
            const banner = document.getElementById('ihmcPublishBanner');
            const eventNameDisplay = document.getElementById('ihmcEventNameDisplay');
            
            if (!banner) return;
            
            const ihmcEvent = getIHMCEventInfo();
            
            if (ihmcEvent) {
                banner.style.display = 'block';
                if (eventNameDisplay) {
                    eventNameDisplay.textContent = ihmcEvent.eventName;
                }
            } else {
                banner.style.display = 'none';
            }
        }
        
        // Show publish confirmation modal
        function showPublishToIHMCModal() {
            const ihmcEvent = getIHMCEventInfo();
            if (!ihmcEvent) {
                showNotification('Error', 'No IHMC event linked');
                return;
            }
            
            // Calculate player stats for preview
            const playerStats = (tournamentData?.players || []).map(p => {
                const scores = p.scores || [];
                const completedHoles = scores.filter(s => s > 0).length;
                const gross = scores.reduce((sum, s) => sum + (s || 0), 0);
                return { name: p.name, handicap: p.handicap, completedHoles, gross };
            });
            
            let modal = document.getElementById('ihmcPublishModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'ihmcPublishModal';
                modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 9999; padding: 20px;';
                document.body.appendChild(modal);
            }
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 12px; max-width: 420px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
                    <!-- Header -->
                    <div style="background: linear-gradient(135deg, #1a3a2f 0%, #2d5a4a 100%); padding: 20px; border-radius: 12px 12px 0 0; text-align: center;">
                        <div style="color: #c9a227; font-size: 12px; font-weight: 600; letter-spacing: 2px; margin-bottom: 8px;">PUBLISH TO</div>
                        <div style="color: white; font-size: 20px; font-weight: 700;">Indian Hills Men's Club</div>
                    </div>
                    
                    <div style="padding: 24px;">
                        <!-- Event Info -->
                        <div style="background: #f9fafb; border-radius: 8px; padding: 16px; margin-bottom: 20px;">
                            <div style="font-size: 16px; font-weight: 600; color: #1a3a2f; margin-bottom: 4px;">${ihmcEvent.eventName}</div>
                            <div style="font-size: 13px; color: #6b7280;">${ihmcEvent.eventDate}</div>
                        </div>
                        
                        <!-- Players Preview -->
                        <div style="margin-bottom: 20px;">
                            <div style="font-size: 13px; font-weight: 600; color: #374151; margin-bottom: 8px;">Players to submit:</div>
                            <div style="max-height: 150px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 6px;">
                                ${playerStats.map((p, i) => `
                                    <div style="padding: 10px 12px; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: space-between; ${i === playerStats.length - 1 ? 'border-bottom: none;' : ''}">
                                        <span style="color: #374151;">${p.name} <span style="color: #9ca3af;">(${p.handicap})</span></span>
                                        <span style="font-weight: 600; color: ${p.completedHoles === 18 ? '#166534' : '#f59e0b'};">${p.completedHoles}/18 • ${p.gross || '-'}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <!-- Warning if incomplete -->
                        ${playerStats.some(p => p.completedHoles < 18) ? `
                            <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 6px; padding: 12px; margin-bottom: 20px;">
                                <span style="color: #92400e; font-size: 13px;">⚠️ Some players have incomplete scorecards. Results will be submitted as-is.</span>
                            </div>
                        ` : ''}
                        
                        <!-- Actions -->
                        <button onclick="executePublishToIHMC()" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #1a3a2f 0%, #2d5a4a 100%); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 12px;">
                            📤 Confirm & Publish
                        </button>
                        
                        <button onclick="closePublishToIHMCModal()" style="width: 100%; padding: 12px; background: white; color: #6b7280; border: 1px solid #d1d5db; border-radius: 8px; font-size: 14px; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            modal.style.display = 'flex';
        }
        
        // Close publish modal
        function closePublishToIHMCModal() {
            const modal = document.getElementById('ihmcPublishModal');
            if (modal) modal.style.display = 'none';
        }
        
        // Execute the publish action
        async function executePublishToIHMC() {
            const modal = document.getElementById('ihmcPublishModal');
            const btn = modal?.querySelector('button');
            
            if (btn) {
                btn.disabled = true;
                btn.innerHTML = '📤 Publishing...';
            }
            
            try {
                const success = await publishResultsToIHMC();
                
                if (success) {
                    closePublishToIHMCModal();
                    updateIHMCBanner(); // Hide banner after successful publish
                }
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = '📤 Confirm & Publish';
                }
            }
        }
        
        // ==================== END IHMC EVENT INTEGRATION ====================
        
        // Create a new cloud tournament
        async function createCloudTournament(tournamentConfig) {
            try {
                // Check if Firebase is loaded
                if (typeof firebase === 'undefined' || !db) {
                    console.error('Firebase not ready - firebase:', typeof firebase, 'db:', !!db);
                    throw new Error('Firebase is not loaded yet. Please wait a moment and try again.');
                }
                
                // Wait for authentication if not ready
                if (!currentUserId || !currentDeviceId) {
                    console.log('Waiting for Firebase authentication...');
                    console.log('currentUserId:', currentUserId, 'currentDeviceId:', currentDeviceId);
                    
                    await new Promise((resolve) => {
                        let attempts = 0;
                        const checkAuth = setInterval(() => {
                            attempts++;
                            console.log(`Auth check attempt ${attempts}:`, currentUserId, currentDeviceId);
                            if (currentUserId && currentDeviceId) {
                                console.log('Authentication successful!');
                                clearInterval(checkAuth);
                                resolve();
                            }
                        }, 100);
                        // Timeout after 10 seconds
                        setTimeout(() => {
                            console.log('Authentication timeout after 10 seconds');
                            clearInterval(checkAuth);
                            resolve();
                        }, 10000);
                    });
                }
                
                // If still not authenticated, throw error
                if (!currentUserId || !currentDeviceId) {
                    console.error('Auth failed - currentUserId:', currentUserId, 'currentDeviceId:', currentDeviceId);
                    throw new Error('Device authentication failed. Please refresh the page and try again.');
                }
                
                const tournamentId = 'T' + Date.now() + Math.random().toString(36).substr(2, 6);
                
                // Generate join code (4 letters + 2 numbers)
                const joinCode = await generateUniqueJoinCode();
                
                // Generate host code (6 alphanumeric characters for co-host access)
                const hostCode = generateHostCode();
                
                // Get course data to store with tournament - try multiple sources
                let tournamentCourseData = courses[tournamentConfig.course] || customCourses[tournamentConfig.course];
                
                // Fallback to global courseData if it matches
                if (!tournamentCourseData && courseData && courseData.holes) {
                    console.log('📍 Using global courseData for tournament');
                    tournamentCourseData = courseData;
                }
                
                console.log('Tournament course data check:', {
                    course: tournamentConfig.course,
                    foundInCourses: !!courses[tournamentConfig.course],
                    foundInCustom: !!customCourses[tournamentConfig.course],
                    usingGlobal: tournamentCourseData === courseData,
                    hasData: !!tournamentCourseData,
                    hasHoles: tournamentCourseData?.holes?.length
                });
                
                // Create tournament in Firestore (no Firebase Auth required)
                console.log('Creating cloud tournament:', tournamentId);
                const tournament = {
                    id: tournamentId,
                    ...tournamentConfig,
                    joinCode: joinCode,
                    hostCode: hostCode, // Secret code to gain co-host access
                    hostDevice: currentDeviceId, // Original host device
                    hostDeviceId: currentDeviceId,
                    hostUserId: currentUserId,
                    hostName: currentAuthUser?.displayName || deviceInitials || 'Host', // Host's display name
                    coHosts: [], // Array of device IDs with co-host access
                    status: 'open', // open, active, locked, ended
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    // Store course data so it's available when loading later
                    courseData: tournamentCourseData ? {
                        name: tournamentCourseData.name,
                        holes: tournamentCourseData.holes,
                        totalPar: tournamentCourseData.totalPar,
                        tees: tournamentCourseData.tees
                    } : null,
                    // Keep players from tournamentConfig (don't overwrite with empty array)
                    devices: {
                        [currentDeviceId]: {
                            name: getDeviceName(),
                            userId: currentUserId,
                            connectedAt: firebase.firestore.FieldValue.serverTimestamp(),
                            lastActive: firebase.firestore.FieldValue.serverTimestamp(),
                            isHost: true
                        }
                    },
                    enabledGames: tournamentConfig.enabledGames || [tournamentConfig.gameType]
                };
                
                console.log('Creating tournament:', tournamentId);
                await db.collection('tournaments').doc(tournamentId).set(tournament);
                
                activeTournamentId = tournamentId;
                isHost = true;
                
                // Add to tournament history
                addToTournamentHistory({
                    id: tournamentId,
                    joinCode: joinCode,
                    name: tournamentConfig.name || '',
                    course: tournamentConfig.course,
                    date: tournamentConfig.date,
                    gameType: tournamentConfig.gameType,
                    playerCount: tournamentConfig.players ? tournamentConfig.players.length : 0,
                    role: 'host'
                });
                
                console.log('Tournament created successfully!');
                return tournamentId;
            } catch (error) {
                console.error('Error creating tournament:', error);
                // Don't show alert here - let the calling function handle it
                throw error; // Re-throw so the catch in startScoring can handle it
            }
        }
        
        // Join existing tournament
        async function joinTournament(tournamentId, playerInfo) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                
                if (!tournamentDoc.exists) {
                    alert('Tournament not found!');
                    return false;
                }
                
                const tournament = tournamentDoc.data();
                
                if (tournament.status === 'ended') {
                    alert('This tournament has ended!');
                    return false;
                }
                
                // Add player and register device
                await tournamentRef.update({
                    players: firebase.firestore.FieldValue.arrayUnion({
                        ...playerInfo,
                        joinedAt: new Date().toISOString(),
                        claimedBy: getClaimIdentifier(),
                        scores: new Array(18).fill(null)
                    }),
                    [`devices.${currentDeviceId}`]: {
                        name: getDeviceName(),
                        userId: currentUserId,
                        connectedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastActive: firebase.firestore.FieldValue.serverTimestamp(),
                        isHost: false
                    }
                });
                
                activeTournamentId = tournamentId;
                claimedPlayers = [playerInfo.name];
                
                // Subscribe to tournament updates
                subscribToTournamentUpdates(tournamentId);
                
                return true;
            } catch (error) {
                console.error('Error joining tournament:', error);
                alert('Failed to join tournament. Please try again.');
                return false;
            }
        }
        
        // Claim additional players (for scoring a foursome)
        async function claimAdditionalPlayer(tournamentId, playerName) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Find the player
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) {
                    alert('Player not found!');
                    return false;
                }
                
                const player = tournament.players[playerIndex];
                
                // Check if already claimed
                if (player.claimedBy && !isClaimedByMe(player)) {
                    alert(`${playerName} is already being scored by another device!`);
                    return false;
                }
                
                // Claim the player
                tournament.players[playerIndex].claimedBy = getClaimIdentifier();
                
                await tournamentRef.update({
                    players: tournament.players
                });
                
                claimedPlayers.push(playerName);
                return true;
            } catch (error) {
                console.error('Error claiming player:', error);
                return false;
            }
        }
        
        // Update player score
        async function updatePlayerScore(tournamentId, playerName, holeIndex, score) {
            console.log('🔥 updatePlayerScore called:');
            console.log('   tournamentId:', tournamentId);
            console.log('   playerName:', playerName);
            console.log('   holeIndex:', holeIndex);
            console.log('   score:', score);
            
            // NEWEST WINS: Record timestamp for this score change
            const now = Date.now();
            const timestampKey = `${playerName}-${holeIndex}`;
            scoreTimestamps[timestampKey] = now;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                
                // Use a transaction to ensure atomic read-modify-write
                // This prevents race conditions where multiple devices overwrite each other
                await db.runTransaction(async (transaction) => {
                    const tournamentDoc = await transaction.get(tournamentRef);
                    
                    if (!tournamentDoc.exists) {
                        throw new Error('Tournament does not exist');
                    }
                    
                    const tournament = tournamentDoc.data();
                    console.log('   Fetched tournament from Firebase (in transaction)');
                    
                    const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                    if (playerIndex === -1) {
                        throw new Error('Player not found: ' + playerName);
                    }
                    
                    console.log('   Found player at index:', playerIndex);
                    
                    // Check permissions - hosts and co-hosts can edit any player
                    if (!canManageTournament() && !isClaimedByMe(tournament.players[playerIndex])) {
                        throw new Error('Permission denied - not your player');
                    }
                    
                    console.log('   Permission check passed');
                    
                    // Initialize scores array if it doesn't exist
                    if (!tournament.players[playerIndex].scores) {
                        tournament.players[playerIndex].scores = new Array(18).fill(null);
                        console.log('   Initialized scores array');
                    }
                    
                    // Initialize scoreTimestamps array if it doesn't exist
                    if (!tournament.players[playerIndex].scoreTimestamps) {
                        tournament.players[playerIndex].scoreTimestamps = new Array(18).fill(0);
                    }
                    
                    // Only update if our score is newer or no timestamp exists
                    const existingTimestamp = tournament.players[playerIndex].scoreTimestamps[holeIndex] || 0;
                    if (now >= existingTimestamp) {
                        tournament.players[playerIndex].scores[holeIndex] = score;
                        tournament.players[playerIndex].scoreTimestamps[holeIndex] = now;
                        console.log('   Updated score with timestamp:', now);
                    } else {
                        console.log('   Skipping update - existing score is newer');
                    }
                    
                    // Mark that WE are writing to Firebase
                    lastFirebaseWriteTime = Date.now();
                    
                    // Update with the LATEST player array from Firebase (not our local stale copy)
                    transaction.update(tournamentRef, {
                        players: tournament.players,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                });
                
                console.log('✅ Score successfully written to Firebase via transaction!');
                return true;
            } catch (error) {
                console.error('❌ Error updating score:', error);
                console.error('   Error details:', error.message);
                
                // If permission denied, show alert
                if (error.message && error.message.includes('Permission denied')) {
                    alert('You cannot edit this player\'s scores!');
                }
                
                return false;
            }
        }
        
        // Subscribe to real-time tournament updates
        function subscribToTournamentUpdates(tournamentId) {
            console.log('📡 Subscribing to tournament updates:', tournamentId);
            
            if (tournamentUnsubscribe) {
                tournamentUnsubscribe();
            }
            
            tournamentUnsubscribe = db.collection('tournaments')
                .doc(tournamentId)
                .onSnapshot((doc) => {
                    if (doc.exists) {
                        const tournament = doc.data();
                        console.log('📥 Received tournament update from Firebase');
                        console.log('   Players:', tournament.players.length);
                        console.log('   Sample scores:', tournament.players[0]?.scores?.slice(0, 3));
                        
                        // VERIFY HOST STATUS from tournament data on every update
                        if (tournament.devices && tournament.devices[currentDeviceId]) {
                            const deviceData = tournament.devices[currentDeviceId];
                            if (deviceData.isHost && !isHost) {
                                isHost = true;
                                hasJoinedTournament = true;
                                console.log('🔑 Host status restored from Firebase tournament data');
                                saveToLocalStorage();
                            }
                            // Also check for co-host status
                            if (deviceData.isCoHost && !isCoHost) {
                                isCoHost = true;
                                hasJoinedTournament = true;
                                console.log('🔑 Co-host status restored from Firebase tournament data');
                                saveToLocalStorage();
                            }
                        }
                        
                        // CHECK FOR WATCHED PLAYER SCORE CHANGES (before updating local state)
                        checkWatchedPlayerScoreChanges(tournament);
                        
                        // FIX: Always process updates - the NEWEST-WINS merge logic in 
                        // updateLocalTournamentState will handle conflicts properly.
                        // We no longer skip updates entirely just because we recently wrote.
                        // The merge logic compares timestamps per-hole, so our recent write
                        // will be preserved while still accepting other devices' scores.
                        
                        const timeSinceOurWrite = Date.now() - lastFirebaseWriteTime;
                        const isOurOwnEcho = lastFirebaseWriteTime > 0 && timeSinceOurWrite < 2000;
                        
                        if (isOurOwnEcho) {
                            console.log('🔄 Recent write detected (' + timeSinceOurWrite + 'ms ago) - skipping UI refresh (our own echo)');
                        }
                        
                        updateLocalTournamentState(tournament);
                        updateLiveLeaderboard(tournament);
                        
                        // Update privacy-based UI
                        updatePrivacyUI();
                        
                        // Refresh UI if on scoring page - BUT not if:
                        // 1. User is actively editing
                        // 2. This is our own write echoing back (causes carousel swipe)
                        if (document.getElementById('scoringPage').classList.contains('active')) {
                            const activeElement = document.activeElement;
                            const isEditingScore = activeElement && 
                                                 (activeElement.classList.contains('score-input') || 
                                                  activeElement.tagName === 'INPUT');
                            
                            // CRITICAL: Skip refresh if this is our own write echoing back
                            if (!isEditingScore && !isOurOwnEcho) {
                                // Clear any pending refresh
                                if (window.subscriptionRefreshTimeout) {
                                    clearTimeout(window.subscriptionRefreshTimeout);
                                }
                                
                                // Debounce: Wait 300ms after last update before re-rendering
                                console.log('🔄 Scheduling scoring page refresh...');
                                window.subscriptionRefreshTimeout = setTimeout(() => {
                                    console.log('🔄 Refreshing scoring page UI from subscription');
                                    renderScoringPage();
                                }, 300);
                            } else if (isOurOwnEcho) {
                                console.log('⏸️ Skipping refresh - our own Firebase echo');
                            } else {
                                console.log('⏸️ User is editing - skipping refresh');
                            }
                        }
                        
                        // Check for notifications
                        if (tournament.status === 'ended' && !sessionStorage.getItem('tournamentEndedNotified_' + tournamentId)) {
                            sessionStorage.setItem('tournamentEndedNotified_' + tournamentId, 'true');
                            showNotification('Tournament Complete!', 'Tap to view final results');
                        }
                    } else {
                        console.warn('⚠️ Tournament document does not exist');
                    }
                }, (error) => {
                    console.error('❌ Error listening to tournament:', error);
                });
        }
        
        // Notification mute state
        let watchedPlayerNotificationsMuted = false;
        
        // Load mute state from localStorage
        function loadNotificationMuteState() {
            const muted = localStorage.getItem('watchedPlayerNotificationsMuted');
            watchedPlayerNotificationsMuted = muted === 'true';
        }
        
        // Toggle notification mute
        function toggleWatchedNotifications() {
            watchedPlayerNotificationsMuted = !watchedPlayerNotificationsMuted;
            localStorage.setItem('watchedPlayerNotificationsMuted', watchedPlayerNotificationsMuted);
            
            // Update UI
            updateNotificationToggleUI();
            
            showNotification(
                watchedPlayerNotificationsMuted ? '🔕 Muted' : '🔔 Unmuted',
                watchedPlayerNotificationsMuted ? 'Score notifications silenced' : 'You\'ll see score updates'
            );
        }
        
        // Update the notification toggle button UI
        function updateNotificationToggleUI() {
            const btn = document.getElementById('notificationToggleBtn');
            if (btn) {
                if (watchedPlayerNotificationsMuted) {
                    btn.innerHTML = '🔕';
                    btn.title = 'Notifications muted - tap to unmute';
                    btn.style.background = '#94a3b8';
                } else {
                    btn.innerHTML = '🔔';
                    btn.title = 'Notifications on - tap to mute';
                    btn.style.background = '#1e3a5f';
                }
            }
        }
        
        // Check for score changes on watched players and notify
        function checkWatchedPlayerScoreChanges(newTournament) {
            // Skip if muted or no local data yet
            if (watchedPlayerNotificationsMuted) return;
            if (!tournamentData || !tournamentData.players) return;
            if (!playerOrder || !playerOrder.watching || playerOrder.watching.length === 0) return;
            
            // Get list of watched player names
            const watchedNames = playerOrder.watching;
            
            newTournament.players.forEach(newPlayer => {
                // Only check watched players (not claimed by us)
                if (!watchedNames.includes(newPlayer.name)) return;
                if (isClaimedByMe(newPlayer)) return; // Don't notify for our own players
                
                // Find the old player data
                const oldPlayer = tournamentData.players.find(p => p.name === newPlayer.name);
                if (!oldPlayer) return;
                
                // Compare scores hole by hole
                for (let i = 0; i < 18; i++) {
                    const oldScore = oldPlayer.scores ? oldPlayer.scores[i] : null;
                    const newScore = newPlayer.scores ? newPlayer.scores[i] : null;
                    
                    // Detect new score entry (was null/0, now has value)
                    if ((!oldScore || oldScore === 0) && newScore && newScore > 0) {
                        const holeNum = i + 1;
                        const par = courseData?.holes?.[i]?.par || 4;
                        const diff = newScore - par;
                        let diffText = '';
                        if (diff === 0) diffText = ' (Par)';
                        else if (diff < 0) diffText = ` (${diff})`;
                        else diffText = ` (+${diff})`;
                        
                        // Get first name for shorter notification
                        const firstName = newPlayer.name.split(' ')[0];
                        
                        showNotification(
                            `👁️ ${firstName}`,
                            `Scored ${newScore}${diffText} on Hole ${holeNum}`
                        );
                        
                        console.log(`🔔 Watched player notification: ${newPlayer.name} scored ${newScore} on hole ${holeNum}`);
                        
                        // Only show one notification per update (don't spam if multiple holes updated)
                        return;
                    }
                }
            });
        }
        
        // Update local state from cloud data - NEWEST WINS approach
        function updateLocalTournamentState(tournament) {
            console.log('📥 NEWEST-WINS SYNC: Merging tournament data from cloud:', {
                players: tournament.players.length,
                hasScores: tournament.players.some(p => p.scores && p.scores.some(s => s > 0))
            });
            
            // Fix fav_ prefix if present (legacy data fix)
            let courseKey = tournament.course;
            if (courseKey && courseKey.startsWith('fav_')) {
                courseKey = courseKey.substring(4);
                tournament.course = courseKey;
            }
            
            // CRITICAL: Load course data from tournament if we don't have it
            if ((!courseData || !courseData.holes) && tournament.courseData) {
                console.log('📍 Loading courseData from Firebase tournament:', tournament.courseData.name);
                courseData = tournament.courseData;
                customCourses[courseKey] = tournament.courseData;
            }
            
            // Sync tombstones from Firebase - merge with local tombstones
            const cloudTombstones = tournament.deletedPlayers || {};
            Object.keys(cloudTombstones).forEach(playerName => {
                const cloudTimestamp = cloudTombstones[playerName];
                const localTimestamp = deletedPlayers[playerName] || 0;
                // Keep the most recent tombstone
                if (cloudTimestamp > localTimestamp) {
                    deletedPlayers[playerName] = cloudTimestamp;
                    console.log(`🪦 TOMBSTONE synced from cloud: "${playerName}" deleted at ${cloudTimestamp}`);
                }
            });
            
            // Initialize tournamentData if it doesn't exist
            if (!tournamentData) {
                tournamentData = {
                    id: tournament.id,
                    name: tournament.name || '',
                    date: tournament.date,
                    course: tournament.course,
                    gameType: tournament.gameType,
                    enabledGames: tournament.enabledGames || [tournament.gameType],
                    players: [],
                    teams: tournament.teams || [],
                    courseData: tournament.courseData
                };
            }
            
            // Also ensure courseData is in tournamentData
            if (tournament.courseData && !tournamentData.courseData) {
                tournamentData.courseData = tournament.courseData;
            }
            
            // Always update non-score data from cloud
            tournamentData.date = tournament.date;
            tournamentData.course = tournament.course;
            tournamentData.gameType = tournament.gameType;
            tournamentData.enabledGames = tournament.enabledGames || [tournament.gameType];
            tournamentData.name = tournament.name || '';
            
            // NEWEST-WINS: Merge players intelligently
            const now = Date.now();
            const mergedPlayers = [];
            
            // Build a map of local players by name
            const localPlayerMap = {};
            if (tournamentData.players) {
                tournamentData.players.forEach(p => {
                    localPlayerMap[p.name] = p;
                });
            }
            
            // Process cloud players
            tournament.players.forEach(cloudPlayer => {
                const localPlayer = localPlayerMap[cloudPlayer.name];
                
                // Check if this player was deleted locally (tombstone check)
                const deletedAt = deletedPlayers[cloudPlayer.name];
                const cloudPlayerAddedAt = cloudPlayer.addedAt ? new Date(cloudPlayer.addedAt).getTime() : 0;
                
                if (deletedAt && cloudPlayerAddedAt < deletedAt) {
                    console.log(`🪦 TOMBSTONE: Blocking zombie player "${cloudPlayer.name}" (deleted at ${deletedAt}, added at ${cloudPlayerAddedAt})`);
                    return; // Skip this player - they were deleted after being added
                }
                
                if (!localPlayer) {
                    // New player from cloud - accept them
                    console.log(`➕ NEW PLAYER from cloud: ${cloudPlayer.name}`);
                    mergedPlayers.push({
                        name: cloudPlayer.name,
                        handicap: cloudPlayer.handicap,
                        scores: cloudPlayer.scores || new Array(18).fill(null),
                        putts: cloudPlayer.putts || new Array(18).fill(null),
                        claimedBy: cloudPlayer.claimedBy,
                        addedAt: cloudPlayer.addedAt || now
                    });
                } else {
                    // Existing player - MERGE scores using timestamps (newest wins)
                    const mergedScores = new Array(18).fill(null);
                    
                    for (let holeIdx = 0; holeIdx < 18; holeIdx++) {
                        const localScore = localPlayer.scores ? localPlayer.scores[holeIdx] : null;
                        const cloudScore = cloudPlayer.scores ? cloudPlayer.scores[holeIdx] : null;
                        const timestampKey = `${cloudPlayer.name}-${holeIdx}`;
                        const localTimestamp = scoreTimestamps[timestampKey] || 0;
                        const cloudTimestamp = cloudPlayer.scoreTimestamps ? (cloudPlayer.scoreTimestamps[holeIdx] || 0) : 0;
                        
                        // NEWEST WINS logic
                        if (localScore !== null && cloudScore !== null) {
                            // Both have scores - use newest
                            if (localTimestamp >= cloudTimestamp) {
                                mergedScores[holeIdx] = localScore;
                                console.log(`🛡️ KEPT LOCAL: ${cloudPlayer.name} H${holeIdx + 1} = ${localScore} (local: ${localTimestamp}, cloud: ${cloudTimestamp})`);
                            } else {
                                mergedScores[holeIdx] = cloudScore;
                                // Update our timestamp to cloud's
                                scoreTimestamps[timestampKey] = cloudTimestamp;
                                console.log(`☁️ TOOK CLOUD: ${cloudPlayer.name} H${holeIdx + 1} = ${cloudScore} (local: ${localTimestamp}, cloud: ${cloudTimestamp})`);
                            }
                        } else if (localScore !== null) {
                            // Only local has score - keep it
                            mergedScores[holeIdx] = localScore;
                            console.log(`🛡️ LOCAL ONLY: ${cloudPlayer.name} H${holeIdx + 1} = ${localScore}`);
                        } else if (cloudScore !== null) {
                            // Only cloud has score - accept it
                            mergedScores[holeIdx] = cloudScore;
                            if (cloudTimestamp) {
                                scoreTimestamps[timestampKey] = cloudTimestamp;
                            }
                            console.log(`☁️ CLOUD ONLY: ${cloudPlayer.name} H${holeIdx + 1} = ${cloudScore}`);
                        }
                        // else both null - keep null
                    }
                    
                    mergedPlayers.push({
                        name: cloudPlayer.name,
                        handicap: cloudPlayer.handicap,
                        scores: mergedScores,
                        putts: cloudPlayer.putts || localPlayer.putts || new Array(18).fill(null),
                        claimedBy: cloudPlayer.claimedBy || localPlayer.claimedBy, // Preserve local claim if cloud doesn't have one yet
                        addedAt: cloudPlayer.addedAt || localPlayer.addedAt || now
                    });
                    
                    // Remove from local map since we processed it
                    delete localPlayerMap[cloudPlayer.name];
                }
            });
            
            // Add any local players that weren't in cloud (unless deleted)
            Object.values(localPlayerMap).forEach(localPlayer => {
                // Check if this player was deleted (has tombstone)
                const deletedAt = deletedPlayers[localPlayer.name];
                if (deletedAt) {
                    console.log(`🪦 TOMBSTONE BLOCK: Not re-adding local player "${localPlayer.name}" (deleted at ${deletedAt})`);
                    return; // Don't re-add deleted players
                }
                
                // Only keep local-only players if they were recently added (within last 5 minutes)
                // This helps with offline support while preventing stale data from persisting
                const addedAt = localPlayer.addedAt || 0;
                const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
                
                if (addedAt > fiveMinutesAgo) {
                    console.log(`🏠 LOCAL ONLY PLAYER: ${localPlayer.name} (keeping - recently added)`);
                    mergedPlayers.push(localPlayer);
                } else {
                    console.log(`🗑️ REMOVING STALE LOCAL PLAYER: ${localPlayer.name} (not in cloud, added ${Math.round((Date.now() - addedAt) / 60000)}m ago)`);
                    // Don't add - this player was removed from cloud and shouldn't persist
                }
            });
            
            tournamentData.players = mergedPlayers;
            
            // Update co-host status
            const coHosts = tournament.coHosts || [];
            isCoHost = coHosts.includes(currentDeviceId);
            console.log('👑 Co-host status:', isCoHost, '| CoHosts:', coHosts);
            
            console.log('✅ NEWEST-WINS SYNC complete:', {
                finalPlayerCount: tournamentData.players.length,
                sampleScores: tournamentData.players[0]?.scores?.slice(0, 3)
            });
            
            // Save merged state
            saveToLocalStorage();
        }
        
        // Host/Co-host: Reassign player to different device
        async function reassignPlayer(tournamentId, playerName, newDeviceId) {
            if (!canManageTournament()) {
                alert('Only hosts and co-hosts can reassign players!');
                return false;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) return false;
                
                tournament.players[playerIndex].claimedBy = newDeviceId;
                
                await tournamentRef.update({
                    players: tournament.players
                });
                
                return true;
            } catch (error) {
                console.error('Error reassigning player:', error);
                return false;
            }
        }
        
        // Host/Co-host: Lock tournament (no more joins)
        async function lockTournament(tournamentId) {
            if (!canManageTournament()) return false;
            
            try {
                await db.collection('tournaments').doc(tournamentId).update({
                    status: 'locked',
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error locking tournament:', error);
                return false;
            }
        }
        
        // Host/Co-host: End tournament
        async function endTournament(tournamentId) {
            if (!canManageTournament()) return false;
            
            try {
                await db.collection('tournaments').doc(tournamentId).update({
                    status: 'ended',
                    endedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Send notifications to all players
                sendTournamentEndNotification(tournamentId);
                
                return true;
            } catch (error) {
                console.error('Error ending tournament:', error);
                return false;
            }
        }
        
        // Host: Add player manually during tournament
        function addPlayerManually() {
            if (!canManageTournament()) {
                showNotification('Error', 'Only hosts can add players');
                return;
            }
            
            const modal = document.createElement('div');
            modal.id = 'addPlayerModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 24px; max-width: 340px; width: 100%;">
                    <h2 style="color: #1e3a5f; font-size: 18px; margin: 0 0 16px 0; text-align: center;">➕ Add Player</h2>
                    
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 6px; color: #475569; font-weight: 600; font-size: 14px;">Player Name</label>
                        <input type="text" id="manualPlayerName" placeholder="Enter name" 
                            style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 16px; box-sizing: border-box;">
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 6px; color: #475569; font-weight: 600; font-size: 14px;">HCP Index</label>
                        <input type="number" id="manualPlayerHcp" placeholder="0" step="0.1" min="-10" max="54"
                            style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 16px; text-align: center; box-sizing: border-box;">
                    </div>
                    
                    <div style="display: flex; gap: 12px;">
                        <button onclick="closeAddPlayerModal()" 
                            style="flex: 1; padding: 14px; background: #f1f5f9; border: none; border-radius: 6px; color: #475569; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                        <button onclick="submitManualPlayer()" 
                            style="flex: 1; padding: 14px; background: #166534; border: none; border-radius: 6px; color: white; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Add Player
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Focus the name input
            setTimeout(() => document.getElementById('manualPlayerName')?.focus(), 100);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeAddPlayerModal();
            };
        }
        
        function closeAddPlayerModal() {
            const modal = document.getElementById('addPlayerModal');
            if (modal) modal.remove();
        }
        
        async function submitManualPlayer() {
            const nameInput = document.getElementById('manualPlayerName');
            const hcpInput = document.getElementById('manualPlayerHcp');
            
            const name = nameInput?.value.trim();
            const handicapIndex = parseFloat(hcpInput?.value) || 0;
            
            if (!name) {
                showNotification('Error', 'Please enter a player name');
                return;
            }
            
            // Check if player already exists
            if (tournamentData.players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                showNotification('Error', 'Player already exists in tournament');
                return;
            }
            
            // Calculate course handicap
            let courseHandicap = handicapIndex;
            if (courseData && courseData.tees && tournamentData.tee) {
                const teeData = courseData.tees[tournamentData.tee];
                if (teeData) {
                    courseHandicap = calculateCourseHandicap(handicapIndex, teeData.slope, teeData.rating, courseData.totalPar);
                }
            }
            
            const newPlayer = {
                name: name,
                handicapIndex: handicapIndex,
                handicap: courseHandicap,
                scores: new Array(18).fill(0),
                claimedBy: null
            };
            
            try {
                // Add to Firebase
                const updatedPlayers = [...tournamentData.players, newPlayer];
                await db.collection('tournaments').doc(activeTournamentId).update({
                    players: updatedPlayers,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update local
                tournamentData.players = updatedPlayers;
                saveToLocalStorage();
                
                closeAddPlayerModal();
                showNotification('Added', `${name} added to tournament`);
                
                // Update player history for quick add
                updatePlayerHistory(name, handicapIndex);
                
            } catch (error) {
                console.error('Error adding player:', error);
                showNotification('Error', 'Could not add player');
            }
        }
        
        // Get device name for display
        function getDeviceName() {
            const deviceType = /iPhone/i.test(navigator.userAgent) ? 'iPhone' :
                              /iPad/i.test(navigator.userAgent) ? 'iPad' :
                              /Android/i.test(navigator.userAgent) ? 'Android' :
                              'Device';
            
            // Try to get a friendly name from localStorage
            const customName = localStorage.getItem('deviceName');
            return customName || deviceType;
        }
        
        // Send tournament end notification
        function sendTournamentEndNotification(tournamentId) {
            // This will use web push notifications if permitted
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification('🏁 Tournament Complete!', {
                    body: 'Tap to view final results',
                    icon: '/apple-touch-icon.png',
                    badge: '/apple-touch-icon.png',
                    tag: 'tournament-ended-' + tournamentId
                });
            }
        }
        
        // Request notification permission
        function requestNotificationPermission() {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        console.log('Notifications enabled');
                    }
                });
            }
        }
        
        // Show in-app notification
        function showNotification(title, message, requireDismiss = false) {
            // Create notification UI element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: #1e3a5f;
                color: white;
                padding: 16px 24px;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10005;
                max-width: 90%;
                text-align: center;
                animation: slideUp 0.3s ease;
            `;
            
            notification.innerHTML = `
                <div style="font-weight: 700; margin-bottom: 4px;">${title}</div>
                <div style="font-size: 14px;">${message}</div>
                ${requireDismiss ? '<button onclick="this.parentElement.remove()" style="margin-top: 12px; background: white; color: #1e3a5f; border: none; padding: 8px 16px; border-radius: 6px; font-weight: 600; cursor: pointer;">OK</button>' : ''}
            `;
            
            document.body.appendChild(notification);
            
            // Auto-dismiss after 4 seconds only if not requiring manual dismissal
            if (!requireDismiss) {
                setTimeout(() => {
                    notification.style.animation = 'slideDown 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }, 4000);
            }
        }
        
        // Generate shareable tournament link
        function getShareLink(tournamentId) {
            return window.location.origin + window.location.pathname + '?join=' + tournamentId;
        }
        
        // Check URL for join parameter on page load
        function checkForJoinLink() {
            const urlParams = new URLSearchParams(window.location.search);
            const joinId = urlParams.get('join');
            if (joinId) {
                // Mark as guest user - they can only participate in this tournament
                isGuestUser = true;
                hasJoinedTournament = false; // Not joined yet, just arrived via link
                
                // Load tournament data first for display
                db.collection('tournaments').doc(joinId).get()
                    .then(doc => {
                        if (doc.exists) {
                            const tournament = doc.data();
                            activeTournamentId = joinId;
                            tournamentMode = 'multi';
                            isHost = false;
                            
                            // Fix fav_ prefix if present (legacy data fix)
                            let courseKey = tournament.course;
                            if (courseKey && courseKey.startsWith('fav_')) {
                                courseKey = courseKey.substring(4);
                            }
                            
                            tournamentData = {
                                id: joinId,
                                name: tournament.name || '',
                                date: tournament.date,
                                gameType: tournament.gameType,
                                course: courseKey,
                                players: tournament.players || [],
                                teams: tournament.teams || [],
                                courseData: tournament.courseData // Include embedded course data!
                            };
                            
                            // Load course data from tournament if available
                            if (tournament.courseData) {
                                courseData = tournament.courseData;
                                customCourses[courseKey] = tournament.courseData;
                                console.log('📍 Loaded course data from joined tournament:', tournament.courseData.name);
                            } else {
                                // Try to load from built-in courses
                                courseData = courses[courseKey] || customCourses[courseKey];
                            }
                            
                            saveToLocalStorage();
                            subscribToTournamentUpdates(joinId);
                            
                            // Go directly to My Players page for claiming
                            showMyPlayersPage();
                        } else {
                            showNotification('Error', 'Tournament not found');
                            showPage('hostHomePage');
                            updateHostHomePage();
                        }
                    })
                    .catch(error => {
                        console.error('Error loading tournament from link:', error);
                        showNotification('Error', 'Failed to load tournament');
                        showPage('hostHomePage');
                        updateHostHomePage();
                    });
            } else {
                // No join link - check if device has claimed players from a previous session
                checkForPreviousSession();
            }
        }
        
        // Check if this device has claimed players from a previous session
        async function checkForPreviousSession() {
            const savedData = localStorage.getItem('indianHillsScoring');
            if (!savedData) return;
            
            try {
                const data = JSON.parse(savedData);
                const savedTournamentId = data._activeTournamentId;
                const savedMode = data._tournamentMode;
                
                // Only check for multi-device tournaments
                if (savedMode !== 'multi' || !savedTournamentId) return;
                
                // Check if tournament still exists and this device has claimed players
                const tournamentDoc = await db.collection('tournaments').doc(savedTournamentId).get();
                if (!tournamentDoc.exists) {
                    console.log('Previous tournament no longer exists');
                    // Clear the old data
                    localStorage.removeItem('indianHillsScoring');
                    return;
                }
                
                const tournament = tournamentDoc.data();
                
                // Skip if tournament is finished - don't show Welcome Back for finished tournaments
                if (tournament.isFinished) {
                    console.log('Previous tournament is finished - clearing session');
                    localStorage.removeItem('indianHillsScoring');
                    localStorage.removeItem('activeTournamentId');
                    return;
                }
                
                const myClaimedPlayers = tournament.players.filter(p => isClaimedByMe(p));
                
                if (myClaimedPlayers.length > 0) {
                    // Device has claimed players - show Keep/Release dialog
                    showKeepReleaseDialog(savedTournamentId, tournament, myClaimedPlayers);
                }
            } catch (error) {
                console.error('Error checking for previous session:', error);
            }
        }
        
        // Show dialog asking user to Keep or Release their claimed players
        function showKeepReleaseDialog(tournamentId, tournament, claimedPlayers) {
            const playerNames = claimedPlayers.map(p => p.name).join(', ');
            
            // Get display name for tournament - use name if available, otherwise course name + game type
            let tournamentName = tournament.name;
            if (!tournamentName) {
                // Get the proper course display name
                const courseName = tournament.courseName || getCourseDisplayName(tournament.course) || tournament.course;
                tournamentName = `${courseName} - ${tournament.gameType}`;
            }
            
            const modal = document.createElement('div');
            modal.id = 'keepReleaseModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 6px; padding: 24px; max-width: 400px; width: 100%; text-align: center; position: relative; box-shadow: 0 4px 20px rgba(0,0,0,0.15);">
                    <button onclick="document.getElementById('keepReleaseModal')?.remove()" style="position: absolute; top: 12px; right: 12px; width: 32px; height: 32px; border: none; background: #f1f5f9; color: #64748b; border-radius: 50%; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;">×</button>
                    <div style="font-size: 48px; margin-bottom: 16px;">⛳</div>
                    <h2 style="color: #1e3a5f; margin-bottom: 12px; font-size: 20px; font-weight: 700;">Welcome Back!</h2>
                    <p style="color: #6b7280; margin-bottom: 16px; font-size: 14px;">
                        You were scoring for <strong style="color: #1e3a5f;">${playerNames}</strong> in:
                    </p>
                    <p style="color: #1e3a5f; font-weight: 600; margin-bottom: 20px; padding: 12px; background: #f5f5f5; border-radius: 8px;">
                        ${tournamentName}
                    </p>
                    <p style="color: #6b7280; margin-bottom: 24px; font-size: 14px;">
                        Would you like to continue scoring or select different players?
                    </p>
                    <div style="display: flex; gap: 12px;">
                        <button onclick="handleKeepPlayers('${tournamentId}')" style="flex: 1; padding: 14px; background: #1e3a5f; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Keep & Continue
                        </button>
                        <button onclick="handleReleaseAndLeave('${tournamentId}')" style="flex: 1; padding: 14px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Release & Leave
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Keep claimed players and continue scoring
        async function handleKeepPlayers(tournamentId) {
            document.getElementById('keepReleaseModal')?.remove();
            
            try {
                const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                if (!tournamentDoc.exists) {
                    showNotification('Error', 'Tournament no longer exists');
                    return;
                }
                
                const tournament = tournamentDoc.data();
                
                // Check if this device is the host
                const isOriginalHost = tournament.hostDevice === currentDeviceId;
                const isCoHostDevice = tournament.coHosts && tournament.coHosts.includes(currentDeviceId);
                
                // Set up tournament state
                activeTournamentId = tournamentId;
                tournamentMode = 'multi';
                isHost = isOriginalHost;
                isCoHost = isCoHostDevice;
                
                // If host, set to player view mode (since they're continuing as a player scoring)
                if (isHost || isCoHost) {
                    hostViewMode = 'player';
                }
                
                // Get claimed players
                claimedPlayers = tournament.players
                    .filter(p => isClaimedByMe(p))
                    .map(p => p.name);
                
                // Load tournament data
                tournamentData = {
                    id: tournamentId,
                    name: tournament.name || '',
                    date: tournament.date,
                    gameType: tournament.gameType,
                    course: tournament.course,
                    players: tournament.players,
                    teams: tournament.teams || [],
                    courseData: tournament.courseData
                };
                
                // Load course data
                if (tournament.courseData) {
                    courseData = tournament.courseData;
                    customCourses[tournament.course] = tournament.courseData;
                } else {
                    courseData = courses[tournament.course] || customCourses[tournament.course];
                }
                
                saveToLocalStorage();
                subscribToTournamentUpdates(tournamentId);
                
                // Go directly to scoring
                renderScoringPage();
                showPage('scoringPage');
                switchToHoleView();
                
                showNotification('Welcome Back!', `Continuing with ${claimedPlayers.join(', ')}`);
            } catch (error) {
                console.error('Error keeping players:', error);
                showNotification('Error', 'Failed to restore session');
            }
        }
        
        // Release all claimed players and show join screen
        async function handleReleaseAndChoose(tournamentId) {
            document.getElementById('keepReleaseModal')?.remove();
            
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                if (!tournamentDoc.exists) {
                    showNotification('Error', 'Tournament no longer exists');
                    return;
                }
                
                const tournament = tournamentDoc.data();
                
                // Release all players claimed by this device
                let released = [];
                tournament.players.forEach(p => {
                    if (isClaimedByMe(p)) {
                        released.push(p.name);
                        p.claimedBy = null;
                    }
                });
                
                // Update tournament
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Clear local claimed players
                claimedPlayers = [];
                playerOrder.claimed = [];
                savePlayerOrder();
                
                // Check if this device is the host
                const isOriginalHost = tournament.hostDevice === currentDeviceId;
                const isCoHostDevice = tournament.coHosts && tournament.coHosts.includes(currentDeviceId);
                
                // Set up tournament state
                activeTournamentId = tournamentId;
                tournamentMode = 'multi';
                isHost = isOriginalHost;
                isCoHost = isCoHostDevice;
                
                // If host, set to player view mode
                if (isHost || isCoHost) {
                    hostViewMode = 'player';
                }
                
                // Load tournament data
                tournamentData = {
                    id: tournamentId,
                    name: tournament.name || '',
                    date: tournament.date,
                    gameType: tournament.gameType,
                    course: tournament.course,
                    players: tournament.players,
                    teams: tournament.teams || [],
                    courseData: tournament.courseData
                };
                
                // Load course data
                if (tournament.courseData) {
                    courseData = tournament.courseData;
                    customCourses[tournament.course] = tournament.courseData;
                } else {
                    courseData = courses[tournament.course] || customCourses[tournament.course];
                }
                
                saveToLocalStorage();
                subscribToTournamentUpdates(tournamentId);
                
                // Show join screen with available players
                showJoinTournamentScreen(tournamentId);
                
                showNotification('Players Released', `${released.join(', ')} are now available`);
            } catch (error) {
                console.error('Error releasing players:', error);
                showNotification('Error', 'Failed to release players');
            }
        }
        
        // Release players and leave tournament entirely
        async function handleReleaseAndLeave(tournamentId) {
            document.getElementById('keepReleaseModal')?.remove();
            
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                if (!tournamentDoc.exists) {
                    showNotification('Error', 'Tournament no longer exists');
                    // Still clear local state
                    clearTournamentState();
                    showPage('guestHomePage');
                    updateGuestHomeDisplay();
                    return;
                }
                
                const tournament = tournamentDoc.data();
                
                // Release all players claimed by this device
                let released = [];
                tournament.players.forEach(p => {
                    if (isClaimedByMe(p)) {
                        released.push(p.name);
                        p.claimedBy = null;
                    }
                });
                
                // Update tournament to release players
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Clear all local state
                clearTournamentState();
                
                showNotification('Left Tournament', released.length > 0 ? `Released ${released.join(', ')}` : 'Successfully left');
                
                // Go back to home
                showPage('guestHomePage');
                updateGuestHomeDisplay();
            } catch (error) {
                console.error('Error leaving tournament:', error);
                // Still try to clear local state
                clearTournamentState();
                showPage('guestHomePage');
                updateGuestHomeDisplay();
                showNotification('Error', 'Failed to release players, but left locally');
            }
        }
        
        // Helper to clear tournament state
        function clearTournamentState() {
            activeTournamentId = null;
            tournamentMode = 'single';
            isHost = false;
            isCoHost = false;
            claimedPlayers = [];
            playerOrder.claimed = [];
            playerOrder.watching = [];
            savePlayerOrder();
            
            // Clear localStorage
            localStorage.removeItem('activeTournamentId');
            localStorage.removeItem('indianHillsScoring');
            localStorage.removeItem('currentTournamentId');
            
            // Reset tournament data
            tournamentData = {
                id: '',
                date: '',
                gameType: '',
                course: '',
                players: [],
                teams: []
            };
            
            // Unsubscribe from listeners
            try {
                unsubscribeFunctions.forEach(fn => {
                    if (typeof fn === 'function') fn();
                });
                unsubscribeFunctions = [];
            } catch (e) {
                console.error('Error unsubscribing:', e);
            }
        }
        
        // Generate share link and display it
        function generateShareLink(tournamentId) {
            const shareLink = getShareLink(tournamentId);
            
            // Show notification with option to view
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: white;
                color: #1e3a5f;
                padding: 16px 24px;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                max-width: 90%;
                text-align: center;
            `;
            notification.innerHTML = `
                <div style="font-weight: 700; margin-bottom: 8px;">🔗 Tournament Ready!</div>
                <div style="font-size: 14px; margin-bottom: 12px;">Share this link or QR code for others to join</div>
                <button onclick="copyShareLink('${shareLink}')" style="padding: 8px 16px; background: #1e3a5f; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; margin-right: 8px;">
                    📋 Copy Link
                </button>
                <button onclick="showQRCode('${tournamentId}')" style="padding: 8px 16px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">
                    📱 Show QR
                </button>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideDown 0.3s ease reverse';
                setTimeout(() => notification.remove(), 300);
            }, 8000);
        }
        
        // Copy share link to clipboard
        function copyShareLink(link) {
            navigator.clipboard.writeText(link).then(() => {
                showNotification('Copied!', 'Share link copied to clipboard');
            }).catch(() => {
                // Fallback for older browsers
                const input = document.createElement('input');
                input.value = link;
                document.body.appendChild(input);
                input.select();
                document.execCommand('copy');
                document.body.removeChild(input);
                showNotification('Copied!', 'Share link copied to clipboard');
            });
        }
        
        // Show QR code for tournament
        async function showQRCode(tournamentId) {
            const link = getShareLink(tournamentId);
            
            // Get current join code from Firebase
            let joinCode = '------';
            try {
                const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                if (tournamentDoc.exists) {
                    joinCode = tournamentDoc.data().joinCode || '------';
                }
            } catch (error) {
                console.error('Error fetching join code:', error);
            }
            
            // Create modal with QR code
            const modal = document.createElement('div');
            modal.id = 'qrCodeModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 10001;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; padding: 24px; border-radius: 6px; max-width: 400px; width: 90%; text-align: center;">
                    <h2 style="color: #1e3a5f; margin-bottom: 16px;">Share Tournament</h2>
                    
                    <!-- Join Code Section -->
                    <div style="background: linear-gradient(135deg, #f0f4f8 0%, #e1e8f0 100%); border: 2px solid #1e3a5f; border-radius: 6px; padding: 16px; margin-bottom: 16px;">
                        <div style="font-size: 13px; color: #1e3a5f; font-weight: 600; margin-bottom: 8px;">JOIN CODE</div>
                        <div style="display: flex; align-items: center; justify-content: center; gap: 12px;">
                            <span id="joinCodeDisplay" style="font-size: 32px; font-weight: 800; color: #1e3a5f; letter-spacing: 3px; font-family: monospace;">${joinCode}</span>
                            ${isHost ? `<button onclick="showEditJoinCodeModal('${tournamentId}', '${joinCode}')" style="padding: 6px 10px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-size: 14px; cursor: pointer;" title="Edit Code">✏️</button>` : ''}
                        </div>
                        <button onclick="copyJoinCode('${joinCode}')" style="margin-top: 10px; padding: 8px 16px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-size: 13px; font-weight: 600; cursor: pointer;">
                            📋 Copy Code
                        </button>
                    </div>
                    
                    <!-- Divider -->
                    <div style="display: flex; align-items: center; margin: 16px 0;">
                        <div style="flex: 1; height: 1px; background: #e2e8f0;"></div>
                        <span style="padding: 0 12px; color: #94a3b8; font-size: 12px;">OR SCAN</span>
                        <div style="flex: 1; height: 1px; background: #e2e8f0;"></div>
                    </div>
                    
                    <!-- QR Code -->
                    <div id="tempQRCode" style="display: inline-block; padding: 12px; background: white; border: 1px solid #e2e8f0; border-radius: 6px;"></div>
                    
                    <!-- Link -->
                    <p style="color: #64748b; font-size: 11px; margin-top: 12px; word-break: break-all;">${link}</p>
                    
                    <button onclick="this.closest('div[style*=fixed]').remove()" style="margin-top: 16px; padding: 12px 24px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; width: 100%;">
                        Close
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Generate QR code
            new QRCode(document.getElementById('tempQRCode'), {
                text: link,
                width: 200,
                height: 200
            });
            
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
        }
        
        // Copy join code to clipboard
        function copyJoinCode(code, buttonEl) {
            // Haptic feedback if available
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
            
            // Find the button that was clicked for visual feedback
            const btn = buttonEl || event?.target;
            if (btn) {
                const originalText = btn.innerHTML;
                const originalBg = btn.style.background;
                btn.innerHTML = '✓ Copied!';
                btn.style.background = '#166534';
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.style.background = originalBg;
                }, 1500);
            }
            
            navigator.clipboard.writeText(code).then(() => {
                showNotification('Copied!', `Join code ${code} copied to clipboard`);
            }).catch(() => {
                showNotification('Copy Failed', 'Please try again');
            });
        }
        
        // Show edit join code modal
        function showEditJoinCodeModal(tournamentId, currentCode) {
            const editModal = document.createElement('div');
            editModal.id = 'editJoinCodeModal';
            editModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.9);
                z-index: 10002;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            editModal.innerHTML = `
                <div style="background: white; padding: 24px; border-radius: 8px; max-width: 340px; width: 90%; text-align: center;">
                    <h3 style="color: #1e3a5f; margin-bottom: 8px; font-size: 20px;">Edit Join Code</h3>
                    <p style="color: #64748b; font-size: 13px; margin-bottom: 16px;">4 letters + 2 numbers (e.g., GOLF42)</p>
                    
                    <input type="text" id="newJoinCodeInput" value="${currentCode}" maxlength="6" 
                        style="width: 100%; padding: 16px; font-size: 28px; font-weight: 800; text-align: center; 
                        border: 2px solid #1e3a5f; border-radius: 6px; letter-spacing: 4px; font-family: monospace;
                        text-transform: uppercase;"
                        oninput="this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0,6)">
                    
                    <p id="joinCodeError" style="color: #a51c30; font-size: 13px; margin-top: 8px; min-height: 20px;"></p>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 16px;">
                        <button onclick="document.getElementById('editJoinCodeModal').remove()" 
                            style="padding: 14px; background: #f1f5f9; color: #475569; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                        <button onclick="saveNewJoinCode('${tournamentId}')" 
                            style="padding: 14px; background: #166534; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">
                            Save
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(editModal);
            
            // Focus and select input
            setTimeout(() => {
                const input = document.getElementById('newJoinCodeInput');
                input.focus();
                input.select();
            }, 100);
        }
        
        // Save new join code
        async function saveNewJoinCode(tournamentId) {
            const input = document.getElementById('newJoinCodeInput');
            const errorEl = document.getElementById('joinCodeError');
            const newCode = input.value.toUpperCase().trim();
            
            // Validate format
            if (!isValidJoinCodeFormat(newCode)) {
                errorEl.textContent = 'Must be 4 letters + 2 numbers';
                input.style.borderColor = '#a51c30';
                return;
            }
            
            // Show loading state
            errorEl.textContent = 'Checking...';
            errorEl.style.color = '#64748b';
            
            const result = await updateJoinCode(tournamentId, newCode);
            
            if (result.success) {
                // Update the display in the QR modal
                const displayEl = document.getElementById('joinCodeDisplay');
                if (displayEl) {
                    displayEl.textContent = result.code;
                }
                
                // Close edit modal
                document.getElementById('editJoinCodeModal').remove();
                
                showNotification('Code Updated!', `Join code changed to ${result.code}`);
            } else {
                errorEl.textContent = result.error;
                errorEl.style.color = '#a51c30';
                input.style.borderColor = '#a51c30';
            }
        }
        
        // Show share buttons on scoring page (for multi-device mode)
        
        // Show QR code for active tournament (legacy - kept for compatibility)
        function showQRCodeForActiveTournament() {
            // Gate check: Cloud features require subscription
            if (!canUseCloudFeatures()) {
                showPaywall('QR codes require a subscription. Upgrade to enable multi-device scoring!');
                return;
            }
            
            if (activeTournamentId) {
                showQRCode(activeTournamentId);
            } else {
                alert('No active tournament!');
            }
        }
        
        // Copy active tournament link (legacy - kept for compatibility)
        function copyActiveTournamentLink() {
            // Gate check: Cloud features require subscription
            if (!canUseCloudFeatures()) {
                showPaywall('Share links require a subscription. Upgrade to enable multi-device scoring!');
                return;
            }
            
            if (activeTournamentId) {
                const link = getShareLink(activeTournamentId);
                copyShareLink(link);
            } else {
                alert('No active tournament!');
            }
        }
        
        // Show QR code from Resume section
        function showQRFromResume() {
            console.log('=== QR CODE DEBUG ===');
            console.log('showQRFromResume called');
            console.log('activeTournamentId:', activeTournamentId);
            console.log('tournamentMode:', tournamentMode);
            console.log('isHost:', isHost);
            
            if (activeTournamentId) {
                console.log('✅ Tournament ID found - showing QR code');
                showQRCode(activeTournamentId);
            } else {
                console.error('❌ No active tournament ID');
                showNotification('No Active Tournament', 'Please start a multi-device tournament first');
            }
        }
        
        // Go to Manage/My Players from Resume section
        function goToManageFromResume() {
            // First resume to load the tournament data
            resumeSavedRound();
            
            // Then navigate to appropriate page based on role
            setTimeout(() => {
                if (canManageTournament()) {
                    showPlayerManagement();
                } else {
                    showMyPlayersPage();
                }
            }, 100);
        }
        
        // Copy link from Resume section
        function copyLinkFromResume() {
            if (activeTournamentId) {
                const link = getShareLink(activeTournamentId);
                navigator.clipboard.writeText(link).then(() => {
                    showNotification('Link Copied!', 'Share link copied to clipboard');
                }).catch(() => {
                    showNotification('Copy Failed', 'Please try again');
                });
            } else {
                showNotification('No Active Tournament', 'Please start a multi-device tournament first');
            }
        }
        
        // Save tournament to file
        function saveTournamentFile() {
            if (!activeTournamentId) {
                showNotification('No Active Tournament', 'Please start a multi-device tournament first');
                return;
            }
            
            try {
                // Create tournament export object
                const exportData = {
                    tournamentId: activeTournamentId,
                    tournamentData: tournamentData,
                    tournamentMode: tournamentMode,
                    savedAt: new Date().toISOString(),
                    version: '1.0'
                };
                
                // Convert to JSON
                const jsonStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                
                // Create download link
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                // Create filename with tournament info
                const date = tournamentData.date || new Date().toISOString().split('T')[0];
                const name = tournamentData.name ? tournamentData.name.replace(/[^a-z0-9]/gi, '_') : 'tournament';
                a.download = `${name}_${date}_${activeTournamentId}.json`;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification('Tournament Saved!', 'File downloaded successfully');
            } catch (error) {
                console.error('Error saving tournament:', error);
                showNotification('Save Failed', 'Could not save tournament file');
            }
        }
        
        // Upload and load tournament from file
        function uploadTournamentFile() {
            // Create hidden file input
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const data = JSON.parse(text);
                    
                    // Validate the file has required fields
                    if (!data.tournamentData || !data.tournamentData.players) {
                        showNotification('Invalid File', 'This file does not contain valid tournament data');
                        return;
                    }
                    
                    // Load the tournament data
                    tournamentData = data.tournamentData;
                    tournamentMode = data.tournamentMode || 'single';
                    activeTournamentId = data.tournamentId || null;
                    
                    // Set course data
                    if (tournamentData.course) {
                        // Strip fav_ prefix if present (legacy data fix)
                        let courseKey = tournamentData.course;
                        if (courseKey.startsWith('fav_')) {
                            courseKey = courseKey.substring(4);
                            tournamentData.course = courseKey; // Update the stored key
                        }
                        
                        courseData = courses[courseKey] || customCourses[courseKey];
                        // If course data was stored with tournament, use it
                        if (!courseData && tournamentData.courseData) {
                            courseData = tournamentData.courseData;
                            customCourses[courseKey] = tournamentData.courseData;
                        }
                    }
                    
                    // If it was a multi-device tournament, set host status
                    if (tournamentMode === 'multi' && activeTournamentId) {
                        isHost = true;
                        // Subscribe to updates if Firebase available
                        if (db) {
                            subscribToTournamentUpdates(activeTournamentId);
                        }
                    }
                    
                    // Add to history
                    addToTournamentHistory({
                        id: activeTournamentId || 'local_' + Date.now(),
                        name: tournamentData.name || 'Uploaded Tournament',
                        course: tournamentData.course,
                        date: tournamentData.date,
                        gameType: tournamentData.gameType,
                        role: isHost ? 'host' : 'player'
                    });
                    
                    saveToLocalStorage();
                    
                    showNotification('Tournament Loaded!', tournamentData.name || 'Uploaded Tournament');
                    
                    // Navigate to appropriate page
                    if (isHost) {
                        updateHostHomePage();
                        showPage('hostHomePage');
                    } else {
                        renderScoringPage();
                        showPage('scoringPage');
                    }
                    
                } catch (error) {
                    console.error('Error loading tournament file:', error);
                    showNotification('Load Failed', 'Could not read tournament file');
                }
            };
            
            input.click();
        }

        // ========================================
        // END FIREBASE FUNCTIONS
        // ========================================

        // Page navigation
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId).classList.add('active');
            
            // Render scoring page when navigating to it
            if (pageId === 'scoringPage') {
                renderScoringPage();
            }
            
            // Render results page when navigating to it
            if (pageId === 'resultsPage') {
                renderResultsPage();
                // Save stats to history when viewing results
                saveStatsToHistory();
                // Update IHMC publish banner visibility
                updateIHMCBanner();
            }
            
            // Populate rounds list when showing home pages
            if (pageId === 'guestHomePage' || pageId === 'hostHomePage') {
                populateHomeRoundsList();
                hideRoundIndicator(); // Hide round indicator on home pages
            }
            
            // Hide Home button for guest users (they can only access this tournament)
            if (isGuestUser) {
                const homeBtn = document.getElementById('backToSetupBtn');
                if (homeBtn) {
                    homeBtn.style.display = 'none';
                }
                
                // On results page, hide finish button for non-hosts (handled in renderResultsPage)
                const finishBtn = document.getElementById('newRoundBtnTop');
                if (finishBtn && !canManageTournament()) {
                    finishBtn.style.display = 'none';
                }
            }
            
            // Refresh quick add buttons and check for saved round when returning to setup page
            if (pageId === 'setupPage') {
                renderQuickAddButtons();
                checkForSavedRound(); // Update resume section with share buttons if needed
                
                // Reset GHIN toggle to default (unchecked/Course HCP mode)
                const ghinCheckbox = document.getElementById('setupUseGhinCheckbox');
                if (ghinCheckbox) {
                    ghinCheckbox.checked = false;
                    toggleSetupGhinMode(false);
                }
                
                // Cancel button is always visible - no need to toggle
                
                // Extra check: If multi-device tournament is active, ensure buttons are visible
                if (tournamentMode === 'multi' && activeTournamentId) {
                    // Multiple checks at different intervals for iOS
                    setTimeout(() => {
                        const shareButtons = document.getElementById('resumeShareButtons');
                        if (shareButtons) {
                            console.log('🔄 Setup page shown (50ms) - forcing share buttons visible');
                            shareButtons.classList.add('visible');
                            shareButtons.style.setProperty('display', 'grid', 'important');
                            shareButtons.style.setProperty('visibility', 'visible', 'important');
                        }
                    }, 50);
                    
                    setTimeout(() => {
                        const shareButtons = document.getElementById('resumeShareButtons');
                        if (shareButtons) {
                            console.log('🔄 Setup page shown (200ms) - forcing share buttons visible');
                            shareButtons.classList.add('visible');
                            shareButtons.style.setProperty('display', 'grid', 'important');
                            shareButtons.style.setProperty('visibility', 'visible', 'important');
                        }
                    }, 200);
                    
                    setTimeout(() => {
                        const shareButtons = document.getElementById('resumeShareButtons');
                        if (shareButtons) {
                            console.log('🔄 Setup page shown (500ms) - forcing share buttons visible');
                            shareButtons.classList.add('visible');
                            shareButtons.style.setProperty('display', 'grid', 'important');
                            shareButtons.style.setProperty('visibility', 'visible', 'important');
                        }
                    }, 500);
                }
            }
        }

        // GHIN Posting Score Modal
        function showGhinModal(playerName, handicap, playerIndex) {
            const player = tournamentData.players[playerIndex];
            if (!player || !courseData) {
                showNotification('Error', 'Could not load player data');
                return;
            }
            
            // Calculate Course Handicap if we have slope
            // Course Handicap = Handicap Index × (Slope Rating / 113)
            // For simplicity, we'll use the stored handicap as course handicap
            const courseHandicap = handicap;
            
            // Calculate GHIN-adjusted scores (Net Double Bogey max)
            let front9Raw = 0, back9Raw = 0;
            let front9Adjusted = 0, back9Adjusted = 0;
            let adjustedHoles = [];
            
            for (let i = 0; i < 18; i++) {
                const score = player.scores[i] || 0;
                const hole = courseData.holes[i];
                
                if (score > 0) {
                    // Calculate strokes received on this hole
                    // Strokes are allocated based on hole handicap (Hcp 1 gets first stroke, etc.)
                    let strokesReceived = 0;
                    if (courseHandicap > 0) {
                        // Positive handicap: receive strokes
                        if (hole.handicap <= courseHandicap) strokesReceived = 1;
                        if (hole.handicap <= courseHandicap - 18) strokesReceived = 2;
                        if (hole.handicap <= courseHandicap - 36) strokesReceived = 3;
                    } else if (courseHandicap < 0) {
                        // Plus handicap (negative): give strokes (max is lower)
                        const absHcp = Math.abs(courseHandicap);
                        if (hole.handicap <= absHcp) strokesReceived = -1;
                    }
                    
                    // Net Double Bogey = Par + 2 + strokes received
                    const maxScore = hole.par + 2 + strokesReceived;
                    const adjustedScore = Math.min(score, maxScore);
                    
                    if (adjustedScore < score) {
                        adjustedHoles.push(hole.number);
                    }
                    
                    // Track raw and adjusted
                    if (i < 9) {
                        front9Raw += score;
                        front9Adjusted += adjustedScore;
                    } else {
                        back9Raw += score;
                        back9Adjusted += adjustedScore;
                    }
                }
            }
            
            const totalRaw = front9Raw + back9Raw;
            const totalAdjusted = front9Adjusted + back9Adjusted;
            
            // Build modal
            const modal = document.createElement('div');
            modal.id = 'ghinModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            const adjustmentNote = adjustedHoles.length > 0 
                ? `<p style="color: #64748b; font-size: 12px; margin: 12px 0 0 0;">Adjusted holes: ${adjustedHoles.join(', ')}<br><span style="font-size: 11px;">(Net Double Bogey applied)</span></p>`
                : `<p style="color: #166534; font-size: 12px; margin: 12px 0 0 0;">✓ No adjustments needed</p>`;
            
            const front9Display = front9Adjusted > 0 ? front9Adjusted : '-';
            const back9Display = back9Adjusted > 0 ? back9Adjusted : '-';
            const totalDisplay = totalAdjusted > 0 ? totalAdjusted : '-';
            
            const front9Note = (front9Raw !== front9Adjusted && front9Raw > 0) ? ` <span style="color: #64748b; font-size: 12px;">(was ${front9Raw})</span>` : '';
            const back9Note = (back9Raw !== back9Adjusted && back9Raw > 0) ? ` <span style="color: #64748b; font-size: 12px;">(was ${back9Raw})</span>` : '';
            const totalNote = (totalRaw !== totalAdjusted && totalRaw > 0) ? ` <span style="color: #64748b; font-size: 12px;">(was ${totalRaw})</span>` : '';
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 24px; max-width: 320px; width: 100%; text-align: center;">
                    <div style="font-size: 32px; margin-bottom: 8px;">📊</div>
                    <h2 style="color: #1e3a5f; font-size: 16px; margin: 0 0 4px 0;">GHIN Posting Score</h2>
                    <p style="color: #64748b; font-size: 13px; margin: 0 0 16px 0;">${playerName} (HCP ${handicap >= 0 ? handicap : handicap})</p>
                    
                    <div style="background: #f8fafc; border-radius: 6px; padding: 16px; margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #e2e8f0;">
                            <span style="color: #64748b; font-weight: 600;">Front 9</span>
                            <span style="color: #1e3a5f; font-weight: 700; font-size: 18px;">${front9Display}${front9Note}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #e2e8f0;">
                            <span style="color: #64748b; font-weight: 600;">Back 9</span>
                            <span style="color: #1e3a5f; font-weight: 700; font-size: 18px;">${back9Display}${back9Note}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                            <span style="color: #1e3a5f; font-weight: 700;">Total</span>
                            <span style="color: #1e3a5f; font-weight: 700; font-size: 20px;">${totalDisplay}${totalNote}</span>
                        </div>
                    </div>
                    
                    ${adjustmentNote}
                    
                    <div style="display: flex; gap: 8px; margin-top: 16px;">
                        <button onclick="copyGhinScore('${playerName}', ${front9Adjusted}, ${back9Adjusted}, ${totalAdjusted})" style="flex: 1; padding: 12px; background: #1e3a5f; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            📋 Copy
                        </button>
                        <button onclick="closeGhinModal()" style="flex: 1; padding: 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Close
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeGhinModal();
            };
        }
        
        function closeGhinModal() {
            const modal = document.getElementById('ghinModal');
            if (modal) modal.remove();
        }
        
        function copyGhinScore(playerName, front9, back9, total) {
            const text = `${playerName} GHIN Score: Front 9: ${front9 || '-'}, Back 9: ${back9 || '-'}, Total: ${total || '-'}`;
            navigator.clipboard.writeText(text).then(() => {
                showNotification('Copied!', 'GHIN score copied to clipboard');
            }).catch(() => {
                showNotification('Copy Failed', 'Could not copy to clipboard');
            });
        }
        
        // ========================================
        // COURSE NOTES SYSTEM
        // ========================================
        
        // Get all course notes from localStorage
        function getAllCourseNotes() {
            try {
                const notes = localStorage.getItem('courseNotes');
                return notes ? JSON.parse(notes) : {};
            } catch (e) {
                console.error('Error loading course notes:', e);
                return {};
            }
        }
        
        // Save all course notes to localStorage
        function saveAllCourseNotes(notes) {
            try {
                localStorage.setItem('courseNotes', JSON.stringify(notes));
            } catch (e) {
                console.error('Error saving course notes:', e);
            }
        }
        
        // Get note for a specific course and hole
        function getCourseNote(courseId, holeNumber) {
            const notes = getAllCourseNotes();
            return notes[courseId]?.[holeNumber] || '';
        }
        
        // Save note for a specific course and hole
        function saveCourseNote(courseId, holeNumber, noteText) {
            const notes = getAllCourseNotes();
            
            if (!notes[courseId]) {
                notes[courseId] = {};
            }
            
            if (noteText.trim()) {
                notes[courseId][holeNumber] = noteText.trim();
            } else {
                // Delete empty notes
                delete notes[courseId][holeNumber];
                // Clean up empty course objects
                if (Object.keys(notes[courseId]).length === 0) {
                    delete notes[courseId];
                }
            }
            
            saveAllCourseNotes(notes);
        }
        
        // Get count of notes for a course
        function getCourseNotesCount(courseId) {
            const notes = getAllCourseNotes();
            return notes[courseId] ? Object.keys(notes[courseId]).length : 0;
        }
        
        // Show course note modal
        function showCourseNoteModal(holeNumber) {
            const courseId = tournamentData.course;
            const courseName = getCourseDisplayName(courseId);
            const existingNote = getCourseNote(courseId, holeNumber);
            
            const modal = document.createElement('div');
            modal.id = 'courseNoteModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 6px; padding: 24px; max-width: 360px; width: 100%;">
                    <div style="text-align: center; margin-bottom: 16px;">
                        <div style="font-size: 32px; margin-bottom: 8px;">📝</div>
                        <h2 style="color: #1e3a5f; font-size: 16px; margin: 0;">Hole ${holeNumber} Notes</h2>
                        <p style="color: #64748b; font-size: 12px; margin: 4px 0 0 0;">${courseName}</p>
                    </div>
                    
                    <textarea id="courseNoteText" placeholder="Add your notes for this hole...&#10;&#10;Examples:&#10;• Aim left off tee&#10;• Club up, plays long&#10;• Watch for false front" style="width: 100%; height: 150px; padding: 12px; border: 1.5px solid #1e3a5f; border-radius: 4px; font-size: 14px; resize: none; box-sizing: border-box; font-family: inherit;">${existingNote}</textarea>
                    
                    <div style="display: flex; gap: 8px; margin-top: 16px;">
                        <button onclick="saveCourseNoteFromModal(${holeNumber})" style="flex: 1; padding: 12px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            💾 Save
                        </button>
                        <button onclick="closeCourseNoteModal()" style="flex: 1; padding: 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                    
                    ${existingNote ? `
                        <button onclick="deleteCourseNoteFromModal(${holeNumber})" style="width: 100%; margin-top: 8px; padding: 10px; background: white; color: #a51c30; border: 1px solid #a51c30; border-radius: 4px; font-size: 13px; font-weight: 600; cursor: pointer;">
                            🗑️ Delete Note
                        </button>
                    ` : ''}
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Focus textarea
            setTimeout(() => {
                document.getElementById('courseNoteText').focus();
            }, 100);
            
            // Close on backdrop click
            modal.onclick = (e) => {
                if (e.target === modal) closeCourseNoteModal();
            };
        }
        
        function closeCourseNoteModal() {
            const modal = document.getElementById('courseNoteModal');
            if (modal) modal.remove();
        }
        
        function saveCourseNoteFromModal(holeNumber) {
            const textarea = document.getElementById('courseNoteText');
            const noteText = textarea.value;
            const courseId = tournamentData.course;
            
            saveCourseNote(courseId, holeNumber, noteText);
            closeCourseNoteModal();
            
            // Re-render hole view to update button color
            renderHoleView();
            
            showNotification('📝 Saved', noteText.trim() ? 'Note saved for this hole' : 'Note cleared');
        }
        
        function deleteCourseNoteFromModal(holeNumber) {
            const courseId = tournamentData.course;
            saveCourseNote(courseId, holeNumber, '');
            closeCourseNoteModal();
            renderHoleView();
            showNotification('🗑️ Deleted', 'Note removed');
        }

        // Custom confirmation dialog (iOS-friendly)
        function showConfirm(title, message, onConfirm) {
            const dialog = document.getElementById('confirmDialog');
            const titleEl = document.getElementById('confirmTitle');
            const messageEl = document.getElementById('confirmMessage');
            const okBtn = document.getElementById('confirmOk');
            const cancelBtn = document.getElementById('confirmCancel');
            
            titleEl.textContent = title;
            messageEl.textContent = message;
            dialog.style.display = 'flex';
            
            // Remove old listeners
            const newOkBtn = okBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
            
            // Add new listeners
            newOkBtn.addEventListener('click', function() {
                dialog.style.display = 'none';
                onConfirm();
            });
            
            newCancelBtn.addEventListener('click', function() {
                dialog.style.display = 'none';
            });
        }
        
        function hideConfirmDialog() {
            const dialog = document.getElementById('confirmDialog');
            if (dialog) {
                dialog.style.display = 'none';
            }
        }

        // Back button - shows resume option if there's an active game
        function confirmBackToHome() {
            console.log('confirmBackToHome called:', {
                tournamentMode,
                isHost,
                isCoHost,
                canManage: canManageTournament(),
                activeTournamentId,
                isSignedIn: !!currentAuthUser
            });
            
            // If user is not signed in, prompt to sign in/sign up
            if (!currentAuthUser) {
                showSignInPromptModal();
                return;
            }
            
            // Hosts and co-hosts go to host home page
            if (tournamentMode === 'multi' && canManageTournament()) {
                console.log('-> Going to Host Home Page');
                showHostHomePage();
            }
            // Non-hosts/non-co-hosts go to guest home page
            else if (tournamentMode === 'multi' && !canManageTournament()) {
                console.log('-> Going to Guest Home Page');
                showGuestHomePage();
            } 
            // Single device mode - show a simple round home or go to setup with current data
            else {
                console.log('-> Single device mode - showing round options');
                // For single-device mode, show a confirmation dialog
                if (tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                    // There's an active round - ask what they want to do
                    const choice = confirm('Round in progress.\n\nOK = Resume Scoring\nCancel = Go to Setup (to start new round)');
                    if (choice) {
                        // Resume scoring - just stay on scoring page
                        renderScoringPage();
                        showPage('scoringPage');
                    } else {
                        // Go to setup but clear backup so Cancel doesn't restore old data
                        previousTournamentBackup = null;
                        showPage('setupPage');
                        // Show Resume button
                        const resumeBtn = document.getElementById('resumeScoringBtn');
                        if (resumeBtn) resumeBtn.style.display = 'block';
                        // Cancel button is always visible - user can cancel back to home
                    }
                } else {
                    // No active round - just go to setup
                    showPage('setupPage');
                }
            }
        }
        
        // Show sign-in prompt modal for guests
        function showSignInPromptModal() {
            const existingModal = document.getElementById('signInPromptModal');
            if (existingModal) existingModal.remove();
            
            const modal = document.createElement('div');
            modal.id = 'signInPromptModal';
            modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 10003; display: flex; align-items: center; justify-content: center; padding: 20px;';
            modal.innerHTML = `
                <div style="background: white; border-radius: 12px; max-width: 340px; width: 100%; padding: 24px; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 12px;">🔐</div>
                    <h3 style="color: #1e3a5f; margin: 0 0 8px 0; font-size: 20px;">Sign In Required</h3>
                    <p style="color: #64748b; margin: 0 0 20px 0; font-size: 14px; line-height: 1.5;">
                        Sign in to access your home page, view past rounds, and sync across devices.
                    </p>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button type="button" id="promptSignInBtn"
                            style="width: 100%; padding: 14px; background: #1e3a5f; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; touch-action: manipulation;">
                            Sign In
                        </button>
                        <button type="button" id="promptCreateAccountBtn"
                            style="width: 100%; padding: 14px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; touch-action: manipulation;">
                            Create Account
                        </button>
                        <button type="button" id="promptCancelBtn"
                            style="width: 100%; padding: 12px; background: transparent; color: #64748b; border: none; font-size: 14px; cursor: pointer; touch-action: manipulation;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Add event listeners after appending to DOM
            document.getElementById('promptSignInBtn').addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                modal.remove();
                setTimeout(() => showSignInModal(), 50);
            });
            
            document.getElementById('promptCreateAccountBtn').addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                modal.remove();
                setTimeout(() => showCreateAccountModal(), 50);
            });
            
            document.getElementById('promptCancelBtn').addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                modal.remove();
            });
        }
        
        // Show Host Home Page
        function showHostHomePage() {
            // Populate tournament info
            if (tournamentData) {
                document.getElementById('hostTournamentName').textContent = tournamentData.name || 'Tournament';
                document.getElementById('hostTournamentInfo').textContent = 
                    `${tournamentData.course || ''} • ${formatDateDisplay(tournamentData.date) || ''}`;
            }
            
            // Update device initials display
            updateDeviceInitialsDisplay();
            
            showPage('hostHomePage');
        }
        
        // Update Host Home Page (called when returning to host home)
        function updateHostHomePage() {
            const currentTournamentCard = document.getElementById('hostCurrentTournament');
            
            // Check if we have an active tournament
            if (tournamentData && tournamentData.players && tournamentData.players.length > 0 && activeTournamentId) {
                // Current tournament is handled by populateHomeRoundsList - keep hidden
                if (currentTournamentCard) currentTournamentCard.style.display = 'none';
                
                // Populate tournament info (for compatibility)
                document.getElementById('hostTournamentName').textContent = tournamentData.name || 'Tournament';
                const courseName = courseData?.name || tournamentData.course || '';
                document.getElementById('hostTournamentInfo').textContent = 
                    `${courseName} • ${formatDateDisplay(tournamentData.date) || ''}`;
                
                // Update device initials display - prefer username if signed in
                const initialsEl = document.getElementById('hostDeviceInitials');
                if (initialsEl) {
                    if (currentAuthUser && currentAuthUser.displayName) {
                        initialsEl.textContent = currentAuthUser.displayName;
                    } else if (currentAuthUser && currentAuthUser.email) {
                        initialsEl.textContent = currentAuthUser.email.split('@')[0];
                    } else {
                        initialsEl.textContent = deviceInitials || 'Guest';
                    }
                }
                
                // Update role badge based on user's actual role
                const badge = document.getElementById('hostTournamentBadge');
                const hostInfo = document.getElementById('hostPageHostInfo');
                const hostName = document.getElementById('hostPageHostName');
                
                if (badge) {
                    if (isHost) {
                        badge.textContent = '👑 HOST';
                        badge.style.background = 'white';
                        badge.style.color = '#f97316';
                        badge.style.borderColor = '#f97316';
                        if (hostInfo) hostInfo.style.display = 'none';
                    } else if (canManageTournament()) {
                        badge.textContent = '⭐ CO-HOST';
                        badge.style.background = '#fef3c7';
                        badge.style.color = '#92400e';
                        badge.style.borderColor = '#f59e0b';
                        if (hostInfo) hostInfo.style.display = 'none';
                    } else {
                        badge.textContent = '👤 PLAYER';
                        badge.style.background = '#dbeafe';
                        badge.style.color = '#1e3a5f';
                        badge.style.borderColor = '#1e3a5f';
                        // Show host info for non-hosts
                        if (hostInfo && hostName) {
                            hostInfo.style.display = 'block';
                            hostName.textContent = getHostDisplayName();
                        }
                    }
                }
                
                // Also update Guest Home host info
                updateGuestHomeHostInfo();
            } else {
                // No active tournament - hide the current tournament card
                if (currentTournamentCard) currentTournamentCard.style.display = 'none';
            }
            
            // Always update history count
            updateHistoryCountDisplay();
        }
        
        // Get host display name from tournament data
        function getHostDisplayName() {
            if (!tournamentData) return '--';
            
            // First try hostName (display name saved at creation)
            if (tournamentData.hostName) {
                return tournamentData.hostName;
            }
            
            // Try hostUsername
            if (tournamentData.hostUsername) {
                return tournamentData.hostUsername;
            }
            
            // Fall back to hostDeviceId (device initials)
            if (tournamentData.hostDeviceId) {
                return tournamentData.hostDeviceId;
            }
            
            if (tournamentData.hostDevice) {
                return tournamentData.hostDevice;
            }
            
            return 'Unknown';
        }
        
        // Update Guest Home host info
        function updateGuestHomeHostInfo() {
            const hostNameEl = document.getElementById('guestHostName');
            if (hostNameEl) {
                hostNameEl.textContent = getHostDisplayName();
            }
        }
        
        // Generate smart info line with progressive shortening
        function generateSmartInfoLine(containerId) {
            if (!tournamentData || !courseData) return;
            
            const container = document.getElementById(containerId);
            if (!container) return;
            
            const tournamentName = tournamentData.name || 'Tournament';
            const gameType = tournamentData.gameType || 'Stroke Play';
            const courseName = courseData.name || tournamentData.course;
            const dateStr = formatDateDisplay(tournamentData.date);
            
            // Get course initials (e.g., "Jurupa Hills Country Club" -> "JHCC")
            const courseInitials = courseName.split(' ')
                .map(word => word.charAt(0).toUpperCase())
                .join('');
            
            // Short date format (MM/DD/YY)
            const shortDate = formatShortDate(tournamentData.date);
            
            // Get container width
            const containerWidth = container.parentElement ? container.parentElement.clientWidth - 40 : 300;
            
            // Create a hidden span to measure text width
            const measureSpan = document.createElement('span');
            measureSpan.style.cssText = 'position: absolute; visibility: hidden; white-space: nowrap; font-size: 12px; font-weight: 600;';
            document.body.appendChild(measureSpan);
            
            // Level 1: Full version
            let infoText = `${tournamentName} | ${gameType} | ${courseName} | ${dateStr}`;
            measureSpan.textContent = infoText;
            
            if (measureSpan.offsetWidth > containerWidth) {
                // Level 2: Abbreviate course name
                infoText = `${tournamentName} | ${gameType} | ${courseInitials} | ${dateStr}`;
                measureSpan.textContent = infoText;
                
                if (measureSpan.offsetWidth > containerWidth) {
                    // Level 3: Also shorten date
                    infoText = `${tournamentName} | ${gameType} | ${courseInitials} | ${shortDate}`;
                }
            }
            
            // Clean up
            document.body.removeChild(measureSpan);
            
            container.textContent = infoText;
        }
        
        // Format date as MM/DD/YY
        function formatShortDate(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString + 'T12:00:00');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const year = String(date.getFullYear()).slice(-2);
            return `${month}/${day}/${year}`;
        }

        // Track if we came from Host Home for the back button
        let previousTournamentBackup = null;
        
        // Start a completely new tournament - clear all existing data
        function startNewTournament() {
            // BACKUP current tournament data before clearing (so we can restore if user cancels)
            const currentSaved = localStorage.getItem('indianHillsScoring');
            if (currentSaved) {
                previousTournamentBackup = currentSaved;
            }
            
            // Clear tournament data in memory (but keep backup)
            tournamentData = {
                name: '',
                date: new Date().toISOString().split('T')[0],
                course: '',
                gameType: 'Stroke Play',
                players: [],
                teams: []
            };
            
            // Clear active tournament ID and host status for new tournament
            activeTournamentId = null;
            tournamentMode = 'single'; // Will become multi when started
            isHost = false;
            hasJoinedTournament = false;
            courseData = null;
            
            // Clear player stats
            clearAllPlayerStats();
            
            // DON'T clear localStorage yet - keep it as backup until new tournament is started
            // localStorage.removeItem('indianHillsScoring');
            
            // Reset form fields
            const nameInput = document.getElementById('tournamentName');
            const dateInput = document.getElementById('tournamentDate');
            const courseSelect = document.getElementById('courseSelect');
            const gameType = document.getElementById('gameType');
            const playerList = document.getElementById('playerList');
            
            if (nameInput) nameInput.value = '';
            if (dateInput) dateInput.valueAsDate = new Date();
            if (courseSelect) courseSelect.value = '';
            if (gameType) gameType.value = 'Stroke Play';
            if (playerList) {
                playerList.innerHTML = `
                    <div class="player-row-wrapper">
                        <div class="player-row-delete" onclick="removePlayer(1)">Delete</div>
                        <div class="player-row" data-player="1">
                            <input type="text" class="player-name-input" placeholder="Player Name" id="player1">
                            <input type="text" class="player-hcp-input" placeholder="H.I." id="hcp1" pattern="-?[0-9.]*" inputmode="decimal" oninput="calculatePlayingHandicap(1)">
                            <input type="text" class="player-ph-input" placeholder="P.H." id="ph1" pattern="-?[0-9]*" inputmode="numeric">
                        </div>
                    </div>
                `;
                currentPlayerCount = 1;
                nextPlayerId = 2;
            }
            
            // Navigate to setup page
            showPage('setupPage');
            
            console.log('✅ Started new tournament setup - backup saved:', !!previousTournamentBackup);
        }
        
        // Cancel setup and return to home
        function cancelSetup() {
            goToHomePage();
        }
        
        // Go to appropriate home page based on role
        function goToHomePage() {
            // If we have a backup, restore it
            if (previousTournamentBackup) {
                try {
                    const data = JSON.parse(previousTournamentBackup);
                    
                    // Restore globals
                    activeTournamentId = data._activeTournamentId;
                    tournamentMode = data._tournamentMode || 'multi';
                    isHost = data._isHost || true;
                    hasJoinedTournament = true;
                    
                    // Restore tournament data
                    const metadataKeys = ['_activeTournamentId', '_tournamentMode', '_isHost', '_hostForTournament', 
                                        '_hasJoinedTournament', '_hostViewMode', '_scoreTimestamps', '_deletedPlayers', '_lastSaved'];
                    metadataKeys.forEach(key => delete data[key]);
                    tournamentData = data;
                    courseData = courses[tournamentData.course] || customCourses[tournamentData.course];
                    
                    // Reconnect to Firebase
                    if (activeTournamentId) {
                        subscribToTournamentUpdates(activeTournamentId);
                    }
                    
                    // Clear backup
                    previousTournamentBackup = null;
                    
                    // Navigate to correct home page
                    goToCorrectHomePage();
                    return;
                } catch (e) {
                    console.error('Error restoring backup:', e);
                }
            }
            
            // Fallback - check current state and go to correct home page
            if (activeTournamentId && tournamentData && tournamentData.name) {
                goToCorrectHomePage();
            } else if (hasJoinedTournament && activeTournamentId) {
                showGuestHomePage();
            } else {
                // No active tournament - show guest home in "no tournament" state
                showGuestHomeNoTournament();
            }
        }
        
        // Show guest home page with NO active tournament
        function showGuestHomeNoTournament() {
            // Hide Enter Tournament card
            const enterCard = document.getElementById('enterTournamentCard');
            if (enterCard) enterCard.style.display = 'none';
            
            // Hide Current Tournament card
            const currentTournamentCard = document.getElementById('guestCurrentTournament');
            if (currentTournamentCard) currentTournamentCard.style.display = 'none';
            
            // Hide Load Tournament card (handled by populateHomeRoundsList now)
            const loadTournamentCard = document.getElementById('loadTournamentCard');
            if (loadTournamentCard) loadTournamentCard.style.display = 'none';
            
            // Update device initials display
            updateDeviceInitialsDisplay();
            
            // Update tournament history count
            updateHistoryCountDisplay();
            
            showPage('guestHomePage');
        }
        
        // Go to correct home page based on isHost status (for navigation from any page)
        function goToCorrectHomePage() {
            // Hosts and co-hosts go to host home page
            if (isHost || canManageTournament()) {
                updateHostHomePage();
                const currentTournamentCard = document.getElementById('hostCurrentTournament');
                if (currentTournamentCard) {
                    currentTournamentCard.style.display = 'none';
                }
                showPage('hostHomePage');
            } else {
                showGuestHomePage();
            }
        }
        
        // Clear all player stats from localStorage
        function clearAllPlayerStats() {
            playerStats = {};
            localStorage.removeItem('playerStats');
            console.log('✅ Player stats cleared');
        }
        
        function confirmBackToSetup() {
            console.log('=== CONFIRM BACK TO SETUP ===');
            console.log('tournamentMode:', tournamentMode);
            console.log('activeTournamentId:', activeTournamentId);
            console.log('isHost:', isHost);
            
            showPage('setupPage');
            
            // Show Resume Scoring button if there are active scores
            if (tournamentData.players && tournamentData.players.length > 0) {
                const resumeBtn = document.getElementById('resumeScoringBtn');
                if (resumeBtn) {
                    resumeBtn.style.display = 'block';
                }
            }
            
            // FORCE share buttons check after a moment (for iOS)
            setTimeout(() => {
                console.log('🔍 Checking share buttons after back to setup...');
                const shareButtons = document.getElementById('resumeShareButtons');
                console.log('  shareButtons element:', shareButtons);
                console.log('  display:', shareButtons?.style.display);
                console.log('  visibility:', shareButtons?.style.visibility);
                console.log('  classList:', shareButtons?.classList);
                
                if (tournamentMode === 'multi' && activeTournamentId && shareButtons) {
                    console.log('  🔧 FORCING VISIBLE');
                    shareButtons.classList.add('visible');
                    shareButtons.style.setProperty('display', 'grid', 'important');
                    shareButtons.style.setProperty('visibility', 'visible', 'important');
                }
            }, 100);
        }

        // Resume scoring - go back to scoring page with existing data
        function resumeScoring() {
            // Check for identity matches before going to scoring
            checkAndPromptForIdentityMatch(() => {
                renderScoringPage();
                showPage('scoringPage');
                
                // Start in Holes view by default
                switchToHoleView();
            });
        }

        // Start scoring from setup page
        // ========================================
        // TOURNAMENT MODE SELECTION & UI HANDLERS
        // ========================================
        
        let tournamentMode = 'multi'; // Always multi-device mode now
        let isOnline = navigator.onLine; // Track connection status
        
        // Connection status monitoring
        function updateConnectionStatus() {
            isOnline = navigator.onLine;
            const dot = document.getElementById('connectionDot');
            const text = document.getElementById('connectionText');
            const statusContainer = document.getElementById('connectionStatus');
            const scoringDot = document.getElementById('scoringConnectionDot');
            const setupDot = document.getElementById('setupConnectionDot');
            
            if (dot && text) {
                if (isOnline) {
                    dot.style.background = '#166534';
                    text.textContent = 'Online - Scores sync across devices';
                    if (statusContainer) statusContainer.style.background = 'rgba(16, 185, 129, 0.2)';
                } else {
                    dot.style.background = '#a51c30';
                    text.textContent = 'Offline - Scores saved locally';
                    if (statusContainer) statusContainer.style.background = 'rgba(239, 68, 68, 0.2)';
                }
            }
            
            // Update scoring page dot
            if (scoringDot) {
                scoringDot.style.background = isOnline ? '#166534' : '#a51c30';
                scoringDot.title = isOnline ? 'Online - Syncing' : 'Offline - Local only';
            }
            
            // Update setup page dot
            if (setupDot) {
                setupDot.style.background = isOnline ? '#166534' : '#a51c30';
                setupDot.title = isOnline ? 'Online' : 'Offline';
            }
            
            // Also update management page status if visible
            updateManagementConnectionStatus();
        }
        
        function updateManagementConnectionStatus() {
            const manageDot = document.getElementById('manageConnectionDot');
            const manageText = document.getElementById('manageConnectionText');
            
            if (manageDot && manageText) {
                if (isOnline) {
                    manageDot.style.background = '#166534';
                    manageText.textContent = 'Connected - Real-time sync active';
                    manageText.style.color = '#166534';
                } else {
                    manageDot.style.background = '#a51c30';
                    manageText.textContent = 'Offline - Changes saved locally';
                    manageText.style.color = '#991b1b';
                }
            }
        }
        
        // Listen for online/offline events
        window.addEventListener('online', () => {
            updateConnectionStatus();
            showNotification('Back Online', 'Syncing scores...');
            // Try to sync any pending changes
            if (activeTournamentId && tournamentData) {
                saveToLocalStorage();
            }
        });
        
        window.addEventListener('offline', () => {
            updateConnectionStatus();
            showNotification('Offline', 'Scores will be saved locally');
        });
        
        // Initialize connection status on page load
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(updateConnectionStatus, 500);
            initializeCourseDropdown();
            loadNotificationMuteState();
            loadAutoAdvanceSetting();
            loadGolfIdentity(); // Load golf identity for stats tracking
            
            // Populate home page rounds list
            setTimeout(populateHomeRoundsList, 100);
            
            // Check if returning from Stripe payment
            setTimeout(checkPaymentReturn, 1000);
            
            // CRITICAL: Check for saved round and navigate to appropriate home page
            // Delay slightly to ensure Firebase is initialized
            setTimeout(() => {
                checkForSavedRound(true);
            }, 300);
        });
        
        function selectScoringMode(mode) {
            // Always use multi-device mode now
            tournamentMode = 'multi';
            requestNotificationPermission();
        }
        
        // ==================== JOIN BY CODE UI FUNCTIONS ====================
        
        // Show Join By Code Modal (from home page)
        function showJoinByCodeModal() {
            // Create modal if it doesn't exist
            let modal = document.getElementById('joinByCodeModalOverlay');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'joinByCodeModalOverlay';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.7);
                    z-index: 10001;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 20px;
                `;
                modal.innerHTML = `
                    <div style="background: white; border-radius: 4px; padding: 24px; max-width: 340px; width: 100%; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.15);">
                        <h3 style="color: #1e3a5f; margin: 0 0 8px 0; font-size: 20px; font-weight: 700;">🏌️ Join Round</h3>
                        <p style="color: #6b7280; font-size: 13px; margin: 0 0 16px 0;">Enter code from host or IHMC event</p>
                        
                        <input type="text" id="modalJoinCodeInput" 
                            placeholder="GOLF42 or IHMC-0215-P7K3" 
                            maxlength="16"
                            oninput="this.value = this.value.toUpperCase(); validateModalJoinCode();"
                            style="width: 100%; padding: 14px; font-size: 18px; text-align: center; border: 1.5px solid #1e3a5f; border-radius: 4px; letter-spacing: 2px; font-weight: 700; text-transform: uppercase; margin-bottom: 8px; color: #1e3a5f;">
                        
                        <p id="modalJoinCodeError" style="color: #a51c30; font-size: 12px; margin: 0 0 16px 0; min-height: 16px;"></p>
                        
                        <div style="display: flex; gap: 10px;">
                            <button id="modalJoinCodeBtn" onclick="submitModalJoinCode()" disabled style="flex: 1; padding: 12px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer; opacity: 0.5;">
                                Join
                            </button>
                            <button onclick="hideJoinByCodeModal()" style="flex: 1; padding: 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">
                                Cancel
                            </button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            } else {
                modal.style.display = 'flex';
            }
            
            // Clear and focus input
            const input = document.getElementById('modalJoinCodeInput');
            if (input) {
                input.value = '';
                setTimeout(() => input.focus(), 100);
            }
            
            // Clear error
            const errorEl = document.getElementById('modalJoinCodeError');
            if (errorEl) errorEl.textContent = '';
            
            // Reset button
            const btn = document.getElementById('modalJoinCodeBtn');
            if (btn) {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.textContent = 'Join';
            }
        }
        
        // Hide Join By Code Modal
        function hideJoinByCodeModal() {
            const modal = document.getElementById('joinByCodeModalOverlay');
            if (modal) modal.style.display = 'none';
        }
        
        // Validate modal join code input
        function validateModalJoinCode() {
            const input = document.getElementById('modalJoinCodeInput');
            const btn = document.getElementById('modalJoinCodeBtn');
            
            if (!input || !btn) return;
            
            const code = input.value.trim();
            const isValid = isValidJoinCodeFormat(code);
            
            btn.disabled = !isValid;
            btn.style.opacity = isValid ? '1' : '0.5';
            
            // Clear error when typing
            const errorEl = document.getElementById('modalJoinCodeError');
            if (errorEl) errorEl.textContent = '';
        }
        
        // Submit modal join code
        async function submitModalJoinCode() {
            const input = document.getElementById('modalJoinCodeInput');
            const btn = document.getElementById('modalJoinCodeBtn');
            const errorEl = document.getElementById('modalJoinCodeError');
            
            if (!input) return;
            
            const code = input.value.trim().toUpperCase();
            
            // Validate format
            if (!isValidJoinCodeFormat(code)) {
                if (errorEl) errorEl.textContent = 'Enter code (e.g., GOLF42 or IHMC-0215-P7K3)';
                return;
            }
            
            // Show loading state
            btn.disabled = true;
            btn.textContent = '...';
            if (errorEl) errorEl.textContent = '';
            
            try {
                const result = await findTournamentByCode(code);
                
                if (result.success) {
                    // Hide modal
                    hideJoinByCodeModal();
                    
                    // Check if this is an IHMC event
                    if (result.isIHMCEvent) {
                        showIHMCJoinScreen(result);
                    } else {
                        // Navigate to join tournament screen
                        showJoinTournamentScreen(result.tournamentId);
                    }
                } else {
                    if (errorEl) errorEl.textContent = result.error || 'Tournament not found';
                }
            } catch (error) {
                console.error('Error joining by code:', error);
                if (errorEl) errorEl.textContent = 'Something went wrong. Please try again.';
            } finally {
                // Reset button
                btn.disabled = false;
                btn.textContent = 'Join';
                validateModalJoinCode();
            }
        }
        
        // Validate join code input and enable/disable button
        function validateJoinCodeInput() {
            const input = document.getElementById('joinCodeInput');
            const btn = document.getElementById('joinByCodeBtn');
            const errorEl = document.getElementById('joinCodeInputError');
            
            if (!input || !btn) return;
            
            const code = input.value.trim();
            const isValid = isValidJoinCodeFormat(code);
            
            btn.disabled = !isValid;
            btn.style.opacity = isValid ? '1' : '0.5';
            
            // Clear error when typing
            if (errorEl) errorEl.textContent = '';
        }
        
        // Join tournament by code
        async function joinByCode() {
            const input = document.getElementById('joinCodeInput');
            const btn = document.getElementById('joinByCodeBtn');
            const errorEl = document.getElementById('joinCodeInputError');
            
            if (!input) return;
            
            const code = input.value.trim();
            
            // Validate format
            if (!isValidJoinCodeFormat(code)) {
                if (errorEl) errorEl.textContent = 'Enter code (e.g., GOLF42 or IHMC-0215-P7K3)';
                return;
            }
            
            // Show loading state
            btn.disabled = true;
            btn.textContent = '...';
            if (errorEl) errorEl.textContent = '';
            
            try {
                const result = await findTournamentByCode(code);
                
                if (result.success) {
                    // Clear input
                    input.value = '';
                    validateJoinCodeInput();
                    
                    // Check if this is an IHMC event
                    if (result.isIHMCEvent) {
                        showIHMCJoinScreen(result);
                    } else {
                        // Navigate to join tournament screen
                        showJoinTournamentScreen(result.tournamentId);
                    }
                } else {
                    if (errorEl) errorEl.textContent = result.error;
                }
            } catch (error) {
                console.error('Error joining by code:', error);
                if (errorEl) errorEl.textContent = 'Something went wrong. Please try again.';
            } finally {
                // Reset button
                btn.disabled = false;
                btn.textContent = 'Join';
                validateJoinCodeInput();
            }
        }
        
        // ==================== END JOIN BY CODE UI FUNCTIONS ====================
        
        // ==================== GUEST/HOST HOME JOIN BY CODE ====================
        
        // Validate guest join code input
        function validateGuestJoinCode() {
            const input = document.getElementById('guestJoinCodeInput');
            const btn = document.getElementById('guestJoinCodeBtn');
            
            if (!input || !btn) return;
            
            const code = input.value.trim();
            const isValid = isValidJoinCodeFormat(code);
            
            btn.disabled = !isValid;
            btn.style.opacity = isValid ? '1' : '0.5';
            
            // Clear error when typing
            const errorEl = document.getElementById('guestJoinCodeError');
            if (errorEl) errorEl.textContent = '';
        }
        
        // Guest join by code
        async function guestJoinByCode() {
            const input = document.getElementById('guestJoinCodeInput');
            const btn = document.getElementById('guestJoinCodeBtn');
            const errorEl = document.getElementById('guestJoinCodeError');
            
            if (!input) return;
            
            const code = input.value.trim();
            
            if (!isValidJoinCodeFormat(code)) {
                if (errorEl) errorEl.textContent = 'Enter code (e.g., GOLF42 or IHMC code)';
                return;
            }
            
            btn.disabled = true;
            btn.textContent = '...';
            if (errorEl) errorEl.textContent = '';
            
            try {
                const result = await findTournamentByCode(code);
                
                if (result.success) {
                    input.value = '';
                    validateGuestJoinCode();
                    if (result.isIHMCEvent) {
                        showIHMCJoinScreen(result);
                    } else {
                        showJoinTournamentScreen(result.tournamentId);
                    }
                } else {
                    if (errorEl) errorEl.textContent = result.error;
                }
            } catch (error) {
                console.error('Error:', error);
                if (errorEl) errorEl.textContent = 'Something went wrong. Try again.';
            } finally {
                btn.disabled = false;
                btn.textContent = 'Join';
                validateGuestJoinCode();
            }
        }
        
        // Validate host join code input
        function validateHostJoinCode() {
            const input = document.getElementById('hostJoinCodeInput');
            const btn = document.getElementById('hostJoinCodeBtn');
            
            if (!input || !btn) return;
            
            const code = input.value.trim();
            const isValid = isValidJoinCodeFormat(code);
            
            btn.disabled = !isValid;
            btn.style.opacity = isValid ? '1' : '0.5';
            
            const errorEl = document.getElementById('hostJoinCodeError');
            if (errorEl) errorEl.textContent = '';
        }
        
        // Host join by code
        async function hostJoinByCode() {
            const input = document.getElementById('hostJoinCodeInput');
            const btn = document.getElementById('hostJoinCodeBtn');
            const errorEl = document.getElementById('hostJoinCodeError');
            
            if (!input) return;
            
            const code = input.value.trim();
            
            if (!isValidJoinCodeFormat(code)) {
                if (errorEl) errorEl.textContent = 'Enter code (e.g., GOLF42 or IHMC code)';
                return;
            }
            
            btn.disabled = true;
            btn.textContent = '...';
            if (errorEl) errorEl.textContent = '';
            
            try {
                const result = await findTournamentByCode(code);
                
                if (result.success) {
                    input.value = '';
                    validateHostJoinCode();
                    if (result.isIHMCEvent) {
                        showIHMCJoinScreen(result);
                    } else {
                        showJoinTournamentScreen(result.tournamentId);
                    }
                } else {
                    if (errorEl) errorEl.textContent = result.error;
                }
            } catch (error) {
                console.error('Error:', error);
                if (errorEl) errorEl.textContent = 'Something went wrong. Try again.';
            } finally {
                btn.disabled = false;
                btn.textContent = 'Join';
                validateHostJoinCode();
            }
        }
        
        // ==================== TOURNAMENT HISTORY ====================
        
        const MAX_TOURNAMENT_HISTORY = 20;
        
        // Get tournament history from localStorage
        function getTournamentHistory() {
            try {
                const history = localStorage.getItem('tournamentHistory');
                return history ? JSON.parse(history) : [];
            } catch (error) {
                console.error('Error reading tournament history:', error);
                return [];
            }
        }
        
        // Save tournament history to localStorage AND Firebase (if signed in)
        function saveTournamentHistory(history) {
            try {
                localStorage.setItem('tournamentHistory', JSON.stringify(history));
                
                // Also sync to Firebase if user is signed in
                if (currentAuthUser && db) {
                    syncTournamentHistoryToFirebase(history);
                }
            } catch (error) {
                console.error('Error saving tournament history:', error);
            }
        }
        
        // Sync tournament history to Firebase for cross-device access
        async function syncTournamentHistoryToFirebase(history) {
            if (!currentAuthUser || !db) return;
            
            try {
                const userRef = db.collection('users').doc(currentAuthUser.uid);
                await userRef.set({
                    tournamentHistory: history,
                    lastHistorySync: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
                console.log('📤 Tournament history synced to Firebase');
            } catch (error) {
                console.error('Error syncing tournament history to Firebase:', error);
            }
        }
        
        // Load tournament history from Firebase and merge with localStorage
        async function loadTournamentHistoryFromFirebase() {
            if (!currentAuthUser || !db) return;
            
            try {
                const userDoc = await db.collection('users').doc(currentAuthUser.uid).get();
                
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    const firebaseHistory = userData.tournamentHistory || [];
                    
                    if (firebaseHistory.length > 0) {
                        // Merge Firebase history with local history
                        const localHistory = getTournamentHistory();
                        const mergedHistory = mergeTournamentHistories(localHistory, firebaseHistory);
                        
                        // Save merged history to localStorage (don't re-sync to avoid loop)
                        localStorage.setItem('tournamentHistory', JSON.stringify(mergedHistory));
                        
                        console.log('📥 Tournament history loaded from Firebase:', firebaseHistory.length, 'tournaments');
                        console.log('🔀 Merged history:', mergedHistory.length, 'tournaments');
                        
                        // Refresh home page to show synced tournaments
                        populateHomeRoundsList();
                    }
                }
            } catch (error) {
                console.error('Error loading tournament history from Firebase:', error);
            }
        }
        
        // Merge two tournament histories, keeping the most recent entry for each tournament
        function mergeTournamentHistories(localHistory, firebaseHistory) {
            const merged = new Map();
            
            // Add all local tournaments
            for (const t of localHistory) {
                merged.set(t.id, t);
            }
            
            // Add/update with Firebase tournaments (prefer more recent lastAccess)
            for (const t of firebaseHistory) {
                const existing = merged.get(t.id);
                if (!existing || (t.lastAccess && t.lastAccess > (existing.lastAccess || 0))) {
                    merged.set(t.id, t);
                }
            }
            
            // Convert back to array and sort by lastAccess (most recent first)
            const result = Array.from(merged.values());
            result.sort((a, b) => (b.lastAccess || 0) - (a.lastAccess || 0));
            
            // Keep only last N tournaments
            return result.slice(0, MAX_TOURNAMENT_HISTORY);
        }
        
        // Add tournament to history (called when joining/creating)
        function addToTournamentHistory(tournamentInfo) {
            const history = getTournamentHistory();
            
            // Remove existing entry for this tournament if present
            const filteredHistory = history.filter(t => t.id !== tournamentInfo.id);
            
            // Add new entry at the beginning
            const newEntry = {
                id: tournamentInfo.id,
                joinCode: tournamentInfo.joinCode || '',
                name: tournamentInfo.name || 'Unnamed Tournament',
                course: tournamentInfo.course || '',
                courseName: tournamentInfo.courseName || getCourseDisplayName(tournamentInfo.course),
                date: tournamentInfo.date || new Date().toISOString().split('T')[0],
                gameType: tournamentInfo.gameType || '',
                playerCount: tournamentInfo.playerCount || 0,
                role: tournamentInfo.role || 'player', // 'host', 'player', 'viewer'
                isFinished: tournamentInfo.isFinished || false,
                lastAccess: Date.now()
            };
            
            filteredHistory.unshift(newEntry);
            
            // Keep only last N tournaments
            const trimmedHistory = filteredHistory.slice(0, MAX_TOURNAMENT_HISTORY);
            
            saveTournamentHistory(trimmedHistory);
            updateHistoryCountDisplay();
            
            return trimmedHistory;
        }
        
        // Remove tournament from history
        function removeFromTournamentHistory(tournamentId) {
            const history = getTournamentHistory();
            const filteredHistory = history.filter(t => t.id !== tournamentId);
            saveTournamentHistory(filteredHistory);
            updateHistoryCountDisplay();
            return filteredHistory;
        }
        
        // Clear all tournament history
        function clearTournamentHistory() {
            saveTournamentHistory([]);
            updateHistoryCountDisplay();
        }
        
        // Get course display name helper
        function getCourseDisplayName(courseKey) {
            const courseNames = {
                'green_river': 'Green River GC',
                'hidden_valley': 'Hidden Valley GC',
                'indian_hills': 'Indian Hills GC',
                'jurupa_hills': 'Jurupa Hills CC',
                'shandin_hills': 'Shandin Hills GC'
            };
            return courseNames[courseKey] || courseKey || 'Unknown Course';
        }
        
        // Update history count display on Guest Home and Host Home
        function updateHistoryCountDisplay() {
            const history = getTournamentHistory();
            const countText = history.length > 0 
                ? `${history.length} tournament${history.length !== 1 ? 's' : ''} saved`
                : 'No saved tournaments';
            
            // Update guest home page
            const countEl = document.getElementById('historyCount');
            if (countEl) {
                countEl.textContent = countText;
            }
            
            // Update host home page
            const hostCountEl = document.getElementById('hostHistoryCount');
            if (hostCountEl) {
                hostCountEl.textContent = countText;
            }
            
            // Update setup page
            const setupCountEl = document.getElementById('setupHistoryCount');
            if (setupCountEl) {
                setupCountEl.textContent = countText;
            }
        }
        
        function populateHomeRoundsList() {
            const history = getTournamentHistory();
            
            // Get elements for both guest and host pages
            const currentBox = document.getElementById('homeCurrentTournament');
            const currentContent = document.getElementById('homeCurrentTournamentContent');
            const pastList = document.getElementById('homeRoundsList');
            const pastBox = document.getElementById('homePastTournaments');
            
            const hostCurrentBox = document.getElementById('hostHomeCurrentTournament');
            const hostCurrentContent = document.getElementById('hostHomeCurrentTournamentContent');
            const hostPastList = document.getElementById('hostHomeRoundsList');
            const hostPastBox = document.getElementById('hostHomePastTournaments');
            
            // If signed out, hide all tournament sections
            if (!currentAuthUser) {
                if (currentBox) currentBox.style.display = 'none';
                if (hostCurrentBox) hostCurrentBox.style.display = 'none';
                if (pastBox) pastBox.style.display = 'none';
                if (hostPastBox) hostPastBox.style.display = 'none';
                if (pastList) pastList.innerHTML = '';
                if (hostPastList) hostPastList.innerHTML = '';
                return;
            }
            
            // Check if there's an active tournament in progress
            const hasActiveTournament = activeTournamentId && tournamentData && tournamentData.players && tournamentData.players.length > 0;
            
            // Show tournament sections (user is signed in)
            if (pastBox) pastBox.style.display = 'block';
            if (hostPastBox) hostPastBox.style.display = 'block';
            
            // Handle Current Tournament Box
            if (hasActiveTournament) {
                const currentCardHTML = createCurrentRoundCardHTML();
                
                if (currentBox && currentContent) {
                    currentBox.style.display = 'block';
                    currentContent.innerHTML = currentCardHTML;
                    // Attach event listeners
                    const resumeBtn = currentContent.querySelector('.current-resume-btn');
                    const leaveBtn = currentContent.querySelector('.current-leave-btn');
                    if (resumeBtn) resumeBtn.onclick = () => showPage('scoringPage');
                    if (leaveBtn) leaveBtn.onclick = () => confirmLeaveTournament();
                }
                
                if (hostCurrentBox && hostCurrentContent) {
                    hostCurrentBox.style.display = 'block';
                    hostCurrentContent.innerHTML = currentCardHTML;
                    // Attach event listeners
                    const resumeBtn = hostCurrentContent.querySelector('.current-resume-btn');
                    const leaveBtn = hostCurrentContent.querySelector('.current-leave-btn');
                    if (resumeBtn) resumeBtn.onclick = () => showPage('scoringPage');
                    if (leaveBtn) leaveBtn.onclick = () => confirmLeaveTournament();
                }
            } else {
                if (currentBox) currentBox.style.display = 'none';
                if (hostCurrentBox) hostCurrentBox.style.display = 'none';
            }
            
            // Filter out the current tournament from history
            const filteredHistory = hasActiveTournament 
                ? history.filter(h => h.id !== activeTournamentId)
                : history;
            
            // Handle Past Tournaments Box (only if signed in)
            // Handle Past Tournaments Box
            if (filteredHistory.length === 0) {
                if (pastList) pastList.innerHTML = '<p style="color: #6b7280; font-size: 12px; text-align: center; padding: 12px 0;">No past rounds yet</p>';
                if (hostPastList) hostPastList.innerHTML = '<p style="color: #6b7280; font-size: 12px; text-align: center; padding: 12px 0;">No past rounds yet</p>';
            } else {
                // Show up to 5 most recent rounds
                const recentRounds = filteredHistory.slice(0, 5);
                
                if (pastList) {
                    pastList.innerHTML = '';
                    recentRounds.forEach(round => {
                        pastList.appendChild(createPastRoundCard(round));
                    });
                    initHomeSwipeToDelete(pastList);
                }
                
                if (hostPastList) {
                    hostPastList.innerHTML = '';
                    recentRounds.forEach(round => {
                        hostPastList.appendChild(createPastRoundCard(round));
                    });
                    initHomeSwipeToDelete(hostPastList);
                }
            }
        }
        
        // Create HTML for current round (no swipe)
        function createCurrentRoundCardHTML() {
            const courseName = tournamentData.courseName || getCourseDisplayName(tournamentData.course) || '';
            const dateStr = tournamentData.date ? formatShortDate(tournamentData.date) : '';
            const roundName = tournamentData.name || 'Tournament';
            const roleIcon = isHost ? '👑' : '🏌️';
            
            return `
                <div style="display: flex; align-items: center; gap: 10px;">
                    <div style="font-size: 20px; flex-shrink: 0;">${roleIcon}</div>
                    <div style="flex: 1; min-width: 0;">
                        <div style="font-weight: 600; color: #111827; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${roundName}
                        </div>
                        <div style="color: #64748b; font-size: 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${courseName}${courseName && dateStr ? ' • ' : ''}${dateStr}
                        </div>
                    </div>
                    <div style="display: flex; gap: 6px; flex-shrink: 0;">
                        <button class="current-resume-btn" style="padding: 8px 14px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">
                            Resume
                        </button>
                        <button class="current-leave-btn" style="padding: 8px 10px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">
                            Leave
                        </button>
                    </div>
                </div>
            `;
        }
        
        // Create past round card with swipe-to-delete
        function createPastRoundCard(round) {
            const container = document.createElement('div');
            container.className = 'past-round-swipe-container';
            container.dataset.roundId = round.id;
            container.style.cssText = `
                position: relative;
                overflow: hidden;
                border-radius: 8px;
                margin-bottom: 8px;
            `;
            
            const dateStr = round.date ? formatShortDate(round.date) : '';
            const courseName = round.courseName || getCourseDisplayName(round.course) || '';
            const roundName = round.name || 'Unnamed Round';
            const roleIcon = round.role === 'host' ? '👑' : '🏌️';
            
            container.innerHTML = `
                <!-- Delete button - positioned absolute, will be revealed when content slides left -->
                <div class="swipe-delete-btn" style="
                    position: absolute; 
                    right: 0; 
                    top: 0; 
                    bottom: 0; 
                    width: 70px; 
                    background: #a51c30; 
                    display: flex; 
                    align-items: center; 
                    justify-content: center; 
                    color: white; 
                    font-weight: 600; 
                    font-size: 12px; 
                    cursor: pointer;
                    z-index: 1;
                " onclick="deletePastRound('${round.id}')">
                    Delete
                </div>
                
                <!-- Card content - covers full width, slides left to reveal delete -->
                <div class="past-round-content" style="
                    background: #e8e8e8;
                    border-radius: 8px;
                    padding: 10px 12px;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    position: relative;
                    z-index: 2;
                    transform: translateX(0);
                    transition: transform 0.2s ease-out;
                    width: 100%;
                    box-sizing: border-box;
                ">
                    <div style="font-size: 16px; flex-shrink: 0;">${roleIcon}</div>
                    <div style="flex: 1; min-width: 0; overflow: hidden;">
                        <div style="font-weight: 600; color: #111827; font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${roundName}
                        </div>
                        <div style="color: #6b7280; font-size: 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${courseName}${courseName && dateStr ? ' • ' : ''}${dateStr}
                        </div>
                    </div>
                    <div style="display: flex; gap: 6px; flex-shrink: 0;">
                        <button class="results-btn" style="padding: 6px 10px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer;">
                            Results
                        </button>
                    </div>
                </div>
            `;
            
            // Attach event listeners
            const reopenBtn = container.querySelector('.reopen-btn');
            const resultsBtn = container.querySelector('.results-btn');
            
            if (reopenBtn) reopenBtn.onclick = (e) => { e.stopPropagation(); resumeRound(round.id); };
            if (resultsBtn) resultsBtn.onclick = (e) => { e.stopPropagation(); viewRoundResults(round.id); };
            
            return container;
        }
        
        // Initialize swipe-to-delete for home page past rounds
        function initHomeSwipeToDelete(container) {
            if (!container) return;
            
            const cards = container.querySelectorAll('.past-round-swipe-container');
            
            cards.forEach(card => {
                const content = card.querySelector('.past-round-content');
                if (!content) return;
                
                let startX = 0;
                let startY = 0;
                let currentX = 0;
                let isSwiping = false;
                let isHorizontalSwipe = null;
                
                content.addEventListener('touchstart', (e) => {
                    // Don't initiate swipe if touching a button
                    if (e.target.closest('button')) {
                        isSwiping = false;
                        return;
                    }
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    currentX = startX;
                    isSwiping = true;
                    isHorizontalSwipe = null;
                    content.style.transition = 'none';
                }, { passive: true });
                
                content.addEventListener('touchmove', (e) => {
                    if (!isSwiping) return;
                    currentX = e.touches[0].clientX;
                    const currentY = e.touches[0].clientY;
                    const diffX = currentX - startX;
                    const diffY = currentY - startY;
                    
                    // Determine swipe direction on first significant movement
                    if (isHorizontalSwipe === null && (Math.abs(diffX) > 10 || Math.abs(diffY) > 10)) {
                        isHorizontalSwipe = Math.abs(diffX) > Math.abs(diffY);
                    }
                    
                    // Only allow left swipe if horizontal and significant movement
                    if (isHorizontalSwipe && diffX < -15) {
                        const translateX = Math.max(diffX, -70);
                        content.style.transform = `translateX(${translateX}px)`;
                    }
                }, { passive: true });
                
                content.addEventListener('touchend', () => {
                    if (!isSwiping) return;
                    isSwiping = false;
                    content.style.transition = 'transform 0.2s ease-out';
                    
                    const diff = currentX - startX;
                    // Require more movement (-50px) to trigger delete reveal
                    if (isHorizontalSwipe && diff < -50) {
                        // Reveal delete button
                        content.style.transform = 'translateX(-70px)';
                        card.classList.add('swiped');
                    } else {
                        // Snap back
                        content.style.transform = 'translateX(0)';
                        card.classList.remove('swiped');
                    }
                    
                    startX = 0;
                    startY = 0;
                    currentX = 0;
                    isHorizontalSwipe = null;
                });
            });
            
            // Close any open swipe when tapping elsewhere
            document.addEventListener('touchstart', (e) => {
                if (!e.target.closest('.past-round-swipe-container')) {
                    cards.forEach(card => {
                        const content = card.querySelector('.past-round-content');
                        if (content && card.classList.contains('swiped')) {
                            content.style.transform = 'translateX(0)';
                            card.classList.remove('swiped');
                        }
                    });
                }
            });
        }
        
        // Delete a past round from history
        function deletePastRound(roundId) {
            showModal(
                '🗑️ Delete Round',
                `<p style="margin-bottom: 16px;">Are you sure you want to delete this round from your history?</p>
                <p style="font-size: 12px; color: #64748b;">This will only remove it from your device. The tournament data will still exist if others are using it.</p>`,
                `<div style="display: flex; gap: 8px;">
                    <button onclick="closeModal()" style="flex: 1; padding: 12px; background: #e5e7eb; color: #374151; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">Cancel</button>
                    <button onclick="confirmDeletePastRound('${roundId}')" style="flex: 1; padding: 12px; background: #a51c30; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">Delete</button>
                </div>`,
                false
            );
        }
        
        // Confirm and execute delete
        function confirmDeletePastRound(roundId) {
            let history = getTournamentHistory();
            history = history.filter(h => h.id !== roundId);
            localStorage.setItem('tournamentHistory', JSON.stringify(history));
            closeModal();
            populateHomeRoundsList();
            showNotification('Deleted', 'Round removed from history');
        }
        
        // Format date as "Mon DD" format
        function formatShortDate(dateStr) {
            if (!dateStr) return '';
            try {
                const date = new Date(dateStr);
                return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            } catch (e) {
                return dateStr;
            }
        }
        
        // Resume a round from history
        async function resumeRound(tournamentId) {
            if (!tournamentId) {
                showNotification('Error', 'Invalid tournament');
                return;
            }
            
            console.log('🔄 Resuming round:', tournamentId);
            
            // Try to load from Firebase first
            let foundInFirebase = false;
            if (db) {
                try {
                    const doc = await db.collection('tournaments').doc(tournamentId).get();
                    if (doc.exists) {
                        const data = doc.data();
                        activeTournamentId = tournamentId;
                        tournamentData = {
                            id: tournamentId,
                            ...data
                        };
                        
                        // Check if user is host
                        const history = getTournamentHistory();
                        const historyEntry = history.find(h => h.id === tournamentId);
                        isHost = historyEntry?.role === 'host';
                        
                        // Set course data
                        courseData = courses[tournamentData.course] || customCourses[tournamentData.course];
                        
                        localStorage.setItem('activeTournamentId', tournamentId);
                        tournamentMode = 'multi';
                        
                        // Setup real-time listeners
                        subscribToTournamentUpdates(tournamentId);
                        
                        showPage('scoringPage');
                        foundInFirebase = true;
                        return;
                    } else {
                        console.log('📭 Tournament not found in Firebase');
                    }
                } catch (error) {
                    console.error('Error loading tournament from Firebase:', error);
                }
            }
            
            // Fallback: Try to load from localStorage
            console.log('📂 Trying localStorage fallback...');
            const savedData = localStorage.getItem('indianHillsScoring');
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    console.log('📦 Local data found, checking ID match:', data._activeTournamentId, data.id, 'vs', tournamentId);
                    if (data._activeTournamentId === tournamentId || data.id === tournamentId) {
                        // Load from local storage
                        activeTournamentId = tournamentId;
                        
                        // Extract metadata
                        const metadataKeys = ['_activeTournamentId', '_tournamentMode', '_isHost', '_hostForTournament', 
                                            '_hasJoinedTournament', '_hostViewMode', '_scoreTimestamps', '_deletedPlayers', '_lastSaved'];
                        
                        isHost = data._isHost || false;
                        tournamentMode = data._tournamentMode || 'single';
                        
                        // Remove metadata from tournamentData
                        const cleanData = {...data};
                        metadataKeys.forEach(key => delete cleanData[key]);
                        tournamentData = cleanData;
                        
                        // Set course data
                        courseData = courses[tournamentData.course] || customCourses[tournamentData.course];
                        
                        console.log('✅ Loaded from localStorage');
                        showPage('scoringPage');
                        return;
                    }
                } catch (error) {
                    console.error('Error loading from localStorage:', error);
                }
            }
            
            showNotification('Not Found', 'Tournament no longer exists');
        }
        
        // View results for a round
        async function viewRoundResults(tournamentId) {
            if (!tournamentId) {
                showNotification('Error', 'Invalid tournament');
                return;
            }
            
            // Try to load from Firebase first
            if (db) {
                try {
                    const doc = await db.collection('tournaments').doc(tournamentId).get();
                    if (doc.exists) {
                        const data = doc.data();
                        activeTournamentId = tournamentId;
                        tournamentData = {
                            id: tournamentId,
                            ...data
                        };
                        
                        // Check if user is host from history
                        const history = getTournamentHistory();
                        const historyEntry = history.find(h => h.id === tournamentId);
                        isHost = historyEntry?.role === 'host';
                        tournamentMode = 'multi';
                        
                        // Set course data
                        courseData = courses[tournamentData.course] || customCourses[tournamentData.course];
                        
                        localStorage.setItem('activeTournamentId', tournamentId);
                        
                        showPage('resultsPage');
                        return;
                    }
                } catch (error) {
                    console.error('Error loading tournament from Firebase:', error);
                }
            }
            
            // Fallback: Try to load from localStorage
            const savedData = localStorage.getItem('indianHillsScoring');
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    if (data._activeTournamentId === tournamentId || data.id === tournamentId) {
                        // Load from local storage
                        activeTournamentId = tournamentId;
                        
                        // Extract metadata
                        const metadataKeys = ['_activeTournamentId', '_tournamentMode', '_isHost', '_hostForTournament', 
                                            '_hasJoinedTournament', '_hostViewMode', '_scoreTimestamps', '_deletedPlayers', '_lastSaved'];
                        
                        // Set isHost and tournamentMode from saved data
                        isHost = data._isHost || false;
                        tournamentMode = data._tournamentMode || 'single';
                        
                        // Remove metadata from tournamentData
                        const cleanData = {...data};
                        metadataKeys.forEach(key => delete cleanData[key]);
                        tournamentData = cleanData;
                        
                        // Set course data
                        courseData = courses[tournamentData.course] || customCourses[tournamentData.course];
                        
                        showPage('resultsPage');
                        return;
                    }
                } catch (error) {
                    console.error('Error loading from localStorage:', error);
                }
            }
            
            showNotification('Not Found', 'Tournament no longer exists');
        }
        
        // Format date for display
        function formatTournamentDate(dateStr) {
            if (!dateStr) return 'Unknown date';
            try {
                const date = new Date(dateStr);
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                
                if (date.toDateString() === today.toDateString()) {
                    return 'Today';
                } else if (date.toDateString() === yesterday.toDateString()) {
                    return 'Yesterday';
                } else {
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                }
            } catch (e) {
                return dateStr;
            }
        }
        
        // Show tournament history modal
        async function showTournamentHistoryModal() {
            const history = getTournamentHistory();
            
            const modal = document.createElement('div');
            modal.id = 'tournamentHistoryModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 10001;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            // Show modal immediately with loading state if we have history to fetch
            if (history.length > 0 && db) {
                modal.innerHTML = `
                    <div style="background: white; border-radius: 6px; padding: 20px; max-width: 400px; width: 95%; max-height: 80vh; overflow-y: auto;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                            <h2 style="color: #1e3a5f; font-size: 20px; margin: 0;">📂 Load Tournament</h2>
                            <button onclick="closeTournamentHistoryModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">✕</button>
                        </div>
                        <div style="text-align: center; padding: 40px;">
                            <div style="font-size: 24px; margin-bottom: 12px;">⏳</div>
                            <p style="color: #64748b;">Loading tournament data...</p>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }
            
            let historyHTML = '';
            
            if (history.length === 0) {
                historyHTML = `
                    <div style="text-align: center; padding: 24px; color: #64748b;">
                        <span style="font-size: 48px; display: block; margin-bottom: 12px;">📭</span>
                        <p style="font-size: 14px;">No tournaments in history</p>
                        <p style="font-size: 12px; margin-top: 8px;">Join a tournament using a code to get started!</p>
                    </div>
                `;
            } else {
                // Fetch fresh data from Firebase for each tournament
                const freshHistory = [];
                for (const t of history) {
                    try {
                        if (db && t.id) {
                            const doc = await db.collection('tournaments').doc(t.id).get();
                            if (doc.exists) {
                                const fbData = doc.data();
                                freshHistory.push({
                                    ...t,
                                    name: fbData.name || t.name,
                                    playerCount: fbData.players?.length || t.playerCount || 0,
                                    date: fbData.date || t.date,
                                    isFinished: fbData.status === 'ended' || t.isFinished
                                });
                            } else {
                                // Tournament no longer exists in Firebase
                                freshHistory.push({ ...t, playerCount: t.playerCount || 0 });
                            }
                        } else {
                            freshHistory.push(t);
                        }
                    } catch (err) {
                        console.warn('Could not fetch tournament', t.id, err);
                        freshHistory.push(t);
                    }
                }
                
                // Sort by date (most recent first)
                const sortedHistory = [...freshHistory].sort((a, b) => {
                    const dateA = new Date(a.date || 0);
                    const dateB = new Date(b.date || 0);
                    return dateB - dateA;
                });
                
                historyHTML = sortedHistory.map((t, idx) => {
                    const roleIcon = t.role === 'host' ? '👑' : t.role === 'viewer' ? '👁' : '🏌️';
                    const roleText = t.role === 'host' ? 'Host' : t.role === 'viewer' ? 'Viewer' : 'Player';
                    const finishedBadge = t.isFinished ? `<span style="background: #fef3c7; color: #92400e; font-size: 9px; font-weight: 700; padding: 2px 6px; border-radius: 4px; margin-left: 6px;">FINISHED</span>` : '';
                    
                    return `
                        <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 6px; padding: 12px; margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; color: #1e293b; font-size: 14px; margin-bottom: 2px;">
                                        ${t.name || 'Unnamed Tournament'}${finishedBadge}
                                    </div>
                                    <div style="font-size: 12px; color: #64748b;">
                                        ${t.courseName || getCourseDisplayName(t.course)} • ${t.playerCount || 0} players • ${formatTournamentDate(t.date)}
                                    </div>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <span style="font-size: 12px;">${roleIcon}</span>
                                    <span style="font-size: 11px; color: #64748b;">${roleText}</span>
                                </div>
                            </div>
                            <div style="display: flex; gap: 8px; align-items: center;">
                                ${t.joinCode ? `<span style="font-family: monospace; font-weight: 700; font-size: 13px; color: #1e3a5f; background: #eff6ff; padding: 4px 8px; border-radius: 4px;">${t.joinCode}</span>` : ''}
                                <button onclick="loadTournamentFromHistory('${t.id}')" style="flex: 1; padding: 10px; background: #1e3a5f; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                                    Load
                                </button>
                                <button onclick="confirmRemoveFromHistory('${t.id}', '${(t.name || 'Tournament').replace(/'/g, "\\'")}')" style="padding: 10px 12px; background: #fee2e2; color: #a51c30; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;" title="Remove">
                                    🗑️
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            // Update or create the modal with final content
            const existingModal = document.getElementById('tournamentHistoryModal');
            const targetModal = existingModal || modal;
            
            targetModal.innerHTML = `
                <div style="background: white; border-radius: 6px; padding: 20px; max-width: 400px; width: 95%; max-height: 80vh; overflow-y: auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h2 style="color: #1e3a5f; font-size: 20px; margin: 0;">📂 Load Tournament</h2>
                        <button onclick="closeTournamentHistoryModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">✕</button>
                    </div>
                    
                    <!-- Join by Code Section (First) -->
                    <div style="background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border: 2px solid #1e3a5f; border-radius: 6px; padding: 14px; margin-bottom: 16px;">
                        <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 10px;">
                            <span style="font-size: 18px;">🎫</span>
                            <span style="font-weight: 700; color: #1e3a5f; font-size: 13px;">Enter Code</span>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="historyJoinCodeInput" placeholder="ABCD12" maxlength="6" 
                                style="flex: 1; padding: 12px; font-size: 16px; font-weight: 700; text-align: center; 
                                border: 2px solid #1e3a5f; border-radius: 8px; letter-spacing: 2px; font-family: monospace;
                                text-transform: uppercase; background: white;"
                                oninput="this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0,6);"
                                onkeypress="if(event.key === 'Enter') joinFromHistoryModal();">
                            <button onclick="joinFromHistoryModal()" style="padding: 12px 20px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-size: 14px; font-weight: 700; cursor: pointer;">
                                Join
                            </button>
                        </div>
                        <p style="font-size: 11px; color: #64748b; margin-top: 6px; text-align: center;">Works with Join Code or Host Code</p>
                        <p id="historyJoinError" style="color: #a51c30; font-size: 12px; margin-top: 4px; text-align: center; min-height: 16px;"></p>
                    </div>
                    
                    <!-- Previous Tournaments Section -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span style="font-size: 13px; font-weight: 700; color: #64748b; text-transform: uppercase;">Previous Tournaments</span>
                        ${history.length > 0 ? `<button onclick="confirmClearHistory()" style="padding: 4px 8px; background: #fee2e2; color: #a51c30; border: none; border-radius: 4px; font-size: 10px; cursor: pointer;">Clear All</button>` : ''}
                    </div>
                    
                    <div id="historyList" style="max-height: 300px; overflow-y: auto;">
                        ${historyHTML}
                    </div>
                    
                    <button onclick="closeTournamentHistoryModal()" style="width: 100%; margin-top: 16px; padding: 14px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 15px; font-weight: 600; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;
            
            // Only append if not already in DOM
            if (!existingModal) {
                document.body.appendChild(targetModal);
            }
            
            targetModal.onclick = (e) => {
                if (e.target === targetModal) {
                    closeTournamentHistoryModal();
                }
            };
        }
        
        // Close tournament history modal
        function closeTournamentHistoryModal() {
            const modal = document.getElementById('tournamentHistoryModal');
            if (modal) modal.remove();
        }
        
        // Load tournament from history
        async function loadTournamentFromHistory(tournamentId) {
            closeTournamentHistoryModal();
            
            // Check if Firebase is available
            if (!db) {
                showNotification('Offline', 'Cannot load tournament - no database connection');
                return;
            }
            
            // Show loading notification
            showNotification('Loading...', 'Connecting to tournament');
            
            try {
                // Check if tournament still exists in Firebase
                const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                
                if (!tournamentDoc.exists) {
                    showNotification('Not Found', 'This tournament no longer exists');
                    removeFromTournamentHistory(tournamentId);
                    return;
                }
                
                const tournament = tournamentDoc.data();
                
                // Check if this device is the original host
                const isOriginalHost = tournament.hostDevice === currentDeviceId;
                
                // Check if tournament is finished
                if (tournament.isFinished && isOriginalHost) {
                    // Load directly into View Only mode (no more modal prompt)
                    activeTournamentId = tournamentId;
                    tournamentData = tournament;
                    isHost = true;
                    tournamentMode = 'multi';
                    
                    // Reset state from any previous session
                    isGuestUser = false;
                    isCoHost = false;
                    claimedPlayers = [];
                    hostViewMode = 'host';
                    currentResultsMode = 'tourney';
                    
                    // Load course data - check local first, then use stored data from tournament
                    courseData = courses[tournament.course] || customCourses[tournament.course];
                    if (!courseData && tournament.courseData) {
                        // Use course data stored with tournament
                        courseData = tournament.courseData;
                        // Also add to customCourses for this session
                        customCourses[tournament.course] = tournament.courseData;
                        console.log('📍 Loaded course data from tournament:', tournament.courseData.name);
                    }
                    
                    // Subscribe to updates
                    subscribToTournamentUpdates(tournamentId);
                    
                    saveToLocalStorage();
                    
                    // Go to Host Home with finished status
                    updateHostHomePage();
                    updateHostHomeBadge();
                    
                    // Keep current tournament card hidden (handled by populateHomeRoundsList)
                    const currentTournamentCard = document.getElementById('hostCurrentTournament');
                    if (currentTournamentCard) {
                        currentTournamentCard.style.display = 'none';
                    }
                    
                    showPage('hostHomePage');
                    showNotification('View Only', 'Finished tournament loaded. Use Tournament Management to reopen or restart.');
                    return;
                }
                
                if (isOriginalHost) {
                    // Device is the host - go straight to host home
                    activeTournamentId = tournamentId;
                    tournamentData = tournament;
                    isHost = true;
                    tournamentMode = 'multi';
                    
                    // Reset state from any previous session
                    isGuestUser = false;
                    isCoHost = false;
                    claimedPlayers = [];
                    hostViewMode = 'host';
                    currentResultsMode = 'tourney';
                    
                    // Load course data - check local first, then use stored data from tournament
                    courseData = courses[tournament.course] || customCourses[tournament.course];
                    if (!courseData && tournament.courseData) {
                        // Use course data stored with tournament
                        courseData = tournament.courseData;
                        // Also add to customCourses for this session
                        customCourses[tournament.course] = tournament.courseData;
                        console.log('📍 Loaded course data from tournament:', tournament.courseData.name);
                    }
                    
                    // Subscribe to updates
                    subscribToTournamentUpdates(tournamentId);
                    
                    saveToLocalStorage();
                    updateHostHomePage();
                    
                    // Keep current tournament card hidden (handled by populateHomeRoundsList)
                    const currentTournamentCard2 = document.getElementById('hostCurrentTournament');
                    if (currentTournamentCard2) {
                        currentTournamentCard2.style.display = 'none';
                    }
                    
                    showPage('hostHomePage');
                    showNotification('Welcome Back', 'Loaded as host');
                } else {
                    // Go to player join screen (no host choice - must use Host Code)
                    showJoinTournamentScreen(tournamentId);
                }
                
            } catch (error) {
                console.error('Error loading tournament:', error);
                showNotification('Error', `Could not load tournament: ${error.message || 'Unknown error'}`);
            }
        }
        
        // Show options for loading a finished tournament (host only)
        function showFinishedTournamentOptions(tournamentId, tournament) {
            const modal = document.createElement('div');
            modal.id = 'finishedTournamentModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            const tournamentName = tournament.name || 'Tournament';
            const courseName = (courses[tournament.course] || customCourses[tournament.course])?.name || tournament.course;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 24px; max-width: 360px; width: 100%; text-align: center;">
                    <div style="font-size: 40px; margin-bottom: 12px;">🏁</div>
                    <h2 style="color: #1e3a5f; font-size: 18px; margin: 0 0 4px 0;">${tournamentName}</h2>
                    <span style="background: #fef3c7; color: #92400e; font-size: 11px; font-weight: 700; padding: 3px 10px; border-radius: 6px;">FINISHED</span>
                    <p style="color: #64748b; font-size: 13px; margin: 12px 0 20px 0;">${courseName} • ${tournament.date || 'Today'}</p>
                    
                    <p style="color: #475569; font-size: 14px; margin-bottom: 20px;">What would you like to do?</p>
                    
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="loadFinishedTournament('${tournamentId}', 'view')" 
                            style="width: 100%; padding: 14px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            👁️ View Only
                            <span style="display: block; font-size: 11px; font-weight: 400; opacity: 0.9;">Players frozen, host can edit</span>
                        </button>
                        <button onclick="loadFinishedTournament('${tournamentId}', 'continue')" 
                            style="width: 100%; padding: 14px; background: #166534; color: white; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            ▶️ Continue Tournament
                            <span style="display: block; font-size: 11px; font-weight: 400; opacity: 0.9;">Unfreeze, all can edit/score</span>
                        </button>
                        <button onclick="confirmRestartTournament('${tournamentId}')" 
                            style="width: 100%; padding: 14px; background: #a51c30; color: white; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            🔄 Restart Tournament
                            <span style="display: block; font-size: 11px; font-weight: 400; opacity: 0.9;">Clear all scores & claims</span>
                        </button>
                    </div>
                    
                    <button onclick="closeFinishedTournamentModal()" 
                        style="margin-top: 16px; padding: 12px; background: transparent; color: #64748b; border: none; font-size: 14px; cursor: pointer; width: 100%;">
                        Cancel
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeFinishedTournamentModal();
            };
        }
        
        function closeFinishedTournamentModal() {
            const modal = document.getElementById('finishedTournamentModal');
            if (modal) modal.remove();
        }
        
        // Load finished tournament with specified mode
        async function loadFinishedTournament(tournamentId, mode) {
            closeFinishedTournamentModal();
            
            try {
                const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                const tournament = tournamentDoc.data();
                
                if (mode === 'continue') {
                    // Unfreeze the tournament
                    await db.collection('tournaments').doc(tournamentId).update({ isFinished: false });
                    tournament.isFinished = false;
                }
                // For 'view' mode, keep isFinished = true but allow host to edit
                
                activeTournamentId = tournamentId;
                tournamentData = tournament;
                isHost = true;
                tournamentMode = 'multi';
                
                // Reset state from any previous session
                isGuestUser = false;
                isCoHost = false;
                claimedPlayers = [];
                hostViewMode = 'host';
                currentResultsMode = 'tourney';
                
                courseData = courses[tournament.course] || customCourses[tournament.course];
                saveToLocalStorage();
                updateHostHomePage();
                
                // Current tournament is handled by populateHomeRoundsList - keep hidden
                document.getElementById('hostCurrentTournament').style.display = 'none';
                
                showPage('hostHomePage');
                showNotification('Loaded', mode === 'continue' ? 'Tournament resumed' : 'Viewing finished tournament');
                
            } catch (error) {
                console.error('Error loading finished tournament:', error);
                showNotification('Error', 'Failed to load tournament');
            }
        }
        
        // Confirm restart tournament
        function confirmRestartTournament(tournamentId) {
            closeFinishedTournamentModal();
            
            showConfirm(
                '🔄 Restart Tournament?',
                'This will clear ALL scores and player claims. The tournament will start fresh as if no one had ever joined. This cannot be undone!',
                async function() {
                    try {
                        const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                        const tournament = tournamentDoc.data();
                        
                        // Reset all players - clear scores and claims
                        const resetPlayers = tournament.players.map(p => ({
                            ...p,
                            scores: new Array(18).fill(null),
                            claimedBy: null,
                            deviceInitials: null
                        }));
                        
                        // Update Firebase
                        await db.collection('tournaments').doc(tournamentId).update({
                            players: resetPlayers,
                            isFinished: false
                        });
                        
                        // Load the reset tournament
                        tournament.players = resetPlayers;
                        tournament.isFinished = false;
                        
                        activeTournamentId = tournamentId;
                        tournamentMode = 'multi';
                        tournamentData = tournament;
                        isHost = true;
                        hasJoinedTournament = true;
                        
                        // Reset state from any previous session
                        isGuestUser = false;
                        isCoHost = false;
                        claimedPlayers = [];
                        hostViewMode = 'host';
                        currentResultsMode = 'tourney';
                        
                        courseData = courses[tournament.course] || customCourses[tournament.course];
                        
                        // CRITICAL: Clear ALL player stats - both general and tournament-specific
                        clearAllPlayerStats();
                        localStorage.removeItem('playerStats_' + tournamentId);
                        
                        saveToLocalStorage();
                        subscribToTournamentUpdates(tournamentId);
                        
                        hideConfirmDialog();
                        updateHostHomePage();
                        document.getElementById('hostCurrentTournament').style.display = 'none';
                        showPage('hostHomePage');
                        showNotification('Restarted', 'Tournament has been reset');
                        
                    } catch (error) {
                        console.error('Error restarting tournament:', error);
                        showNotification('Error', 'Failed to restart tournament');
                        hideConfirmDialog();
                    }
                }
            );
        }
        
        // Show dialog to choose between joining as player or host
        function showJoinOrHostDialog(tournamentId, tournament) {
            const modal = document.createElement('div');
            modal.id = 'joinOrHostModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            const tournamentName = tournament.name || 'Tournament';
            const courseName = (courses[tournament.course] || customCourses[tournament.course])?.name || tournament.course;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 24px; max-width: 340px; width: 100%; text-align: center;">
                    <div style="font-size: 40px; margin-bottom: 12px;">⛳</div>
                    <h2 style="color: #1e3a5f; font-size: 18px; margin: 0 0 8px 0;">${tournamentName}</h2>
                    <p style="color: #64748b; font-size: 13px; margin: 0 0 20px 0;">${courseName} • ${tournament.date || 'Today'}</p>
                    
                    <p style="color: #475569; font-size: 14px; margin-bottom: 20px;">How would you like to join?</p>
                    
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <button onclick="joinAsPlayerFromDialog('${tournamentId}')" 
                            style="width: 100%; padding: 16px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px;">
                            <span style="font-size: 20px;">👤</span> Join as Player
                        </button>
                        <button onclick="joinAsHostFromDialog('${tournamentId}')" 
                            style="width: 100%; padding: 16px; background: #f97316; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px;">
                            <span style="font-size: 20px;">👑</span> Join as Host
                        </button>
                    </div>
                    
                    <button onclick="closeJoinOrHostDialog()" 
                        style="margin-top: 16px; padding: 12px; background: transparent; color: #64748b; border: none; font-size: 14px; cursor: pointer; width: 100%;">
                        Cancel
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeJoinOrHostDialog();
            };
        }
        
        function closeJoinOrHostDialog() {
            const modal = document.getElementById('joinOrHostModal');
            if (modal) modal.remove();
        }
        
        async function joinAsPlayerFromDialog(tournamentId) {
            closeJoinOrHostDialog();
            // Navigate to join screen for player selection
            showJoinTournamentScreen(tournamentId);
        }
        
        async function joinAsHostFromDialog(tournamentId) {
            closeJoinOrHostDialog();
            
            try {
                // Ensure device ID is initialized
                if (!currentDeviceId) {
                    currentDeviceId = localStorage.getItem('deviceId');
                    if (!currentDeviceId) {
                        currentDeviceId = 'device_' + Math.random().toString(36).substr(2, 9);
                        localStorage.setItem('deviceId', currentDeviceId);
                    }
                }
                
                // Ensure device name/initials are set
                if (!deviceName) {
                    deviceName = localStorage.getItem('deviceName') || 'Host Device';
                }
                if (!deviceInitials) {
                    deviceInitials = localStorage.getItem('deviceInitials') || 'HD';
                }
                
                const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                
                if (!tournamentDoc.exists) {
                    showNotification('Not Found', 'Tournament no longer exists');
                    return;
                }
                
                const tournament = tournamentDoc.data();
                
                // Take over as host
                await db.collection('tournaments').doc(tournamentId).update({
                    hostDevice: currentDeviceId,
                    [`devices.${currentDeviceId}`]: {
                        name: deviceName,
                        initials: deviceInitials,
                        isHost: true,
                        joinedAt: firebase.firestore.FieldValue.serverTimestamp()
                    }
                });
                
                // Set local state
                activeTournamentId = tournamentId;
                tournamentData = { ...tournament, hostDevice: currentDeviceId };
                isHost = true;
                tournamentMode = 'multi';
                
                // Reset state from any previous session
                isGuestUser = false;
                isCoHost = false;
                claimedPlayers = [];
                hostViewMode = 'host';
                currentResultsMode = 'tourney';
                
                courseData = courses[tournament.course] || customCourses[tournament.course];
                saveToLocalStorage();
                
                // Go to host home page
                updateHostHomePage();
                showPage('hostHomePage');
                showNotification('Host Mode', 'You are now the tournament host');
                
            } catch (error) {
                console.error('Error joining as host:', error);
                showNotification('Error', `Could not take over as host: ${error.message || 'Unknown error'}`);
            }
        }
        
        // Join from history modal (checks both Join Code and Host Code)
        async function joinFromHistoryModal() {
            const input = document.getElementById('historyJoinCodeInput');
            const errorEl = document.getElementById('historyJoinError');
            
            if (!input) return;
            
            const code = input.value.trim().toUpperCase();
            
            if (!isValidJoinCodeFormat(code)) {
                if (errorEl) errorEl.textContent = 'Enter 4 letters + 2 numbers (e.g., ABCD12)';
                return;
            }
            
            if (errorEl) {
                errorEl.textContent = 'Looking up...';
                errorEl.style.color = '#64748b';
            }
            
            try {
                // First, try to find by Join Code
                const joinCodeResult = await findTournamentByCode(code);
                
                if (joinCodeResult.success) {
                    closeTournamentHistoryModal();
                    
                    // Fetch tournament data to check host status
                    const tournamentDoc = await db.collection('tournaments').doc(joinCodeResult.tournamentId).get();
                    
                    if (tournamentDoc.exists) {
                        const tournament = tournamentDoc.data();
                        
                        // Check if this device is the original host
                        const isOriginalHost = tournament.hostDevice === currentDeviceId;
                        
                        if (isOriginalHost) {
                            // Device is the host - go straight to host home
                            activeTournamentId = joinCodeResult.tournamentId;
                            tournamentData = tournament;
                            isHost = true;
                            tournamentMode = 'multi';
                            
                            // Reset state from any previous session
                            isGuestUser = false;
                            isCoHost = false;
                            claimedPlayers = [];
                            hostViewMode = 'host';
                            currentResultsMode = 'tourney';
                            
                            courseData = courses[tournament.course] || customCourses[tournament.course];
                            saveToLocalStorage();
                            updateHostHomePage();
                            showPage('hostHomePage');
                            showNotification('Welcome Back', 'Loaded as host');
                        } else {
                            // Go to player join screen
                            showJoinTournamentScreen(joinCodeResult.tournamentId);
                        }
                    } else {
                        showNotification('Error', 'Tournament not found');
                    }
                    return;
                }
                
                // Not a Join Code - try Host Code
                const hostCodeSnapshot = await db.collection('tournaments')
                    .where('hostCode', '==', code)
                    .limit(1)
                    .get();
                
                if (!hostCodeSnapshot.empty) {
                    const tournamentDoc = hostCodeSnapshot.docs[0];
                    const tournament = tournamentDoc.data();
                    const tournamentId = tournamentDoc.id;
                    
                    // Check if tournament is still active
                    if (tournament.status === 'ended') {
                        if (errorEl) {
                            errorEl.textContent = 'This tournament has ended';
                            errorEl.style.color = '#a51c30';
                        }
                        return;
                    }
                    
                    closeTournamentHistoryModal();
                    
                    // Grant co-host access
                    const coHosts = tournament.coHosts || [];
                    if (!coHosts.includes(currentDeviceId)) {
                        coHosts.push(currentDeviceId);
                        await db.collection('tournaments').doc(tournamentId).update({
                            coHosts: coHosts,
                            [`devices.${currentDeviceId}`]: {
                                name: deviceName || 'Co-Host Device',
                                initials: deviceInitials || 'CH',
                                isCoHost: true,
                                joinedAt: firebase.firestore.FieldValue.serverTimestamp()
                            },
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                    
                    // Set local state
                    activeTournamentId = tournamentId;
                    tournamentData = tournament;
                    isHost = false;
                    isCoHost = true;
                    courseData = courses[tournament.course] || customCourses[tournament.course];
                    
                    // Add to tournament history
                    addToTournamentHistory({
                        id: tournamentId,
                        joinCode: tournament.joinCode,
                        name: tournament.name || '',
                        date: tournament.date,
                        course: tournament.course,
                        courseName: courseData?.name || tournament.course,
                        role: 'cohost'
                    });
                    
                    saveToLocalStorage();
                    
                    // Go to player join screen to claim players
                    showJoinTournamentScreen(tournamentId);
                    showNotification('Co-Host Access! 🎉', 'You now have co-host privileges');
                    return;
                }
                
                // Neither Join Code nor Host Code found
                if (errorEl) {
                    errorEl.textContent = 'Code not found. Check and try again.';
                    errorEl.style.color = '#a51c30';
                }
                
            } catch (error) {
                console.error('Error joining by code:', error);
                if (errorEl) {
                    errorEl.textContent = 'Something went wrong. Try again.';
                    errorEl.style.color = '#a51c30';
                }
            }
        }
        
        // Join as Co-Host from history modal (using host code)
        
        // Confirm remove from history
        function confirmRemoveFromHistory(tournamentId, tournamentName) {
            showConfirm(
                'Remove from History?',
                `Remove "${tournamentName}" from your saved tournaments?`,
                function() {
                    removeFromTournamentHistory(tournamentId);
                    hideConfirmDialog();
                    // Refresh the modal
                    closeTournamentHistoryModal();
                    showTournamentHistoryModal();
                    showNotification('Removed', 'Tournament removed from history');
                }
            );
        }
        
        // Confirm clear all history
        function confirmClearHistory() {
            showConfirm(
                'Clear All History?',
                'This will remove all saved tournaments from your device.',
                function() {
                    clearTournamentHistory();
                    hideConfirmDialog();
                    closeTournamentHistoryModal();
                    showTournamentHistoryModal();
                    showNotification('Cleared', 'Tournament history cleared');
                }
            );
        }
        
        // ==================== END TOURNAMENT HISTORY ====================
        
        // Show join tournament screen
        // Track selected players for joining
        let joinSelections = {
            claim: [],  // Players to score for
            watch: [],  // Players to watch
            tournamentId: null
        };
        
        function showJoinTournamentScreen(tournamentId) {
            // Reset selections
            joinSelections = { claim: [], watch: [], tournamentId: tournamentId };
            
            // Load tournament info
            db.collection('tournaments').doc(tournamentId).get()
                .then(doc => {
                    if (doc.exists) {
                        const tournament = doc.data();
                        
                        // AUTO-REJOIN: Check if this device already has claimed players
                        if (tournament.players && tournament.players.length > 0) {
                            const claimedByThisDevice = tournament.players.filter(p => isClaimedByMe(p));
                            if (claimedByThisDevice.length > 0) {
                                // Device recognized with claimed players - bypass join screen!
                                console.log(`🔄 Auto-rejoin: Found ${claimedByThisDevice.length} claimed players for device ${currentDeviceId}`);
                                
                                // Set up tournament data and go directly to scoring
                                tournamentData = {
                                    id: tournamentId,
                                    name: tournament.name || '',
                                    date: tournament.date,
                                    gameType: tournament.gameType,
                                    course: tournament.course,
                                    players: tournament.players,
                                    teams: tournament.teams || [],
                                    courseData: tournament.courseData
                                };
                                activeTournamentId = tournamentId;
                                tournamentMode = 'multi';
                                isHost = false;
                                
                                // Set up course data - prefer embedded data from tournament
                                if (tournament.courseData) {
                                    courseData = tournament.courseData;
                                    customCourses[tournament.course] = tournament.courseData;
                                } else if (tournament.course && courses[tournament.course]) {
                                    courseData = courses[tournament.course];
                                } else if (customCourses[tournament.course]) {
                                    courseData = customCourses[tournament.course];
                                }
                                
                                // Update claimed players list
                                claimedPlayers = claimedByThisDevice.map(p => p.name);
                                playerOrder.claimed = claimedPlayers;
                                savePlayerOrder();
                                saveToLocalStorage();
                                
                                // Set up real-time listener
                                subscribToTournamentUpdates(tournamentId);
                                
                                // Add to tournament history
                                addToTournamentHistory({
                                    id: tournamentId,
                                    joinCode: tournament.joinCode || '',
                                    name: tournament.name || '',
                                    course: tournament.course,
                                    date: tournament.date,
                                    gameType: tournament.gameType,
                                    role: 'player'
                                });
                                
                                // Go directly to scoring page
                                renderScoringPage();
                                showPage('scoringPage');
                                switchToHoleView();
                                
                                showNotification('Welcome Back!', `Scoring for ${claimedPlayers.join(', ')}`);
                                return;
                            }
                        }
                        
                        // SKIP JOIN PAGE - Go directly to scoring/My Players page
                        // This avoids the Android rendering issues with the join selection screen
                        console.log('📱 Skipping join page, going directly to My Players');
                        
                        // Set up tournament data
                        tournamentData = {
                            id: tournamentId,
                            name: tournament.name || '',
                            date: tournament.date,
                            gameType: tournament.gameType,
                            course: tournament.course,
                            players: tournament.players || [],
                            teams: tournament.teams || [],
                            courseData: tournament.courseData
                        };
                        activeTournamentId = tournamentId;
                        tournamentMode = 'multi';
                        isHost = false;
                        isGuestUser = true;
                        hasJoinedTournament = true;
                        
                        // Set up course data - prefer embedded data from tournament
                        if (tournament.courseData) {
                            courseData = tournament.courseData;
                            customCourses[tournament.course] = tournament.courseData;
                        } else if (tournament.course && courses[tournament.course]) {
                            courseData = courses[tournament.course];
                        } else if (customCourses[tournament.course]) {
                            courseData = customCourses[tournament.course];
                        }
                        
                        // Register device with tournament
                        db.collection('tournaments').doc(tournamentId).update({
                            [`devices.${currentDeviceId}`]: {
                                name: getDeviceName(),
                                userId: currentUserId,
                                connectedAt: firebase.firestore.FieldValue.serverTimestamp(),
                                lastActive: firebase.firestore.FieldValue.serverTimestamp(),
                                isHost: false
                            }
                        }).catch(err => console.log('Could not register device:', err));
                        
                        saveToLocalStorage();
                        
                        // Set up real-time listener
                        subscribToTournamentUpdates(tournamentId);
                        
                        // Add to tournament history
                        addToTournamentHistory({
                            id: tournamentId,
                            joinCode: tournament.joinCode || '',
                            name: tournament.name || '',
                            course: tournament.course,
                            date: tournament.date,
                            gameType: tournament.gameType,
                            role: 'player'
                        });
                        
                        // Go directly to My Players page where they can claim players
                        showMyPlayersPage();
                        
                        showNotification('Tournament Joined!', 'Tap a player to claim and start scoring');
                    } else {
                        showNotification('Error', 'Tournament not found!');
                        showPage('setupPage');
                    }
                })
                .catch(error => {
                    console.error('Error loading tournament:', error);
                    showNotification('Error', 'Failed to load tournament. Please try again.');
                    showPage('setupPage');
                });
        }
        
        function toggleJoinSelection(index, type, playerName) {
            const claimBtn = document.getElementById(`claimBtn_${index}`);
            const watchBtn = document.getElementById(`watchBtn_${index}`);
            
            if (type === 'claim') {
                const idx = joinSelections.claim.indexOf(playerName);
                if (idx > -1) {
                    // Deselect claim
                    joinSelections.claim.splice(idx, 1);
                    claimBtn.style.background = 'white';
                    claimBtn.style.color = '#166534';
                } else {
                    // Select claim, remove from watch if there
                    joinSelections.claim.push(playerName);
                    claimBtn.style.background = '#166534';
                    claimBtn.style.color = 'white';
                    
                    // Remove from watch
                    const watchIdx = joinSelections.watch.indexOf(playerName);
                    if (watchIdx > -1) {
                        joinSelections.watch.splice(watchIdx, 1);
                        watchBtn.style.background = 'white';
                        watchBtn.style.color = '#64748b';
                    }
                }
            } else if (type === 'watch') {
                const idx = joinSelections.watch.indexOf(playerName);
                if (idx > -1) {
                    // Deselect watch
                    joinSelections.watch.splice(idx, 1);
                    watchBtn.style.background = 'white';
                    watchBtn.style.color = '#64748b';
                } else {
                    // Select watch, remove from claim if there
                    joinSelections.watch.push(playerName);
                    watchBtn.style.background = '#64748b';
                    watchBtn.style.color = 'white';
                    
                    // Remove from claim
                    const claimIdx = joinSelections.claim.indexOf(playerName);
                    if (claimIdx > -1) {
                        joinSelections.claim.splice(claimIdx, 1);
                        claimBtn.style.background = 'white';
                        claimBtn.style.color = '#166534';
                    }
                }
            }
            
            updateJoinSelectionUI();
        }
        
        function updateJoinSelectionUI() {
            const hasSelections = joinSelections.claim.length > 0 || joinSelections.watch.length > 0;
            
            document.getElementById('joinTournamentBtnContainer').style.display = hasSelections ? 'block' : 'none';
            document.getElementById('selectionSummary').style.display = hasSelections ? 'block' : 'none';
            document.getElementById('claimCount').textContent = joinSelections.claim.length;
            document.getElementById('watchCount').textContent = joinSelections.watch.length;
        }
        
        async function executeJoinTournament() {
            if (joinSelections.claim.length === 0 && joinSelections.watch.length === 0) {
                showNotification('Select Players', 'Please select at least one player to claim or watch');
                return;
            }
            
            // If claiming players, need initials - but auto-use logged in name if available
            if (joinSelections.claim.length > 0) {
                let playerInitials = localStorage.getItem('deviceInitials');
                
                // Check if user is logged in - always prefer their display name
                if (currentAuthUser && currentAuthUser.displayName) {
                    playerInitials = currentAuthUser.displayName;
                    console.log('📧 Using logged-in display name:', playerInitials);
                } else if (currentAuthUser && currentAuthUser.email) {
                    // Use email username (before @)
                    playerInitials = currentAuthUser.email.split('@')[0];
                    console.log('📧 Using email username:', playerInitials);
                } else if (!playerInitials) {
                    // Not logged in and no stored initials - prompt
                    playerInitials = prompt('Enter your initials (so host knows who\'s scoring):');
                    if (!playerInitials) return;
                    playerInitials = playerInitials.toUpperCase();
                }
                
                localStorage.setItem('deviceInitials', playerInitials);
                deviceInitials = playerInitials;
            }
            
            try {
                const tournamentId = joinSelections.tournamentId;
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Claim selected players
                for (const playerName of joinSelections.claim) {
                    const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                    if (playerIndex > -1 && !tournament.players[playerIndex].claimedBy) {
                        tournament.players[playerIndex].claimedBy = getClaimIdentifier();
                    }
                }
                
                // Initialize devices if needed
                if (!tournament.devices) tournament.devices = {};
                const deviceInitialsValue = localStorage.getItem('deviceInitials') || 'Guest';
                tournament.devices[currentDeviceId] = {
                    name: deviceInitialsValue,
                    initials: deviceInitialsValue,
                    joinedAt: new Date().toISOString()
                };
                
                // Save to Firebase
                await tournamentRef.update({
                    players: tournament.players,
                    devices: tournament.devices,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Set local state
                activeTournamentId = tournamentId;
                tournamentMode = 'multi';
                isHost = false;
                isGuestUser = true;
                hasJoinedTournament = true; // Mark as joined
                claimedPlayers = joinSelections.claim;
                playerOrder.claimed = joinSelections.claim;
                playerOrder.watching = joinSelections.watch;
                savePlayerOrder();
                
                // Load tournament data
                tournamentData = {
                    id: tournamentId,
                    name: tournament.name || '',
                    date: tournament.date,
                    gameType: tournament.gameType,
                    course: tournament.course,
                    players: tournament.players,
                    teams: tournament.teams || [],
                    courseData: tournament.courseData
                };
                
                // Load course data
                if (tournament.courseData) {
                    courseData = tournament.courseData;
                    customCourses[tournament.course] = tournament.courseData;
                } else {
                    courseData = courses[tournament.course] || customCourses[tournament.course];
                }
                
                saveToLocalStorage();
                subscribToTournamentUpdates(tournamentId);
                
                // Add to tournament history
                addToTournamentHistory({
                    id: tournamentId,
                    joinCode: tournament.joinCode || '',
                    name: tournament.name || '',
                    course: tournament.course,
                    date: tournament.date,
                    gameType: tournament.gameType,
                    role: joinSelections.claim.length > 0 ? 'player' : 'viewer'
                });
                
                // Navigate based on what was selected
                if (joinSelections.claim.length > 0) {
                    renderScoringPage();
                    showPage('scoringPage');
                    switchToHoleView();
                    showNotification('Ready!', `Scoring for ${joinSelections.claim.join(', ')}`);
                } else {
                    renderScoringPage();
                    showPage('scoringPage');
                    showNotification('Watching', `Following ${joinSelections.watch.join(', ')}`);
                }
            } catch (error) {
                console.error('Error joining tournament:', error);
                showNotification('Error', 'Failed to join tournament');
            }
        }
        
        async function joinAsViewer() {
            try {
                const tournamentId = joinSelections.tournamentId;
                const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                const tournament = tournamentDoc.data();
                
                // Set local state as viewer only
                activeTournamentId = tournamentId;
                tournamentMode = 'multi';
                isHost = false;
                isGuestUser = true;
                hasJoinedTournament = true; // Mark as joined (as viewer)
                claimedPlayers = [];
                
                tournamentData = {
                    id: tournamentId,
                    name: tournament.name || '',
                    date: tournament.date,
                    gameType: tournament.gameType,
                    course: tournament.course,
                    players: tournament.players,
                    teams: tournament.teams || []
                };
                
                saveToLocalStorage();
                subscribToTournamentUpdates(tournamentId);
                
                // Add to tournament history
                addToTournamentHistory({
                    id: tournamentId,
                    joinCode: tournament.joinCode || '',
                    name: tournament.name || '',
                    course: tournament.course,
                    date: tournament.date,
                    gameType: tournament.gameType,
                    role: 'viewer'
                });
                
                renderScoringPage();
                showPage('scoringPage');
                showNotification('Viewing', 'Watching the tournament');
            } catch (error) {
                console.error('Error joining as viewer:', error);
                showNotification('Error', 'Failed to join');
            }
        }
        
        function showAddNewPlayerForm() {
            document.getElementById('joinExistingPlayers').style.display = 'none';
            document.getElementById('joinDivider').style.display = 'none';
            document.getElementById('joinBottomOptions').style.display = 'none';
            document.getElementById('joinTournamentBtnContainer').style.display = 'none';
            document.getElementById('joinTournamentForm').style.display = 'block';
        }
        
        function hideAddNewPlayerForm() {
            document.getElementById('joinExistingPlayers').style.display = 'block';
            document.getElementById('joinDivider').style.display = 'block';
            document.getElementById('joinBottomOptions').style.display = 'block';
            document.getElementById('joinTournamentForm').style.display = 'none';
            updateJoinSelectionUI();
        }
        
        // Handle join tournament form submission
        document.addEventListener('DOMContentLoaded', () => {
            // Set default date to today
            const today = new Date();
            const dateStr = today.toISOString().split('T')[0];
            const dateInput = document.getElementById('tournamentDate');
            if (dateInput && !dateInput.value) {
                dateInput.value = dateStr;
            }
            
            // Check if URL has join parameter
            checkForJoinLink();
            
            const joinForm = document.getElementById('joinTournamentForm');
            if (joinForm) {
                joinForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const tournamentId = joinForm.dataset.tournamentId;
                    const playerInfo = {
                        name: document.getElementById('joinPlayerName').value.trim(),
                        handicap: parseFloat(document.getElementById('joinPlayerHandicap').value) || 0,
                        email: document.getElementById('joinPlayerEmail').value.trim(),
                        phone: document.getElementById('joinPlayerPhone').value.trim()
                    };
                    
                    const success = await joinTournament(tournamentId, playerInfo);
                    
                    if (success) {
                        isGuestUser = true; // Mark as guest - no home access
                        showNotification('Joined!', 'You\'ve joined the tournament');
                        // Navigate to scoring
                        renderScoringPage();
                        showPage('scoringPage');
                    }
                });
            }
        });
        
        // Show handicap confirmation dialog
        // Claim dialog state
        let claimHcpMode = 'course'; // 'index' or 'course' - default to course for casual golfers
        let claimSelectedTee = null;
        let claimPlayerHandicapIndex = null;
        
        function showHandicapConfirmDialog(tournamentId, playerName, currentHandicap) {
            const dialog = document.getElementById('handicapConfirmDialog');
            const nameInput = document.getElementById('claimPlayerNameInput');
            const originalNameInput = document.getElementById('claimPlayerOriginalName');
            const handicapInput = document.getElementById('handicapConfirmInput');
            const initialsInput = document.getElementById('initialsInput');
            const cancelBtn = document.getElementById('handicapConfirmCancel');
            const okBtn = document.getElementById('handicapConfirmOk');
            const ghinCheckbox = document.getElementById('useGhinIndexCheckbox');
            
            // Set editable name field and store original name
            nameInput.value = playerName;
            originalNameInput.value = playerName;
            
            // Get player's handicap from tournament data
            const player = tournamentData?.players?.find(p => p.name === playerName);
            const playerHandicap = player?.handicap ?? currentHandicap ?? 0;
            
            // Reset to default mode (course handicap) - uncheck the GHIN checkbox
            claimHcpMode = 'course';
            if (ghinCheckbox) ghinCheckbox.checked = false;
            toggleGhinIndexMode(false);
            
            // Set initial handicap value (the course handicap)
            handicapInput.value = Math.round(playerHandicap);
            
            // Set selected tee to tournament default
            claimSelectedTee = tournamentData?.tee || null;
            
            // Render tee buttons (hidden in course mode)
            renderClaimTeeButtons();
            
            // Update calculated course HCP display
            updateClaimCourseHcp();
            
            // Pre-fill initials - prefer logged-in user name, then localStorage
            let savedInitials = '';
            if (currentAuthUser && currentAuthUser.displayName) {
                savedInitials = currentAuthUser.displayName;
            } else if (currentAuthUser && currentAuthUser.email) {
                savedInitials = currentAuthUser.email.split('@')[0];
            } else {
                savedInitials = localStorage.getItem('deviceInitials') || '';
            }
            initialsInput.value = savedInitials;
            
            dialog.style.display = 'flex';
            
            // Focus on handicap if initials are pre-filled (logged in or saved), otherwise initials
            setTimeout(() => {
                if (savedInitials) {
                    handicapInput.focus();
                } else {
                    initialsInput.focus();
                }
            }, 100);
            
            // Auto-uppercase initials
            initialsInput.addEventListener('input', (e) => {
                e.target.value = e.target.value.toUpperCase();
            });
            
            // Cancel handler
            const handleCancel = () => {
                dialog.style.display = 'none';
                cancelBtn.removeEventListener('click', handleCancel);
                okBtn.removeEventListener('click', handleOk);
            };
            
            // OK handler
            const handleOk = () => {
                const newName = nameInput.value.trim();
                const originalName = originalNameInput.value;
                const initials = initialsInput.value.trim().toUpperCase();
                
                if (!newName) {
                    alert('Please enter a player name');
                    nameInput.focus();
                    return;
                }
                
                if (!initials) {
                    alert('Please enter your initials');
                    initialsInput.focus();
                    return;
                }
                
                // Round handicap index to nearest tenth
                let handicapIndexRaw = parseFloat(handicapInput.value) || 0;
                let handicapIndex = Math.round(handicapIndexRaw * 10) / 10;
                
                // Calculate final course handicap (always whole number)
                let finalCourseHcp;
                
                if (claimHcpMode === 'index') {
                    // Calculate course handicap from index
                    if (courseData && courseData.tees && claimSelectedTee) {
                        const teeData = courseData.tees[claimSelectedTee];
                        if (teeData) {
                            finalCourseHcp = calculateCourseHandicap(handicapIndex, teeData.slope, teeData.rating, courseData.totalPar);
                        } else {
                            finalCourseHcp = Math.round(handicapIndex);
                        }
                    } else {
                        finalCourseHcp = Math.round(handicapIndex);
                    }
                } else {
                    // Course HCP mode - use entered value directly (round to whole)
                    finalCourseHcp = Math.round(parseFloat(handicapInput.value) || 0);
                    handicapIndex = null; // Mark as manually entered
                }
                
                // Save initials for next time
                localStorage.setItem('deviceInitials', initials);
                
                dialog.style.display = 'none';
                cancelBtn.removeEventListener('click', handleCancel);
                okBtn.removeEventListener('click', handleOk);
                
                // Pass additional data for tee, mode, and name change
                selectExistingPlayerWithTee(tournamentId, originalName, finalCourseHcp, initials, {
                    tee: claimSelectedTee,
                    handicapIndex: handicapIndex,
                    hcpMode: claimHcpMode,
                    needsHcpConfirmation: false,
                    newName: newName !== originalName ? newName : null
                });
            };
            
            cancelBtn.addEventListener('click', handleCancel);
            okBtn.addEventListener('click', handleOk);
            
            // Enter key to confirm on both inputs
            const handleEnterKey = (e) => {
                if (e.key === 'Enter') {
                    handleOk();
                }
            };
            
            handicapInput.addEventListener('keyup', handleEnterKey);
            initialsInput.addEventListener('keyup', handleEnterKey);
        }
        
        // Toggle between Course HCP and GHIN Index mode
        function toggleGhinIndexMode(useIndex) {
            claimHcpMode = useIndex ? 'index' : 'course';
            const label = document.getElementById('handicapInputLabel');
            const calcDisplay = document.getElementById('claimCalculatedHcp');
            const input = document.getElementById('handicapConfirmInput');
            const teeSection = document.getElementById('claimTeeSelectionDiv');
            
            if (useIndex) {
                // GHIN Index mode
                label.textContent = 'GHIN Handicap Index';
                input.step = '0.1';
                input.placeholder = '12.4';
                calcDisplay.style.display = 'block';
                if (teeSection) teeSection.style.display = 'block';
                // Restore index value if saved
                if (claimPlayerHandicapIndex !== null) {
                    input.value = claimPlayerHandicapIndex;
                }
            } else {
                // Course Handicap mode (default)
                label.textContent = 'Course Handicap';
                input.step = '1';
                input.placeholder = '0';
                calcDisplay.style.display = 'none';
                if (teeSection) teeSection.style.display = 'none';
            }
            updateClaimCourseHcp();
        }
        
        // Legacy function for compatibility
        function setClaimHcpMode(mode) {
            const checkbox = document.getElementById('useGhinIndexCheckbox');
            if (checkbox) {
                checkbox.checked = (mode === 'index');
            }
            toggleGhinIndexMode(mode === 'index');
        }
        
        function renderClaimTeeButtons() {
            const container = document.getElementById('claimTeeButtons');
            const defaultNote = document.getElementById('claimTeeDefault');
            
            if (!container) return;
            
            if (!courseData || !courseData.tees) {
                container.innerHTML = '<span style="color: #64748b; font-size: 13px;">No tee data available</span>';
                return;
            }
            
            const teeColors = {
                black: '#1e293b',
                blue: '#1e3a5f',
                white: '#f1f5f9',
                gold: '#fbbf24',
                red: '#a51c30'
            };
            
            const tournamentTee = tournamentData?.tee || null;
            
            container.innerHTML = Object.keys(courseData.tees).map(teeKey => {
                const tee = courseData.tees[teeKey];
                const bgColor = teeColors[teeKey] || '#94a3b8';
                const textColor = (teeKey === 'white' || teeKey === 'gold') ? '#1e293b' : 'white';
                const isSelected = claimSelectedTee === teeKey;
                const isDefault = tournamentTee === teeKey;
                const borderColor = isSelected ? '#166534' : (teeKey === 'white' ? '#cbd5e1' : bgColor);
                
                // Format the display name (shorten combos)
                const displayName = formatTeeName(tee.name || teeKey);
                
                return `
                    <button type="button" onclick="selectClaimTee('${teeKey}')" style="
                        padding: 8px 14px;
                        background: ${bgColor};
                        color: ${textColor};
                        border: 3px solid ${borderColor};
                        border-radius: 8px;
                        font-size: 12px;
                        font-weight: 600;
                        cursor: pointer;
                        position: relative;
                        ${isSelected ? 'box-shadow: 0 0 0 2px #166534;' : ''}
                    " title="${tee.name || teeKey}">
                        ${displayName}
                        ${isDefault ? ' ★' : ''}
                    </button>
                `;
            }).join('');
            
            if (tournamentTee) {
                const teeName = courseData.tees[tournamentTee]?.name || tournamentTee;
                defaultNote.textContent = `★ = Tournament default (${teeName})`;
            } else {
                defaultNote.textContent = '';
            }
        }
        
        function selectClaimTee(teeKey) {
            claimSelectedTee = teeKey;
            renderClaimTeeButtons();
            updateClaimCourseHcp();
        }
        
        function updateClaimCourseHcp() {
            const input = document.getElementById('handicapConfirmInput');
            const calcDisplay = document.getElementById('claimCalculatedHcp');
            
            if (!calcDisplay) return;
            
            if (claimHcpMode === 'course') {
                calcDisplay.style.display = 'none';
                calcDisplay.textContent = '';
                return;
            }
            
            const indexValue = parseFloat(input?.value) || 0;
            
            if (courseData && courseData.tees && claimSelectedTee) {
                const teeData = courseData.tees[claimSelectedTee];
                if (teeData) {
                    const courseHcp = calculateCourseHandicap(indexValue, teeData.slope, teeData.rating, courseData.totalPar);
                    calcDisplay.textContent = `Course HCP: ${courseHcp}`;
                    calcDisplay.style.display = 'block';
                    return;
                }
            }
            
            calcDisplay.textContent = `Course HCP: ${Math.round(indexValue)}`;
            calcDisplay.style.display = 'block';
        }
        
        // Select existing player when joining
        async function selectExistingPlayer(tournamentId, playerName, confirmedHandicap, userInitials) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) {
                    alert('Player not found!');
                    return;
                }
                
                const player = tournament.players[playerIndex];
                
                // Check if already claimed
                if (player.claimedBy) {
                    alert(`${playerName} is already being scored by another device!`);
                    return;
                }
                
                // Initialize devices object if it doesn't exist
                if (!tournament.devices) {
                    tournament.devices = {};
                }
                
                // Create or update device entry with initials
                if (userInitials) {
                    tournament.devices[currentDeviceId] = {
                        name: userInitials,
                        initials: userInitials,
                        joinedAt: new Date().toISOString()
                    };
                }
                
                // Update handicap if provided
                if (confirmedHandicap !== undefined && confirmedHandicap !== player.handicap) {
                    tournament.players[playerIndex].handicap = confirmedHandicap;
                }
                
                // Save changes before claiming
                await tournamentRef.update({
                    players: tournament.players,
                    devices: tournament.devices,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Claim this player
                const claimed = await claimAdditionalPlayer(tournamentId, playerName);
                if (claimed) {
                    activeTournamentId = tournamentId;
                    tournamentMode = 'multi';
                    // Only set isHost to false if NOT already the host
                    // (hosts claiming players should retain host status)
                    if (!isHost) {
                        isHost = false; // Not the host, just a participant
                    }
                    
                    // Add to claimed players list if not already there
                    if (!claimedPlayers.includes(playerName)) {
                        claimedPlayers.push(playerName);
                    }
                    
                    // Load tournament data into local tournamentData
                    tournamentData = {
                        id: tournamentId,
                        name: tournament.name || '',
                        date: tournament.date,
                        gameType: tournament.gameType,
                        course: tournament.course,
                        players: tournament.players,
                        teams: tournament.teams || []
                    };
                    
                    // Save to localStorage
                    saveToLocalStorage();
                    
                    // Subscribe to updates
                    subscribToTournamentUpdates(tournamentId);
                    
                    // Check if we should return to My Players page
                    if (claimingFromMyPlayersModal || window.returnToMyPlayersPage) {
                        claimingFromMyPlayersModal = false;
                        window.returnToMyPlayersPage = false;
                        showNotification('Claimed!', `Now scoring for ${playerName}`);
                        showMyPlayersPage(); // Return to My Players page
                    } else {
                        // FIXED: Ensure scoring page shows content by defaulting to Hole View
                        currentView = 'hole'; // Force hole view
                        renderScoringPage();
                        showPage('scoringPage');
                        
                        // Delay hole view render to ensure tournamentData is fully loaded
                        setTimeout(() => {
                            switchToHoleView();
                        }, 100);
                        
                        showNotification('Ready to Score!', `You're scoring for ${playerName}`);
                    }
                }
            } catch (error) {
                console.error('Error selecting player:', error);
                alert('Failed to select player');
            }
        }
        
        // Select existing player with tee and HCP mode info
        async function selectExistingPlayerWithTee(tournamentId, playerName, confirmedHandicap, userInitials, options = {}) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) {
                    alert('Player not found!');
                    return;
                }
                
                const player = tournament.players[playerIndex];
                
                // Check if already claimed
                if (player.claimedBy) {
                    alert(`${playerName} is already being scored by another device!`);
                    return;
                }
                
                // Initialize devices object if it doesn't exist
                if (!tournament.devices) {
                    tournament.devices = {};
                }
                
                // Create or update device entry with initials
                if (userInitials) {
                    tournament.devices[currentDeviceId] = {
                        name: userInitials,
                        initials: userInitials,
                        joinedAt: new Date().toISOString()
                    };
                    // If logged in, also store user ID mapping
                    if (currentAuthUser) {
                        tournament.devices['user_' + currentAuthUser.uid] = {
                            name: userInitials,
                            initials: userInitials,
                            displayName: currentAuthUser.displayName || userInitials
                        };
                    }
                }
                
                // Handle name change if provided
                const finalPlayerName = options.newName || playerName;
                if (options.newName) {
                    tournament.players[playerIndex].name = options.newName;
                }
                
                // Store claimer display name on player for easy lookup
                tournament.players[playerIndex].claimerDisplayName = userInitials || currentAuthUser?.displayName || 'Unknown';
                
                // Update player with handicap and tee info
                tournament.players[playerIndex].handicap = confirmedHandicap;
                tournament.players[playerIndex].tee = options.tee || tournament.tee;
                tournament.players[playerIndex].handicapIndex = options.handicapIndex;
                tournament.players[playerIndex].hcpMode = options.hcpMode || 'index';
                tournament.players[playerIndex].needsHcpConfirmation = false; // Confirmed on claim
                
                // Save changes before claiming
                await tournamentRef.update({
                    players: tournament.players,
                    devices: tournament.devices,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Claim this player (use final name after possible rename)
                const claimed = await claimAdditionalPlayer(tournamentId, finalPlayerName);
                if (claimed) {
                    activeTournamentId = tournamentId;
                    tournamentMode = 'multi';
                    // Only set isHost to false if NOT already the host
                    if (!isHost) {
                        isHost = false;
                    }
                    
                    if (!claimedPlayers.includes(finalPlayerName)) {
                        claimedPlayers.push(finalPlayerName);
                    }
                    
                    tournamentData = {
                        id: tournamentId,
                        name: tournament.name || '',
                        date: tournament.date,
                        gameType: tournament.gameType,
                        course: tournament.course,
                        tee: tournament.tee,
                        players: tournament.players,
                        teams: tournament.teams || []
                    };
                    
                    saveToLocalStorage();
                    subscribToTournamentUpdates(tournamentId);
                    
                    if (claimingFromMyPlayersModal || window.returnToMyPlayersPage) {
                        claimingFromMyPlayersModal = false;
                        window.returnToMyPlayersPage = false;
                        showNotification('Claimed!', `Now scoring for ${finalPlayerName}`);
                        showMyPlayersPage();
                    } else {
                        currentView = 'hole';
                        renderScoringPage();
                        showPage('scoringPage');
                        setTimeout(() => switchToHoleView(), 100);
                        showNotification('Ready to Score!', `You're scoring for ${playerName}`);
                    }
                }
            } catch (error) {
                console.error('Error selecting player:', error);
                alert('Failed to select player');
            }
        }
        
        // Handle leaderboard action button click
        function handleLeaderboardAction() {
            // If user has claimed players and tournament data loaded, go to scoring
            if (activeTournamentId && tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                renderScoringPage();
                showPage('scoringPage');
                switchToHoleView();
            } else {
                // Otherwise go to setup page
                showPage('setupPage');
            }
        }
        
        // Show list of unclaimed players for additional claims
        async function showClaimPlayersList() {
            if (!activeTournamentId) {
                showNotification('Error', 'No active tournament');
                return;
            }
            
            const modal = document.getElementById('claimPlayersModal');
            const content = document.getElementById('claimPlayersListContent');
            
            // Show loading state immediately (helps Android rendering)
            content.innerHTML = `
                <div style="text-align: center; padding: 40px 20px;">
                    <p style="font-size: 24px; margin-bottom: 12px;">⏳</p>
                    <p style="color: #64748b; font-size: 14px;">Loading players...</p>
                </div>
            `;
            modal.style.display = 'flex';
            
            // Small delay to let modal render before heavy processing (Android fix)
            await new Promise(resolve => setTimeout(resolve, 50));
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                if (!tournament || !tournament.players) {
                    content.innerHTML = `
                        <div style="text-align: center; padding: 40px 20px;">
                            <p style="font-size: 40px; margin-bottom: 12px;">⚠️</p>
                            <p style="color: #64748b; font-size: 16px;">Could not load tournament data</p>
                        </div>
                    `;
                    return;
                }
                
                // Filter unclaimed players - check for null, undefined, or empty string
                const unclaimedPlayers = tournament.players.filter(p => !p.claimedBy || p.claimedBy === '');
                
                console.log(`📋 Claim list: ${unclaimedPlayers.length} unclaimed of ${tournament.players.length} total`);
                
                if (unclaimedPlayers.length === 0) {
                    content.innerHTML = `
                        <div style="text-align: center; padding: 40px 20px;">
                            <p style="font-size: 40px; margin-bottom: 12px;">✅</p>
                            <p style="color: #64748b; font-size: 16px;">All players have been claimed!</p>
                        </div>
                    `;
                } else {
                    content.innerHTML = unclaimedPlayers.map((p, index) => {
                        const colors = [
                            { bg: '#dbeafe', border: '#1e3a5f', text: '#1e3a5f' },
                            { bg: '#fef3c7', border: '#f59e0b', text: '#92400e' },
                            { bg: '#d1fae5', border: '#166534', text: '#166534' },
                            { bg: '#fce7f3', border: '#ec4899', text: '#9f1239' },
                            { bg: '#e0e7ff', border: '#6366f1', text: '#3730a3' },
                        ];
                        const color = colors[index % colors.length];
                        // Escape player name for safe use in onclick
                        const safeName = (p.name || 'Unknown').replace(/'/g, "\\'").replace(/"/g, '&quot;');
                        const handicap = p.handicap ?? 0;
                        
                        return `
                            <button type="button"
                                onclick="claimAdditionalPlayerFromList('${safeName}', ${handicap})"
                                style="
                                    width: 100%;
                                    padding: 16px;
                                    margin-bottom: 12px;
                                    background: ${color.bg};
                                    border: 2px solid ${color.border};
                                    border-radius: 6px;
                                    color: ${color.text};
                                    font-size: 16px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    display: flex;
                                    align-items: center;
                                    justify-content: space-between;
                                    touch-action: manipulation;
                                    -webkit-tap-highlight-color: rgba(0,0,0,0.1);
                                ">
                                <span style="display: flex; align-items: center; gap: 12px; pointer-events: none;">
                                    <span style="font-size: 24px;">⛳</span>
                                    <span>${p.name || 'Unknown'}</span>
                                </span>
                                <span style="background: white; padding: 4px 12px; border-radius: 8px; font-size: 14px; pointer-events: none;">
                                    HCP ${handicap}
                                </span>
                            </button>
                        `;
                    }).join('');
                }
            } catch (error) {
                console.error('Error loading players:', error);
                content.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px;">
                        <p style="font-size: 40px; margin-bottom: 12px;">❌</p>
                        <p style="color: #64748b; font-size: 16px;">Failed to load players</p>
                        <p style="color: #94a3b8; font-size: 12px; margin-top: 8px;">${error.message || 'Unknown error'}</p>
                    </div>
                `;
            }
        }
        
        // Claim additional player from the list
        function claimAdditionalPlayerFromList(playerName, currentHandicap) {
            // Close the modal
            document.getElementById('claimPlayersModal').style.display = 'none';
            // Show handicap confirmation dialog
            showHandicapConfirmDialog(activeTournamentId, playerName, currentHandicap);
        }
        
        // Update Live leaderboard display
        function updateLiveLeaderboard(tournament) {
            if (!tournament || !tournament.players) return;
            
            // Update tournament info header
            const infoEl = document.getElementById('liveLeaderboardInfo');
            if (infoEl) {
                let infoText = tournament.date || '';
                if (tournament.name) {
                    infoText = tournament.name + (tournament.date ? ' • ' + tournament.date : '');
                }
                infoEl.textContent = infoText;
            }
            
            const content = document.getElementById('liveLeaderboardContent');
            if (!content) return;
            
            // Get current game type from tabs or use first enabled game
            const enabledGames = tournament.enabledGames || [tournament.gameType];
            const currentGame = document.querySelector('.game-tab.active')?.dataset.gameType || enabledGames[0];
            
            // Calculate results for current game - show ALL players
            const results = calculateGameResults(tournament.players, currentGame, tournament.course);
            
            // Render leaderboard - ALL players, not just top 10
            content.innerHTML = results.map((player, index) => {
                const medal = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : '';
                const rankClass = index === 0 ? 'first' : index === 1 ? 'second' : index === 2 ? 'third' : '';
                
                // Count holes played
                const holesPlayed = player.scores ? player.scores.filter(s => s > 0).length : 0;
                const thruText = holesPlayed === 18 ? 'F' : holesPlayed > 0 ? `${holesPlayed}` : '-';
                
                return `
                    <div class="leaderboard-entry ${rankClass}" onclick="showPlayerScorecardPopup('${player.name.replace(/'/g, "\\'")}')" style="cursor: pointer;">
                        <div class="leaderboard-rank">${medal || (index + 1) + '.'}</div>
                        <div class="leaderboard-name" style="flex: 1;">
                            ${player.name}
                            <span style="font-size: 10px; color: #94a3b8; margin-left: 4px;">thru ${thruText}</span>
                        </div>
                        <div class="leaderboard-score">${player.displayScore}</div>
                    </div>
                `;
            }).join('');
            
            // Update info
            document.getElementById('activePlayersCount').textContent = tournament.players.length;
            document.getElementById('lastUpdateTime').textContent = 'Just now';
            
            // Update action button based on whether user can score
            const actionBtn = document.getElementById('leaderboardActionBtn');
            if (actionBtn) {
                if (activeTournamentId && tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                    actionBtn.textContent = 'Start Scoring ⛳';
                    actionBtn.style.background = 'linear-gradient(135deg, #166534, #166534)';
                    actionBtn.style.boxShadow = '0 4px 12px rgba(16, 185, 129, 0.4)';
                } else {
                    actionBtn.textContent = 'Back to Home';
                    actionBtn.style.background = '#94a3b8';
                    actionBtn.style.boxShadow = 'none';
                }
            }
        }
        
        // Show player scorecard popup
        function showPlayerScorecardPopup(playerName) {
            // Find the player data
            const player = tournamentData?.players?.find(p => p.name === playerName);
            if (!player) return;
            
            // Get course data
            const course = courses[tournamentData.course] || customCourses[tournamentData.course];
            if (!course) return;
            
            // Calculate totals
            const frontNine = player.scores.slice(0, 9).reduce((sum, s) => sum + (s || 0), 0);
            const backNine = player.scores.slice(9, 18).reduce((sum, s) => sum + (s || 0), 0);
            const total = frontNine + backNine;
            const toPar = total - course.totalPar;
            const toParDisplay = toPar === 0 ? 'E' : toPar > 0 ? `+${toPar}` : toPar;
            
            // Build scorecard HTML
            let html = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10002; display: flex; align-items: center; justify-content: center; padding: 16px;" onclick="this.remove()">
                    <div style="background: white; border-radius: 6px; padding: 20px; max-width: 400px; width: 100%; max-height: 85vh; overflow-y: auto;" onclick="event.stopPropagation()">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                            <div>
                                <div style="font-size: 18px; font-weight: 700; color: #1e293b;">${playerName}</div>
                                <div style="font-size: 13px; color: #64748b;">HCP: ${player.handicap > 0 ? player.handicap : player.handicap < 0 ? '+' + Math.abs(player.handicap) : 'Scratch'}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 24px; font-weight: 700; color: ${toPar < 0 ? '#a51c30' : toPar > 0 ? '#1e3a5f' : '#166534'};">${toParDisplay}</div>
                                <div style="font-size: 13px; color: #64748b;">${total} total</div>
                            </div>
                        </div>
                        
                        <div style="background: #f8fafc; border-radius: 6px; overflow: hidden; margin-bottom: 16px;">
                            <!-- Front 9 -->
                            <div style="background: #1e3a5f; color: white; padding: 8px 12px; font-weight: 700; font-size: 13px;">Front 9</div>
                            <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                                <tr style="background: #e2e8f0;">
                                    <td style="padding: 6px 8px; font-weight: 600;">Hole</td>
                                    ${[1,2,3,4,5,6,7,8,9].map(h => `<td style="padding: 6px 4px; text-align: center; font-weight: 600;">${h}</td>`).join('')}
                                    <td style="padding: 6px 8px; text-align: center; font-weight: 700; background: #cbd5e1;">OUT</td>
                                </tr>
                                <tr>
                                    <td style="padding: 6px 8px; color: #64748b;">Par</td>
                                    ${course.holes.slice(0,9).map(h => `<td style="padding: 6px 4px; text-align: center; color: #64748b;">${h.par}</td>`).join('')}
                                    <td style="padding: 6px 8px; text-align: center; font-weight: 600; background: #f1f5f9;">${course.holes.slice(0,9).reduce((s,h) => s + h.par, 0)}</td>
                                </tr>
                                <tr style="background: white;">
                                    <td style="padding: 6px 8px; font-weight: 600;">Score</td>
                                    ${player.scores.slice(0,9).map((s, i) => {
                                        const par = course.holes[i].par;
                                        const diff = s ? s - par : 0;
                                        let bg = 'transparent', color = '#1e293b';
                                        if (s && diff <= -2) { bg = '#fbbf24'; color = '#1e293b'; } // Eagle
                                        else if (s && diff === -1) { bg = '#a51c30'; color = 'white'; } // Birdie
                                        else if (s && diff === 1) { bg = '#1e3a5f'; color = 'white'; } // Bogey
                                        else if (s && diff >= 2) { bg = '#1e3a5f'; color = 'white'; } // Double+
                                        return `<td style="padding: 6px 4px; text-align: center; background: ${bg}; color: ${color}; font-weight: ${s ? '600' : '400'};">${s || '-'}</td>`;
                                    }).join('')}
                                    <td style="padding: 6px 8px; text-align: center; font-weight: 700; background: #e2e8f0;">${frontNine || '-'}</td>
                                </tr>
                            </table>
                            
                            <!-- Back 9 -->
                            <div style="background: #1e3a5f; color: white; padding: 8px 12px; font-weight: 700; font-size: 13px;">Back 9</div>
                            <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                                <tr style="background: #e2e8f0;">
                                    <td style="padding: 6px 8px; font-weight: 600;">Hole</td>
                                    ${[10,11,12,13,14,15,16,17,18].map(h => `<td style="padding: 6px 4px; text-align: center; font-weight: 600;">${h}</td>`).join('')}
                                    <td style="padding: 6px 8px; text-align: center; font-weight: 700; background: #cbd5e1;">IN</td>
                                </tr>
                                <tr>
                                    <td style="padding: 6px 8px; color: #64748b;">Par</td>
                                    ${course.holes.slice(9,18).map(h => `<td style="padding: 6px 4px; text-align: center; color: #64748b;">${h.par}</td>`).join('')}
                                    <td style="padding: 6px 8px; text-align: center; font-weight: 600; background: #f1f5f9;">${course.holes.slice(9,18).reduce((s,h) => s + h.par, 0)}</td>
                                </tr>
                                <tr style="background: white;">
                                    <td style="padding: 6px 8px; font-weight: 600;">Score</td>
                                    ${player.scores.slice(9,18).map((s, i) => {
                                        const par = course.holes[i + 9].par;
                                        const diff = s ? s - par : 0;
                                        let bg = 'transparent', color = '#1e293b';
                                        if (s && diff <= -2) { bg = '#fbbf24'; color = '#1e293b'; } // Eagle
                                        else if (s && diff === -1) { bg = '#a51c30'; color = 'white'; } // Birdie
                                        else if (s && diff === 1) { bg = '#1e3a5f'; color = 'white'; } // Bogey
                                        else if (s && diff >= 2) { bg = '#1e3a5f'; color = 'white'; } // Double+
                                        return `<td style="padding: 6px 4px; text-align: center; background: ${bg}; color: ${color}; font-weight: ${s ? '600' : '400'};">${s || '-'}</td>`;
                                    }).join('')}
                                    <td style="padding: 6px 8px; text-align: center; font-weight: 700; background: #e2e8f0;">${backNine || '-'}</td>
                                </tr>
                            </table>
                        </div>
                        
                        <button onclick="this.parentElement.parentElement.remove()" style="width: 100%; padding: 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-weight: 600; font-size: 14px; cursor: pointer;">
                            Close
                        </button>
                    </div>
                </div>
            `;
            
            const popup = document.createElement('div');
            popup.innerHTML = html;
            document.body.appendChild(popup.firstElementChild);
        }
        
        // Calculate game results (simplified version)
        function calculateGameResults(players, gameType, course) {
            // This is a simplified calculation - full logic would match your existing results calculation
            return players.map(player => {
                const totalScore = player.scores.reduce((sum, score) => sum + (score || 0), 0);
                const holesPlayed = player.scores.filter(s => s > 0).length;
                const par = courses[course]?.totalPar || customCourses[course]?.totalPar || 72;
                const toPar = totalScore - par;
                const displayScore = toPar >= 0 ? `+${toPar}` : toPar;
                
                return {
                    name: player.name,
                    totalScore,
                    holesPlayed,
                    scores: player.scores,
                    toPar,
                    displayScore: holesPlayed === 0 ? '-' : `${totalScore} (${displayScore === '+0' ? 'E' : displayScore})`
                };
            }).sort((a, b) => {
                // Sort by holes played (more holes = higher priority), then by score
                if (a.holesPlayed === 0 && b.holesPlayed > 0) return 1;
                if (b.holesPlayed === 0 && a.holesPlayed > 0) return -1;
                if (a.holesPlayed === 0 && b.holesPlayed === 0) return 0;
                return a.totalScore - b.totalScore;
            });
        }
        
        // Render game toggle tabs
        function renderGameTabs(enabledGames) {
            const tabsContainer = document.getElementById('gameToggleTabs');
            if (!tabsContainer) return;
            
            const gameLabels = {
                'Stroke Play Gross': 'Gross',
                'Stroke Play Net': 'Net',
                'Gross Skins': 'Skins',
                'Net Skins (Full Hcp)': 'Net Skins',
                'Stableford': 'Stableford'
            };
            
            tabsContainer.innerHTML = enabledGames.map((game, index) => `
                <button class="game-tab ${index === 0 ? 'active' : ''}" data-game-type="${game}" onclick="switchGameTab('${game}')">
                    ${gameLabels[game] || game}
                </button>
            `).join('');
        }
        
        // Switch active game tab
        function switchGameTab(gameType) {
            document.querySelectorAll('.game-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.gameType === gameType);
            });
            
            // Reload leaderboard for new game type
            if (activeTournamentId) {
                db.collection('tournaments').doc(activeTournamentId).get()
                    .then(doc => {
                        if (doc.exists) {
                            updateLiveLeaderboard(doc.data());
                        }
                    });
            }
        }

        // ========================================
        // MAIN SCORING FUNCTION (MODIFIED FOR CLOUD)
        // ========================================
        
        function startScoring() {
            const date = document.getElementById('tournamentDate').value;
            const tournamentName = document.getElementById('tournamentName').value.trim();
            const gameType = document.getElementById('gameType').value;
            let selectedCourse = document.getElementById('courseSelect').value;
            
            // Strip fav_ prefix if present - save the actual course key
            if (selectedCourse && selectedCourse.startsWith('fav_')) {
                selectedCourse = selectedCourse.substring(4);
            }
            
            // Validate date selection
            if (!date) {
                alert('Please select a date');
                return;
            }
            
            // Validate game type selection
            if (!gameType) {
                alert('Please select a game type');
                return;
            }
            
            // Validate course selection
            if (!selectedCourse) {
                alert('Please select a course');
                return;
            }
            
            // Update course data
            courseData = courses[selectedCourse] || customCourses[selectedCourse];
            
            // Get tee data for course handicap calculation
            const teeData = (courseData && selectedTee && courseData.tees) ? courseData.tees[selectedTee] : null;
            
            // Check if GHIN mode is enabled
            const useGhinMode = document.getElementById('setupUseGhinCheckbox')?.checked || false;
            
            const players = [];
            // Loop through all player rows (they may not be sequential)
            const playerRows = document.querySelectorAll('.player-row');
            playerRows.forEach(row => {
                const playerId = row.getAttribute('data-player');
                const nameInput = document.getElementById(`player${playerId}`);
                const hcpInput = document.getElementById(`hcp${playerId}`);
                
                if (nameInput) {
                    const name = nameInput.value.trim();
                    const inputValue = parseFloat(hcpInput?.value);
                    
                    let handicap = 0;
                    let handicapIndex = null;
                    let hcpMode = 'course';
                    
                    if (!isNaN(inputValue)) {
                        if (useGhinMode) {
                            // GHIN mode: input is handicap index, calculate course handicap
                            handicapIndex = Math.round(inputValue * 10) / 10;
                            hcpMode = 'index';
                            
                            if (teeData) {
                                handicap = calculateCourseHandicap(handicapIndex, teeData.slope, teeData.rating, courseData.totalPar);
                            } else {
                                handicap = Math.round(handicapIndex);
                            }
                        } else {
                            // Course HCP mode: input is direct course handicap
                            handicap = Math.round(inputValue);
                        }
                    }
                    
                    if (name) {
                        players.push({
                            name: name,
                            handicap: handicap,
                            handicapIndex: handicapIndex,
                            hcpMode: hcpMode,
                            scores: new Array(18).fill(0)
                        });
                    }
                }
            });

            if (players.length === 0) {
                alert('Please enter at least one player name');
                return;
            }

            // Save players to history
            players.forEach(player => {
                updatePlayerHistory(player.name, player.handicap);
            });

            // Capture team assignments for Best Ball games
            let teams = [];
            if (gameType.includes('Best Ball')) {
                const numTeams = 2;
                const playersPerTeam = gameType === '2-Man Best Ball' ? 2 : gameType === '3-Man Best Ball' ? 3 : 4;
                
                for (let t = 0; t < numTeams; t++) {
                    const teamPlayers = [];
                    for (let p = 0; p < playersPerTeam; p++) {
                        const playerIndex = document.getElementById(`team${t}_player${p}`).value;
                        if (playerIndex !== '') {
                            teamPlayers.push(parseInt(playerIndex));
                        }
                    }
                    if (teamPlayers.length > 0) {
                        teams.push(teamPlayers);
                    }
                }
                
                if (teams.length < 2) {
                    alert('Please assign players to both teams');
                    return;
                }
            }

            // Get privacy settings
            const privacyViewLeaderboard = document.getElementById('privacyViewLeaderboard')?.checked ?? true;
            const privacySignedEarly = document.getElementById('privacySignedEarly')?.checked ?? false;
            const privacyWatchOthers = document.getElementById('privacyWatchOthers')?.checked ?? true;

            tournamentData = {
                id: generateTournamentId(),
                name: tournamentName || '', // Optional tournament name
                date: date,
                gameType: gameType,
                course: selectedCourse,
                tee: selectedTee, // Store which tees were played
                players: players,
                teams: teams,
                privacy: {
                    viewLeaderboard: privacyViewLeaderboard,
                    signedEarly: privacySignedEarly,
                    watchOthers: privacyWatchOthers
                }
            };

            // Hide Resume button when starting fresh
            const resumeBtn = document.getElementById('resumeScoringBtn');
            if (resumeBtn) {
                resumeBtn.style.display = 'none';
            }

            // Pro users always get multi-device mode
            console.log('🎯 startScoring - checking subscription:', {
                hasActive: hasActiveSubscription(),
                currentAuthUser: currentAuthUser?.email,
                tournamentModeBefore: tournamentMode
            });
            if (hasActiveSubscription()) {
                tournamentMode = 'multi';
                console.log('🎯 Pro user detected - set tournamentMode to multi');
            }

            // Handle based on scoring mode
            if (tournamentMode === 'multi') {
                // Gate check: Cloud features require subscription
                if (!canUseCloudFeatures()) {
                    // Check if they have more than FREE_PLAYER_LIMIT players
                    if (players.length > FREE_PLAYER_LIMIT) {
                        showPaywall(`Free plan allows ${FREE_PLAYER_LIMIT} players. You have ${players.length}. Upgrade for unlimited players and multi-device!`);
                        return;
                    }
                    // Allow single-device mode for free users with <= 4 players
                    tournamentMode = 'single';
                    showNotification('Single-Device Mode', `Free plan - scoring on this device only. Upgrade for multi-device!`);
                }
                
                // Create cloud tournament (only if we still have multi mode)
                if (tournamentMode === 'multi') {
                    // REQUIRE SIGN-IN to create tournaments (so host is never unknown)
                    if (!currentAuthUser) {
                        showNotification('Sign In Required', 'Please sign in to host a tournament');
                        // Show sign-in modal
                        showSignInModal();
                        return;
                    }
                    
                    createCloudTournament({
                    name: tournamentName || '', // Optional tournament name
                    date: date,
                    gameType: gameType,
                    course: selectedCourse,
                    tee: selectedTee, // Store which tees were played
                    players: players.map(p => ({
                        ...p,
                        scores: new Array(18).fill(null),
                        claimedBy: null // No one claimed yet
                    })),
                    teams: teams,
                    enabledGames: [gameType], // Can add more games later
                    privacy: {
                        viewLeaderboard: privacyViewLeaderboard,
                        signedEarly: privacySignedEarly,
                        watchOthers: privacyWatchOthers
                    }
                }).then(tournamentId => {
                    if (tournamentId) {
                        activeTournamentId = tournamentId;
                        isHost = true;
                        tournamentMode = 'multi'; // Ensure this is set
                        
                        // Ensure courseData is loaded
                        if (!courseData) {
                            courseData = courses[selectedCourse] || customCourses[selectedCourse];
                            console.log('🏌️ Loaded courseData in success callback:', courseData?.name);
                        }
                        
                        console.log('🎯 Tournament created successfully:', {
                            tournamentId,
                            isHost,
                            tournamentMode,
                            activeTournamentId,
                            courseDataLoaded: !!courseData,
                            playersCount: tournamentData?.players?.length
                        });
                        
                        // CLEAR the backup - new tournament is now the active one
                        previousTournamentBackup = null;
                        localStorage.removeItem('indianHillsScoring'); // Clear old data before saving new
                        
                        // Subscribe to real-time updates
                        subscribToTournamentUpdates(tournamentId);
                        
                        // Initialize foursome games if needed
                        initFoursomeGameIfNeeded();
                        
                        // Continue to scoring
                        saveToLocalStorage();
                        renderScoringPage();
                        showPage('scoringPage');
                        switchToHoleView();
                        
                        // Show notification
                        showNotification('Tournament Created!', 'Go back to Setup page to share QR/Link');
                    } else {
                        // If tournament creation returned null (shouldn't happen with throw, but just in case)
                        console.error('Tournament creation returned null');
                        throw new Error('Tournament creation failed');
                    }
                }).catch(error => {
                    console.error('Tournament creation error:', error);
                    
                    // Show single consolidated error message
                    const errorMsg = error.message || 'Unknown error';
                    showNotification('Multi-Device Mode Failed', `Switching to Single-Device mode. Error: ${errorMsg}`, true);
                    
                    // Fall back to single-device mode
                    tournamentMode = 'single';
                    document.getElementById('singleDeviceBtn').classList.add('active');
                    document.getElementById('multiDeviceBtn').classList.remove('active');
                    
                    saveToLocalStorage();
                    renderScoringPage();
                    showPage('scoringPage');
                    switchToHoleView();
                });
                } else {
                    // Downgraded to single-device mode for free users
                    previousTournamentBackup = null;
                    localStorage.removeItem('indianHillsScoring');
                    
                    // Free users in single-device mode are still the host
                    isHost = true;
                    
                    saveToLocalStorage();
                    renderScoringPage();
                    showPage('scoringPage');
                    switchToHoleView();
                }
            } else {
                // Single-device mode - existing behavior
                // CLEAR the backup - new tournament is now the active one
                previousTournamentBackup = null;
                localStorage.removeItem('indianHillsScoring'); // Clear old data before saving new
                
                // CRITICAL: Clear old Firebase tournament ID for single-device mode
                activeTournamentId = null;
                isHost = true; // In single-device mode, user is always the "host"
                hasJoinedTournament = false;
                
                // Initialize foursome games if needed
                initFoursomeGameIfNeeded();
                
                saveToLocalStorage();
                renderScoringPage();
                showPage('scoringPage');
                switchToHoleView();
            }
        }

        // Show player management page (host only)
        async function showPlayerManagement() {
            if (!canManageTournament()) {
                showNotification('Not Available', 'Only hosts and co-hosts can manage the tournament');
                return;
            }
            
            let tournament;
            
            // For single-device mode (no activeTournamentId), use local data
            if (!activeTournamentId || tournamentMode === 'single') {
                // Use local tournamentData for single-device mode
                console.log('📋 Showing management page in single-device mode');
                tournament = tournamentData;
            } else {
                // Multi-device mode - fetch from Firebase
                try {
                    // Check if db is available
                    if (!db) {
                        showNotification('Offline', 'Cannot load - no database connection');
                        return;
                    }
                    
                    const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                    const tournamentDoc = await tournamentRef.get();
                    
                    if (!tournamentDoc.exists) {
                        showNotification('Not Found', 'Tournament not found in database');
                        return;
                    }
                    
                    tournament = tournamentDoc.data();
                    
                    if (!tournament) {
                        showNotification('Error', 'Tournament data is empty');
                        return;
                    }
                    
                    // Update local tournamentData
                    tournamentData = tournament;
                } catch (error) {
                    console.error('Error loading tournament:', error);
                    showNotification('Error', 'Failed to load tournament data');
                    return;
                }
            }
            
            try {
            // Store current tee selection for management (used by edit modal)
            managementSelectedTee = tournament.tee || null;
            
            // Update connection status
            const statusDiv = document.getElementById('managementConnectionStatus');
            if (statusDiv) {
                if (isOnline && tournamentMode === 'multi') {
                    statusDiv.innerHTML = `
                        <span style="width: 8px; height: 8px; border-radius: 50%; background: #166534;"></span>
                        <span style="color: #166534; font-size: 12px; font-weight: 500;">Connected</span>
                    `;
                    statusDiv.parentElement.style.background = '#f0fdf4';
                    statusDiv.parentElement.style.borderColor = '#166534';
                } else if (tournamentMode === 'single') {
                    statusDiv.innerHTML = `
                        <span style="width: 8px; height: 8px; border-radius: 50%; background: #1e3a5f;"></span>
                        <span style="color: #1e3a5f; font-size: 12px; font-weight: 500;">Single-Device</span>
                    `;
                    statusDiv.parentElement.style.background = '#f0f4f8';
                    statusDiv.parentElement.style.borderColor = '#1e3a5f';
                } else {
                    statusDiv.innerHTML = `
                        <span style="width: 8px; height: 8px; border-radius: 50%; background: #a51c30;"></span>
                        <span style="color: #991b1b; font-size: 12px; font-weight: 500;">Offline</span>
                    `;
                    statusDiv.parentElement.style.background = '#fef2f2';
                    statusDiv.parentElement.style.borderColor = '#e57373';
                }
            }
            
            // Update smart info line with tournament details
            const smartInfo = document.getElementById('managementSmartInfo');
            if (smartInfo) {
                const name = tournament.name || 'Tournament';
                const gameType = tournament.gameType || 'Stroke Play';
                // Get full course name from courseData if available, otherwise use tournament.course
                const courseName = (courseData && courseData.name) ? courseData.name : (tournament.course || 'Course');
                // Get course initials (e.g., "Indian Hills Golf Club" -> "IHGC")
                const courseInitials = courseName.split(/[\s_-]+/)
                    .filter(word => word.length > 0)
                    .map(word => word.charAt(0).toUpperCase())
                    .join('');
                const date = tournament.date ? new Date(tournament.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) : '';
                smartInfo.textContent = `${name} | ${gameType} | ${courseInitials} | ${date}`;
            }
            
            // Generate player cards with reorder buttons - swipe to delete enabled
            const content = document.getElementById('playerManagementContent');
            const playerCount = tournament.players.length;
            
            // Ensure devices object exists for single-device mode
            if (!tournament.devices) {
                tournament.devices = {};
            }
            
            content.innerHTML = tournament.players.map((p, index) => {
                const claimedDevice = p.claimedBy ? tournament.devices[p.claimedBy] : null;
                const isHostPlayer = isClaimedByMe(p);
                const deviceDisplay = claimedDevice ? (claimedDevice.initials || claimedDevice.name) : null;
                const holesPlayed = p.scores ? p.scores.filter(s => s !== null && s !== undefined).length : 0;
                const totalScore = p.scores ? p.scores.reduce((sum, s) => sum + (s || 0), 0) : 0;
                
                return `
                    <div class="player-swipe-container" data-player-name="${p.name}" style="position: relative; overflow: hidden; margin-bottom: 8px; border-radius: 8px;">
                        <!-- Delete button revealed on swipe -->
                        <div class="swipe-delete-btn" style="position: absolute; right: 0; top: 0; bottom: 0; width: 70px; background: #a51c30; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 12px; cursor: pointer;" onclick="deletePlayerFromTournament('${p.name}')">
                            Delete
                        </div>
                        
                        <!-- Player card content -->
                        <div class="player-card-content" style="
                            background: #f5f5f5;
                            border: ${p.claimedBy ? '2px solid #228b22' : '1px solid #e5e7eb'};
                            border-radius: 8px;
                            padding: 10px;
                            display: flex;
                            align-items: center;
                                gap: 8px;
                                position: relative;
                                z-index: 1;
                                transform: translateX(0);
                                transition: transform 0.2s ease-out;
                            ">
                                <!-- Player Info -->
                                <div style="flex: 1; min-width: 0;">
                                    <!-- Row 1: Name + HCP -->
                                    <div style="display: flex; align-items: center; gap: 4px;">
                                        <span style="font-weight: 600; color: #1e293b; font-size: 14px;">${p.name}</span>
                                        <span style="color: #64748b; font-size: 12px;">(${p.handicap})</span>
                                    </div>
                                    <!-- Row 2: Holes + Score + Device -->
                                    <div style="font-size: 11px; color: #64748b; margin-top: 2px; display: flex; align-items: center; gap: 6px;">
                                        <span>${holesPlayed > 0 ? `${holesPlayed} holes • Score: ${totalScore}` : 'No scores yet'}</span>
                                        ${p.claimedBy ? `
                                            <span>•</span>
                                            <span style="color: #228b22; font-weight: 600;">✓ ${deviceDisplay}</span>
                                        ` : `
                                            <span>•</span>
                                            <span style="color: #94a3b8;">Unclaimed</span>
                                        `}
                                    </div>
                                </div>
                                
                                <!-- Action Buttons - Release, Edit (pencil), and Reorder arrows -->
                                <div style="display: flex; gap: 4px; flex-shrink: 0; align-items: center;">
                                    ${p.claimedBy ? `
                                        <button onclick="unclaimPlayer('${p.name}')" style="padding: 4px 8px; background: transparent; color: #a51c30; border: 1px solid #a51c30; border-radius: 4px; font-size: 10px; font-weight: 600; cursor: pointer;">Release</button>
                                    ` : ''}
                                    <button onclick="editPlayerFromManagement('${p.name}', ${p.handicap})" style="padding: 4px 8px; background: white; color: #1e3a5f; border: 1px solid #d4b896; border-radius: 4px; font-size: 12px; cursor: pointer;">✏️</button>
                                    
                                    <!-- Reorder arrows - navy styling -->
                                    <div style="display: flex; flex-direction: column; gap: 2px; margin-left: 4px;">
                                        <button onclick="movePlayerUp(${index})" ${index === 0 ? 'disabled' : ''} style="width: 24px; height: 20px; border: 1px solid ${index === 0 ? '#d1d5db' : '#1e3a5f'}; background: white; color: ${index === 0 ? '#d1d5db' : '#1e3a5f'}; border-radius: 4px; font-size: 10px; cursor: ${index === 0 ? 'default' : 'pointer'}; display: flex; align-items: center; justify-content: center;">↑</button>
                                        <button onclick="movePlayerDown(${index})" ${index === playerCount - 1 ? 'disabled' : ''} style="width: 24px; height: 20px; border: 1px solid ${index === playerCount - 1 ? '#d1d5db' : '#1e3a5f'}; background: white; color: ${index === playerCount - 1 ? '#d1d5db' : '#1e3a5f'}; border-radius: 4px; font-size: 10px; cursor: ${index === playerCount - 1 ? 'default' : 'pointer'}; display: flex; align-items: center; justify-content: center;">↓</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Initialize swipe-to-delete for player cards
                initPlayerSwipeToDelete();
                
                if (tournament.players.length === 0) {
                    content.innerHTML = '<p style="text-align: center; color: #64748b; padding: 20px;">No players added yet</p>';
                }
                
                showPage('playerManagementPage');
                
                // Update the Host/Player toggle UI
                updateHostViewModeUI();
                
                // Show "Become Co-Host" section for non-hosts who aren't already co-hosts
                const becomeCoHostSection = document.getElementById('becomeCoHostSection');
                const isOriginalHost = tournament.hostDevice === currentDeviceId;
                
                if (becomeCoHostSection) {
                    const isCoHost = tournament.coHosts && tournament.coHosts.includes(currentDeviceId);
                    becomeCoHostSection.style.display = (!isOriginalHost && !isCoHost) ? 'block' : 'none';
                }
                
                // Render co-hosts section (host only)
                renderCoHostsSection();
                
                // Show/hide finished tournament actions
                const finishedActions = document.getElementById('finishedTournamentActions');
                if (finishedActions) {
                    if (tournament.isFinished) {
                        finishedActions.style.display = 'block';
                    } else {
                        finishedActions.style.display = 'none';
                    }
                }
                
                // Show Finish Tournament section only for hosts (when tournament is not finished)
                const finishSection = document.getElementById('finishTournamentSection');
                if (finishSection) {
                    const isOrigHost = tournament.hostDevice === currentDeviceId;
                    finishSection.style.display = (isOrigHost && !tournament.isFinished) ? 'block' : 'none';
                }
            } catch (error) {
                console.error('Error loading tournament management:', error);
                showNotification('Error', 'Failed to load tournament management');
            }
        }
        
        // Move player up in the list
        async function movePlayerUp(index) {
            if (index <= 0) return;
            await swapPlayers(index, index - 1);
        }
        
        // Move player down in the list
        async function movePlayerDown(index) {
            if (!tournamentData || index >= tournamentData.players.length - 1) return;
            await swapPlayers(index, index + 1);
        }
        
        // Swap two players in the list
        async function swapPlayers(indexA, indexB) {
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Swap players
                const temp = tournament.players[indexA];
                tournament.players[indexA] = tournament.players[indexB];
                tournament.players[indexB] = temp;
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update local data
                tournamentData.players = tournament.players;
                saveToLocalStorage();
                
                // Refresh the page
                showPlayerManagement();
            } catch (error) {
                console.error('Error reordering players:', error);
                showNotification('Error', 'Failed to reorder players');
            }
        }
        
        // ========================================
        // CO-HOST MANAGEMENT FUNCTIONS
        // ========================================
        
        // Render co-hosts section in management page
        async function renderCoHostsSection() {
            const section = document.getElementById('coHostsSection');
            const content = document.getElementById('coHostsContent');
            
            if (!section || !content) return;
            
            // Only show for the original host (not co-hosts)
            if (!isHost) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const coHosts = tournament.coHosts || [];
                const devices = tournament.devices || {};
                const connectedDevices = tournament.connectedDevices || {};
                
                // Get device IDs that have claimed players (still actively in tournament)
                const activeDeviceIds = new Set();
                tournament.players.forEach(player => {
                    if (player.claimedBy) {
                        activeDeviceIds.add(player.claimedBy);
                    }
                });
                
                // Also include devices in connectedDevices
                Object.keys(connectedDevices).forEach(id => activeDeviceIds.add(id));
                
                // Get list of devices that could be promoted (has claimed players or connected, not host, not already co-host)
                const availableDevices = Object.entries(devices).filter(([deviceId, device]) => {
                    // Must not be current device (host)
                    if (deviceId === currentDeviceId) return false;
                    // Must not already be a co-host
                    if (coHosts.includes(deviceId)) return false;
                    // Must have claimed players OR be in connected devices (actively participating)
                    return activeDeviceIds.has(deviceId);
                });
                
                // Also filter co-hosts to only show ones that are still active
                const activeCoHosts = coHosts.filter(coHostId => {
                    return devices[coHostId] && (activeDeviceIds.has(coHostId) || coHostId === currentDeviceId);
                });
                
                let html = '';
                
                // Current co-hosts (only active ones)
                if (activeCoHosts.length > 0) {
                    html += '<div style="margin-bottom: 10px;">';
                    activeCoHosts.forEach(coHostId => {
                        const device = devices[coHostId];
                        const displayName = device ? (device.initials || device.name || 'Unknown') : 'Unknown Device';
                        html += `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: white; border: 1px solid #c4b5fd; border-radius: 6px; margin-bottom: 6px;">
                                <span style="font-size: 13px; color: #5b21b6; font-weight: 500;">👑 ${displayName}</span>
                                <button onclick="removeCoHost('${coHostId}')" style="padding: 4px 8px; background: #fee2e2; color: #a51c30; border: none; border-radius: 4px; font-size: 11px; cursor: pointer;">Remove</button>
                            </div>
                        `;
                    });
                    html += '</div>';
                }
                
                // Available devices to promote
                if (availableDevices.length > 0) {
                    html += `
                        <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                            ${availableDevices.map(([deviceId, device]) => {
                                const displayName = device.initials || device.name || 'Device';
                                return `
                                    <button onclick="addCoHost('${deviceId}')" style="padding: 6px 10px; background: white; color: #1e3a5f; border: 1.5px solid #c4b5fd; border-radius: 6px; font-size: 11px; font-weight: 500; cursor: pointer;">
                                        + ${displayName}
                                    </button>
                                `;
                            }).join('')}
                        </div>
                    `;
                } else if (activeCoHosts.length === 0) {
                    html += '<p style="font-size: 12px; color: #9ca3af; margin: 0;">No other devices connected yet. Share the link to add co-hosts.</p>';
                }
                
                content.innerHTML = html;
            } catch (error) {
                console.error('Error rendering co-hosts:', error);
                content.innerHTML = '<p style="font-size: 12px; color: #a51c30; margin: 0;">Error loading co-hosts</p>';
            }
        }
        
        // Add a device as co-host
        async function addCoHost(deviceId) {
            if (!isHost) {
                showNotification('Not Authorized', 'Only the host can add co-hosts');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const coHosts = tournament.coHosts || [];
                
                if (!coHosts.includes(deviceId)) {
                    coHosts.push(deviceId);
                    
                    await tournamentRef.update({
                        coHosts: coHosts,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    const device = tournament.devices[deviceId];
                    const displayName = device ? (device.initials || device.name) : 'Device';
                    showNotification('Co-host Added', `${displayName} can now manage the tournament`);
                    renderCoHostsSection();
                }
            } catch (error) {
                console.error('Error adding co-host:', error);
                showNotification('Error', 'Failed to add co-host');
            }
        }
        
        // Remove a co-host
        async function removeCoHost(deviceId) {
            if (!isHost) {
                showNotification('Not Authorized', 'Only the host can remove co-hosts');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                let coHosts = tournament.coHosts || [];
                coHosts = coHosts.filter(id => id !== deviceId);
                
                await tournamentRef.update({
                    coHosts: coHosts,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                const device = tournament.devices[deviceId];
                const displayName = device ? (device.initials || device.name) : 'Device';
                showNotification('Co-host Removed', `${displayName} is no longer a co-host`);
                renderCoHostsSection();
            } catch (error) {
                console.error('Error removing co-host:', error);
                showNotification('Error', 'Failed to remove co-host');
            }
        }
        
        // Clear scores for a single player
        async function clearPlayerScores(playerName) {
            if (!confirm(`Clear all scores for ${playerName}?`)) return;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) return;
                
                tournament.players[playerIndex].scores = Array(18).fill(null);
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update local data
                tournamentData.players = tournament.players;
                saveToLocalStorage();
                
                showNotification('Cleared', `Scores cleared for ${playerName}`);
                showPlayerManagement();
            } catch (error) {
                console.error('Error clearing player scores:', error);
                showNotification('Error', 'Failed to clear scores');
            }
        }
        
        // Variable to track selected tee in management
        let managementSelectedTee = null;
        
        // Show Edit Tournament modal
        function showEditTournamentModal() {
            // Create modal
            const modal = document.createElement('div');
            modal.id = 'editTournamentModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
                overflow-y: auto;
            `;
            
            // Get current values
            const name = tournamentData.name || '';
            const date = tournamentData.date || new Date().toISOString().split('T')[0];
            const currentCourse = tournamentData.course || '';
            const currentTee = tournamentData.tee || '';
            
            // Get privacy settings
            const viewLeaderboard = tournamentData.privacy?.viewLeaderboard !== false;
            const signedEarly = tournamentData.privacy?.signedEarly === true;
            const watchOthers = tournamentData.privacy?.watchOthers !== false;
            
            // Build course options
            let courseOptions = '';
            Object.keys(courses).forEach(key => {
                const selected = key === currentCourse ? 'selected' : '';
                courseOptions += `<option value="${key}" ${selected}>${courses[key].name}</option>`;
            });
            Object.keys(customCourses).forEach(key => {
                if (!courses[key]) {
                    const selected = key === currentCourse ? 'selected' : '';
                    courseOptions += `<option value="${key}" ${selected}>${customCourses[key].name} ⭐</option>`;
                }
            });
            
            // Build tee buttons
            const courseObj = courses[currentCourse] || customCourses[currentCourse];
            let teeButtonsHtml = '';
            if (courseObj && courseObj.tees) {
                Object.keys(courseObj.tees).forEach(teeKey => {
                    const tee = courseObj.tees[teeKey];
                    const isSelected = teeKey === currentTee;
                    const border = isSelected ? '2px solid #1e3a5f' : '1px solid #d1d5db';
                    
                    teeButtonsHtml += `
                        <button type="button" onclick="selectEditTee('${teeKey}')" 
                            data-tee="${teeKey}"
                            style="padding: 6px 12px; background: white; color: #64748b; border: ${border}; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">
                            ${tee.name}
                        </button>
                    `;
                });
            }
            
            // Check if this is the original host (for Host Code button)
            const isOriginalHost = tournamentData.hostDevice === currentDeviceId;
            const hostCodeBtnHtml = isOriginalHost && tournamentMode === 'multi' ? `
                <button type="button" onclick="closeEditTournamentModal(); showHostCodeModal();" style="padding: 8px 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; white-space: nowrap;">
                    🔑 Host Code
                </button>
            ` : '';
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 6px; padding: 20px; max-width: 380px; width: 100%; max-height: 90vh; overflow-y: auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h2 style="color: #1e3a5f; font-size: 18px; margin: 0;">✏️ Edit Tournament</h2>
                        <button onclick="closeEditTournamentModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b; line-height: 1;">✕</button>
                    </div>
                    
                    <!-- Tournament Name -->
                    <div style="margin-bottom: 12px;">
                        <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Tournament Name</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="editTournamentName" value="${name}" placeholder="Tournament Name" style="flex: 1; padding: 10px; border: 1.5px solid #e2e8f0; border-radius: 4px; font-size: 14px; box-sizing: border-box;">
                            ${hostCodeBtnHtml}
                        </div>
                    </div>
                    
                    <!-- Date & Course -->
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <div style="flex: 0 0 auto;">
                            <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Date</label>
                            <input type="date" id="editTournamentDate" value="${date}" style="padding: 10px; border: 1.5px solid #e2e8f0; border-radius: 4px; font-size: 14px; box-sizing: border-box;">
                        </div>
                        <div style="flex: 1; min-width: 0;">
                            <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Course</label>
                            <select id="editTournamentCourse" onchange="updateEditTeeOptions()" style="width: 100%; padding: 10px; border: 1.5px solid #e2e8f0; border-radius: 4px; font-size: 14px; box-sizing: border-box;">
                                ${courseOptions}
                            </select>
                        </div>
                    </div>
                    
                    <!-- Tee Selection -->
                    <div style="margin-bottom: 16px;">
                        <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Playing Tees</label>
                        <div id="editTeeButtons" style="display: flex; gap: 6px; flex-wrap: wrap;">
                            ${teeButtonsHtml}
                        </div>
                    </div>
                    
                    <!-- Privacy Settings (Multi-device only) -->
                    <div id="editPrivacySection" style="display: ${tournamentMode === 'multi' ? 'block' : 'none'}; margin-bottom: 16px; padding: 12px; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 4px;">
                        <h3 style="color: #1e3a5f; font-size: 12px; margin: 0 0 10px 0;">🔒 Player Privacy</h3>
                        
                        <!-- View Leaderboard Toggle -->
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div>
                                <div style="font-weight: 600; color: #1e293b; font-size: 13px;">Can view leaderboard</div>
                                <div style="font-size: 10px; color: #64748b;">Results & other scorecards</div>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="editPrivacyViewLeaderboard" ${viewLeaderboard ? 'checked' : ''} onchange="updateEditPrivacyToggles()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <!-- Signed Early Toggle -->
                        <div id="editPrivacySignedEarlySection" style="display: ${viewLeaderboard ? 'none' : 'block'}; margin-left: 16px; margin-bottom: 10px; padding-left: 10px; border-left: 2px solid #e2e8f0;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-weight: 600; color: #1e293b; font-size: 13px;">Signed can view early</div>
                                    <div style="font-size: 10px; color: #64748b;">Unlock after signing</div>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="editPrivacySignedEarly" ${signedEarly ? 'checked' : ''}>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Watch Others Toggle -->
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-weight: 600; color: #1e293b; font-size: 13px;">Can watch others</div>
                                <div style="font-size: 10px; color: #64748b;">Watch unclaimed players</div>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="editPrivacyWatchOthers" ${watchOthers ? 'checked' : ''}>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div style="display: flex; gap: 8px;">
                        <button type="button" onclick="closeEditTournamentModal()" style="flex: 1; padding: 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                        <button type="button" onclick="saveEditTournament()" style="flex: 1; padding: 12px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            💾 Save
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Store selected tee
            window.editSelectedTee = currentTee;
        }
        
        // Close Edit Tournament modal
        function closeEditTournamentModal() {
            const modal = document.getElementById('editTournamentModal');
            if (modal) modal.remove();
        }
        
        // Select tee in Edit modal
        function selectEditTee(teeKey) {
            window.editSelectedTee = teeKey;
            
            const courseKey = document.getElementById('editTournamentCourse').value;
            const courseObj = courses[courseKey] || customCourses[courseKey];
            
            if (!courseObj || !courseObj.tees) return;
            
            // Update button styles
            const container = document.getElementById('editTeeButtons');
            container.querySelectorAll('button').forEach(btn => {
                const btnTeeKey = btn.getAttribute('data-tee');
                const isSelected = btnTeeKey === teeKey;
                btn.style.background = 'white';
                btn.style.color = '#64748b';
                btn.style.border = isSelected ? '2px solid #1e3a5f' : '1px solid #d1d5db';
            });
        }
        
        // Update tee options when course changes in Edit modal
        function updateEditTeeOptions() {
            const courseKey = document.getElementById('editTournamentCourse').value;
            const courseObj = courses[courseKey] || customCourses[courseKey];
            
            const container = document.getElementById('editTeeButtons');
            container.innerHTML = '';
            
            if (courseObj && courseObj.tees) {
                const teeKeys = Object.keys(courseObj.tees);
                // Select first tee by default when course changes
                window.editSelectedTee = teeKeys[0] || '';
                
                teeKeys.forEach(teeKey => {
                    const tee = courseObj.tees[teeKey];
                    const isSelected = teeKey === window.editSelectedTee;
                    const border = isSelected ? '2px solid #1e3a5f' : '1px solid #d1d5db';
                    
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.setAttribute('data-tee', teeKey);
                    btn.style.cssText = `padding: 6px 12px; background: white; color: #64748b; border: ${border}; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;`;
                    btn.textContent = tee.name;
                    btn.onclick = () => selectEditTee(teeKey);
                    container.appendChild(btn);
                });
            }
        }
        
        // Update privacy toggles visibility in Edit modal
        function updateEditPrivacyToggles() {
            const viewLeaderboard = document.getElementById('editPrivacyViewLeaderboard').checked;
            const signedEarlySection = document.getElementById('editPrivacySignedEarlySection');
            if (signedEarlySection) {
                signedEarlySection.style.display = viewLeaderboard ? 'none' : 'block';
            }
        }
        
        // Save tournament from Edit modal
        async function saveEditTournament() {
            const name = document.getElementById('editTournamentName').value.trim();
            const date = document.getElementById('editTournamentDate').value;
            const course = document.getElementById('editTournamentCourse').value;
            const newTee = window.editSelectedTee;
            
            // Get privacy settings
            const viewLeaderboard = document.getElementById('editPrivacyViewLeaderboard')?.checked !== false;
            const signedEarly = document.getElementById('editPrivacySignedEarly')?.checked === true;
            const watchOthers = document.getElementById('editPrivacyWatchOthers')?.checked !== false;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const oldCourse = tournament.course;
                const oldTee = tournament.tee;
                
                // Check if tee changed - need to recalculate handicaps
                const teeChanged = (newTee !== oldTee) || (course !== oldCourse);
                let updatedPlayers = tournament.players;
                let courseHcpPlayersCount = 0;
                
                if (teeChanged && newTee) {
                    const courseObj = courses[course] || customCourses[course];
                    const newTeeData = courseObj?.tees?.[newTee];
                    const oldTeeData = courseObj?.tees?.[oldTee];
                    
                    if (newTeeData && courseObj) {
                        // Recalculate course handicaps for all players
                        updatedPlayers = tournament.players.map(player => {
                            const updatedPlayer = { ...player };
                            
                            if (player.hcpMode === 'course') {
                                courseHcpPlayersCount++;
                                
                                if (oldTeeData && player.handicap) {
                                    const estimatedIndex = (player.handicap - (oldTeeData.rating - courseObj.totalPar)) * (113 / oldTeeData.slope);
                                    const newCourseHcp = calculateCourseHandicap(
                                        estimatedIndex,
                                        newTeeData.slope,
                                        newTeeData.rating,
                                        courseObj.totalPar
                                    );
                                    
                                    updatedPlayer.handicap = newCourseHcp;
                                    updatedPlayer.estimatedIndex = Math.round(estimatedIndex * 10) / 10;
                                }
                                
                                updatedPlayer.needsHcpConfirmation = true;
                                updatedPlayer.tee = newTee;
                            } else if (player.handicapIndex !== null && player.handicapIndex !== undefined) {
                                const newCourseHcp = calculateCourseHandicap(
                                    player.handicapIndex, 
                                    newTeeData.slope, 
                                    newTeeData.rating, 
                                    courseObj.totalPar
                                );
                                updatedPlayer.handicap = newCourseHcp;
                                updatedPlayer.tee = newTee;
                                updatedPlayer.needsHcpConfirmation = true;
                            } else {
                                updatedPlayer.needsHcpConfirmation = true;
                                updatedPlayer.tee = newTee;
                            }
                            
                            return updatedPlayer;
                        });
                    }
                }
                
                // Show warning if there are Course HCP players
                if (teeChanged && courseHcpPlayersCount > 0) {
                    const courseHcpNames = tournament.players
                        .filter(p => p.hcpMode === 'course')
                        .map(p => p.name)
                        .join(', ');
                    
                    const confirmed = confirm(
                        `⚠️ Tee Change Warning\n\n` +
                        `${courseHcpPlayersCount} player(s) have manually entered Course HCPs:\n` +
                        `${courseHcpNames}\n\n` +
                        `Their handicaps will be estimated for the new tees and marked for confirmation.\n\n` +
                        `Continue with tee change?`
                    );
                    
                    if (!confirmed) return;
                }
                
                // Build update object
                const updateObj = {
                    name: name,
                    date: date,
                    course: course,
                    tee: newTee,
                    players: updatedPlayers,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                // Add privacy settings if multi-device
                if (tournamentMode === 'multi') {
                    updateObj.privacy = {
                        viewLeaderboard: viewLeaderboard,
                        signedEarly: signedEarly,
                        watchOthers: watchOthers
                    };
                }
                
                await tournamentRef.update(updateObj);
                
                // Update local data
                tournamentData.name = name;
                tournamentData.date = date;
                tournamentData.course = course;
                tournamentData.tee = newTee;
                tournamentData.players = updatedPlayers;
                if (tournamentMode === 'multi') {
                    tournamentData.privacy = {
                        viewLeaderboard: viewLeaderboard,
                        signedEarly: signedEarly,
                        watchOthers: watchOthers
                    };
                }
                courseData = courses[course] || customCourses[course];
                saveToLocalStorage();
                
                // Update smart info lines
                generateSmartInfoLine('scoringSmartInfo');
                generateSmartInfoLine('resultsSmartInfo');
                
                // Close modal
                closeEditTournamentModal();
                
                if (teeChanged) {
                    const teeData = courseData?.tees?.[newTee];
                    const teeName = teeData?.name || newTee;
                    if (courseHcpPlayersCount > 0) {
                        showNotification('Saved', `Switched to ${teeName} tees. ${courseHcpPlayersCount} player(s) need HCP confirmation.`);
                    } else {
                        showNotification('Saved', `Switched to ${teeName} tees. Handicaps recalculated.`);
                    }
                } else {
                    showNotification('Saved', 'Tournament updated');
                }
            } catch (error) {
                console.error('Error saving tournament:', error);
                showNotification('Error', 'Failed to save tournament');
            }
        }

        // Show Host Code modal (original host only)
        async function showHostCodeModal() {
            if (!activeTournamentId) return;
            
            try {
                const tournamentDoc = await db.collection('tournaments').doc(activeTournamentId).get();
                const tournament = tournamentDoc.data();
                
                // Only original host can see this
                if (tournament.hostDevice !== currentDeviceId) {
                    showNotification('Not Available', 'Only the original host can view the host code');
                    return;
                }
                
                const hostCode = tournament.hostCode || 'Not Set';
                
                const modal = document.createElement('div');
                modal.id = 'hostCodeModal';
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.8); z-index: 10001;
                    display: flex; align-items: center; justify-content: center; padding: 20px;
                `;
                
                modal.innerHTML = `
                    <div style="background: white; border-radius: 8px; padding: 24px; max-width: 320px; width: 100%; text-align: center;">
                        <div style="display: flex; justify-content: flex-end; margin: -8px -8px 8px 0;">
                            <button onclick="closeHostCodeModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b; line-height: 1;">✕</button>
                        </div>
                        
                        <div style="font-size: 40px; margin-bottom: 8px;">🔑</div>
                        <h2 style="color: #1e3a5f; font-size: 18px; margin: 0 0 16px 0;">Host Code</h2>
                        
                        <div id="hostCodeDisplay" style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 6px; padding: 16px; margin-bottom: 16px;">
                            <span id="hostCodeValue" style="font-size: 28px; font-weight: 700; font-family: monospace; letter-spacing: 4px; color: #92400e;">${hostCode}</span>
                        </div>
                        
                        <div id="hostCodeEditSection" style="display: none; margin-bottom: 16px;">
                            <input type="text" id="hostCodeEditInput" value="${hostCode}" maxlength="6" 
                                style="width: 100%; padding: 12px; font-size: 20px; font-weight: 700; text-align: center; 
                                border: 2px solid #f59e0b; border-radius: 8px; font-family: monospace; letter-spacing: 3px;
                                text-transform: uppercase; box-sizing: border-box;"
                                oninput="this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0,6);">
                        </div>
                        
                        <p style="color: #64748b; font-size: 12px; margin-bottom: 20px;">Share this code with trusted people to grant them co-host access.</p>
                        
                        <div id="hostCodeActions" style="display: flex; gap: 12px;">
                            <button onclick="editHostCode()" style="flex: 1; padding: 12px; background: #f1f5f9; border: none; border-radius: 6px; color: #475569; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;">
                                ✏️ Edit
                            </button>
                            <button onclick="copyHostCode()" style="flex: 1; padding: 12px; background: #1e3a5f; border: none; border-radius: 6px; color: white; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;">
                                📋 Copy
                            </button>
                        </div>
                        
                        <div id="hostCodeSaveActions" style="display: none; gap: 12px;">
                            <button onclick="cancelEditHostCode()" style="flex: 1; padding: 12px; background: #f1f5f9; border: none; border-radius: 6px; color: #475569; font-size: 14px; font-weight: 600; cursor: pointer;">
                                Cancel
                            </button>
                            <button onclick="saveHostCode()" style="flex: 1; padding: 12px; background: #166534; border: none; border-radius: 6px; color: white; font-size: 14px; font-weight: 600; cursor: pointer;">
                                Save
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                modal.onclick = (e) => {
                    if (e.target === modal) closeHostCodeModal();
                };
            } catch (error) {
                console.error('Error showing host code:', error);
                showNotification('Error', 'Could not load host code');
            }
        }
        
        function closeHostCodeModal() {
            const modal = document.getElementById('hostCodeModal');
            if (modal) modal.remove();
        }
        
        function editHostCode() {
            document.getElementById('hostCodeDisplay').style.display = 'none';
            document.getElementById('hostCodeEditSection').style.display = 'block';
            document.getElementById('hostCodeActions').style.display = 'none';
            document.getElementById('hostCodeSaveActions').style.display = 'flex';
            document.getElementById('hostCodeEditInput').focus();
        }
        
        function cancelEditHostCode() {
            document.getElementById('hostCodeDisplay').style.display = 'block';
            document.getElementById('hostCodeEditSection').style.display = 'none';
            document.getElementById('hostCodeActions').style.display = 'flex';
            document.getElementById('hostCodeSaveActions').style.display = 'none';
        }
        
        async function saveHostCode() {
            const newCode = document.getElementById('hostCodeEditInput').value.trim().toUpperCase();
            
            if (newCode.length < 4) {
                showNotification('Error', 'Host code must be at least 4 characters');
                return;
            }
            
            try {
                await db.collection('tournaments').doc(activeTournamentId).update({
                    hostCode: newCode,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update display
                document.getElementById('hostCodeValue').textContent = newCode;
                cancelEditHostCode();
                showNotification('Saved', 'Host code updated');
            } catch (error) {
                console.error('Error saving host code:', error);
                showNotification('Error', 'Could not save host code');
            }
        }
        
        function copyHostCode() {
            const code = document.getElementById('hostCodeValue').textContent;
            navigator.clipboard.writeText(code).then(() => {
                showNotification('Copied', 'Host code copied to clipboard');
            }).catch(() => {
                showNotification('Error', 'Could not copy to clipboard');
            });
        }
        
        // Verify host code to become co-host
        async function verifyHostCode() {
            const input = document.getElementById('coHostCodeInput');
            const errorEl = document.getElementById('coHostCodeError');
            
            if (!input) return;
            
            const code = input.value.trim().toUpperCase();
            
            if (code.length < 4) {
                if (errorEl) errorEl.textContent = 'Enter at least 4 characters';
                return;
            }
            
            try {
                const tournamentDoc = await db.collection('tournaments').doc(activeTournamentId).get();
                const tournament = tournamentDoc.data();
                
                if (tournament.hostCode === code) {
                    // Grant co-host access
                    const coHosts = tournament.coHosts || [];
                    if (!coHosts.includes(currentDeviceId)) {
                        coHosts.push(currentDeviceId);
                        await db.collection('tournaments').doc(activeTournamentId).update({
                            coHosts: coHosts,
                            [`devices.${currentDeviceId}.isCoHost`]: true,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                    
                    // Update local state
                    isCoHost = true;
                    
                    // Hide the become co-host section
                    document.getElementById('becomeCoHostSection').style.display = 'none';
                    
                    showNotification('Success! 🎉', 'You are now a co-host');
                    
                    // Clear input
                    input.value = '';
                    if (errorEl) errorEl.textContent = '';
                } else {
                    if (errorEl) {
                        errorEl.textContent = 'Invalid host code';
                    }
                }
            } catch (error) {
                console.error('Error verifying host code:', error);
                if (errorEl) errorEl.textContent = 'Error verifying code';
            }
        }
        
        // Confirm delete tournament
        function confirmDeleteTournament() {
            if (!confirm('Are you sure you want to delete this tournament? This cannot be undone.')) return;
            if (!confirm('FINAL WARNING: All scores and data will be permanently deleted. Continue?')) return;
            deleteTournament();
        }
        
        // Delete tournament
        async function deleteTournament() {
            try {
                await db.collection('tournaments').doc(activeTournamentId).delete();
                
                // Clear local data
                localStorage.removeItem('letsgolf_data');
                activeTournamentId = null;
                tournamentData = null;
                isHost = false;
                
                showNotification('Deleted', 'Tournament has been deleted');
                showPage('setupPage');
            } catch (error) {
                console.error('Error deleting tournament:', error);
                showNotification('Error', 'Failed to delete tournament');
            }
        }
        
        // Clear all scores (all 18 holes)
        async function clearAllScores() {
            if (!confirm('Clear ALL scores AND stats for ALL players? This cannot be undone.')) return;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                tournament.players.forEach(p => {
                    p.scores = Array(18).fill(null);
                });
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                tournamentData.players = tournament.players;
                
                // Clear all player stats (FIR, GIR, Putts, Dots)
                playerStats = {};
                savePlayerStatsToLocalStorage();
                
                saveToLocalStorage();
                
                showNotification('Cleared', 'All scores and stats have been cleared');
                showPlayerManagement();
            } catch (error) {
                console.error('Error clearing scores:', error);
                showNotification('Error', 'Failed to clear scores');
            }
        }
        
        // Clear front 9 scores
        async function clearFront9Scores() {
            if (!confirm('Clear Front 9 scores AND stats (holes 1-9) for ALL players?')) return;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                tournament.players.forEach(p => {
                    if (!p.scores) p.scores = Array(18).fill(null);
                    for (let i = 0; i < 9; i++) {
                        p.scores[i] = null;
                    }
                });
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                tournamentData.players = tournament.players;
                
                // Clear front 9 stats for all players
                Object.keys(playerStats).forEach(playerName => {
                    const stats = playerStats[playerName];
                    if (stats) {
                        for (let i = 0; i < 9; i++) {
                            if (stats.fir) stats.fir[i] = null;
                            if (stats.gir) stats.gir[i] = null;
                            if (stats.putts) stats.putts[i] = null;
                            if (stats.dots) stats.dots[i] = null;
                        }
                    }
                });
                savePlayerStatsToLocalStorage();
                
                saveToLocalStorage();
                
                showNotification('Cleared', 'Front 9 scores and stats have been cleared');
                showPlayerManagement();
            } catch (error) {
                console.error('Error clearing front 9:', error);
                showNotification('Error', 'Failed to clear scores');
            }
        }
        
        // Clear back 9 scores
        async function clearBack9Scores() {
            if (!confirm('Clear Back 9 scores AND stats (holes 10-18) for ALL players?')) return;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                tournament.players.forEach(p => {
                    if (!p.scores) p.scores = Array(18).fill(null);
                    for (let i = 9; i < 18; i++) {
                        p.scores[i] = null;
                    }
                });
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                tournamentData.players = tournament.players;
                
                // Clear back 9 stats for all players
                Object.keys(playerStats).forEach(playerName => {
                    const stats = playerStats[playerName];
                    if (stats) {
                        for (let i = 9; i < 18; i++) {
                            if (stats.fir) stats.fir[i] = null;
                            if (stats.gir) stats.gir[i] = null;
                            if (stats.putts) stats.putts[i] = null;
                            if (stats.dots) stats.dots[i] = null;
                        }
                    }
                });
                savePlayerStatsToLocalStorage();
                
                saveToLocalStorage();
                
                showNotification('Cleared', 'Back 9 scores and stats have been cleared');
                showPlayerManagement();
            } catch (error) {
                console.error('Error clearing back 9:', error);
                showNotification('Error', 'Failed to clear scores');
            }
        }
        
        // Unclaim a player (host and co-hosts)
        async function unclaimPlayer(playerName) {
            if (!activeTournamentId || !canManageTournament()) {
                showNotification('Not Authorized', 'Only hosts and co-hosts can release claims');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) return;
                
                tournament.players[playerIndex].claimedBy = null;
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                showNotification('Released', `${playerName} is now unclaimed`);
                showPlayerManagement(); // Refresh the page
            } catch (error) {
                console.error('Error unclaiming player:', error);
                showNotification('Error', 'Failed to release claim');
            }
        }
        
        // Show add player form
        function showAddPlayerForm() {
            document.getElementById('addPlayerForm').style.display = 'block';
            document.getElementById('newPlayerName').focus();
        }
        
        // Hide add player form
        function hideAddPlayerForm() {
            document.getElementById('addPlayerForm').style.display = 'none';
            document.getElementById('newPlayerName').value = '';
            document.getElementById('newPlayerHandicap').value = '0';
        }
        
        // Refresh player management
        function refreshPlayerManagement() {
            showPlayerManagement();
            showNotification('Refreshed', 'Player list updated');
        }
        
        // Add new player from management page
        async function addNewPlayerFromManagement() {
            const name = document.getElementById('newPlayerName').value.trim();
            const handicap = parseFloat(document.getElementById('newPlayerHandicap').value) || 0;
            
            if (!name) {
                showNotification('Error', 'Please enter a player name');
                return;
            }
            
            if (!activeTournamentId) {
                showNotification('Error', 'No active tournament');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Check if name already exists
                if (tournament.players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                    showNotification('Error', 'Player with this name already exists');
                    return;
                }
                
                // Add new player
                const newPlayer = {
                    name: name,
                    handicap: handicap,
                    scores: new Array(18).fill(0),
                    claimedBy: null
                };
                
                tournament.players.push(newPlayer);
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Also update local data
                tournamentData.players.push(newPlayer);
                saveToLocalStorage();
                
                hideAddPlayerForm();
                showNotification('Added', `${name} added to tournament`);
                showPlayerManagement(); // Refresh
            } catch (error) {
                console.error('Error adding player:', error);
                showNotification('Error', 'Failed to add player');
            }
        }

        // ========================================
        // MY PLAYERS MANAGEMENT FUNCTIONS
        // ========================================
        
        // Load player order from localStorage
        function loadPlayerOrder() {
            // Use tournament-specific key to avoid cross-contamination between tournaments
            const storageKey = activeTournamentId ? `playerOrder_${currentDeviceId}_${activeTournamentId}` : `playerOrder_${currentDeviceId}`;
            const saved = localStorage.getItem(storageKey);
            if (saved) {
                try {
                    playerOrder = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading player order:', e);
                    playerOrder = { claimed: [], watching: [] };
                }
            } else {
                // No saved order for this tournament - start fresh
                playerOrder = { claimed: [], watching: [] };
            }
        }
        
        // Save player order to localStorage
        function savePlayerOrder() {
            // Use tournament-specific key
            const storageKey = activeTournamentId ? `playerOrder_${currentDeviceId}_${activeTournamentId}` : `playerOrder_${currentDeviceId}`;
            localStorage.setItem(storageKey, JSON.stringify(playerOrder));
        }
        
        // Get device name for display
        function getDeviceName(tournament, deviceId) {
            if (!deviceId) return 'UNK';
            if (!tournament || !tournament.devices) return deviceId.substring(0, 3).toUpperCase();
            if (tournament.devices[deviceId]) {
                return tournament.devices[deviceId].initials || tournament.devices[deviceId].name || deviceId.substring(0, 3).toUpperCase();
            }
            return deviceId.substring(0, 3).toUpperCase();
        }
        
        // Sort players by saved order
        function sortPlayersByOrder(players, orderArray) {
            const ordered = [];
            const unordered = [...players];
            
            orderArray.forEach(name => {
                const player = unordered.find(p => p.name === name);
                if (player) {
                    ordered.push(player);
                    unordered.splice(unordered.indexOf(player), 1);
                }
            });
            
            return [...ordered, ...unordered];
        }
        
        // Render individual player row
        function renderPlayerRow(player, index, type, totalCount) {
            const canEdit = type === 'claimed';
            const isFirst = index === 0;
            const isLast = index === totalCount - 1;
            
            const bgColor = type === 'claimed' ? '#fef3c7' : '#dbeafe';
            const borderColor = type === 'claimed' ? '#f59e0b' : '#1e3a5f';
            
            return `
                <div style="background: ${bgColor}; border: 2px solid ${borderColor}; border-radius: 8px; padding: 12px; margin-bottom: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <div style="flex: 1;">
                            <div style="font-weight: 700; font-size: 15px;">${player.name}</div>
                            <div style="font-size: 13px; color: #64748b;">Handicap: ${player.handicap}</div>
                            ${type === 'watching' && player.claimedBy ? 
                                (() => {
                                    const displayName = (player.claimerDisplayName && player.claimerDisplayName !== 'null' && player.claimerDisplayName !== 'Null' && player.claimerDisplayName !== 'undefined') 
                                        ? player.claimerDisplayName 
                                        : getClaimerDisplayName(player.claimedBy, tournamentData);
                                    return displayName ? `<div style="font-size: 12px; color: #1e3a5f;">Scored by: ${displayName}</div>` : '';
                                })() : 
                                ''}
                        </div>
                        <div style="display: flex; gap: 4px; align-items: center;">
                            <button 
                                onclick="movePlayer('${player.name}', ${index}, -1, '${type}')"
                                ${isFirst ? 'disabled' : ''}
                                style="width: 32px; height: 32px; background: ${isFirst ? '#e2e8f0' : '#ffffff'}; border: 2px solid ${borderColor}; border-radius: 6px; cursor: ${isFirst ? 'not-allowed' : 'pointer'}; font-size: 16px;">
                                ⬆️
                            </button>
                            <button 
                                onclick="movePlayer('${player.name}', ${index}, 1, '${type}')"
                                ${isLast ? 'disabled' : ''}
                                style="width: 32px; height: 32px; background: ${isLast ? '#e2e8f0' : '#ffffff'}; border: 2px solid ${borderColor}; border-radius: 6px; cursor: ${isLast ? 'not-allowed' : 'pointer'}; font-size: 16px;">
                                ⬇️
                            </button>
                            ${canEdit ? `
                                <button 
                                    onclick="editPlayerModal('${player.name}', ${player.handicap})"
                                    style="width: 32px; height: 32px; background: #ffffff; border: 2px solid ${borderColor}; border-radius: 6px; cursor: pointer; font-size: 16px;">
                                    ✏️
                                </button>
                            ` : ''}
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        ${canEdit ? `
                            <button onclick="releasePlayer('${player.name}')" style="flex: 1; padding: 8px; background: #a51c30; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                                Release Player
                            </button>
                        ` : `
                            <button onclick="removeFromWatchList('${player.name}')" style="flex: 1; padding: 8px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 13px; font-weight: 600; cursor: pointer;">
                                Stop Watching
                            </button>
                        `}
                    </div>
                </div>
            `;
        }
        
        // Show My Players Page (Full Page for Non-Hosts)
        async function showMyPlayersPage() {
            if (!activeTournamentId) {
                showNotification('Error', 'No active tournament');
                return;
            }
            
            // Only load player order if not already set (e.g., fresh from joining)
            if (!playerOrder || (!playerOrder.claimed?.length && !playerOrder.watching?.length)) {
                loadPlayerOrder();
            }
            
            // Show the Host/Player toggle if host in player mode
            updateMyPlayersHostToggle();
            
            // Update notification toggle button state
            updateNotificationToggleUI();
            
            try {
                // Check if db is available
                if (!db) {
                    showNotification('Offline', 'Cannot load - no database connection');
                    return;
                }
                
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                
                if (!tournamentDoc.exists) {
                    showNotification('Not Found', 'Tournament not found');
                    return;
                }
                
                const tournament = tournamentDoc.data();
                
                if (!tournament || !tournament.players) {
                    showNotification('Error', 'Tournament has no player data');
                    return;
                }
                
                // Update local tournamentData
                tournamentData = tournament;
                
                // Update smart info line with tournament details
                const smartInfo = document.getElementById('myPlayersSmartInfo');
                if (smartInfo) {
                    const name = tournament.name || 'Tournament';
                    const gameType = tournament.gameType || 'Stroke Play';
                    // Get full course name from courseData if available, otherwise use tournament.course
                    const courseName = (courseData && courseData.name) ? courseData.name : (tournament.course || 'Course');
                    // Get course initials (e.g., "Indian Hills Golf Club" -> "IHGC")
                    const courseInitials = courseName.split(/[\s_-]+/)
                        .filter(word => word.length > 0)
                        .map(word => word.charAt(0).toUpperCase())
                        .join('');
                    const date = tournament.date ? new Date(tournament.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) : '';
                    smartInfo.textContent = `${name} | ${gameType} | ${courseInitials} | ${date}`;
                }
                
                const claimedPlayers = tournament.players.filter(p => isClaimedByMe(p));
                const watchedPlayerNames = playerOrder.watching || [];
                const watchedPlayers = tournament.players.filter(p => 
                    watchedPlayerNames.includes(p.name) && !isClaimedByMe(p)
                );
                const availablePlayers = tournament.players.filter(p => 
                    !claimedPlayers.includes(p) && !watchedPlayers.includes(p)
                );
                
                // IMPORTANT: Ensure claimed players are in the order array
                claimedPlayers.forEach(p => {
                    if (!playerOrder.claimed.includes(p.name)) {
                        playerOrder.claimed.push(p.name);
                    }
                });
                // Remove any players from order that are no longer claimed
                playerOrder.claimed = playerOrder.claimed.filter(name => 
                    claimedPlayers.some(p => p.name === name)
                );
                savePlayerOrder();
                
                const sortedClaimed = sortPlayersByOrder(claimedPlayers, playerOrder.claimed);
                const sortedWatched = sortPlayersByOrder(watchedPlayers, playerOrder.watching);
                
                const content = document.getElementById('myPlayersPageContent');
                
                // Load stats config
                loadStatsConfig();
                
                content.innerHTML = `
                    <!-- STATS TRACKER BOX - White background -->
                    <div style="background: white; border: 1px solid #e5e7eb; border-radius: 6px; padding: 12px; margin-bottom: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="color: #1e3a5f; font-size: 14px; margin: 0;">📊 Stats Tracker</h3>
                            <button onclick="showStatsHistoryModal()" style="padding: 6px 12px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer;">
                                📈 History
                            </button>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;">
                            <button onclick="toggleStat('fir')" style="padding: 12px 6px; border-radius: 8px; border: ${statsTrackerConfig.fir ? 'none' : '2px solid #1e3a5f'}; background: ${statsTrackerConfig.fir ? '#1e3a5f' : 'white'}; color: ${statsTrackerConfig.fir ? 'white' : '#1e3a5f'}; font-size: 12px; font-weight: 600; cursor: pointer;">
                                FIR
                            </button>
                            <button onclick="toggleStat('gir')" style="padding: 12px 6px; border-radius: 8px; border: ${statsTrackerConfig.gir ? 'none' : '2px solid #1e3a5f'}; background: ${statsTrackerConfig.gir ? '#1e3a5f' : 'white'}; color: ${statsTrackerConfig.gir ? 'white' : '#1e3a5f'}; font-size: 12px; font-weight: 600; cursor: pointer;">
                                GIR
                            </button>
                            <button onclick="toggleStat('putts')" style="padding: 12px 6px; border-radius: 8px; border: ${statsTrackerConfig.putts ? 'none' : '2px solid #1e3a5f'}; background: ${statsTrackerConfig.putts ? '#1e3a5f' : 'white'}; color: ${statsTrackerConfig.putts ? 'white' : '#1e3a5f'}; font-size: 12px; font-weight: 600; cursor: pointer;">
                                Putts
                            </button>
                            <button onclick="toggleStat('dots')" style="padding: 12px 6px; border-radius: 8px; border: ${statsTrackerConfig.dots ? 'none' : '2px solid #1e3a5f'}; background: ${statsTrackerConfig.dots ? '#1e3a5f' : 'white'}; color: ${statsTrackerConfig.dots ? 'white' : '#1e3a5f'}; font-size: 12px; font-weight: 600; cursor: pointer;">
                                Dots
                            </button>
                        </div>
                        <p style="color: #6b7280; font-size: 10px; margin: 8px 0 0 0; text-align: center;">Tap to enable/disable stats in Hole View</p>
                    </div>
                    
                    <!-- SECTION 1: My Claimed Players - White background, no border -->
                    <div style="background: white; border-radius: 6px; padding: 12px; margin-bottom: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="color: #1e3a5f; font-size: 13px; margin: 0;">✅ My Claimed Players</h3>
                            ${sortedClaimed.length > 0 ? `<button onclick="clearAllClaimed()" style="padding: 5px 12px; background: transparent; color: #a51c30; border: 1px solid #a51c30; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer;">Clear All</button>` : ''}
                        </div>
                        ${sortedClaimed.length === 0 ? 
                            '<p style="color: #6b7280; font-size: 12px;">No claimed players</p>' :
                            sortedClaimed.map((p, index) => renderMyPlayerRow(p, index, 'claimed', sortedClaimed.length)).join('')
                        }
                    </div>
                    
                    <!-- SECTION 2: Watching - White background, no border -->
                    <div style="background: white; border-radius: 6px; padding: 12px; margin-bottom: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="color: #1e3a5f; font-size: 13px; margin: 0;">👁️ Watching</h3>
                            <div style="display: flex; gap: 6px;">
                                <button onclick="toggleWatchedNotifications()" id="watchingNotifyBtn" style="padding: 5px 10px; background: white; color: #1e3a5f; border: 1px solid #1e3a5f; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer;">🔔 Notify</button>
                                ${sortedWatched.length > 0 ? `<button onclick="clearAllWatched()" style="padding: 5px 12px; background: transparent; color: #a51c30; border: 1px solid #a51c30; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer;">Clear All</button>` : ''}
                            </div>
                        </div>
                        ${sortedWatched.length === 0 ? 
                            '<p style="color: #6b7280; font-size: 12px;">Not watching any players</p>' :
                            sortedWatched.map((p, index) => renderMyPlayerRow(p, index, 'watching', sortedWatched.length)).join('')
                        }
                    </div>
                    
                    <!-- SECTION 3: Available Players - White background -->
                    <div style="background: white; border-radius: 6px; padding: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="color: #374151; font-size: 13px; margin: 0;">📋 Available Players</h3>
                            <button onclick="showAddPlayerDialogFromMyPlayers()" style="padding: 5px 12px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer;">
                                + Add Player
                            </button>
                        </div>
                        ${availablePlayers.length === 0 ? 
                            '<p style="color: #6b7280; font-size: 12px;">All players claimed or watched</p>' :
                            availablePlayers.map(p => `
                                <div style="background: #f5f5f5; border: 1px solid #e5e7eb; border-radius: 8px; padding: 10px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="font-weight: 600; font-size: 14px; color: #1e293b;">${p.name}</div>
                                        <div style="font-size: 11px; color: #6b7280;">HCP ${p.handicap}${p.claimedBy ? ' • Claimed by ' + getDeviceName(tournament, p.claimedBy) : ''}</div>
                                    </div>
                                    <div style="display: flex; gap: 6px;">
                                        ${!p.claimedBy ? `
                                            <button onclick="claimPlayerFromMyPage('${p.name}')" style="padding: 6px 12px; background: white; color: #1e3a5f; border: 1px solid #1e3a5f; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer;">
                                                ✓ Claim
                                            </button>
                                        ` : ''}
                                        ${canWatchOthers() ? `
                                            <button onclick="addToWatchListFromPage('${p.name}')" style="padding: 6px 12px; background: white; color: #1e3a5f; border: 1px solid #1e3a5f; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer;">
                                                👁 Watch
                                            </button>
                                        ` : `
                                            <button onclick="showPrivacyBlockedMessage('watch')" style="padding: 6px 12px; background: #9ca3af; color: white; border: none; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer; opacity: 0.6;">
                                                🔒 Watch
                                            </button>
                                        `}
                                    </div>
                                </div>
                            `).join('')
                        }
                    </div>
                `;
                
                showPage('myPlayersPage');
            } catch (error) {
                console.error('Error loading my players:', error);
                showNotification('Error', 'Failed to load players');
            }
        }
        
        // Render player row for My Players page
        function renderMyPlayerRow(player, index, type, totalCount) {
            const canMoveUp = index > 0;
            const canMoveDown = index < totalCount - 1;
            const holesPlayed = player.scores ? player.scores.filter(s => s !== null && s !== undefined).length : 0;
            const totalScore = player.scores ? player.scores.reduce((sum, s) => sum + (s || 0), 0) : 0;
            
            return `
                <div style="background: #f5f5f5; border: 1px solid #e5e7eb; border-radius: 8px; padding: 10px; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                    <!-- Player Info -->
                    <div style="flex: 1; min-width: 0;">
                        <!-- Row 1: Name + HCP -->
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <span style="font-weight: 600; color: #1e293b; font-size: 14px;">${player.name}</span>
                            <span style="color: #64748b; font-size: 12px;">(${player.handicap > 0 ? player.handicap : player.handicap < 0 ? '+' + Math.abs(player.handicap) : 'Scr'})</span>
                        </div>
                        <!-- Row 2: Holes + Score -->
                        <div style="font-size: 11px; color: #64748b; margin-top: 2px;">
                            ${holesPlayed > 0 ? `${holesPlayed} holes • Score: ${totalScore}` : 'No scores yet'}
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div style="display: flex; gap: 4px; flex-shrink: 0; align-items: center;">
                        ${type === 'claimed' ? `
                            <button onclick="releasePlayerFromPage('${player.name}')" style="padding: 4px 8px; background: transparent; color: #a51c30; border: 1px solid #a51c30; border-radius: 4px; font-size: 10px; font-weight: 600; cursor: pointer;">Release</button>
                            <button onclick="editPlayerFromPage('${player.name}', ${player.handicap})" style="padding: 4px 8px; background: white; color: #1e3a5f; border: 1px solid #d4b896; border-radius: 4px; font-size: 12px; cursor: pointer;">✏️</button>
                        ` : `
                            <button onclick="removeFromWatchListFromPage('${player.name}')" style="padding: 4px 8px; background: transparent; color: #a51c30; border: 1px solid #a51c30; border-radius: 4px; font-size: 10px; font-weight: 600; cursor: pointer;">Stop</button>
                        `}
                        
                        <!-- Reorder arrows - navy styling -->
                        <div style="display: flex; flex-direction: column; gap: 2px; margin-left: 4px;">
                            <button onclick="movePlayerInPage('${player.name}', ${index}, -1, '${type}')" ${!canMoveUp ? 'disabled' : ''} style="width: 24px; height: 20px; border: 1px solid ${canMoveUp ? '#1e3a5f' : '#d1d5db'}; background: white; color: ${canMoveUp ? '#1e3a5f' : '#d1d5db'}; border-radius: 4px; font-size: 10px; cursor: ${canMoveUp ? 'pointer' : 'default'}; display: flex; align-items: center; justify-content: center;">↑</button>
                            <button onclick="movePlayerInPage('${player.name}', ${index}, 1, '${type}')" ${!canMoveDown ? 'disabled' : ''} style="width: 24px; height: 20px; border: 1px solid ${canMoveDown ? '#1e3a5f' : '#d1d5db'}; background: white; color: ${canMoveDown ? '#1e3a5f' : '#d1d5db'}; border-radius: 4px; font-size: 10px; cursor: ${canMoveDown ? 'pointer' : 'default'}; display: flex; align-items: center; justify-content: center;">↓</button>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // My Players Page helper functions
        function movePlayerInPage(playerName, currentIndex, direction, type) {
            const orderArray = type === 'claimed' ? playerOrder.claimed : playerOrder.watching;
            const newIndex = currentIndex + direction;
            
            if (newIndex < 0 || newIndex >= orderArray.length) return;
            
            // Swap
            [orderArray[currentIndex], orderArray[newIndex]] = [orderArray[newIndex], orderArray[currentIndex]];
            savePlayerOrder();
            showMyPlayersPage();
        }
        
        // Show add player dialog from My Players page
        function showAddPlayerDialogFromMyPlayers() {
            // Get username for pre-fill suggestion
            const suggestedName = currentAuthUser?.displayName || '';
            
            // Build tee buttons HTML
            let teeButtonsHtml = '';
            if (courseData && courseData.tees) {
                const teeColors = {
                    black: '#1e293b', tournament: '#1e293b',
                    blue: '#1e3a5f', championship: '#1e3a5f',
                    white: '#f1f5f9', regular: '#f1f5f9',
                    gold: '#fbbf24', forward: '#fbbf24',
                    red: '#a51c30', silver: '#94a3b8'
                };
                const tournamentTee = tournamentData?.tee || Object.keys(courseData.tees)[0];
                
                teeButtonsHtml = Object.keys(courseData.tees).map(teeKey => {
                    const tee = courseData.tees[teeKey];
                    const bgColor = teeColors[teeKey] || '#94a3b8';
                    const textColor = (teeKey === 'white' || teeKey === 'gold' || teeKey === 'regular' || teeKey === 'forward') ? '#1e293b' : 'white';
                    const isDefault = teeKey === tournamentTee;
                    const displayName = tee.name || teeKey;
                    
                    return `<button type="button" onclick="selectAddPlayerTee('${teeKey}')" id="addTee_${teeKey}"
                        style="padding: 6px 12px; background: ${bgColor}; color: ${textColor}; border: 2px solid ${isDefault ? '#166534' : (teeKey === 'white' || teeKey === 'regular' ? '#cbd5e1' : bgColor)}; border-radius: 16px; font-size: 12px; font-weight: 600; cursor: pointer;">
                        ${displayName}${isDefault ? ' ★' : ''}
                    </button>`;
                }).join('');
            }
            
            showModal(
                '➕ Add New Player',
                `
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <div>
                        <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Player Name</label>
                        <input type="text" id="newPlayerNameInput" value="${suggestedName}" placeholder="Enter player name" 
                            style="width: 100%; padding: 10px; border: 1.5px solid #e2e8f0; border-radius: 8px; font-size: 14px; box-sizing: border-box;">
                    </div>
                    ${courseData?.tees ? `
                    <div id="addPlayerTeeSection">
                        <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Playing From</label>
                        <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                            ${teeButtonsHtml}
                        </div>
                        <p style="font-size: 10px; color: #64748b; margin-top: 4px;">★ = Tournament default</p>
                    </div>
                    ` : ''}
                    <div>
                        <label id="addPlayerHcpLabel" style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Course Handicap</label>
                        <input type="number" id="newPlayerHandicapInput" value="0" min="-10" max="54" step="1"
                            style="width: 100%; padding: 10px; border: 1.5px solid #e2e8f0; border-radius: 8px; font-size: 14px; box-sizing: border-box;"
                            oninput="updateAddPlayerHcp()">
                        <p id="addPlayerCalcHcp" style="font-size: 11px; color: #166534; margin-top: 4px; font-weight: 600; display: none;"></p>
                    </div>
                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
                        <input type="checkbox" id="addPlayerGhinCheckbox" class="ghin-checkbox" onchange="toggleAddPlayerGhinMode(this.checked)">
                        <span style="color: #475569; font-weight: 600; font-size: 13px;">Use GHIN Handicap Index</span>
                    </label>
                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                        <button onclick="closeModal()" style="flex: 1; padding: 12px; background: #94a3b8; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                        <button onclick="addPlayerFromMyPlayersDialog()" style="flex: 1; padding: 12px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Add & Claim
                        </button>
                    </div>
                </div>
                `,
                null,
                false
            );
            
            // Set default tee selection
            window.addPlayerSelectedTee = tournamentData?.tee || (courseData?.tees ? Object.keys(courseData.tees)[0] : null);
            
            // Focus on name input
            setTimeout(() => {
                const input = document.getElementById('newPlayerNameInput');
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 100);
        }
        
        // Select tee for add player modal
        function selectAddPlayerTee(teeKey) {
            window.addPlayerSelectedTee = teeKey;
            
            // Update button styles
            if (courseData?.tees) {
                Object.keys(courseData.tees).forEach(key => {
                    const btn = document.getElementById(`addTee_${key}`);
                    if (btn) {
                        const isSelected = key === teeKey;
                        if (isSelected) {
                            btn.style.border = '3px solid #166534';
                            btn.style.boxShadow = '0 0 0 2px rgba(22, 101, 52, 0.3)';
                        } else {
                            btn.style.border = `2px solid ${(key === 'white' || key === 'regular') ? '#cbd5e1' : btn.style.backgroundColor}`;
                            btn.style.boxShadow = 'none';
                        }
                    }
                });
            }
            
            // Recalculate HCP if in GHIN mode
            updateAddPlayerHcp();
        }
        
        // Toggle GHIN mode in Add Player modal
        function toggleAddPlayerGhinMode(useGhin) {
            const label = document.getElementById('addPlayerHcpLabel');
            const input = document.getElementById('newPlayerHandicapInput');
            const calcDisplay = document.getElementById('addPlayerCalcHcp');
            
            if (useGhin) {
                label.textContent = 'GHIN Handicap Index';
                input.step = '0.1';
                input.placeholder = '12.4';
                calcDisplay.style.display = 'block';
                updateAddPlayerHcp();
            } else {
                label.textContent = 'Course Handicap';
                input.step = '1';
                input.placeholder = '0';
                calcDisplay.style.display = 'none';
            }
        }
        
        // Update calculated HCP in Add Player modal
        function updateAddPlayerHcp() {
            const useGhin = document.getElementById('addPlayerGhinCheckbox')?.checked;
            const calcDisplay = document.getElementById('addPlayerCalcHcp');
            const input = document.getElementById('newPlayerHandicapInput');
            
            if (!useGhin || !calcDisplay) return;
            
            const index = parseFloat(input.value) || 0;
            
            if (courseData && courseData.tees) {
                const tee = window.addPlayerSelectedTee || tournamentData?.tee || Object.keys(courseData.tees)[0];
                const teeData = courseData.tees[tee];
                if (teeData) {
                    const courseHcp = calculateCourseHandicap(index, teeData.slope, teeData.rating, courseData.totalPar);
                    calcDisplay.textContent = `= Course HCP ${courseHcp} (${teeData.name || tee} tees)`;
                    return;
                }
            }
            calcDisplay.textContent = `= Course HCP ${Math.round(index)}`;
        }
        
        // Add player from My Players dialog and claim them
        async function addPlayerFromMyPlayersDialog() {
            const nameInput = document.getElementById('newPlayerNameInput');
            const handicapInput = document.getElementById('newPlayerHandicapInput');
            const useGhin = document.getElementById('addPlayerGhinCheckbox')?.checked;
            
            const playerName = nameInput?.value?.trim();
            const inputValue = parseFloat(handicapInput?.value) || 0;
            
            // Get selected tee
            const selectedTee = window.addPlayerSelectedTee || tournamentData?.tee || (courseData?.tees ? Object.keys(courseData.tees)[0] : null);
            
            let handicap, handicapIndex, hcpMode;
            
            if (useGhin) {
                handicapIndex = Math.round(inputValue * 10) / 10;
                hcpMode = 'index';
                if (courseData && courseData.tees && selectedTee) {
                    const teeData = courseData.tees[selectedTee];
                    if (teeData) {
                        handicap = calculateCourseHandicap(handicapIndex, teeData.slope, teeData.rating, courseData.totalPar);
                    } else {
                        handicap = Math.round(handicapIndex);
                    }
                } else {
                    handicap = Math.round(handicapIndex);
                }
            } else {
                handicap = Math.round(inputValue);
                handicapIndex = null;
                hcpMode = 'course';
            }
            
            if (!playerName) {
                showNotification('Error', 'Please enter a player name');
                return;
            }
            
            // Check if player already exists
            if (tournamentData.players.some(p => p.name.toLowerCase() === playerName.toLowerCase())) {
                showNotification('Error', 'A player with this name already exists');
                return;
            }
            
            closeModal();
            
            try {
                // Add player to tournament
                const newPlayer = {
                    name: playerName,
                    handicap: handicap,
                    handicapIndex: handicapIndex,
                    hcpMode: hcpMode,
                    scores: new Array(18).fill(null),
                    claimedBy: getClaimIdentifier(),
                    claimerDisplayName: currentAuthUser?.displayName || 'Player'
                };
                
                // Update Firebase
                if (activeTournamentId) {
                    await db.collection('tournaments').doc(activeTournamentId).update({
                        players: firebase.firestore.FieldValue.arrayUnion(newPlayer),
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
                
                // Update local
                tournamentData.players.push(newPlayer);
                
                // Add to claimed list
                if (!claimedPlayers.includes(playerName)) {
                    claimedPlayers.push(playerName);
                }
                if (!playerOrder.claimed.includes(playerName)) {
                    playerOrder.claimed.push(playerName);
                }
                savePlayerOrder();
                
                saveToLocalStorage();
                showNotification('Added!', `${playerName} added and claimed`);
                
                // Refresh My Players page
                showMyPlayersPage();
                
            } catch (error) {
                console.error('Error adding player:', error);
                showNotification('Error', 'Failed to add player');
            }
        }
        
        async function claimPlayerFromMyPage(playerName) {
            // Get current handicap
            const player = tournamentData.players.find(p => p.name === playerName);
            if (player) {
                showHandicapConfirmDialog(activeTournamentId, playerName, player.handicap);
                // Set flag to return to My Players page after claiming
                window.returnToMyPlayersPage = true;
            }
        }
        
        function addToWatchListFromPage(playerName) {
            // Check privacy settings
            if (!canWatchOthers()) {
                showPrivacyBlockedMessage('watch');
                return;
            }
            
            if (!playerOrder.watching.includes(playerName)) {
                playerOrder.watching.push(playerName);
                savePlayerOrder();
                showMyPlayersPage();
            }
        }
        
        function removeFromWatchListFromPage(playerName) {
            playerOrder.watching = playerOrder.watching.filter(n => n !== playerName);
            savePlayerOrder();
            showMyPlayersPage();
        }
        
        // Clear all claimed players
        async function clearAllClaimed() {
            if (!activeTournamentId) return;
            
            showConfirm(
                'Release All Players?',
                'This will release all your claimed players. Their scores will be preserved.',
                async function() {
                    try {
                        const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                        const tournamentDoc = await tournamentRef.get();
                        const tournament = tournamentDoc.data();
                        
                        // Release all players claimed by this device
                        let releasedCount = 0;
                        tournament.players.forEach(player => {
                            if (isClaimedByMe(player)) {
                                player.claimedBy = null;
                                player.deviceInitials = null;
                                releasedCount++;
                            }
                        });
                        
                        if (releasedCount > 0) {
                            await tournamentRef.update({ players: tournament.players });
                            
                            // Clear local order
                            playerOrder.claimed = [];
                            savePlayerOrder();
                            
                            showNotification('Released', `${releasedCount} player(s) released`);
                        }
                        
                        showMyPlayersPage();
                    } catch (error) {
                        console.error('Error clearing claimed players:', error);
                        showNotification('Error', 'Failed to release players');
                    }
                }
            );
        }
        
        // Clear all watched players
        function clearAllWatched() {
            showConfirm(
                'Stop Watching All?',
                'This will remove all players from your watch list.',
                function() {
                    playerOrder.watching = [];
                    savePlayerOrder();
                    showNotification('Cleared', 'Watch list cleared');
                    showMyPlayersPage();
                }
            );
        }
        
        async function releasePlayerFromPage(playerName) {
            if (!activeTournamentId) return;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex !== -1 && isClaimedByMe(tournament.players[playerIndex])) {
                    tournament.players[playerIndex].claimedBy = null;
                    tournament.players[playerIndex].deviceInitials = null;
                    
                    await tournamentRef.update({ players: tournament.players });
                    
                    // Remove from local order
                    playerOrder.claimed = playerOrder.claimed.filter(n => n !== playerName);
                    savePlayerOrder();
                    
                    showNotification('Released', `${playerName} is now available`);
                    showMyPlayersPage();
                }
            } catch (error) {
                console.error('Error releasing player:', error);
                showNotification('Error', 'Failed to release player');
            }
        }
        
        function editPlayerFromPage(playerName, currentHandicap) {
            // Edit dialog with name and handicap fields
            const dialog = document.getElementById('confirmDialog');
            const titleEl = document.getElementById('confirmTitle');
            const messageEl = document.getElementById('confirmMessage');
            const cancelBtn = document.getElementById('confirmCancel');
            const okBtn = document.getElementById('confirmOk');
            
            // Get player's current data
            const player = tournamentData?.players?.find(p => p.name === playerName);
            const currentIndex = player?.handicapIndex || null;
            const isGhinMode = player?.hcpMode === 'index' || currentIndex !== null;
            
            // Build tee buttons HTML
            let teeButtonsHtml = '';
            if (courseData && courseData.tees) {
                const teeColors = {
                    black: '#1e293b', tournament: '#1e293b',
                    blue: '#1e3a5f', championship: '#1e3a5f',
                    white: '#f1f5f9', regular: '#f1f5f9',
                    gold: '#fbbf24', forward: '#fbbf24',
                    red: '#a51c30', silver: '#94a3b8'
                };
                const tournamentTee = tournamentData?.tee || Object.keys(courseData.tees)[0];
                
                teeButtonsHtml = Object.keys(courseData.tees).map(teeKey => {
                    const tee = courseData.tees[teeKey];
                    const bgColor = teeColors[teeKey] || '#94a3b8';
                    const textColor = (teeKey === 'white' || teeKey === 'gold' || teeKey === 'regular' || teeKey === 'forward') ? '#1e293b' : 'white';
                    const isDefault = teeKey === tournamentTee;
                    const displayName = tee.name || teeKey;
                    
                    return `<button type="button" onclick="selectEditPageTee('${teeKey}')" id="editPageTee_${teeKey}"
                        style="padding: 6px 10px; background: ${bgColor}; color: ${textColor}; border: 2px solid ${isDefault ? '#166534' : (teeKey === 'white' || teeKey === 'regular' ? '#cbd5e1' : bgColor)}; border-radius: 14px; font-size: 11px; font-weight: 600; cursor: pointer;">
                        ${displayName}${isDefault ? ' ★' : ''}
                    </button>`;
                }).join('');
            }
            
            titleEl.textContent = `Edit Player`;
            messageEl.innerHTML = `
                <div style="margin: 12px 0;">
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 14px;">Name:</label>
                    <input type="text" id="editPlayerNameInput" value="${playerName}" 
                        style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px;"
                        maxlength="30">
                </div>
                ${courseData?.tees ? `
                <div style="margin: 12px 0;">
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 14px;">Playing From:</label>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        ${teeButtonsHtml}
                    </div>
                    <p style="font-size: 10px; color: #64748b; margin-top: 4px;">★ = Tournament default</p>
                </div>
                ` : ''}
                <div style="margin: 12px 0;">
                    <label id="editPageHcpLabel" style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 14px;">Course Handicap:</label>
                    <input type="number" id="editPlayerHcpInput" value="${currentHandicap}" 
                        style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; text-align: center;"
                        min="-10" max="54" step="1" oninput="updateEditPageHcp()">
                    <p id="editPageCalcHcp" style="font-size: 12px; color: #166534; margin-top: 4px; font-weight: 600; display: none;"></p>
                </div>
                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
                    <input type="checkbox" id="editPageGhinCheckbox" class="ghin-checkbox" ${isGhinMode ? 'checked' : ''} onchange="toggleEditPageGhinMode(this.checked)">
                    <span style="color: #475569; font-weight: 600; font-size: 13px;">Use GHIN Handicap Index</span>
                </label>
            `;
            
            cancelBtn.textContent = 'Cancel';
            okBtn.textContent = 'Save';
            okBtn.style.background = '#1e3a5f';
            
            // Set default tee selection
            window.editPageSelectedTee = tournamentData?.tee || (courseData?.tees ? Object.keys(courseData.tees)[0] : null);
            
            // Initialize the display based on current mode
            setTimeout(() => {
                toggleEditPageGhinMode(isGhinMode);
                if (isGhinMode && currentIndex !== null) {
                    document.getElementById('editPlayerHcpInput').value = currentIndex;
                }
            }, 50);
            
            const newCancelHandler = () => {
                dialog.style.display = 'none';
            };
            const newOkHandler = async () => {
                const newName = document.getElementById('editPlayerNameInput').value.trim();
                const useGhin = document.getElementById('editPageGhinCheckbox').checked;
                const inputValue = parseFloat(document.getElementById('editPlayerHcpInput').value) || 0;
                
                // Get selected tee
                const selectedTee = window.editPageSelectedTee || tournamentData?.tee || (courseData?.tees ? Object.keys(courseData.tees)[0] : null);
                
                let newHandicap, handicapIndex, hcpMode;
                
                if (useGhin) {
                    handicapIndex = Math.round(inputValue * 10) / 10;
                    hcpMode = 'index';
                    if (courseData && courseData.tees && selectedTee) {
                        const teeData = courseData.tees[selectedTee];
                        if (teeData) {
                            newHandicap = calculateCourseHandicap(handicapIndex, teeData.slope, teeData.rating, courseData.totalPar);
                        } else {
                            newHandicap = Math.round(handicapIndex);
                        }
                    } else {
                        newHandicap = Math.round(handicapIndex);
                    }
                } else {
                    newHandicap = Math.round(inputValue);
                    handicapIndex = null;
                    hcpMode = 'course';
                }
                
                if (!newName) {
                    showNotification('Error', 'Player name cannot be empty');
                    return;
                }
                
                await updateClaimedPlayer(playerName, newName, newHandicap, handicapIndex, hcpMode);
                dialog.style.display = 'none';
                showMyPlayersPage();
            };
            
            cancelBtn.replaceWith(cancelBtn.cloneNode(true));
            okBtn.replaceWith(okBtn.cloneNode(true));
            document.getElementById('confirmCancel').addEventListener('click', newCancelHandler);
            document.getElementById('confirmOk').addEventListener('click', newOkHandler);
            
            dialog.style.display = 'flex';
        }
        
        // Select tee for edit page modal
        function selectEditPageTee(teeKey) {
            window.editPageSelectedTee = teeKey;
            
            // Update button styles
            if (courseData?.tees) {
                Object.keys(courseData.tees).forEach(key => {
                    const btn = document.getElementById(`editPageTee_${key}`);
                    if (btn) {
                        const isSelected = key === teeKey;
                        if (isSelected) {
                            btn.style.border = '3px solid #166534';
                            btn.style.boxShadow = '0 0 0 2px rgba(22, 101, 52, 0.3)';
                        } else {
                            btn.style.border = `2px solid ${(key === 'white' || key === 'regular') ? '#cbd5e1' : btn.style.backgroundColor}`;
                            btn.style.boxShadow = 'none';
                        }
                    }
                });
            }
            
            // Recalculate HCP if in GHIN mode
            updateEditPageHcp();
        }
        
        // Toggle GHIN mode in Edit Page modal
        function toggleEditPageGhinMode(useGhin) {
            const label = document.getElementById('editPageHcpLabel');
            const input = document.getElementById('editPlayerHcpInput');
            const calcDisplay = document.getElementById('editPageCalcHcp');
            
            if (useGhin) {
                label.textContent = 'GHIN Handicap Index:';
                input.step = '0.1';
                calcDisplay.style.display = 'block';
                updateEditPageHcp();
            } else {
                label.textContent = 'Course Handicap:';
                input.step = '1';
                calcDisplay.style.display = 'none';
            }
        }
        
        // Update calculated HCP in Edit Page modal
        function updateEditPageHcp() {
            const useGhin = document.getElementById('editPageGhinCheckbox')?.checked;
            const calcDisplay = document.getElementById('editPageCalcHcp');
            const input = document.getElementById('editPlayerHcpInput');
            
            if (!useGhin || !calcDisplay) return;
            
            const index = parseFloat(input.value) || 0;
            
            if (courseData && courseData.tees) {
                const tee = window.editPageSelectedTee || tournamentData?.tee || Object.keys(courseData.tees)[0];
                const teeData = courseData.tees[tee];
                if (teeData) {
                    const courseHcp = calculateCourseHandicap(index, teeData.slope, teeData.rating, courseData.totalPar);
                    calcDisplay.textContent = `= Course HCP ${courseHcp} (${teeData.name || tee} tees)`;
                    return;
                }
            }
            calcDisplay.textContent = `= Course HCP ${Math.round(index)}`;
        }
        
        // Update claimed player name and handicap
        async function updateClaimedPlayer(oldName, newName, newHandicap, handicapIndex = null, hcpMode = 'course') {
            try {
                // Find the player in local data
                const playerIdx = tournamentData.players.findIndex(p => p.name === oldName);
                if (playerIdx === -1) {
                    showNotification('Error', 'Player not found');
                    return;
                }
                
                // Update local data
                tournamentData.players[playerIdx].name = newName;
                tournamentData.players[playerIdx].handicap = newHandicap;
                tournamentData.players[playerIdx].handicapIndex = handicapIndex;
                tournamentData.players[playerIdx].hcpMode = hcpMode;
                
                // Update player order if name changed
                if (oldName !== newName) {
                    const orderIdx = playerOrder.claimed.indexOf(oldName);
                    if (orderIdx > -1) {
                        playerOrder.claimed[orderIdx] = newName;
                        savePlayerOrder();
                    }
                }
                
                // Save locally
                saveToLocalStorage();
                
                // Update Firebase if in multi-device mode
                if (activeTournamentId && tournamentMode === 'multi') {
                    const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                    const tournamentDoc = await tournamentRef.get();
                    const tournament = tournamentDoc.data();
                    
                    const fbPlayerIdx = tournament.players.findIndex(p => p.name === oldName);
                    if (fbPlayerIdx > -1) {
                        tournament.players[fbPlayerIdx].name = newName;
                        tournament.players[fbPlayerIdx].handicap = newHandicap;
                        tournament.players[fbPlayerIdx].handicapIndex = handicapIndex;
                        tournament.players[fbPlayerIdx].hcpMode = hcpMode;
                        
                        await tournamentRef.update({
                            players: tournament.players,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                }
                
                showNotification('Updated', `${newName} saved`);
            } catch (error) {
                console.error('Error updating player:', error);
                showNotification('Error', 'Failed to update player');
            }
        }
        
        // Show Guest Home Page (Non-Host)
        function showGuestHomePage() {
            // Populate tournament info
            if (tournamentData) {
                document.getElementById('guestTournamentName').textContent = tournamentData.name || 'Tournament';
                const courseName = courseData?.name || tournamentData.course || '';
                document.getElementById('guestTournamentInfo').textContent = 
                    `${courseName} • ${formatDateDisplay(tournamentData.date) || ''}`;
                
                // Update role badge based on user's role
                const roleBadge = document.getElementById('guestRoleBadge');
                if (roleBadge) {
                    if (isHost) {
                        roleBadge.innerHTML = '👑 HOST';
                        roleBadge.style.background = 'white';
                        roleBadge.style.color = '#f97316';
                        roleBadge.style.borderColor = '#f97316';
                    } else if (canManageTournament()) {
                        roleBadge.innerHTML = '👑 CO-HOST';
                        roleBadge.style.background = '#fef3c7';
                        roleBadge.style.color = '#92400e';
                        roleBadge.style.borderColor = '#f59e0b';
                    } else {
                        roleBadge.innerHTML = '👤 PLAYER';
                        roleBadge.style.background = '#dbeafe';
                        roleBadge.style.color = '#1e3a5f';
                        roleBadge.style.borderColor = '#1e3a5f';
                    }
                }
                
                // Update host info
                const hostNameEl = document.getElementById('guestHostName');
                if (hostNameEl) {
                    // Try to get host name from tournament data
                    const hostName = tournamentData.hostName || tournamentData.createdByName || 'Unknown';
                    hostNameEl.textContent = hostName;
                }
                
                // Current Tournament card is now handled by populateHomeRoundsList()
                // Keep guestCurrentTournament hidden
                document.getElementById('guestCurrentTournament').style.display = 'none';
            }
            
            // Update device initials display
            updateDeviceInitialsDisplay();
            
            // Update tournament history count
            updateHistoryCountDisplay();
            
            // Check if device has claimed or watched any players
            const hasClaimedOrWatched = checkIfDeviceHasPlayers();
            
            // If device has claimed/watched players, they're considered joined
            if (hasClaimedOrWatched) {
                hasJoinedTournament = true;
            }
            
            // Update Enter/Leave Tournament button based on join status
            updateEnterLeaveButton();
            
            showPage('guestHomePage');
        }
        
        // Check if current device has claimed or watched any players
        function checkIfDeviceHasPlayers() {
            if (!tournamentData || !tournamentData.players) return false;
            
            // Check claimed players
            const hasClaimed = tournamentData.players.some(p => isClaimedByMe(p));
            
            // Check watched players from playerOrder
            const hasWatched = playerOrder.watching && playerOrder.watching.length > 0;
            
            return hasClaimed || hasWatched;
        }
        
        // Update the Enter/Leave Tournament button based on hasJoinedTournament
        function updateEnterLeaveButton() {
            const enterCard = document.getElementById('enterTournamentCard');
            const leaveBtn = document.getElementById('guestLeaveBtn');
            const activeButtons = document.getElementById('guestActiveButtons');
            const currentTournamentCard = document.getElementById('guestCurrentTournament');
            const loadTournamentCard = document.getElementById('loadTournamentCard');
            
            // Also check if device has players (another indicator of being joined)
            const hasPlayers = checkIfDeviceHasPlayers();
            const isJoined = hasJoinedTournament || hasPlayers;
            
            if (isJoined) {
                // Hide Enter Tournament card, show Leave button, enable active buttons
                if (enterCard) enterCard.style.display = 'none';
                if (leaveBtn) leaveBtn.style.display = 'flex';
                if (activeButtons) activeButtons.style.display = 'flex';
                // Keep current/load cards hidden (handled by populateHomeRoundsList)
                if (currentTournamentCard) currentTournamentCard.style.display = 'none';
                if (loadTournamentCard) loadTournamentCard.style.display = 'none';
            } else {
                // Show Enter Tournament card, hide Leave button
                // Also hide Load Tournament card to simplify the initial view
                if (enterCard) enterCard.style.display = 'block';
                if (leaveBtn) leaveBtn.style.display = 'none';
                if (loadTournamentCard) loadTournamentCard.style.display = 'none';
                if (currentTournamentCard) currentTournamentCard.style.display = 'none';
            }
        }
        
        // Handle Enter Tournament button click
        function handleEnterTournament() {
            if (activeTournamentId) {
                showJoinTournamentScreen(activeTournamentId);
            } else {
                showNotification('Error', 'No tournament to enter');
            }
        }
        
        // Handle Enter/Leave Tournament button click
        function handleEnterLeaveTournament() {
            if (hasJoinedTournament) {
                confirmLeaveTournament();
            } else {
                // Go to join tournament page
                if (activeTournamentId) {
                    showJoinTournamentScreen(activeTournamentId);
                } else {
                    showNotification('Error', 'No tournament to enter');
                }
            }
        }
        
        // Guest Resume Scoring - check if joined first, then check for identity matches
        function guestResumeScoring() {
            if (!hasJoinedTournament) {
                showNotification('Not Joined', 'Please enter the tournament first to access scoring');
                return;
            }
            
            // Check for identity matches before going to scoring
            checkAndPromptForIdentityMatch(() => {
                showPage('scoringPage');
            });
        }
        
        // Guest View Results - check if joined first
        function guestViewResults() {
            if (!hasJoinedTournament) {
                showNotification('Not Joined', 'Please enter the tournament first to view results');
                return;
            }
            showPage('resultsPage');
        }
        
        // Host/Player View Mode Toggle
        function setHostViewMode(mode) {
            hostViewMode = mode;
            saveToLocalStorage();
            
            const hostBtn = document.getElementById('toggleHostMode');
            const playerBtn = document.getElementById('togglePlayerMode');
            
            if (mode === 'host') {
                // Host selected - tan fill, navy text
                hostBtn.style.background = '#d4b896';
                hostBtn.style.color = '#1e3a5f';
                // Player not selected - white fill, gray text
                playerBtn.style.background = 'white';
                playerBtn.style.color = '#6b7280';
                // Show host management
                showPlayerManagement();
            } else {
                // Host not selected - white fill, gray text
                hostBtn.style.background = 'white';
                hostBtn.style.color = '#6b7280';
                // Player selected - tan fill, navy text
                playerBtn.style.background = '#d4b896';
                playerBtn.style.color = '#1e3a5f';
                // Show My Players page (player view)
                showMyPlayersPage();
            }
            
            // Update Host Home button
            updateHostHomeManageButton();
        }
        
        // Switch from My Players page to Host mode (Tournament Management)
        function switchToHostMode() {
            hostViewMode = 'host';
            saveToLocalStorage();
            showPlayerManagement();
        }
        
        // Show/hide the Host/Player toggle on My Players page based on whether user is host
        function updateMyPlayersHostToggle() {
            const toggle = document.getElementById('myPlayersHostToggle');
            if (toggle) {
                // Show toggle for hosts (or co-hosts) so they can switch to Tournament Management
                if (isHost || canManageTournament()) {
                    toggle.style.display = 'flex';
                    // Update button styles based on current mode
                    const hostBtn = document.getElementById('myPlayersHostBtn');
                    const playerBtn = document.getElementById('myPlayersPlayerBtn');
                    if (hostBtn && playerBtn) {
                        // Player mode is active (we're on My Players page)
                        hostBtn.style.background = 'white';
                        hostBtn.style.color = '#6b7280';
                        playerBtn.style.background = '#d4b896';
                        playerBtn.style.color = '#1e3a5f';
                    }
                } else {
                    toggle.style.display = 'none';
                }
            }
        }
        
        // Reopen a finished tournament (allow all players to edit again)
        async function reopenTournament() {
            if (!activeTournamentId) {
                showNotification('Error', 'No active tournament');
                return;
            }
            
            try {
                // Update Firebase
                await db.collection('tournaments').doc(activeTournamentId).update({
                    isFinished: false
                });
                
                // Update local
                if (tournamentData) {
                    tournamentData.isFinished = false;
                }
                
                // Update history
                updateTournamentHistoryItem(activeTournamentId, { isFinished: false });
                
                // Hide the finished actions
                const finishedActions = document.getElementById('finishedTournamentActions');
                if (finishedActions) {
                    finishedActions.style.display = 'none';
                }
                
                // Update Host Home badge
                updateHostHomeBadge();
                
                saveToLocalStorage();
                showNotification('Reopened', 'Tournament is now open for editing');
                
            } catch (error) {
                console.error('Error reopening tournament:', error);
                showNotification('Error', 'Failed to reopen tournament');
            }
        }
        
        // Confirm restart for current tournament
        function confirmRestartCurrentTournament() {
            if (!activeTournamentId) {
                showNotification('Error', 'No active tournament');
                return;
            }
            
            showConfirm(
                '🔄 Restart Tournament?',
                'This will clear ALL scores and player claims. The tournament will start fresh as if no one had ever joined. This cannot be undone!',
                async function() {
                    try {
                        const tournamentDoc = await db.collection('tournaments').doc(activeTournamentId).get();
                        const tournament = tournamentDoc.data();
                        
                        // Reset all players - clear scores and claims
                        const resetPlayers = tournament.players.map(p => ({
                            ...p,
                            scores: new Array(18).fill(null),
                            claimedBy: null,
                            deviceInitials: null
                        }));
                        
                        // Update Firebase
                        await db.collection('tournaments').doc(activeTournamentId).update({
                            players: resetPlayers,
                            isFinished: false
                        });
                        
                        // Update local
                        tournamentData.players = resetPlayers;
                        tournamentData.isFinished = false;
                        
                        // Clear player stats
                        clearAllPlayerStats();
                        localStorage.removeItem('playerStats_' + activeTournamentId);
                        
                        // Hide the finished actions
                        const finishedActions = document.getElementById('finishedTournamentActions');
                        if (finishedActions) {
                            finishedActions.style.display = 'none';
                        }
                        
                        // Update Host Home badge
                        updateHostHomeBadge();
                        
                        saveToLocalStorage();
                        hideConfirmDialog();
                        showNotification('Restarted', 'Tournament has been reset');
                        
                        // Refresh the management page
                        showPlayerManagement();
                        
                    } catch (error) {
                        console.error('Error restarting tournament:', error);
                        showNotification('Error', 'Failed to restart tournament');
                        hideConfirmDialog();
                    }
                }
            );
        }
        
        // Update tournament history item
        function updateTournamentHistoryItem(tournamentId, updates) {
            const history = getTournamentHistory();
            const index = history.findIndex(t => t.id === tournamentId);
            if (index !== -1) {
                history[index] = { ...history[index], ...updates };
                localStorage.setItem('tournamentHistory', JSON.stringify(history));
            }
        }
        
        // Update Host Home badge based on tournament status
        function updateHostHomeBadge() {
            const badge = document.getElementById('hostTournamentBadge');
            if (badge) {
                if (tournamentData?.isFinished) {
                    badge.innerHTML = '👑 HOST <span style="background: #fef3c7; color: #92400e; font-size: 9px; margin-left: 4px; padding: 1px 4px; border-radius: 3px;">FINISHED</span>';
                } else {
                    badge.innerHTML = '👑 HOST';
                }
            }
        }
        
        
        // Update Host Home manage button based on hostViewMode
        function updateHostHomeManageButton() {
            const btn = document.getElementById('hostHomeManageBtn');
            const icon = document.getElementById('hostHomeManageBtnIcon');
            const text = document.getElementById('hostHomeManageBtnText');
            
            if (btn && icon && text) {
                if (hostViewMode === 'player') {
                    // In Player mode - show Tournament Management
                    icon.textContent = '⚙️';
                    text.textContent = 'Tournament Management';
                    btn.onclick = function() { showPlayerManagement(); };
                } else {
                    // In Host mode - show Manage Tournament (same function, different label)
                    icon.textContent = '⚙️';
                    text.textContent = 'Manage Tournament';
                    btn.onclick = function() { showPlayerManagement(); };
                }
            }
        }
        
        // Update toggle buttons to reflect current mode
        function updateHostViewModeUI() {
            const hostBtn = document.getElementById('toggleHostMode');
            const playerBtn = document.getElementById('togglePlayerMode');
            
            if (hostBtn && playerBtn) {
                if (hostViewMode === 'host') {
                    // Host selected - tan fill, navy text
                    hostBtn.style.background = '#d4b896';
                    hostBtn.style.color = '#1e3a5f';
                    // Player not selected - white fill, gray text
                    playerBtn.style.background = 'white';
                    playerBtn.style.color = '#6b7280';
                } else {
                    // Host not selected - white fill, gray text
                    hostBtn.style.background = 'white';
                    hostBtn.style.color = '#6b7280';
                    // Player selected - tan fill, navy text
                    playerBtn.style.background = '#d4b896';
                    playerBtn.style.color = '#1e3a5f';
                }
            }
            
            // Also update Host Home button
            updateHostHomeManageButton();
        }
        
        // Update device initials display on home pages
        function updateDeviceInitialsDisplay() {
            const initials = localStorage.getItem('deviceInitials') || '--';
            const guestEl = document.getElementById('guestDeviceInitials');
            const hostEl = document.getElementById('hostDeviceInitials');
            if (guestEl) guestEl.textContent = initials;
            if (hostEl) hostEl.textContent = initials;
        }
        
        // Show edit device name dialog
        function showEditDeviceNameDialog() {
            const currentInitials = localStorage.getItem('deviceInitials') || '';
            
            const dialog = document.getElementById('confirmDialog');
            const titleEl = document.getElementById('confirmTitle');
            const messageEl = document.getElementById('confirmMessage');
            const cancelBtn = document.getElementById('confirmCancel');
            const okBtn = document.getElementById('confirmOk');
            
            titleEl.textContent = '📱 Edit Device Name';
            messageEl.innerHTML = `
                <p style="color: #64748b; font-size: 14px; margin-bottom: 12px;">Your initials are shown to the host so they know who's scoring which players.</p>
                <div style="margin: 12px 0;">
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 14px;">Your Initials:</label>
                    <input type="text" id="editDeviceInitialsInput" value="${currentInitials}" 
                        style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 18px; text-align: center; text-transform: uppercase; font-weight: 600;"
                        maxlength="3" placeholder="ABC">
                </div>
            `;
            
            cancelBtn.textContent = 'Cancel';
            okBtn.textContent = 'Save';
            okBtn.style.background = '#1e3a5f';
            
            const newCancelHandler = () => {
                dialog.style.display = 'none';
            };
            const newOkHandler = async () => {
                const newInitials = document.getElementById('editDeviceInitialsInput').value.trim().toUpperCase();
                
                if (!newInitials) {
                    showNotification('Error', 'Please enter your initials');
                    return;
                }
                
                // Save locally
                localStorage.setItem('deviceInitials', newInitials);
                
                // Update Firebase if in multi-device mode
                if (activeTournamentId && tournamentMode === 'multi') {
                    try {
                        const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                        const tournamentDoc = await tournamentRef.get();
                        const tournament = tournamentDoc.data();
                        
                        // Update devices object
                        if (!tournament.devices) tournament.devices = {};
                        tournament.devices[currentDeviceId] = {
                            ...tournament.devices[currentDeviceId],
                            initials: newInitials
                        };
                        
                        // Also update deviceInitials on any claimed players
                        tournament.players.forEach(p => {
                            if (isClaimedByMe(p)) {
                                p.deviceInitials = newInitials;
                            }
                        });
                        
                        await tournamentRef.update({
                            devices: tournament.devices,
                            players: tournament.players,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    } catch (error) {
                        console.error('Error updating device initials:', error);
                    }
                }
                
                dialog.style.display = 'none';
                updateDeviceInitialsDisplay();
                showNotification('Saved', `Device name set to "${newInitials}"`);
            };
            
            cancelBtn.replaceWith(cancelBtn.cloneNode(true));
            okBtn.replaceWith(okBtn.cloneNode(true));
            document.getElementById('confirmCancel').addEventListener('click', newCancelHandler);
            document.getElementById('confirmOk').addEventListener('click', newOkHandler);
            
            dialog.style.display = 'flex';
            
            // Auto-focus and select the input
            setTimeout(() => {
                const input = document.getElementById('editDeviceInitialsInput');
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 100);
        }
        
        // Leave tournament (non-host) - 3 options: Cancel, Save & Leave, Leave
        function confirmLeaveTournament() {
            // Create custom 3-button modal
            let modal = document.getElementById('leaveConfirmModal');
            if (modal) modal.remove();
            
            modal = document.createElement('div');
            modal.id = 'leaveConfirmModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                padding: 20px;
            `;
            
            const tournamentName = tournamentData?.name || tournamentData?.course || 'Tournament';
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 6px; padding: 24px; max-width: 400px; width: 100%; text-align: center;">
                    <div style="font-size: 40px; margin-bottom: 12px;">🚪</div>
                    <h2 style="color: #1e293b; margin-bottom: 12px; font-size: 20px;">Leave Tournament?</h2>
                    <p style="color: #64748b; margin-bottom: 8px; font-size: 14px;">
                        <strong>${tournamentName}</strong>
                    </p>
                    <p style="color: #64748b; margin-bottom: 20px; font-size: 13px;">
                        Your claimed players will be released.
                    </p>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="handleLeaveCancel()" style="width: 100%; padding: 14px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Stay in Tournament
                        </button>
                        <button onclick="handleLeaveOnly()" style="width: 100%; padding: 14px; background: #a51c30; color: white; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Leave Tournament
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function handleLeaveCancel() {
            document.getElementById('leaveConfirmModal')?.remove();
        }
        
        async function handleSaveAndLeave() {
            document.getElementById('leaveConfirmModal')?.remove();
            
            // Save tournament first
            if (tournamentData) {
                const saveData = {
                    ...tournamentData,
                    savedAt: new Date().toISOString()
                };
                
                const savedTournaments = JSON.parse(localStorage.getItem('savedTournaments') || '[]');
                savedTournaments.unshift(saveData);
                if (savedTournaments.length > 10) savedTournaments.pop();
                localStorage.setItem('savedTournaments', JSON.stringify(savedTournaments));
            }
            
            // Then leave
            await leaveTournament();
            showNotification('Saved & Left', 'Tournament saved for later viewing');
        }
        
        async function handleLeaveOnly() {
            document.getElementById('leaveConfirmModal')?.remove();
            await leaveTournament();
        }
        
        async function leaveTournament() {
            try {
                // Release all claimed players and remove device from tournament
                if (activeTournamentId) {
                    const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                    const tournamentDoc = await tournamentRef.get();
                    const tournament = tournamentDoc.data();
                    
                    // Release all players claimed by this device
                    tournament.players.forEach(p => {
                        if (isClaimedByMe(p)) {
                            p.claimedBy = null;
                            p.deviceInitials = null;
                        }
                    });
                    
                    // Remove this device from devices list
                    if (tournament.devices && tournament.devices[currentDeviceId]) {
                        delete tournament.devices[currentDeviceId];
                    }
                    
                    // Remove this device from connectedDevices list
                    if (tournament.connectedDevices && tournament.connectedDevices[currentDeviceId]) {
                        delete tournament.connectedDevices[currentDeviceId];
                    }
                    
                    // Remove this device from coHosts list if present
                    if (tournament.coHosts && tournament.coHosts.includes(currentDeviceId)) {
                        tournament.coHosts = tournament.coHosts.filter(id => id !== currentDeviceId);
                    }
                    
                    await tournamentRef.update({ 
                        players: tournament.players,
                        devices: tournament.devices || {},
                        connectedDevices: tournament.connectedDevices || {},
                        coHosts: tournament.coHosts || []
                    });
                }
                
                // Clear all session data
                activeTournamentId = null;
                tournamentData = null;
                isHost = false;
                isCoHost = false;
                hasJoinedTournament = false;
                playerOrder = { claimed: [], watching: [] };
                claimedPlayers = [];
                
                localStorage.removeItem('activeTournamentId');
                localStorage.removeItem('playerOrder');
                localStorage.removeItem('indianHillsScoring');
                
                // Hide all tournament cards (handled by populateHomeRoundsList)
                document.getElementById('guestCurrentTournament').style.display = 'none';
                document.getElementById('enterTournamentCard').style.display = 'none';
                document.getElementById('loadTournamentCard').style.display = 'none';
                
                showNotification('Left', 'You have left the tournament');
                showPage('guestHomePage');
            } catch (error) {
                console.error('Error leaving tournament:', error);
                showNotification('Error', 'Failed to leave tournament');
                // Still try to show guest home even if error
                showPage('guestHomePage');
            }
        }
        
        // Delete last tournament and hide the card
        function deleteLastTournament() {
            // Clear tournament data from memory
            tournamentData = null;
            localStorage.removeItem('indianHillsScoring');
            
            // Hide the Last Tournament card entirely
            document.getElementById('guestCurrentTournament').style.display = 'none';
            
            showNotification('Deleted', 'Tournament data cleared');
        }
        
        // Save last tournament data for later viewing (called from Save & Leave)
        function saveLastTournament() {
            if (tournamentData) {
                const saveData = {
                    ...tournamentData,
                    savedAt: new Date().toISOString()
                };
                
                // Get existing saved tournaments or create new array
                const savedTournaments = JSON.parse(localStorage.getItem('savedTournaments') || '[]');
                savedTournaments.unshift(saveData); // Add to front
                
                // Keep only last 10 tournaments
                if (savedTournaments.length > 10) {
                    savedTournaments.pop();
                }
                
                localStorage.setItem('savedTournaments', JSON.stringify(savedTournaments));
                
                // Clear tournament data from memory
                tournamentData = null;
                localStorage.removeItem('indianHillsScoring');
            }
        }
        
        // Load a previously saved tournament for viewing
        function loadPreviousTournament() {
            const savedTournaments = JSON.parse(localStorage.getItem('savedTournaments') || '[]');
            
            if (savedTournaments.length === 0) {
                showNotification('No Saved Tournaments', 'No tournaments have been saved');
                return;
            }
            
            // For now, just load the most recent one
            // TODO: Show a picker if multiple tournaments
            const tournament = savedTournaments[0];
            tournamentData = tournament;
            
            // Update course data
            if (tournament.course && courses[tournament.course]) {
                courseData = courses[tournament.course];
            }
            
            // Go to results page
            showPage('resultsPage');
        }
        
        // Legacy function for compatibility
        function showMyPlayersModal() {
            showMyPlayersPage();
        }
        
        function closeMyPlayersModal() {
            showPage('scoringPage');
            renderScoringPage();
        }
        
        function movePlayer(playerName, currentIndex, direction, type) {
            const orderArray = type === 'claimed' ? playerOrder.claimed : playerOrder.watching;
            const newIndex = currentIndex + direction;
            
            if (newIndex < 0 || newIndex >= orderArray.length) return;
            
            [orderArray[currentIndex], orderArray[newIndex]] = [orderArray[newIndex], orderArray[currentIndex]];
            
            savePlayerOrder();
            showMyPlayersModal();
        }
        
        function addToWatchList(playerName) {
            if (!playerOrder.watching.includes(playerName)) {
                playerOrder.watching.push(playerName);
                savePlayerOrder();
                showMyPlayersModal();
                showNotification('Added', `Now watching ${playerName}`);
                
                // Refresh current view to show the new watched player
                if (currentView === 'hole') {
                    renderHoleView();
                } else {
                    renderCompactPlayerView(getPlayersToShow());
                }
            }
        }
        
        function removeFromWatchList(playerName) {
            const index = playerOrder.watching.indexOf(playerName);
            if (index > -1) {
                playerOrder.watching.splice(index, 1);
                savePlayerOrder();
                showMyPlayersModal();
                showNotification('Removed', `Stopped watching ${playerName}`);
                
                // Refresh current view to remove the unwatched player
                if (currentView === 'hole') {
                    renderHoleView();
                } else {
                    renderCompactPlayerView(getPlayersToShow());
                }
            }
        }
        
        // Helper function to get filtered players list
        function getPlayersToShow() {
            let playersToShow = tournamentData.players;
            // Show filtered view for non-hosts OR when host is in player mode
            if (tournamentMode === 'multi' && (!canManageTournament() || isHostInPlayerMode())) {
                // Separate claimed and watched players
                const claimedPlayers = tournamentData.players.filter(p => isClaimedByMe(p));
                const watchedPlayers = tournamentData.players.filter(p => 
                    playerOrder.watching && playerOrder.watching.includes(p.name) && !isClaimedByMe(p)
                );
                // Sort each group by their saved order
                const sortedClaimed = sortPlayersByOrder(claimedPlayers, playerOrder.claimed || []);
                const sortedWatched = sortPlayersByOrder(watchedPlayers, playerOrder.watching || []);
                // Claimed first, then watched
                playersToShow = [...sortedClaimed, ...sortedWatched];
                
                // DON'T fallback to all players - return empty array if no claims/watches
                // This ensures player mode users only see their claimed/watched players
            }
            return playersToShow;
        }
        
        // Track if claiming from My Players modal
        let claimingFromMyPlayersModal = false;
        
        async function claimPlayerFromModal(playerName) {
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                const player = tournament.players.find(p => p.name === playerName);
                
                if (!player) {
                    showNotification('Error', 'Player not found');
                    return;
                }
                
                // Set flag to return to My Players page after claiming
                claimingFromMyPlayersModal = true;
                showHandicapConfirmDialog(activeTournamentId, playerName, player.handicap);
            } catch (error) {
                console.error('Error claiming player:', error);
                showNotification('Error', 'Failed to claim player');
            }
        }
        
        async function releasePlayer(playerName) {
            showConfirm(
                'Release Player?',
                `Are you sure you want to release ${playerName}? You'll stop scoring for them, but their scores will be preserved.`,
                async function() {
                    try {
                        const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                        const tournamentDoc = await tournamentRef.get();
                        const tournament = tournamentDoc.data();
                        
                        const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                        if (playerIndex > -1) {
                            tournament.players[playerIndex].claimedBy = null;
                            
                            await tournamentRef.update({
                                players: tournament.players,
                                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                            });
                            
                            const index = playerOrder.claimed.indexOf(playerName);
                            if (index > -1) {
                                playerOrder.claimed.splice(index, 1);
                            }
                            
                            const cpIndex = claimedPlayers.indexOf(playerName);
                            if (cpIndex > -1) {
                                claimedPlayers.splice(cpIndex, 1);
                            }
                            
                            savePlayerOrder();
                            hideConfirmDialog();
                            showMyPlayersModal();
                            showNotification('Released', `${playerName} is now unclaimed`);
                        }
                    } catch (error) {
                        console.error('Error releasing player:', error);
                        showNotification('Error', 'Failed to release player');
                    }
                }
            );
        }
        
        function editPlayerModal(playerName, currentHandicap) {
            const dialog = document.getElementById('confirmDialog');
            const titleEl = document.getElementById('confirmTitle');
            const messageEl = document.getElementById('confirmMessage');
            const cancelBtn = document.getElementById('confirmCancel');
            const okBtn = document.getElementById('confirmOk');
            
            // Get player's current data
            const player = tournamentData?.players?.find(p => p.name === playerName);
            const currentIndex = player?.handicapIndex || null;
            const isGhinMode = player?.hcpMode === 'index' || currentIndex !== null;
            
            titleEl.textContent = `Edit ${playerName}`;
            messageEl.innerHTML = `
                <div style="margin: 16px 0;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">Name:</label>
                    <input type="text" id="editPlayerName" value="${playerName}" 
                        style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                    
                    <label id="editHcpLabel" style="display: block; margin: 16px 0 8px; font-weight: 600;">Course Handicap:</label>
                    <input type="number" id="editPlayerHandicap" value="${currentHandicap}" 
                        style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; box-sizing: border-box;"
                        min="-10" max="54" step="1" oninput="updateEditModalHcp()">
                    <p id="editCalcHcp" style="font-size: 12px; color: #166534; margin-top: 4px; font-weight: 600; display: none;"></p>
                    
                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0; margin-top: 12px;">
                        <input type="checkbox" id="editUseGhinCheckbox" class="ghin-checkbox" ${isGhinMode ? 'checked' : ''} onchange="toggleEditGhinMode(this.checked)">
                        <span style="color: #475569; font-weight: 600; font-size: 13px;">Use GHIN Handicap Index</span>
                    </label>
                </div>
            `;
            
            dialog.style.display = 'flex';
            
            // Initialize the display based on current mode
            setTimeout(() => {
                toggleEditGhinMode(isGhinMode);
                if (isGhinMode && currentIndex !== null) {
                    document.getElementById('editPlayerHandicap').value = currentIndex;
                }
            }, 50);
            
            const handleOk = async () => {
                const newName = document.getElementById('editPlayerName').value.trim();
                const useGhin = document.getElementById('editUseGhinCheckbox').checked;
                const inputValue = parseFloat(document.getElementById('editPlayerHandicap').value) || 0;
                
                let newHandicap, handicapIndex, hcpMode;
                
                if (useGhin) {
                    // Calculate course handicap from index
                    handicapIndex = Math.round(inputValue * 10) / 10;
                    hcpMode = 'index';
                    if (courseData && courseData.tees) {
                        const tee = tournamentData?.tee || Object.keys(courseData.tees)[0];
                        const teeData = courseData.tees[tee];
                        if (teeData) {
                            newHandicap = calculateCourseHandicap(handicapIndex, teeData.slope, teeData.rating, courseData.totalPar);
                        } else {
                            newHandicap = Math.round(handicapIndex);
                        }
                    } else {
                        newHandicap = Math.round(handicapIndex);
                    }
                } else {
                    newHandicap = Math.round(inputValue);
                    handicapIndex = null;
                    hcpMode = 'course';
                }
                
                if (!newName) {
                    alert('Name cannot be empty');
                    return;
                }
                
                try {
                    const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                    const tournamentDoc = await tournamentRef.get();
                    const tournament = tournamentDoc.data();
                    
                    const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                    if (playerIndex > -1) {
                        tournament.players[playerIndex].name = newName;
                        tournament.players[playerIndex].handicap = newHandicap;
                        tournament.players[playerIndex].handicapIndex = handicapIndex;
                        tournament.players[playerIndex].hcpMode = hcpMode;
                        
                        await tournamentRef.update({
                            players: tournament.players,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        
                        tournamentData.players = tournament.players;
                        saveToLocalStorage();
                        
                        if (newName !== playerName) {
                            const claimedIndex = playerOrder.claimed.indexOf(playerName);
                            if (claimedIndex > -1) {
                                playerOrder.claimed[claimedIndex] = newName;
                            }
                            const watchingIndex = playerOrder.watching.indexOf(playerName);
                            if (watchingIndex > -1) {
                                playerOrder.watching[watchingIndex] = newName;
                            }
                            savePlayerOrder();
                        }
                        
                        hideConfirmDialog();
                        showMyPlayersModal();
                        showNotification('Updated', `Player updated successfully`);
                    }
                } catch (error) {
                    console.error('Error updating player:', error);
                    showNotification('Error', 'Failed to update player');
                }
            };
            
            okBtn.onclick = handleOk;
            cancelBtn.onclick = hideConfirmDialog;
        }
        
        // Toggle GHIN mode in edit modal
        function toggleEditGhinMode(useGhin) {
            const label = document.getElementById('editHcpLabel');
            const input = document.getElementById('editPlayerHandicap');
            const calcDisplay = document.getElementById('editCalcHcp');
            
            if (useGhin) {
                label.textContent = 'GHIN Handicap Index:';
                input.step = '0.1';
                input.placeholder = '12.4';
                calcDisplay.style.display = 'block';
                updateEditModalHcp();
            } else {
                label.textContent = 'Course Handicap:';
                input.step = '1';
                input.placeholder = '12';
                calcDisplay.style.display = 'none';
            }
        }
        
        // Update calculated HCP in edit modal
        function updateEditModalHcp() {
            const useGhin = document.getElementById('editUseGhinCheckbox')?.checked;
            const calcDisplay = document.getElementById('editCalcHcp');
            const input = document.getElementById('editPlayerHandicap');
            
            if (!useGhin || !calcDisplay) return;
            
            const index = parseFloat(input.value) || 0;
            
            if (courseData && courseData.tees) {
                const tee = tournamentData?.tee || Object.keys(courseData.tees)[0];
                const teeData = courseData.tees[tee];
                if (teeData) {
                    const courseHcp = calculateCourseHandicap(index, teeData.slope, teeData.rating, courseData.totalPar);
                    calcDisplay.textContent = `= Course HCP ${courseHcp} (${tee} tees)`;
                    return;
                }
            }
            calcDisplay.textContent = `= Course HCP ${Math.round(index)}`;
        }
        
        // Management edit modal helpers (with tee selection)
        function selectEditMgmtTee(teeKey) {
            window.editMgmtSelectedTee = teeKey;
            // Update button styles
            if (courseData?.tees) {
                Object.keys(courseData.tees).forEach(key => {
                    const btn = document.getElementById(`editMgmtTee_${key}`);
                    if (btn) {
                        const isSelected = key === teeKey;
                        if (isSelected) {
                            btn.style.border = '3px solid #166534';
                            btn.style.boxShadow = '0 0 0 2px rgba(22, 101, 52, 0.3)';
                        } else {
                            btn.style.border = `2px solid ${(key === 'white' || key === 'regular') ? '#cbd5e1' : btn.style.backgroundColor}`;
                            btn.style.boxShadow = 'none';
                        }
                    }
                });
            }
            updateEditMgmtHcp();
        }
        
        function toggleEditMgmtGhinMode(useGhin) {
            const label = document.getElementById('editHcpLabel');
            const input = document.getElementById('editPlayerHandicap');
            const calcDisplay = document.getElementById('editCalcHcp');
            
            if (useGhin) {
                label.textContent = 'GHIN Handicap Index:';
                input.step = '0.1';
                input.placeholder = '12.4';
                calcDisplay.style.display = 'block';
                updateEditMgmtHcp();
            } else {
                label.textContent = 'Course Handicap:';
                input.step = '1';
                input.placeholder = '12';
                calcDisplay.style.display = 'none';
            }
        }
        
        function updateEditMgmtHcp() {
            const useGhin = document.getElementById('editUseGhinCheckbox')?.checked;
            const calcDisplay = document.getElementById('editCalcHcp');
            const input = document.getElementById('editPlayerHandicap');
            
            if (!useGhin || !calcDisplay) return;
            
            const index = parseFloat(input.value) || 0;
            const selectedTee = window.editMgmtSelectedTee;
            
            if (courseData && courseData.tees && selectedTee) {
                const teeData = courseData.tees[selectedTee];
                if (teeData) {
                    const courseHcp = calculateCourseHandicap(index, teeData.slope, teeData.rating, courseData.totalPar);
                    calcDisplay.textContent = `= Course HCP ${courseHcp} (${teeData.name || selectedTee} tees)`;
                    return;
                }
            }
            calcDisplay.textContent = `= Course HCP ${Math.round(index)}`;
        }
        
        function getOrderedPlayers() {
            loadPlayerOrder();
            
            let playersToShow = tournamentData.players;
            
            // Show filtered view for non-hosts OR when host is in player mode
            if (tournamentMode === 'multi' && (!canManageTournament() || isHostInPlayerMode())) {
                const claimed = playersToShow.filter(p => isClaimedByMe(p));
                const watched = playersToShow.filter(p => playerOrder.watching && playerOrder.watching.includes(p.name) && !isClaimedByMe(p));
                
                const sortedClaimed = sortPlayersByOrder(claimed, playerOrder.claimed);
                const sortedWatched = sortPlayersByOrder(watched, playerOrder.watching);
                
                playersToShow = [...sortedClaimed, ...sortedWatched];
                
                // DON'T fallback to all players - return empty if no claims/watches
            }
            
            return playersToShow;
        }
        
        function setResultsFilter(filter) {
            // Privacy check: if trying to view 'all' and leaderboard is hidden
            if (filter === 'all' && !canViewLeaderboard()) {
                showPrivacyBlockedMessage('leaderboard');
                // Force back to 'mine' filter
                filter = 'mine';
            }
            
            currentResultsFilter = filter;
            
            // Update both sets of toggles (card and header)
            const allBtn = document.getElementById('resultsToggleAll');
            const mineBtn = document.getElementById('resultsToggleMine');
            const allBtnHeader = document.getElementById('resultsToggleAllHeader');
            const mineBtnHeader = document.getElementById('resultsToggleMineHeader');
            
            const buttons = [
                { all: allBtn, mine: mineBtn },
                { all: allBtnHeader, mine: mineBtnHeader }
            ];
            
            buttons.forEach(({ all, mine }) => {
                if (all && mine) {
                    if (filter === 'all') {
                        all.style.background = '#1e3a5f';
                        all.style.color = 'white';
                        mine.style.background = 'transparent';
                        mine.style.color = '#6b7280';
                    } else {
                        mine.style.background = '#1e3a5f';
                        mine.style.color = 'white';
                        all.style.background = 'transparent';
                        all.style.color = '#6b7280';
                    }
                }
            });
            
            updateResultsDisplay();
        }
        
        // Edit player from management page (host function)
        async function editPlayerFromManagement(playerName, currentHandicap) {
            const dialog = document.getElementById('confirmDialog');
            const titleEl = document.getElementById('confirmTitle');
            const messageEl = document.getElementById('confirmMessage');
            const cancelBtn = document.getElementById('confirmCancel');
            const okBtn = document.getElementById('confirmOk');
            
            // Get player's current data
            const player = tournamentData?.players?.find(p => p.name === playerName);
            const currentIndex = player?.handicapIndex || null;
            const isGhinMode = player?.hcpMode === 'index' || currentIndex !== null;
            
            // Build tee buttons HTML
            let teeButtonsHtml = '';
            const defaultTee = tournamentData?.tee || (courseData?.defaultTee) || (courseData?.tees ? Object.keys(courseData.tees)[0] : null);
            window.editMgmtSelectedTee = defaultTee;
            
            if (courseData?.tees) {
                const teeColors = {
                    black: '#1e293b', blue: '#1e3a5f', white: '#f1f5f9', gold: '#fbbf24',
                    silver: '#94a3b8', red: '#a51c30', green: '#166534',
                    tournament: '#1e293b', championship: '#1e3a5f', regular: '#64748b', forward: '#fbbf24'
                };
                teeButtonsHtml = Object.keys(courseData.tees).map(teeKey => {
                    const tee = courseData.tees[teeKey];
                    const bgColor = teeColors[teeKey] || '#64748b';
                    const textColor = ['white', 'gold', 'silver', 'forward'].includes(teeKey) ? '#1e293b' : 'white';
                    const isDefault = teeKey === defaultTee;
                    const borderStyle = isDefault ? '3px solid #166534' : '2px solid ' + bgColor;
                    return `<button type="button" onclick="selectEditMgmtTee('${teeKey}')" id="editMgmtTee_${teeKey}"
                        style="padding: 8px 12px; background: ${bgColor}; color: ${textColor}; border: ${borderStyle}; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer;">
                        ${tee.name}${isDefault ? ' ★' : ''}
                    </button>`;
                }).join('');
            }
            
            titleEl.textContent = `Edit ${playerName}`;
            messageEl.innerHTML = `
                <div style="margin: 16px 0;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">Name:</label>
                    <input type="text" id="editPlayerName" value="${playerName}" 
                        style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                    
                    ${courseData?.tees ? `
                    <label style="display: block; margin: 12px 0 8px; font-weight: 600;">Playing From:</label>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 8px;">
                        ${teeButtonsHtml}
                    </div>
                    <p style="font-size: 10px; color: #64748b;">★ = Tournament default</p>
                    ` : ''}
                    
                    <label id="editHcpLabel" style="display: block; margin: 16px 0 8px; font-weight: 600;">Course Handicap:</label>
                    <input type="number" id="editPlayerHandicap" value="${currentHandicap}" 
                        style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; box-sizing: border-box;"
                        min="-10" max="54" step="1" oninput="updateEditMgmtHcp()">
                    <p id="editCalcHcp" style="font-size: 12px; color: #166534; margin-top: 4px; font-weight: 600; display: none;"></p>
                    
                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0; margin-top: 12px;">
                        <input type="checkbox" id="editUseGhinCheckbox" class="ghin-checkbox" ${isGhinMode ? 'checked' : ''} onchange="toggleEditMgmtGhinMode(this.checked)">
                        <span style="color: #475569; font-weight: 600; font-size: 13px;">Use GHIN Handicap Index</span>
                    </label>
                </div>
            `;
            
            dialog.style.display = 'flex';
            
            // Initialize the display based on current mode
            setTimeout(() => {
                toggleEditMgmtGhinMode(isGhinMode);
                if (isGhinMode && currentIndex !== null) {
                    document.getElementById('editPlayerHandicap').value = currentIndex;
                }
            }, 50);
            
            const handleOk = async () => {
                const newName = document.getElementById('editPlayerName').value.trim();
                const useGhin = document.getElementById('editUseGhinCheckbox').checked;
                const inputValue = parseFloat(document.getElementById('editPlayerHandicap').value) || 0;
                const selectedTee = window.editMgmtSelectedTee;
                
                let newHandicap, handicapIndex, hcpMode;
                
                if (useGhin) {
                    // Calculate course handicap from index using selected tee
                    handicapIndex = Math.round(inputValue * 10) / 10;
                    hcpMode = 'index';
                    if (courseData && courseData.tees && selectedTee) {
                        const teeData = courseData.tees[selectedTee];
                        if (teeData) {
                            newHandicap = calculateCourseHandicap(handicapIndex, teeData.slope, teeData.rating, courseData.totalPar);
                        } else {
                            newHandicap = Math.round(handicapIndex);
                        }
                    } else {
                        newHandicap = Math.round(handicapIndex);
                    }
                } else {
                    newHandicap = Math.round(inputValue);
                    handicapIndex = null;
                    hcpMode = 'course';
                }
                
                if (!newName) {
                    alert('Name cannot be empty');
                    return;
                }
                
                try {
                    const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                    const tournamentDoc = await tournamentRef.get();
                    const tournament = tournamentDoc.data();
                    
                    const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                    if (playerIndex > -1) {
                        tournament.players[playerIndex].name = newName;
                        tournament.players[playerIndex].handicap = newHandicap;
                        tournament.players[playerIndex].handicapIndex = handicapIndex;
                        tournament.players[playerIndex].hcpMode = hcpMode;
                        
                        await tournamentRef.update({
                            players: tournament.players,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        
                        // Update local tournamentData
                        tournamentData.players = tournament.players;
                        saveToLocalStorage();
                        
                        hideConfirmDialog();
                        showPlayerManagement(); // Refresh the page
                        showNotification('Updated', `Player updated successfully`);
                    }
                } catch (error) {
                    console.error('Error updating player:', error);
                    showNotification('Error', 'Failed to update player');
                }
            };
            
            okBtn.onclick = handleOk;
            cancelBtn.onclick = hideConfirmDialog;
        }
        
        // Confirm player HCP after tee change (clears the warning indicator)
        async function confirmPlayerHcp(playerName) {
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex > -1) {
                    tournament.players[playerIndex].needsHcpConfirmation = false;
                    
                    await tournamentRef.update({
                        players: tournament.players,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    // Update local tournamentData
                    tournamentData.players = tournament.players;
                    saveToLocalStorage();
                    
                    showPlayerManagement(); // Refresh the page
                    showNotification('Confirmed', `${playerName}'s handicap confirmed`);
                }
            } catch (error) {
                console.error('Error confirming player HCP:', error);
                showNotification('Error', 'Failed to confirm handicap');
            }
        }
        
        // Add player to tournament (host and co-hosts)
        async function addPlayerToTournament() {
            if (!activeTournamentId || !canManageTournament()) {
                showNotification('Not Authorized', 'Only hosts and co-hosts can add players');
                return;
            }
            
            const nameInput = document.getElementById('newPlayerName');
            const handicapInput = document.getElementById('newPlayerHandicap');
            const name = nameInput.value.trim();
            const handicap = parseInt(handicapInput.value) || 0;
            
            if (!name) {
                showNotification('Error', 'Please enter a player name');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Check if player already exists
                if (tournament.players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                    showNotification('Error', 'Player already exists');
                    return;
                }
                
                // Add new player with empty scores
                const newPlayer = {
                    name: name,
                    handicap: handicap,
                    scores: new Array(18).fill(0),
                    claimedBy: null
                };
                
                tournament.players.push(newPlayer);
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update local data
                tournamentData.players = tournament.players;
                saveToLocalStorage();
                
                // Clear inputs
                nameInput.value = '';
                handicapInput.value = '0';
                
                showNotification('Added', `${name} added to tournament`);
                showPlayerManagement(); // Refresh
            } catch (error) {
                console.error('Error adding player:', error);
                showNotification('Error', 'Failed to add player');
            }
        }
        
        // Delete player from tournament (host and co-hosts)
        async function deletePlayerFromTournament(playerName) {
            if (!activeTournamentId || !canManageTournament()) {
                showNotification('Not Authorized', 'Only hosts and co-hosts can delete players');
                return;
            }
            
            showConfirm(
                'Delete Player?',
                `Are you sure you want to remove ${playerName} from the tournament? All their scores will be lost.`,
                async function() {
                    try {
                        const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                        const tournamentDoc = await tournamentRef.get();
                        const tournament = tournamentDoc.data();
                        
                        // TOMBSTONE: Record deletion time to prevent zombie reappearance
                        const deletionTime = Date.now();
                        deletedPlayers[playerName] = deletionTime;
                        console.log(`🪦 TOMBSTONE created for "${playerName}" at ${deletedPlayers[playerName]}`);
                        
                        // Remove player
                        tournament.players = tournament.players.filter(p => p.name !== playerName);
                        
                        // Store tombstone in Firebase so all devices know this player was deleted
                        const cloudTombstones = tournament.deletedPlayers || {};
                        cloudTombstones[playerName] = deletionTime;
                        
                        await tournamentRef.update({
                            players: tournament.players,
                            deletedPlayers: cloudTombstones,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        
                        // Update local data
                        tournamentData.players = tournament.players;
                        saveToLocalStorage();
                        
                        hideConfirmDialog();
                        showNotification('Deleted', `${playerName} removed from tournament`);
                        showPlayerManagement(); // Refresh
                    } catch (error) {
                        console.error('Error deleting player:', error);
                        showNotification('Error', 'Failed to delete player');
                    }
                }
            );
        }

        // Initialize swipe-to-delete for player cards in Host management
        function initPlayerSwipeToDelete() {
            const containers = document.querySelectorAll('.player-swipe-container');
            
            containers.forEach(container => {
                const cardContent = container.querySelector('.player-card-content');
                if (!cardContent) return;
                
                let startX = 0;
                let startY = 0;
                let currentX = 0;
                let isDragging = false;
                let isHorizontalSwipe = null;
                const deleteThreshold = 70;
                
                // Touch events
                cardContent.addEventListener('touchstart', (e) => {
                    // Don't initiate swipe if touching a button
                    if (e.target.closest('button')) {
                        isDragging = false;
                        return;
                    }
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    currentX = startX;
                    isDragging = true;
                    isHorizontalSwipe = null;
                    cardContent.style.transition = 'none';
                }, { passive: true });
                
                cardContent.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    currentX = e.touches[0].clientX;
                    const currentY = e.touches[0].clientY;
                    const diffX = startX - currentX;
                    const diffY = startY - e.touches[0].clientY;
                    
                    // Determine swipe direction on first significant movement
                    if (isHorizontalSwipe === null && (Math.abs(diffX) > 10 || Math.abs(diffY) > 10)) {
                        isHorizontalSwipe = Math.abs(diffX) > Math.abs(diffY);
                    }
                    
                    // Only allow swiping left if horizontal and significant movement (>15px)
                    if (isHorizontalSwipe && diffX > 15) {
                        const translateX = Math.min(diffX, deleteThreshold);
                        cardContent.style.transform = `translateX(-${translateX}px)`;
                    } else if (!isHorizontalSwipe || diffX <= 15) {
                        cardContent.style.transform = 'translateX(0)';
                    }
                }, { passive: true });
                
                cardContent.addEventListener('touchend', () => {
                    if (!isDragging) return;
                    isDragging = false;
                    cardContent.style.transition = 'transform 0.2s ease-out';
                    
                    const diff = startX - currentX;
                    
                    // Require more movement (50px) to trigger delete reveal
                    if (isHorizontalSwipe && diff >= 50) {
                        // Keep showing delete button
                        cardContent.style.transform = `translateX(-${deleteThreshold}px)`;
                    } else {
                        // Snap back
                        cardContent.style.transform = 'translateX(0)';
                    }
                    
                    startX = 0;
                    startY = 0;
                    currentX = 0;
                    isHorizontalSwipe = null;
                });
                
                // Click anywhere else to close
                cardContent.addEventListener('click', (e) => {
                    // If swiped open and clicking on card (not buttons), close it
                    if (cardContent.style.transform !== 'translateX(0px)' && cardContent.style.transform !== '' && cardContent.style.transform !== 'translateX(0)') {
                        // Check if click is not on a button
                        if (!e.target.closest('button')) {
                            cardContent.style.transform = 'translateX(0)';
                        }
                    }
                });
            });
            
            // Close any open swipe when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.player-swipe-container')) {
                    containers.forEach(container => {
                        const cardContent = container.querySelector('.player-card-content');
                        if (cardContent) {
                            cardContent.style.transition = 'transform 0.2s ease-out';
                            cardContent.style.transform = 'translateX(0)';
                        }
                    });
                }
            });
        }

        // Render the scoring page
        function renderScoringPage() {
            // ENSURE STATS ARE LOADED - safety net for force close recovery
            loadPlayerStatsFromLocalStorage();
            loadStatsConfig();
            
            // Load the correct course data - check tournament's embedded courseData first, then lookup by key
            if (tournamentData.courseData && tournamentData.courseData.holes) {
                courseData = tournamentData.courseData;
            } else {
                courseData = courses[tournamentData.course] || customCourses[tournamentData.course];
            }
            
            // Debug logging
            console.log('🏌️ renderScoringPage:', {
                course: tournamentData.course,
                courseDataLoaded: !!courseData,
                holesLoaded: courseData?.holes?.length,
                playersCount: tournamentData?.players?.length
            });
            
            // Update smart info line
            setTimeout(() => {
                generateSmartInfoLine('scoringSmartInfo');
            }, 10);

            // Clear the player cards container - content will be rendered by view-specific functions
            const container = document.getElementById('playerCards');
            container.innerHTML = '';
            
            // Show/hide crown badge for host in player mode
            const scoringHostBadge = document.getElementById('scoringHostBadge');
            if (scoringHostBadge) {
                scoringHostBadge.style.display = isHostInPlayerMode() ? 'inline-block' : 'none';
            }
            
            // Show/hide Manage Players button (for host and co-hosts, but NOT when host is in player mode)
            const manageBtn = document.getElementById('managePlayersBtn');
            if (manageBtn) {
                if (canManageTournament() && !isHostInPlayerMode()) {
                    manageBtn.style.display = 'flex';
                } else {
                    manageBtn.style.display = 'none';
                }
            }
            
            // Show My Players button for non-hosts/non-co-hosts OR when host is in player mode
            const myPlayersBtnHeader = document.getElementById('myPlayersBtnHeader');
            if (myPlayersBtnHeader) {
                if (tournamentMode === 'multi' && (!canManageTournament() || isHostInPlayerMode())) {
                    myPlayersBtnHeader.style.display = 'flex';
                } else {
                    myPlayersBtnHeader.style.display = 'none';
                }
            }
            
            // Show/hide Claim Another Player button (only for non-hosts/non-co-hosts in multi-device mode, OR host in player mode)
            const claimBtn = document.getElementById('claimAnotherBtn');
            if (claimBtn) {
                if (tournamentMode === 'multi' && (!canManageTournament() || isHostInPlayerMode())) {
                    claimBtn.style.display = 'block';
                } else {
                    claimBtn.style.display = 'none';
                }
            }
            
            // Update connection status
            updateConnectionStatus();
            
            // FIXED: Default to hole view if not set, and always render content
            if (!currentView) {
                currentView = 'hole';
            }
            
            // FIXED: Ensure the correct view container is visible BEFORE rendering
            const playerCardsEl = document.getElementById('playerCards');
            const holeViewEl = document.getElementById('holeView');
            
            if (currentView === 'hole') {
                if (playerCardsEl) playerCardsEl.style.display = 'none';
                if (holeViewEl) holeViewEl.style.display = 'block';
                // Remove players-view-active class
                document.getElementById('scoringPage').classList.remove('players-view-active');
            } else {
                if (playerCardsEl) playerCardsEl.style.display = 'block';
                if (holeViewEl) holeViewEl.style.display = 'none';
                // Add players-view-active class to lock vertical scroll
                document.getElementById('scoringPage').classList.add('players-view-active');
            }
            
            // Render the current active view (hole or player)
            // Use setTimeout to ensure DOM is ready
            setTimeout(() => {
                if (currentView === 'hole') {
                    renderHoleView();
                } else if (currentView === 'player') {
                    renderCompactPlayerView(getPlayersToShow());
                } else {
                    // Fallback to hole view
                    currentView = 'hole';
                    if (holeViewEl) holeViewEl.style.display = 'block';
                    renderHoleView();
                }
            }, 10);
        }

        // Score modification functions
        async function updateScore(playerIndex, holeIndex, value, skipRender = false) {
            const score = parseInt(value) || 0;
            tournamentData.players[playerIndex].scores[holeIndex] = score;
            
            // NEWEST WINS: Record timestamp for this score change
            const playerName = tournamentData.players[playerIndex].name;
            const timestampKey = `${playerName}-${holeIndex}`;
            scoreTimestamps[timestampKey] = Date.now();
            
            // IMMEDIATE SAVE with verification - this happens FIRST before any async
            const saveSuccess = saveToLocalStorage();
            
            // VERIFY the score was actually saved
            if (saveSuccess) {
                const verified = await verifyScoreSaved(playerIndex, holeIndex, score);
                if (!verified) {
                    console.error('❌ MANUAL INPUT: Score verification failed! Retrying save...');
                    tournamentData.players[playerIndex].scores[holeIndex] = score;
                    saveToLocalStorage();
                }
            }
            
            // Sync to Firebase if in cloud mode - AWAIT to ensure completion
            if (activeTournamentId && tournamentMode === 'multi') {
                const playerName = tournamentData.players[playerIndex].name;
                try {
                    await updatePlayerScore(activeTournamentId, playerName, holeIndex, score);
                } catch (error) {
                    console.error('❌ Firebase sync failed, but localStorage has the score:', error);
                }
            }
            
            updateProgressBar();
            
            // Only re-render if not skipped (caller will handle rendering)
            if (!skipRender) {
                renderScoringPage();
            }
        }

        async function incrementScore(playerIndex, holeIndex) {
            console.log('=== INCREMENT SCORE CALLED ===');
            console.log('playerIndex:', playerIndex, 'holeIndex:', holeIndex);
            
            if (playerIndex === undefined || holeIndex === undefined) {
                console.error('❌ Invalid parameters:', { playerIndex, holeIndex });
                return;
            }
            
            if (!tournamentData || !tournamentData.players || !tournamentData.players[playerIndex]) {
                console.error('❌ Invalid player data:', { 
                    hasTournamentData: !!tournamentData, 
                    playersLength: tournamentData?.players?.length,
                    playerIndex 
                });
                return;
            }
            
            const currentScore = tournamentData.players[playerIndex].scores[holeIndex];
            const par = (courseData?.holes?.[holeIndex]?.par) || 4;
            
            console.log('Player:', tournamentData.players[playerIndex].name);
            console.log('Hole:', holeIndex + 1);
            console.log('Current score:', currentScore);
            
            // If score is 0 or null, set to par first
            if (!currentScore || currentScore === 0) {
                tournamentData.players[playerIndex].scores[holeIndex] = par;
            } else {
                tournamentData.players[playerIndex].scores[holeIndex] = Math.min(currentScore + 1, 15);
            }
            
            const newScore = tournamentData.players[playerIndex].scores[holeIndex];
            console.log('New score:', newScore);
            console.log('Full scores array:', tournamentData.players[playerIndex].scores);
            
            // NEWEST WINS: Record timestamp for this score change
            const playerName = tournamentData.players[playerIndex].name;
            const timestampKey = `${playerName}-${holeIndex}`;
            scoreTimestamps[timestampKey] = Date.now();
            
            // IMMEDIATE SAVE with verification
            console.log('💾 Attempting localStorage save...');
            const saveSuccess = saveToLocalStorage();
            console.log('💾 Save result:', saveSuccess);
            
            // VERIFY the score was actually saved
            if (saveSuccess) {
                const verified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                if (!verified) {
                    console.error('❌ INCREMENT: Score verification failed! Retrying save...');
                    tournamentData.players[playerIndex].scores[holeIndex] = newScore;
                    const retrySuccess = saveToLocalStorage();
                    console.log('💾 Retry save result:', retrySuccess);
                    
                    // Verify again
                    const reVerified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                    if (!reVerified) {
                        console.error('🚨 CRITICAL: Score still not saved after retry!');
                        // Don't alert - Firebase has it
                    }
                }
            } else {
                console.error('🚨 CRITICAL: Initial save failed!');
                // Don't alert - Firebase has it
            }
            
            // Sync to Firebase if in cloud mode
            console.log('Checking Firebase sync:');
            console.log('  activeTournamentId:', activeTournamentId);
            console.log('  tournamentMode:', tournamentMode);
            
            if (activeTournamentId && tournamentMode === 'multi') {
                console.log('✅ SYNCING to Firebase:', playerName, 'Hole', holeIndex + 1, '=', newScore);
                updatePlayerScore(activeTournamentId, playerName, holeIndex, newScore);
            } else {
                console.log('❌ NOT syncing - missing activeTournamentId or not in multi mode');
            }
            
            updateProgressBar();
            
            // Update only the specific score input without full re-render
            updateScoreDisplay(playerIndex, holeIndex, newScore, par);
            
            // Check if hole is complete for auto-advance
            setTimeout(() => checkAutoAdvance(), 500);
        }

        async function decrementScore(playerIndex, holeIndex) {
            console.log('=== DECREMENT SCORE CALLED ===');
            console.log('playerIndex:', playerIndex, 'holeIndex:', holeIndex);
            
            if (playerIndex === undefined || holeIndex === undefined) {
                console.error('❌ Invalid parameters:', { playerIndex, holeIndex });
                return;
            }
            
            if (!tournamentData || !tournamentData.players || !tournamentData.players[playerIndex]) {
                console.error('❌ Invalid player data:', { 
                    hasTournamentData: !!tournamentData, 
                    playersLength: tournamentData?.players?.length,
                    playerIndex 
                });
                return;
            }
            
            const currentScore = tournamentData.players[playerIndex].scores[holeIndex];
            const par = (courseData?.holes?.[holeIndex]?.par) || 4;
            
            console.log('Player:', tournamentData.players[playerIndex].name);
            console.log('Hole:', holeIndex + 1);
            console.log('Current score:', currentScore);
            
            // If score is 0 or null, set to par first
            if (!currentScore || currentScore === 0) {
                tournamentData.players[playerIndex].scores[holeIndex] = par;
            } else {
                tournamentData.players[playerIndex].scores[holeIndex] = Math.max(currentScore - 1, 0);
            }
            
            const newScore = tournamentData.players[playerIndex].scores[holeIndex];
            console.log('New score:', newScore);
            console.log('Full scores array:', tournamentData.players[playerIndex].scores);
            
            // NEWEST WINS: Record timestamp for this score change
            const playerName = tournamentData.players[playerIndex].name;
            const timestampKey = `${playerName}-${holeIndex}`;
            scoreTimestamps[timestampKey] = Date.now();
            
            // IMMEDIATE SAVE with verification
            console.log('💾 Attempting localStorage save...');
            const saveSuccess = saveToLocalStorage();
            console.log('💾 Save result:', saveSuccess);
            
            // VERIFY the score was actually saved
            if (saveSuccess) {
                const verified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                if (!verified) {
                    console.error('❌ DECREMENT: Score verification failed! Retrying save...');
                    tournamentData.players[playerIndex].scores[holeIndex] = newScore;
                    const retrySuccess = saveToLocalStorage();
                    console.log('💾 Retry save result:', retrySuccess);
                    
                    // Verify again
                    const reVerified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                    if (!reVerified) {
                        console.error('🚨 CRITICAL: Score still not saved after retry!');
                        // Don't alert - Firebase has it
                    }
                }
            } else {
                console.error('🚨 CRITICAL: Initial save failed!');
                // Don't alert - Firebase has it
            }
            
            // Sync to Firebase if in cloud mode
            console.log('Checking Firebase sync:');
            console.log('  activeTournamentId:', activeTournamentId);
            console.log('  tournamentMode:', tournamentMode);
            
            if (activeTournamentId && tournamentMode === 'multi') {
                console.log('✅ SYNCING to Firebase:', playerName, 'Hole', holeIndex + 1, '=', newScore);
                updatePlayerScore(activeTournamentId, playerName, holeIndex, newScore);
            } else {
                console.log('❌ NOT syncing - missing activeTournamentId or not in multi mode');
            }
            
            updateProgressBar();
            
            // Update only the specific score input without full re-render
            updateScoreDisplay(playerIndex, holeIndex, newScore, par);
        }
        
        // Update just the score display without re-rendering entire page
        function updateScoreDisplay(playerIndex, holeIndex, score, par) {
            // Find the score input for this player/hole
            const grid = document.getElementById(`player${playerIndex}Grid`);
            if (!grid) return; // Player not visible (filtered out)
            
            const holeInputs = grid.querySelectorAll('.hole-input-group');
            if (!holeInputs[holeIndex]) return;
            
            const scoreInput = holeInputs[holeIndex].querySelector('.score-input');
            if (!scoreInput) return;
            
            // Update value
            scoreInput.value = score || '';
            
            // Update color class
            scoreInput.className = 'score-input';
            if (score > 0) {
                const diff = score - par;
                if (diff >= 2) {
                    scoreInput.classList.add('double-bogey-plus');
                } else if (diff === 1) {
                    scoreInput.classList.add('bogey');
                } else if (diff === 0) {
                    scoreInput.classList.add('par');
                } else if (diff <= -1) {
                    scoreInput.classList.add('birdie-better');
                }
            }
            
            // Update player total
            const playerCard = scoreInput.closest('.player-card');
            if (playerCard) {
                const player = tournamentData.players[playerIndex];
                const total = player.scores.reduce((sum, s) => sum + (s || 0), 0);
                const toPar = total - courseData.totalPar;
                const toParText = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar);
                
                const totalDisplay = playerCard.querySelector('.player-total');
                if (totalDisplay) {
                    totalDisplay.innerHTML = `${total > 0 ? total : '-'} <span style="font-size: 16px; color: #64748b;">(${toParText})</span>`;
                }
            }
        }
        
        // Update score display for COMPACT CAROUSEL view (no re-render)
        function updateCompactScoreDisplay(playerIndex, holeIndex, score) {
            const player = tournamentData.players[playerIndex];
            if (!player) return;
            
            const par = (courseData?.holes?.[holeIndex]?.par) || 4;
            
            // Find the current carousel slide for this player
            const slides = document.querySelectorAll('.player-carousel-slide');
            let targetSlide = null;
            
            // Find slide that contains this player
            slides.forEach((slide, idx) => {
                const nameEl = slide.querySelector('.player-name-compact span');
                if (nameEl && nameEl.textContent.includes(player.name)) {
                    targetSlide = slide;
                }
            });
            
            if (!targetSlide) return;
            
            // Find the hole cell (0-indexed)
            const holeCells = targetSlide.querySelectorAll('.hole-cell');
            const targetCell = holeCells[holeIndex];
            if (!targetCell) return;
            
            // Update the score cell
            const scoreCell = targetCell.querySelector('.score-cell');
            if (scoreCell) {
                // Update score text
                scoreCell.textContent = score || '-';
                
                // Update score color class
                scoreCell.className = 'score-cell';
                if (score > 0) {
                    const diff = score - par;
                    if (diff <= -2) {
                        scoreCell.classList.add('eagle-better');
                    } else if (diff === -1) {
                        scoreCell.classList.add('birdie');
                    } else if (diff === 0) {
                        scoreCell.classList.add('par');
                    } else if (diff === 1) {
                        scoreCell.classList.add('bogey');
                    } else {
                        scoreCell.classList.add('double-plus');
                    }
                } else {
                    scoreCell.classList.add('empty');
                }
            }
            
            // Update totals
            const scores = player.scores || [];
            const front9 = scores.slice(0, 9).reduce((sum, s) => sum + (s || 0), 0);
            const back9 = scores.slice(9, 18).reduce((sum, s) => sum + (s || 0), 0);
            const total = front9 + back9;
            const toPar = total - (courseData?.totalPar || 72);
            const toParText = total === 0 ? '-' : (toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar));
            
            // Update totals row
            const totalsRow = targetSlide.querySelector('.totals-row');
            if (totalsRow) {
                const totalItems = totalsRow.querySelectorAll('.total-item .total-value');
                if (totalItems[0]) totalItems[0].textContent = front9 > 0 ? front9 : '-';
                if (totalItems[1]) totalItems[1].textContent = back9 > 0 ? back9 : '-';
                if (totalItems[2]) totalItems[2].textContent = total > 0 ? total : '-';
                if (totalItems[3]) totalItems[3].textContent = toParText;
            }
            
            // Update header total
            const headerTotal = targetSlide.querySelector('.player-total-compact');
            if (headerTotal) {
                headerTotal.textContent = `${total > 0 ? total : '-'} (${toParText})`;
            }
        }
        
        // Fallback: Full re-render of player view when in-place update isn't possible
        function refreshPlayerView() {
            if (currentView === 'player') {
                renderCompactPlayerView(getPlayersToShow());
            }
        }

        // Update progress bar
        function updateProgressBar() {
            const progressBar = document.getElementById('tournamentProgress');
            if (progressBar) {
                const progress = getTournamentProgress();
                progressBar.style.width = progress + '%';
            }
        }

        // Show finish confirmation dialog with 3 options
        function showFinishConfirmation() {
            const modal = document.createElement('div');
            modal.id = 'finishConfirmModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 24px; max-width: 340px; width: 100%; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 12px;">🏆</div>
                    <h2 style="color: #1e3a5f; margin-bottom: 8px; font-size: 20px;">View Results?</h2>
                    <p style="color: #64748b; margin-bottom: 20px; font-size: 14px;">
                        What would you like to do?
                    </p>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="confirmFinishAndView()" style="padding: 14px; background: #166534; color: white; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            ✓ View Results
                        </button>
                        <button onclick="saveAndStay()" style="padding: 14px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            💾 Save Backup & Stay
                        </button>
                        <button onclick="document.getElementById('finishConfirmModal').remove()" style="padding: 14px; background: #e2e8f0; color: #64748b; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Confirm and go to results
        function confirmFinishAndView() {
            document.getElementById('finishConfirmModal')?.remove();
            finishRound();
        }
        
        // Save backup and stay on scoring page
        function saveAndStay() {
            document.getElementById('finishConfirmModal')?.remove();
            saveTournamentFile();
            showNotification('Saved!', 'Backup file downloaded');
        }

        // Finish round and show results
        async function finishRound() {
            // Force sync from Firestore in multi-device mode before showing results
            if (tournamentMode === 'multi' && activeTournamentId) {
                try {
                    const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                    const tournamentDoc = await tournamentRef.get();
                    if (tournamentDoc.exists) {
                        const tournament = tournamentDoc.data();
                        updateLocalTournamentState(tournament);
                    }
                } catch (error) {
                    console.error('Error syncing tournament data:', error);
                }
            }
            
            renderResultsPage();
            showPage('resultsPage');
            // Celebrate with confetti!
            setTimeout(() => showConfetti(), 300);
        }

        function backToScoring() {
            showPage('scoringPage');
        }

        // Helper functions for net score calculations
        function getNetScore(grossScore, playerHcp, holeHcp, method = 'full') {
            if (grossScore === 0) return 0;
            
            let strokes = 0;
            
            // Handle plus handicaps (negative values)
            if (playerHcp < 0) {
                const absHcp = Math.abs(playerHcp);
                
                if (method === 'full') {
                    // Plus handicap: add strokes on EASIEST holes (18, 17, 16...)
                    strokes = -Math.floor(absHcp / 18); // Negative = add to score
                    if (holeHcp > (18 - (absHcp % 18))) {
                        strokes -= 1; // Add another stroke on easier holes
                    }
                } else if (method === '18max') {
                    // 18 Max: max 1 stroke added per hole on easiest holes
                    if (holeHcp > (18 - Math.min(absHcp, 18))) {
                        strokes = -1;
                    }
                } else if (method === 'half') {
                    // Half Pop: 0.5 stroke added per allocated stroke
                    const fullStrokes = Math.floor(absHcp / 18);
                    const extraStroke = holeHcp > (18 - (absHcp % 18)) ? 1 : 0;
                    strokes = -(fullStrokes + extraStroke) * 0.5;
                }
            } 
            // Handle regular (positive) handicaps
            else if (playerHcp > 0) {
                if (method === 'full') {
                    // Regular handicap: subtract strokes on HARDEST holes (1, 2, 3...)
                    strokes = Math.floor(playerHcp / 18);
                    if (holeHcp <= (playerHcp % 18)) {
                        strokes += 1;
                    }
                } else if (method === '18max') {
                    // 18 Max: max 1 stroke per hole
                    if (holeHcp <= Math.min(playerHcp, 18)) {
                        strokes = 1;
                    }
                } else if (method === 'half') {
                    // Half Pop: 0.5 stroke per allocated stroke
                    const fullStrokes = Math.floor(playerHcp / 18);
                    const extraStroke = holeHcp <= (playerHcp % 18) ? 1 : 0;
                    strokes = (fullStrokes + extraStroke) * 0.5;
                }
            }
            
            return grossScore - strokes;
        }
        
        // Get the number of handicap strokes for a specific hole
        // Returns: positive = strokes subtracted (getting pops), negative = strokes added (plus handicap)
        function getHandicapStrokesForHole(playerHcp, holeHcp, method = 'full') {
            if (playerHcp === 0) return 0;
            
            let strokes = 0;
            
            // Handle plus handicaps (negative values) - add strokes on easiest holes
            if (playerHcp < 0) {
                const absHcp = Math.abs(playerHcp);
                
                if (method === 'full') {
                    strokes = -Math.floor(absHcp / 18);
                    if (holeHcp > (18 - (absHcp % 18))) {
                        strokes -= 1;
                    }
                } else if (method === '18max') {
                    if (holeHcp > (18 - Math.min(absHcp, 18))) {
                        strokes = -1;
                    }
                } else if (method === 'half') {
                    const fullStrokes = Math.floor(absHcp / 18);
                    const extraStroke = holeHcp > (18 - (absHcp % 18)) ? 1 : 0;
                    strokes = -(fullStrokes + extraStroke) * 0.5;
                }
            } 
            // Handle regular (positive) handicaps - subtract strokes on hardest holes
            else if (playerHcp > 0) {
                if (method === 'full') {
                    strokes = Math.floor(playerHcp / 18);
                    if (holeHcp <= (playerHcp % 18)) {
                        strokes += 1;
                    }
                } else if (method === '18max') {
                    if (holeHcp <= Math.min(playerHcp, 18)) {
                        strokes = 1;
                    }
                } else if (method === 'half') {
                    const fullStrokes = Math.floor(playerHcp / 18);
                    const extraStroke = holeHcp <= (playerHcp % 18) ? 1 : 0;
                    strokes = (fullStrokes + extraStroke) * 0.5;
                }
            }
            
            return strokes;
        }

        function getStablefordPoints(netScore, par, modified = false) {
            const diff = netScore - par;
            
            if (modified) {
                // Modified Stableford
                if (diff <= -4) return 11;  // Condor
                if (diff === -3) return 8;   // Albatross
                if (diff === -2) return 5;   // Eagle
                if (diff === -1) return 2;   // Birdie
                if (diff === 0) return 0;    // Par
                if (diff === 1) return -1;   // Bogey
                return -3;                    // Double bogey or worse
            } else {
                // Standard Stableford
                if (diff <= -4) return 6;    // Condor
                if (diff === -3) return 5;   // Albatross
                if (diff === -2) return 4;   // Eagle
                if (diff === -1) return 3;   // Birdie
                if (diff === 0) return 2;    // Par
                if (diff === 1) return 1;    // Bogey
                return 0;                     // Double bogey or worse
            }
        }

        function renderResultsPage() {
            // Load the correct course data
            courseData = courses[tournamentData.course];
            
            // Update smart info line
            setTimeout(() => {
                generateSmartInfoLine('resultsSmartInfo');
            }, 10);
            
            // Show/hide crown badge for host in player mode
            const resultsHostBadge = document.getElementById('resultsHostBadge');
            if (resultsHostBadge) {
                resultsHostBadge.style.display = isHostInPlayerMode() ? 'inline-block' : 'none';
            }
            
            // Show/hide manage button for hosts and co-hosts (but NOT when host is in player mode)
            const manageBtn = document.getElementById('resultsManageBtn');
            if (manageBtn) {
                manageBtn.style.display = (canManageTournament() && !isHostInPlayerMode()) ? 'flex' : 'none';
            }
            
            // Show/hide finish button (only for hosts/co-hosts, but NOT when host is in player mode)
            const finishBtn = document.getElementById('newRoundBtnTop');
            if (finishBtn) {
                finishBtn.style.display = (canManageTournament() && !isHostInPlayerMode()) ? 'flex' : 'none';
            }
            
            // Show My Players button for non-hosts/non-co-hosts OR when host is in player mode
            const myPlayersBtn = document.getElementById('resultsMyPlayersBtn');
            if (myPlayersBtn) {
                myPlayersBtn.style.display = ((!canManageTournament() || isHostInPlayerMode()) && tournamentMode === 'multi') ? 'flex' : 'none';
            }
            
            // Show/hide filter toggle (only for non-hosts/non-co-hosts in multi mode, OR host in player mode)
            const filterToggle = document.getElementById('resultsFilterToggle');
            if (filterToggle) {
                filterToggle.style.display = ((!canManageTournament() || isHostInPlayerMode()) && tournamentMode === 'multi') ? 'flex' : 'none';
            }
            
            // Show/hide header filter toggle - NOW HIDDEN, toggle is in settings card
            const filterToggleHeader = document.getElementById('resultsFilterToggleHeader');
            if (filterToggleHeader) {
                filterToggleHeader.style.display = 'none';
            }
            
            // PRIVACY CHECK: If user can't view leaderboard, force "My Players" filter
            if (!canViewLeaderboard() && tournamentMode === 'multi') {
                currentResultsFilter = 'mine';
                // Update toggle button styles
                const allBtnHeader = document.getElementById('resultsToggleAllHeader');
                const mineBtnHeader = document.getElementById('resultsToggleMineHeader');
                if (allBtnHeader) {
                    allBtnHeader.style.background = 'transparent';
                    allBtnHeader.style.color = '#64748b';
                    allBtnHeader.innerHTML = '🔒 All Players';
                }
                if (mineBtnHeader) {
                    mineBtnHeader.style.background = '#1e3a5f';
                    mineBtnHeader.style.color = 'white';
                }
            } else if (tournamentMode === 'multi') {
                // Privacy allows viewing - ensure buttons are in correct state
                const allBtnHeader = document.getElementById('resultsToggleAllHeader');
                const mineBtnHeader = document.getElementById('resultsToggleMineHeader');
                if (allBtnHeader) {
                    allBtnHeader.innerHTML = 'All Players';
                    if (currentResultsFilter === 'all') {
                        allBtnHeader.style.background = '#1e3a5f';
                        allBtnHeader.style.color = 'white';
                    } else {
                        allBtnHeader.style.background = 'transparent';
                        allBtnHeader.style.color = '#64748b';
                    }
                }
                if (mineBtnHeader) {
                    if (currentResultsFilter === 'mine') {
                        mineBtnHeader.style.background = '#1e3a5f';
                        mineBtnHeader.style.color = 'white';
                    } else {
                        mineBtnHeader.style.background = 'transparent';
                        mineBtnHeader.style.color = '#64748b';
                    }
                }
            }
            
            // Set the dropdown to match current game type
            const resultsGameTypeEl = document.getElementById('resultsGameType');
            if (resultsGameTypeEl) {
                // Map old game types to new consolidated types
                let displayGameType = tournamentData.gameType;
                if (displayGameType.includes('Stroke Play')) displayGameType = 'Stroke Play';
                if (displayGameType.includes('Skins')) displayGameType = 'Skins';
                resultsGameTypeEl.value = displayGameType;
            }
            
            // Update scoring method buttons based on game type
            updateScoringMethodButtons();
            
            updateResultsDisplay();
            
            // Render foursome game results if applicable
            renderFoursomeGameResults();
        }

        // Current scoring method state
        let currentScoringMethod = 'gross'; // 'gross', 'net', 'net18', 'netHalf'
        let currentBestBallView = false; // Whether viewing Best Ball results
        
        // Results page Best Ball config (separate from setup page)
        let resultsBestBallConfig = null; // Will hold { playersPerTeam, scoresPerHole, format, teams }
        
        // Set scoring method
        function setScoringMethod(method) {
            currentScoringMethod = method;
            
            // Use medium blue for both tournament and side game modes
            const activeColor = '#1e3a5f';
            
            // Update button styles for main settings card
            const methods = ['gross', 'net', 'net18', 'netHalf'];
            methods.forEach(m => {
                const btn = document.getElementById(`scoringMethod${m.charAt(0).toUpperCase() + m.slice(1)}`);
                if (btn && !btn.disabled) {
                    if (m === method) {
                        btn.style.background = activeColor;
                        btn.style.border = 'none';
                        btn.style.color = 'white';
                    } else {
                        btn.style.background = 'white';
                        btn.style.border = '1px solid #d1d5db';
                        btn.style.color = '#374151';
                    }
                }
                
                // Also update side game buttons
                const sideBtn = document.getElementById(`sideGameMethod${m.charAt(0).toUpperCase() + m.slice(1)}`);
                if (sideBtn && !sideBtn.disabled) {
                    if (m === method) {
                        sideBtn.style.background = activeColor;
                        sideBtn.style.border = 'none';
                        sideBtn.style.color = 'white';
                    } else {
                        sideBtn.style.background = 'white';
                        sideBtn.style.border = '1px solid #d1d5db';
                        sideBtn.style.color = '#374151';
                    }
                }
            });
            
            // Update results display
            updateResultsDisplay();
        }
        
        // Update scoring method buttons based on game type
        function updateScoringMethodButtons() {
            const gameType = document.getElementById('resultsGameType')?.value || tournamentData.gameType;
            const netHalfBtn = document.getElementById('scoringMethodNetHalf');
            
            // Enable Net ½ only for Skins
            if (netHalfBtn) {
                const isSkins = gameType === 'Skins' || gameType.includes('Skins');
                netHalfBtn.disabled = !isSkins;
                netHalfBtn.style.opacity = isSkins ? '1' : '0.5';
                netHalfBtn.style.color = isSkins ? '#475569' : '#9ca3af';
                
                // If currently on netHalf and switching away from Skins, reset to gross
                if (!isSkins && currentScoringMethod === 'netHalf') {
                    setScoringMethod('gross');
                }
            }
        }
        
        // Current results mode: 'tourney' or 'sideGame'
        let currentResultsMode = 'tourney';
        
        // Set results mode (Tourney or Side Game)
        function setResultsMode(mode) {
            currentResultsMode = mode;
            
            // New toggle and button rows
            const tourneyModeToggle = document.getElementById('tourneyModeToggle');
            const sideGameModeToggle = document.getElementById('sideGameModeToggle');
            const resultsModeToggleRow = document.getElementById('resultsModeToggleRow');
            const resultsSideGameBtnRow = document.getElementById('resultsSideGameBtnRow');
            
            // Settings cards
            const resultsSettingsCard = document.getElementById('resultsSettingsCard');
            const sideGameSettingsCard = document.getElementById('sideGameSettingsCard');
            
            // Legacy elements (keep for backward compatibility)
            const tourneyBtn = document.getElementById('tourneyModeBtn');
            const sideGameBtn = document.getElementById('sideGameModeBtn');
            const tourneyBtnHeader = document.getElementById('tourneyModeBtnHeader');
            const sideGameBtnHeader = document.getElementById('sideGameModeBtnHeader');
            const gameTypeSelect = document.getElementById('resultsGameType');
            const filterRow = document.getElementById('resultsFilterRow');
            const filterToggleHeader = document.getElementById('resultsFilterToggleHeader');
            
            // Header row toggles (legacy)
            const tourneyHeaderRow = document.getElementById('resultsTourneyHeaderRow');
            const sideGameHeaderRow = document.getElementById('resultsSideGameHeaderRow');
            
            if (mode === 'tourney') {
                // Show Tournament/Side Game toggle, hide Back to Tournament buttons
                if (resultsModeToggleRow) resultsModeToggleRow.style.display = 'flex';
                if (resultsSideGameBtnRow) resultsSideGameBtnRow.style.display = 'none';
                
                // Update toggle buttons visual state
                if (tourneyModeToggle) {
                    tourneyModeToggle.style.background = '#1e3a5f';
                    tourneyModeToggle.style.color = 'white';
                }
                if (sideGameModeToggle) {
                    sideGameModeToggle.style.background = 'transparent';
                    sideGameModeToggle.style.color = '#6b7280';
                }
                
                // Show/hide settings cards
                if (resultsSettingsCard) resultsSettingsCard.style.display = 'block';
                if (sideGameSettingsCard) sideGameSettingsCard.style.display = 'none';
                
                // Legacy: Keep old header rows hidden - we use settings card now
                if (tourneyHeaderRow) tourneyHeaderRow.style.display = 'none';
                if (sideGameHeaderRow) sideGameHeaderRow.style.display = 'none';
                
                // Update card buttons
                if (tourneyBtn) {
                    tourneyBtn.style.background = '#1e3a5f';
                    tourneyBtn.style.color = 'white';
                }
                if (sideGameBtn) {
                    sideGameBtn.style.background = 'transparent';
                    sideGameBtn.style.color = '#6b7280';
                }
                // Update header buttons
                if (tourneyBtnHeader) {
                    tourneyBtnHeader.style.background = '#1e3a5f';
                    tourneyBtnHeader.style.color = 'white';
                }
                if (sideGameBtnHeader) {
                    sideGameBtnHeader.style.background = 'transparent';
                    sideGameBtnHeader.style.color = '#6b7280';
                }
                
                if (gameTypeSelect) gameTypeSelect.style.display = '';
                // Keep filterRow hidden - we use the settings card toggle now
                if (filterRow) filterRow.style.display = 'none';
                
                // Filter toggle is now in settings card, keep header hidden
                if (filterToggleHeader) {
                    filterToggleHeader.style.display = 'none';
                }
                
                // Reset to regular view
                currentBestBallView = false;
                
                // Reset scoring method buttons to medium blue
                updateScoringMethodButtonColors('navy');
                
                updateResultsDisplay();
            } else {
                // Hide Tournament/Side Game toggle, show Back to Tournament buttons
                if (resultsModeToggleRow) resultsModeToggleRow.style.display = 'none';
                if (resultsSideGameBtnRow) resultsSideGameBtnRow.style.display = 'flex';
                
                // Show/hide settings cards
                if (resultsSettingsCard) resultsSettingsCard.style.display = 'none';
                if (sideGameSettingsCard) sideGameSettingsCard.style.display = 'block';
                
                // Legacy: Keep header rows hidden
                if (tourneyHeaderRow) tourneyHeaderRow.style.display = 'none';
                if (sideGameHeaderRow) sideGameHeaderRow.style.display = 'none';
                
                // Update card buttons
                if (tourneyBtn) {
                    tourneyBtn.style.background = 'transparent';
                    tourneyBtn.style.color = '#6b7280';
                }
                if (sideGameBtn) {
                    sideGameBtn.style.background = '#1e3a5f';
                    sideGameBtn.style.color = 'white';
                }
                // Update header buttons
                if (tourneyBtnHeader) {
                    tourneyBtnHeader.style.background = 'transparent';
                    tourneyBtnHeader.style.color = '#6b7280';
                }
                if (sideGameBtnHeader) {
                    sideGameBtnHeader.style.background = '#1e3a5f';
                    sideGameBtnHeader.style.color = 'white';
                }
                
                if (gameTypeSelect) gameTypeSelect.style.display = 'none';
                if (filterRow) filterRow.style.display = 'none';
                if (filterToggleHeader) filterToggleHeader.style.display = 'none';
                
                // Update scoring method buttons to navy (same as tourney now)
                updateScoringMethodButtonColors('navy');
                
                // Check if we have saved config
                const savedConfig = loadBestBallConfig();
                if (savedConfig && savedConfig.teams && savedConfig.teams.length >= 2) {
                    resultsBestBallConfig = savedConfig;
                    currentBestBallView = true;
                    updateResultsDisplay();
                } else {
                    // First time - show setup modal
                    showResultsBestBallSetup();
                }
            }
        }
        
        // Update scoring method button colors based on mode
        function updateScoringMethodButtonColors(colorScheme) {
            // Simply re-apply the current scoring method which will use the correct color
            // based on currentResultsMode
            setScoringMethod(currentScoringMethod);
        }
        
        // Toggle Best Ball view (legacy - now handled by setResultsMode)
        function toggleBestBallView() {
            if (currentBestBallView) {
                setResultsMode('tourney');
            } else {
                setResultsMode('sideGame');
            }
        }
        
        // Show Best Ball setup modal for results page
        function showResultsBestBallSetup() {
            const players = tournamentData.players || [];
            if (players.length < 2) {
                showNotification('Not Enough Players', 'Need at least 2 players for Best Ball');
                return;
            }
            
            // Load saved config if exists
            const savedConfig = loadBestBallConfig();
            const config = savedConfig || {
                playersPerTeam: 2,
                scoresPerHole: 1,
                format: 'stroke',
                teams: []
            };
            
            const modal = document.createElement('div');
            modal.id = 'bestBallSetupModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.85);
                display: flex;
                align-items: flex-start;
                justify-content: center;
                z-index: 10002;
                padding: 20px;
                overflow-y: auto;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 6px; padding: 20px; max-width: 400px; width: 100%; margin: 20px auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h2 style="color: #1e3a5f; margin: 0; font-size: 18px; display: flex; align-items: center; gap: 8px;">⛳ Side Game Setup</h2>
                        <button onclick="closeBestBallSetup()" style="padding: 8px 14px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">← Back to Tournament</button>
                    </div>
                    
                    <!-- Players Per Team -->
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; font-size: 13px; font-weight: 600; color: #1e3a5f; margin-bottom: 8px;">Players Per Team</label>
                        <div style="display: flex; gap: 8px;">
                            ${[1, 2, 3, 4].map(n => `
                                <button type="button" onclick="setBestBallPlayersPerTeam(${n})" id="bbPPT${n}"
                                    style="flex: 1; padding: 12px; border: 1px solid ${config.playersPerTeam === n ? '#1e3a5f' : '#d1d5db'}; 
                                    background: ${config.playersPerTeam === n ? '#1e3a5f' : 'white'}; 
                                    color: ${config.playersPerTeam === n ? 'white' : '#1e3a5f'}; 
                                    border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer;">${n}</button>
                            `).join('')}
                        </div>
                    </div>
                    
                    <!-- Scores Per Hole -->
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; font-size: 13px; font-weight: 600; color: #1e3a5f; margin-bottom: 8px;">Scores to Count Per Hole</label>
                        <div style="display: flex; gap: 8px;">
                            ${[1, 2, 3].map(n => `
                                <button type="button" onclick="setBestBallScoresPerHole(${n})" id="bbSPH${n}"
                                    style="flex: 1; padding: 12px; border: 1px solid ${config.scoresPerHole === n ? '#1e3a5f' : '#d1d5db'}; 
                                    background: ${config.scoresPerHole === n ? '#1e3a5f' : 'white'}; 
                                    color: ${config.scoresPerHole === n ? 'white' : '#1e3a5f'}; 
                                    border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer;">${n}</button>
                            `).join('')}
                        </div>
                    </div>
                    
                    <!-- Format -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-size: 13px; font-weight: 600; color: #1e3a5f; margin-bottom: 8px;">Format</label>
                        <div style="display: flex; gap: 8px;">
                            <button type="button" onclick="setBestBallFormat('stroke')" id="bbFormatStroke"
                                style="flex: 1; padding: 12px; border: 1px solid ${config.format === 'stroke' ? '#d4b896' : '#d1d5db'}; 
                                background: ${config.format === 'stroke' ? '#d4b896' : 'white'}; 
                                color: ${config.format === 'stroke' ? '#1e3a5f' : '#6b7280'}; 
                                border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer;">Stroke Play</button>
                            <button type="button" onclick="setBestBallFormat('match')" id="bbFormatMatch"
                                style="flex: 1; padding: 12px; border: 1px solid ${config.format === 'match' ? '#d4b896' : '#d1d5db'}; 
                                background: ${config.format === 'match' ? '#d4b896' : 'white'}; 
                                color: ${config.format === 'match' ? '#1e3a5f' : '#6b7280'}; 
                                border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer;">Match Play</button>
                        </div>
                    </div>
                    
                    <!-- Team Assignment Section -->
                    <div style="border-top: 1px solid #e5e7eb; padding-top: 16px; margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <label style="font-size: 14px; font-weight: 700; color: #1e3a5f;">Assign Teams</label>
                            <button type="button" onclick="addBestBallTeam()" style="padding: 6px 12px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">+ Add Team</button>
                        </div>
                        <div id="bestBallTeamsContainer">
                            <!-- Teams will be rendered here -->
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button type="button" onclick="saveBestBallAndShowResults()" style="padding: 14px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; touch-action: manipulation; -webkit-tap-highlight-color: rgba(30, 58, 95, 0.3);">
                            ✓ View Results
                        </button>
                        <button type="button" onclick="clearBestBallTeamsOnSetup()" style="padding: 12px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer; touch-action: manipulation;">
                            🗑 Clear Teams
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Store temp config for editing
            window.tempBestBallConfig = { ...config, teams: [...(config.teams || [])] };
            
            // Render existing teams or add default ones
            if (window.tempBestBallConfig.teams.length === 0) {
                // Auto-create teams based on player count
                autoCreateBestBallTeams();
            } else {
                renderBestBallTeams();
            }
        }
        
        // Load saved Best Ball config from localStorage
        function loadBestBallConfig() {
            const key = activeTournamentId ? `bestBall_${activeTournamentId}` : 'bestBall_local';
            const saved = localStorage.getItem(key);
            return saved ? JSON.parse(saved) : null;
        }
        
        // Save Best Ball config to localStorage
        function saveBestBallConfig(config) {
            const key = activeTournamentId ? `bestBall_${activeTournamentId}` : 'bestBall_local';
            localStorage.setItem(key, JSON.stringify(config));
        }
        
        // Close Best Ball setup modal and return to Tournament view
        function closeBestBallSetup() {
            document.getElementById('bestBallSetupModal')?.remove();
            window.tempBestBallConfig = null;
            // Return to tourney mode
            setResultsMode('tourney');
        }
        
        // Close Best Ball setup without changing mode (for when setup is complete)
        function closeBestBallSetupOnly() {
            document.getElementById('bestBallSetupModal')?.remove();
            window.tempBestBallConfig = null;
        }
        
        // Set players per team
        function setBestBallPlayersPerTeam(n) {
            if (!window.tempBestBallConfig) return;
            window.tempBestBallConfig.playersPerTeam = n;
            
            // Update button styles - navy for selected
            [1, 2, 3, 4].forEach(num => {
                const btn = document.getElementById(`bbPPT${num}`);
                if (btn) {
                    btn.style.borderColor = num === n ? '#1e3a5f' : '#d1d5db';
                    btn.style.background = num === n ? '#1e3a5f' : 'white';
                    btn.style.color = num === n ? 'white' : '#1e3a5f';
                }
            });
            
            // Re-render teams to adjust player count per team
            renderBestBallTeams();
        }
        
        // Set scores per hole
        function setBestBallScoresPerHole(n) {
            if (!window.tempBestBallConfig) return;
            window.tempBestBallConfig.scoresPerHole = n;
            
            [1, 2, 3].forEach(num => {
                const btn = document.getElementById(`bbSPH${num}`);
                if (btn) {
                    btn.style.borderColor = num === n ? '#1e3a5f' : '#d1d5db';
                    btn.style.background = num === n ? '#1e3a5f' : 'white';
                    btn.style.color = num === n ? 'white' : '#1e3a5f';
                }
            });
        }
        
        // Set format (stroke/match)
        function setBestBallFormat(format) {
            if (!window.tempBestBallConfig) return;
            window.tempBestBallConfig.format = format;
            
            const strokeBtn = document.getElementById('bbFormatStroke');
            const matchBtn = document.getElementById('bbFormatMatch');
            
            if (strokeBtn) {
                strokeBtn.style.borderColor = format === 'stroke' ? '#d4b896' : '#d1d5db';
                strokeBtn.style.background = format === 'stroke' ? '#d4b896' : 'white';
                strokeBtn.style.color = format === 'stroke' ? '#1e3a5f' : '#6b7280';
            }
            if (matchBtn) {
                matchBtn.style.borderColor = format === 'match' ? '#d4b896' : '#d1d5db';
                matchBtn.style.background = format === 'match' ? '#d4b896' : 'white';
                matchBtn.style.color = format === 'match' ? '#1e3a5f' : '#6b7280';
            }
        }
        
        // Auto-create teams based on number of players
        function autoCreateBestBallTeams() {
            if (!window.tempBestBallConfig) return;
            const players = tournamentData.players || [];
            const ppt = window.tempBestBallConfig.playersPerTeam;
            const numTeams = Math.floor(players.length / ppt);
            
            window.tempBestBallConfig.teams = [];
            for (let i = 0; i < numTeams; i++) {
                const team = [];
                for (let j = 0; j < ppt; j++) {
                    const playerIndex = i * ppt + j;
                    if (playerIndex < players.length) {
                        team.push(players[playerIndex].name);
                    }
                }
                window.tempBestBallConfig.teams.push(team);
            }
            
            renderBestBallTeams();
        }
        
        // Add a new team
        function addBestBallTeam() {
            if (!window.tempBestBallConfig) return;
            const ppt = window.tempBestBallConfig.playersPerTeam;
            const newTeam = Array(ppt).fill('');
            window.tempBestBallConfig.teams.push(newTeam);
            renderBestBallTeams();
        }
        
        // Remove a team
        function removeBestBallTeam(teamIndex) {
            if (!window.tempBestBallConfig) return;
            window.tempBestBallConfig.teams.splice(teamIndex, 1);
            renderBestBallTeams();
        }
        
        // Update a player in a team
        function updateBestBallTeamPlayer(teamIndex, playerSlot, playerName) {
            if (!window.tempBestBallConfig) return;
            window.tempBestBallConfig.teams[teamIndex][playerSlot] = playerName;
        }
        
        // Render teams in the modal
        function renderBestBallTeams() {
            const container = document.getElementById('bestBallTeamsContainer');
            if (!container || !window.tempBestBallConfig) return;
            
            const teams = window.tempBestBallConfig.teams;
            const ppt = window.tempBestBallConfig.playersPerTeam;
            const players = tournamentData.players || [];
            
            // Get list of already assigned players
            const assignedPlayers = new Set();
            teams.forEach(team => {
                team.forEach(name => {
                    if (name) assignedPlayers.add(name);
                });
            });
            
            container.innerHTML = teams.map((team, teamIdx) => {
                // Check if team is valid (has at least one player)
                const hasPlayers = team.some(name => name && name.trim() !== '');
                const borderColor = hasPlayers ? '#166534' : '#dc2626';
                const borderStyle = hasPlayers ? '2px solid #166534' : '2px dashed #dc2626';
                const bgColor = hasPlayers ? 'rgba(22, 101, 52, 0.05)' : 'rgba(220, 38, 38, 0.05)';
                const statusIcon = hasPlayers ? '✓' : '!';
                const statusColor = hasPlayers ? '#166534' : '#dc2626';
                
                // Build player dropdown options
                const playerOptions = players.map(p => {
                    const isAssigned = assignedPlayers.has(p.name);
                    const isInThisTeam = team.includes(p.name);
                    return `<option value="${p.name}" ${isAssigned && !isInThisTeam ? 'disabled style="color: #9ca3af;"' : ''}>${p.name}${isAssigned && !isInThisTeam ? ' (assigned)' : ''}</option>`;
                }).join('');
                
                // Build player slots
                const slots = [];
                for (let i = 0; i < ppt; i++) {
                    const selectedPlayer = team[i] || '';
                    const slotEmpty = !selectedPlayer;
                    slots.push(`
                        <select onchange="updateBestBallTeamPlayer(${teamIdx}, ${i}, this.value)" 
                            style="flex: 1; padding: 8px; border: 1px solid ${slotEmpty ? '#fca5a5' : '#d1d5db'}; border-radius: 6px; font-size: 13px; min-width: 0; background: ${slotEmpty ? '#fef2f2' : 'white'}; color: #1e3a5f;">
                            <option value="">Select Player</option>
                            ${playerOptions.replace(`value="${selectedPlayer}"`, `value="${selectedPlayer}" selected`)}
                        </select>
                    `);
                }
                
                return `
                    <div style="background: ${bgColor}; border: ${borderStyle}; border-radius: 8px; padding: 12px; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-size: 13px; font-weight: 700; color: #1e3a5f; display: flex; align-items: center; gap: 6px;">
                                <span style="width: 18px; height: 18px; border-radius: 50%; background: ${statusColor}; color: white; font-size: 11px; display: flex; align-items: center; justify-content: center; font-weight: bold;">${statusIcon}</span>
                                Team ${teamIdx + 1}
                            </span>
                            <button type="button" onclick="removeBestBallTeam(${teamIdx})" style="background: none; border: none; color: #a51c30; font-size: 16px; cursor: pointer; padding: 4px;">✕</button>
                        </div>
                        <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                            ${slots.join('')}
                        </div>
                        ${!hasPlayers ? '<div style="font-size: 11px; color: #dc2626; margin-top: 6px;">⚠️ Select at least one player</div>' : ''}
                    </div>
                `;
            }).join('');
            
            // Show summary of valid teams
            const validCount = teams.filter(team => team.some(name => name && name.trim() !== '')).length;
            const totalCount = teams.length;
            
            if (teams.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 16px; color: #64748b; font-size: 13px;">No teams created yet. Click "+ Add Team" to start.</div>';
            } else if (validCount < 2) {
                container.innerHTML += `<div style="text-align: center; padding: 8px; color: #dc2626; font-size: 12px; font-weight: 600;">Need at least 2 valid teams (currently ${validCount})</div>`;
            }
        }
        
        // Save config and show results
        function saveBestBallAndShowResults() {
            console.log('📊 saveBestBallAndShowResults called');
            
            if (!window.tempBestBallConfig) {
                console.log('❌ No tempBestBallConfig');
                showNotification('Error', 'No team configuration found');
                return;
            }
            
            // Validate teams have at least some players
            const validTeams = window.tempBestBallConfig.teams.filter(team => 
                team.some(name => name && name.trim() !== '')
            );
            
            console.log(`📊 Valid teams: ${validTeams.length} of ${window.tempBestBallConfig.teams.length}`);
            
            if (validTeams.length < 2) {
                showNotification('Incomplete Teams', `Need at least 2 teams with players assigned. You have ${validTeams.length}.`);
                return;
            }
            
            // Save config
            resultsBestBallConfig = { ...window.tempBestBallConfig, teams: validTeams };
            saveBestBallConfig(resultsBestBallConfig);
            
            // Close modal (without returning to tourney mode)
            document.getElementById('bestBallSetupModal')?.remove();
            window.tempBestBallConfig = null;
            
            currentBestBallView = true;
            currentResultsMode = 'sideGame';
            
            // Switch header to Side Game mode
            const tourneyHeaderRow = document.getElementById('resultsTourneyHeaderRow');
            const sideGameHeaderRow = document.getElementById('resultsSideGameHeaderRow');
            if (tourneyHeaderRow) tourneyHeaderRow.style.display = 'none';
            if (sideGameHeaderRow) sideGameHeaderRow.style.display = 'flex';
            
            // Hide game type dropdown
            const gameTypeSelect = document.getElementById('resultsGameType');
            if (gameTypeSelect) gameTypeSelect.style.display = 'none';
            
            // Update legacy toggle buttons (hidden but for state consistency)
            const tourneyBtn = document.getElementById('tourneyModeBtn');
            const sideGameBtn = document.getElementById('sideGameModeBtn');
            if (tourneyBtn && sideGameBtn) {
                tourneyBtn.style.background = 'transparent';
                tourneyBtn.style.color = '#64748b';
                sideGameBtn.style.background = '#166534';
                sideGameBtn.style.color = 'white';
            }
            
            // Update scoring method button color to green for side game
            updateScoringMethodButtonColors('green');
            
            console.log('📊 Calling updateResultsDisplay');
            updateResultsDisplay();
        }
        
        // Clear teams - clears team data and goes to setup page
        function clearBestBallTeams() {
            // Clear all Best Ball state
            resultsBestBallConfig = null;
            window.tempBestBallConfig = null;
            currentBestBallView = false;
            
            // Remove from localStorage
            const key = activeTournamentId ? `bestBall_${activeTournamentId}` : 'bestBall_local';
            localStorage.removeItem(key);
            
            // Close any existing modal
            document.getElementById('bestBallSetupModal')?.remove();
            
            showNotification('Cleared', 'Teams cleared');
            
            // Go to setup page to create new teams
            showResultsBestBallSetup();
        }
        
        // Clear teams on setup page - clears assignments but stays on setup
        function clearBestBallTeamsOnSetup() {
            // Clear temp config teams
            if (window.tempBestBallConfig) {
                window.tempBestBallConfig.teams = [];
            }
            
            // Remove from localStorage
            const key = activeTournamentId ? `bestBall_${activeTournamentId}` : 'bestBall_local';
            localStorage.removeItem(key);
            
            // Clear saved config
            resultsBestBallConfig = null;
            
            showNotification('Cleared', 'Team assignments cleared');
            
            // Re-render teams (will show empty)
            renderBestBallTeams();
        }
        
        // Edit existing Best Ball teams
        function editBestBallTeams() {
            showResultsBestBallSetup();
        }
        
        // Render Best Ball results
        function renderBestBallResults(container, config) {
            const { playersPerTeam, scoresPerHole, format, teams } = config;
            const players = tournamentData.players || [];
            const isNet = currentScoringMethod !== 'gross';
            const netMethod = currentScoringMethod === 'net' ? 'full' : 
                             currentScoringMethod === 'net18' ? '18max' : 
                             currentScoringMethod === 'netHalf' ? 'half' : 'full';
            
            // Build label
            let formatLabel = format === 'match' ? 'Match Play' : 'Stroke Play';
            let scoringLabel = isNet ? (currentScoringMethod === 'net18' ? 'Net (18 Max)' : 'Net') : 'Gross';
            let teamLabel = `${playersPerTeam}-Player, ${scoresPerHole} Best`;
            
            container.innerHTML = `
                <div style="text-align: center; margin-bottom: 12px;">
                    <span style="background: #d4b896; color: #1e3a5f; padding: 4px 12px; border-radius: 6px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">
                        Best Ball ${formatLabel} (${scoringLabel})
                    </span>
                    <div style="font-size: 11px; color: #64748b; margin-top: 4px;">${teamLabel}</div>
                </div>
            `;
            
            // Calculate team scores
            const teamResults = teams.map((team, teamIdx) => {
                // Get player objects for this team
                const teamPlayers = team.map(name => players.find(p => p.name === name)).filter(p => p);
                
                if (teamPlayers.length === 0) {
                    return { teamIdx, teamName: `Team ${teamIdx + 1}`, players: team, total: 0, holeScores: [], holesWon: 0, holesLost: 0, status: 'AS' };
                }
                
                // Calculate best ball score for each hole
                const holeScores = [];
                let total = 0;
                
                for (let holeIdx = 0; holeIdx < 18; holeIdx++) {
                    const holeData = courseData.holes[holeIdx];
                    const playerScores = teamPlayers.map(p => {
                        const gross = p.scores[holeIdx] || 0;
                        if (gross === 0) return 999;
                        
                        if (isNet) {
                            return getNetScore(gross, p.handicap, holeData.handicap, netMethod);
                        }
                        return gross;
                    }).filter(s => s < 999).sort((a, b) => a - b);
                    
                    // Take the best N scores for this hole
                    const bestScores = playerScores.slice(0, scoresPerHole);
                    const holeTotal = bestScores.reduce((sum, s) => sum + s, 0);
                    
                    holeScores.push({
                        scores: bestScores,
                        total: holeTotal,
                        par: holeData.par * scoresPerHole
                    });
                    
                    if (bestScores.length > 0) {
                        total += holeTotal;
                    }
                }
                
                return {
                    teamIdx,
                    teamName: `Team ${teamIdx + 1}`,
                    players: team.filter(n => n),
                    total,
                    holeScores,
                    holesWon: 0,
                    holesLost: 0,
                    status: 'AS'
                };
            });
            
            // Match Play: Calculate holes won/lost between teams
            if (format === 'match' && teamResults.length >= 2) {
                renderMatchPlayResults(container, teamResults);
            } else {
                // Stroke Play: Sort by total and display
                renderStrokePlayBestBallResults(container, teamResults);
            }
        }
        
        // Render Stroke Play Best Ball results
        function renderStrokePlayBestBallResults(container, teamResults) {
            // Sort by total (lowest first)
            const sortedTeams = [...teamResults].filter(t => t.total > 0).sort((a, b) => a.total - b.total);
            
            // Calculate total par for scoring type
            const scoresPerHole = resultsBestBallConfig?.scoresPerHole || 1;
            const totalPar = courseData.totalPar * scoresPerHole;
            
            sortedTeams.forEach((team, position) => {
                const medal = position === 0 ? '🏆' : position === 1 ? '🥈' : position === 2 ? '🥉' : `${position + 1}.`;
                const toPar = team.total - totalPar;
                const toParText = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : `${toPar}`);
                
                const div = document.createElement('div');
                div.style.cssText = 'background: white; border: 1px solid #e5e7eb; border-radius: 6px; padding: 14px; margin-bottom: 10px; animation: fadeIn 0.3s ease-out;';
                
                div.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: space-between;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: ${position < 3 ? '24px' : '16px'}; ${position >= 3 ? 'color: #64748b; font-weight: 700;' : ''}">${medal}</span>
                            <div>
                                <div style="font-weight: 700; color: #1e3a5f; font-size: 15px;">${team.teamName}</div>
                                <div style="font-size: 11px; color: #64748b;">${team.players.join(' & ')}</div>
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 20px; font-weight: 800; color: #1e293b;">${team.total}</div>
                            <div style="font-size: 12px; color: ${toPar < 0 ? '#166534' : toPar > 0 ? '#a51c30' : '#64748b'};">${toParText}</div>
                        </div>
                    </div>
                `;
                
                container.appendChild(div);
            });
            
            if (sortedTeams.length === 0) {
                container.innerHTML += '<div style="text-align: center; padding: 24px; color: #64748b;">No scores yet</div>';
            }
        }
        
        // Render Match Play results
        function renderMatchPlayResults(container, teamResults) {
            // For match play, we compare teams head to head on each hole
            // If more than 2 teams, we'll show all matchups
            
            if (teamResults.length === 2) {
                // Single match
                renderSingleMatchPlay(container, teamResults[0], teamResults[1]);
            } else {
                // Multiple teams - show round robin or bracket style
                container.innerHTML += `
                    <div style="font-size: 12px; color: #64748b; font-weight: 600; margin-bottom: 10px; text-transform: uppercase;">Team Matchups</div>
                `;
                
                // Show each pair
                for (let i = 0; i < teamResults.length; i++) {
                    for (let j = i + 1; j < teamResults.length; j++) {
                        renderSingleMatchPlay(container, teamResults[i], teamResults[j], true);
                    }
                }
            }
        }
        
        // Render a single match play matchup between two teams
        function renderSingleMatchPlay(container, team1, team2, compact = false) {
            // Calculate match play result
            let team1Up = 0;
            let holesPlayed = 0;
            let team1Wins = 0, team2Wins = 0, halved = 0;
            
            for (let holeIdx = 0; holeIdx < 18; holeIdx++) {
                const score1 = team1.holeScores[holeIdx];
                const score2 = team2.holeScores[holeIdx];
                
                // Only count holes where both teams have scores
                if (score1.scores.length > 0 && score2.scores.length > 0) {
                    holesPlayed++;
                    
                    if (score1.total < score2.total) {
                        team1Up++;
                        team1Wins++;
                    } else if (score2.total < score1.total) {
                        team1Up--;
                        team2Wins++;
                    } else {
                        halved++;
                    }
                }
            }
            
            // Determine match status
            const holesRemaining = 18 - holesPlayed;
            let status = '';
            let winner = null;
            let statusColor = '#64748b';
            
            if (holesPlayed === 0) {
                status = 'Not Started';
            } else if (Math.abs(team1Up) > holesRemaining) {
                // Match is over - one team can't catch up
                winner = team1Up > 0 ? team1 : team2;
                const margin = Math.abs(team1Up);
                status = `${margin}&${holesRemaining}`;
                statusColor = '#166534';
            } else if (holesPlayed === 18) {
                // All 18 played
                if (team1Up === 0) {
                    status = 'AS';
                    statusColor = '#f59e0b';
                } else {
                    winner = team1Up > 0 ? team1 : team2;
                    status = `${Math.abs(team1Up)}UP`;
                    statusColor = '#166534';
                }
            } else {
                // Match in progress
                if (team1Up === 0) {
                    status = 'AS';
                    statusColor = '#1e3a5f';
                } else {
                    const leader = team1Up > 0 ? team1 : team2;
                    status = `${Math.abs(team1Up)}UP`;
                    statusColor = '#1e3a5f';
                }
            }
            
            // Build the display
            const matchDiv = document.createElement('div');
            matchDiv.style.cssText = `background: white; border: 1px solid #e5e7eb; border-radius: 6px; padding: ${compact ? '12px' : '16px'}; margin-bottom: ${compact ? '10px' : '12px'};`;
            
            if (compact) {
                // Compact view for multiple matchups
                const leader = team1Up > 0 ? team1 : team1Up < 0 ? team2 : null;
                const loser = team1Up > 0 ? team2 : team1Up < 0 ? team1 : null;
                
                matchDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex: 1;">
                            <div style="font-weight: ${team1Up >= 0 ? '700' : '500'}; color: ${team1Up > 0 ? '#1e3a5f' : '#6b7280'}; font-size: 13px;">${team1.teamName}</div>
                            <div style="font-size: 10px; color: #64748b;">${team1.players.join(', ')}</div>
                        </div>
                        <div style="padding: 6px 12px; background: ${winner ? '#166534' : team1Up === 0 ? '#1e3a5f' : '#1e3a5f'}; color: white; border-radius: 8px; font-weight: 700; font-size: 14px;">
                            ${status}
                        </div>
                        <div style="flex: 1; text-align: right;">
                            <div style="font-weight: ${team1Up <= 0 ? '700' : '500'}; color: ${team1Up < 0 ? '#1e3a5f' : '#6b7280'}; font-size: 13px;">${team2.teamName}</div>
                            <div style="font-size: 10px; color: #64748b;">${team2.players.join(', ')}</div>
                        </div>
                    </div>
                `;
            } else {
                // Full view for single matchup
                matchDiv.innerHTML = `
                    <div style="text-align: center; margin-bottom: 12px;">
                        <div style="font-size: 11px; color: #1e3a5f; font-weight: 600; text-transform: uppercase; margin-bottom: 4px;">Match Play</div>
                        <div style="font-size: 32px; font-weight: 800; color: #1e3a5f;">${status}</div>
                        ${winner ? `<div style="font-size: 13px; color: #166534; font-weight: 600;">${winner.teamName} Wins!</div>` : ''}
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; gap: 12px;">
                        <div style="flex: 1; text-align: center; padding: 12px; background: ${team1Up > 0 ? 'white' : 'white'}; border: 2px solid ${team1Up > 0 ? '#166534' : '#e5e7eb'}; border-radius: 6px;">
                            <div style="font-weight: 700; color: #1e3a5f; font-size: 15px;">${team1.teamName}</div>
                            <div style="font-size: 11px; color: #64748b; margin-top: 2px;">${team1.players.join(' & ')}</div>
                            <div style="font-size: 12px; color: #64748b; margin-top: 6px;">${team1Wins}W · ${halved}H</div>
                        </div>
                        
                        <div style="font-size: 14px; font-weight: 600; color: #9ca3af;">VS</div>
                        
                        <div style="flex: 1; text-align: center; padding: 12px; background: ${team1Up < 0 ? 'white' : 'white'}; border: 2px solid ${team1Up < 0 ? '#166534' : '#e5e7eb'}; border-radius: 6px;">
                            <div style="font-weight: 700; color: #1e3a5f; font-size: 15px;">${team2.teamName}</div>
                            <div style="font-size: 11px; color: #64748b; margin-top: 2px;">${team2.players.join(' & ')}</div>
                            <div style="font-size: 12px; color: #64748b; margin-top: 6px;">${team2Wins}W · ${halved}H</div>
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin-top: 12px; font-size: 11px; color: #64748b;">
                        ${holesPlayed} holes played · ${holesRemaining} remaining
                    </div>
                `;
            }
            
            container.appendChild(matchDiv);
        }

        function updateResultsGameType() {
            const newGameType = document.getElementById('resultsGameType').value;
            
            // Update scoring method buttons
            updateScoringMethodButtons();
            
            // Update results display with new game type
            updateResultsDisplay(newGameType);
        }
        
        // Refresh results data from Firebase
        async function refreshResultsData() {
            if (!activeTournamentId) {
                // Single device mode - just re-render
                updateResultsDisplay();
                showNotification('Refreshed', 'Results updated');
                return;
            }
            
            try {
                // Fetch latest from Firebase
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                
                if (tournamentDoc.exists) {
                    const tournament = tournamentDoc.data();
                    updateLocalTournamentState(tournament);
                    updateResultsDisplay();
                    showNotification('Refreshed', 'Latest scores loaded');
                } else {
                    showNotification('Error', 'Tournament not found');
                }
            } catch (error) {
                console.error('Error refreshing results:', error);
                showNotification('Error', 'Failed to refresh');
            }
        }

        function updateResultsDisplay(displayGameType) {
            const baseGameType = displayGameType || document.getElementById('resultsGameType')?.value || tournamentData.gameType;
            const container = document.getElementById('resultsContent');
            
            // Update leaderboard status text
            const statusText = document.getElementById('leaderboardStatusText');
            if (statusText) {
                if (currentBestBallView && resultsBestBallConfig) {
                    // Show specific side game name
                    const format = resultsBestBallConfig.format === 'match' ? 'Match Play' : 'Stroke Play';
                    const players = resultsBestBallConfig.playersPerTeam;
                    const scores = resultsBestBallConfig.scoresPerHole;
                    statusText.textContent = `Best Ball ${format} (${players}-Player, ${scores} Best)`;
                } else {
                    // Show tournament name
                    statusText.textContent = tournamentData.name || 'Tournament';
                }
            }
            
            // Handle Best Ball view separately
            if (currentBestBallView && resultsBestBallConfig) {
                renderBestBallResults(container, resultsBestBallConfig);
                return;
            }
            
            // Determine display label based on game type and scoring method
            let displayLabel = baseGameType;
            if (baseGameType === 'Stroke Play' || baseGameType === 'Footlong' || baseGameType === 'Nassau') {
                if (currentScoringMethod === 'net') displayLabel = baseGameType + ' Net';
                else if (currentScoringMethod === 'net18') displayLabel = baseGameType + ' Net (18 Max)';
                else displayLabel = baseGameType + ' Gross';
            } else if (baseGameType === 'Skins') {
                if (currentScoringMethod === 'net') displayLabel = 'Net Skins (Full Hcp)';
                else if (currentScoringMethod === 'net18') displayLabel = 'Net Skins (18 Max)';
                else if (currentScoringMethod === 'netHalf') displayLabel = 'Net Skins (1/2 Pop)';
                else displayLabel = 'Gross Skins';
            }
            
            container.innerHTML = `<div style="text-align: center; margin-bottom: 12px;">
                <span style="background: #d4b896; color: #1e3a5f; padding: 4px 12px; border-radius: 4px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">${displayLabel}</span>
            </div>`;
            
            // Filter players based on currentResultsFilter
            let playersToDisplay = tournamentData.players || [];
            if (currentResultsFilter === 'mine' && tournamentMode === 'multi') {
                loadPlayerOrder();
                playersToDisplay = playersToDisplay.filter(p => 
                    isClaimedByMe(p) || playerOrder.watching.includes(p.name)
                );
            }
            
            // Map to internal game type for processing
            let gameType = baseGameType;
            
            // Handle Stroke Play with scoring method
            if (baseGameType === 'Stroke Play') {
                if (currentScoringMethod === 'gross') {
                    gameType = 'Stroke Play Gross';
                } else {
                    gameType = 'Stroke Play Net';
                }
            }
            
            // Handle Skins with scoring method
            if (baseGameType === 'Skins') {
                if (currentScoringMethod === 'gross') gameType = 'Gross Skins';
                else if (currentScoringMethod === 'net') gameType = 'Net Skins (Full Hcp)';
                else if (currentScoringMethod === 'net18') gameType = 'Net Skins (18 Max)';
                else if (currentScoringMethod === 'netHalf') gameType = 'Net Skins (1/2 Pop)';
            }
            
            // Get net method for calculations
            const netMethod = currentScoringMethod === 'net' ? 'full' : 
                             currentScoringMethod === 'net18' ? '18max' : 
                             currentScoringMethod === 'netHalf' ? 'half' : 'full';

            // Stroke Play Gross
            if (gameType === 'Stroke Play Gross') {
                renderStrokePlayResults(container, playersToDisplay, 'gross');
            }

            // Stroke Play Net
            else if (gameType === 'Stroke Play Net') {
                renderStrokePlayResults(container, playersToDisplay, netMethod);
            }
            
            // Footlong - Front 9 and Back 9 winners
            else if (baseGameType === 'Footlong') {
                renderFootlongResults(container, playersToDisplay, currentScoringMethod === 'gross' ? 'gross' : netMethod);
            }
            
            // Nassau - Front 9, Back 9, and Overall winners
            else if (baseGameType === 'Nassau') {
                renderNassauResults(container, playersToDisplay, currentScoringMethod === 'gross' ? 'gross' : netMethod);
            }

            // Skins Games
            else if (gameType.includes('Skins')) {
                const method = gameType === 'Gross Skins' ? 'gross' : 
                              gameType === 'Net Skins (Full Hcp)' ? 'full' :
                              gameType === 'Net Skins (18 Max)' ? '18max' : 'half';
                
                renderSkinsResults(container, playersToDisplay, method);
            }

            // Stableford
            else if (gameType === 'Stableford') {
                renderStablefordResults(container, playersToDisplay, false, currentScoringMethod === 'gross' ? 'gross' : netMethod);
            }

            // Stableford (Modified)
            else if (gameType === 'Stableford (Modified)') {
                renderStablefordResults(container, playersToDisplay, true, currentScoringMethod === 'gross' ? 'gross' : netMethod);
            }

            // Best Ball Games - for now just show message
            else if (gameType === 'Best Ball' || gameType.includes('Best Ball')) {
                container.innerHTML += '<div style="text-align: center; padding: 24px; color: #64748b;">Best Ball results - use the Best Ball button below to configure teams</div>';
            }
        }
        
        // Render Stroke Play results
        function renderStrokePlayResults(container, players, method) {
            const isNet = method !== 'gross';
            
            const results = players.map((player, idx) => {
                let total = 0;
                player.scores.forEach((score, holeIdx) => {
                    if (score > 0) {
                        if (isNet) {
                            total += getNetScore(score, player.handicap, courseData.holes[holeIdx].handicap, method);
                        } else {
                            total += score;
                        }
                    }
                });
                const toPar = total - courseData.totalPar;
                return { player, total, toPar, index: idx };
            }).filter(r => r.total > 0);

            // Sort by total, then by tiebreaker on hardest holes
            results.sort((a, b) => {
                if (a.total !== b.total) return a.total - b.total;
                
                for (let hcp = 1; hcp <= 18; hcp++) {
                    const holeIdx = courseData.holes.findIndex(h => h.handicap === hcp);
                    let scoreA = a.player.scores[holeIdx] || 0;
                    let scoreB = b.player.scores[holeIdx] || 0;
                    if (isNet) {
                        scoreA = getNetScore(scoreA, a.player.handicap, hcp, method);
                        scoreB = getNetScore(scoreB, b.player.handicap, hcp, method);
                    }
                    if (scoreA !== scoreB) return scoreA - scoreB;
                }
                return 0;
            });

            results.forEach((r, position) => {
                const medal = position === 0 ? '🥇' : position === 1 ? '🥈' : position === 2 ? '🥉' : `${position + 1}.`;
                const toParText = r.toPar === 0 ? 'E' : (r.toPar > 0 ? `+${r.toPar}` : `${r.toPar}`);
                container.appendChild(createPlayerResultCard(medal, r.player.name, r.total, toParText, r.player.handicap, isNet ? 'Net' : 'Gross'));
            });
        }
        
        // Render Footlong results (Front 9 + Back 9 winners)
        function renderFootlongResults(container, players, method) {
            const isNet = method !== 'gross';
            
            // Calculate front 9 and back 9 totals
            const results = players.map((player, idx) => {
                let front9 = 0, back9 = 0;
                
                player.scores.forEach((score, holeIdx) => {
                    if (score > 0) {
                        const netScore = isNet ? 
                            getNetScore(score, player.handicap, courseData.holes[holeIdx].handicap, method) : score;
                        
                        if (holeIdx < 9) front9 += netScore;
                        else back9 += netScore;
                    }
                });
                
                return { player, front9, back9, index: idx };
            });
            
            // Front 9 Winner
            const front9Results = results.filter(r => r.front9 > 0).sort((a, b) => {
                if (a.front9 !== b.front9) return a.front9 - b.front9;
                return footlongTiebreaker(a, b, 0, 8, isNet, method); // Holes 0-8 (front 9)
            });
            
            // Back 9 Winner  
            const back9Results = results.filter(r => r.back9 > 0).sort((a, b) => {
                if (a.back9 !== b.back9) return a.back9 - b.back9;
                return footlongTiebreaker(a, b, 9, 17, isNet, method); // Holes 9-17 (back 9)
            });
            
            // Front 9 par
            const front9Par = courseData.holes.slice(0, 9).reduce((sum, h) => sum + h.par, 0);
            const back9Par = courseData.holes.slice(9, 18).reduce((sum, h) => sum + h.par, 0);
            
            // Display Front 9 Winner
            container.innerHTML += `
                <div style="background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%); border: 2px solid #166534; border-radius: 6px; padding: 16px; margin-bottom: 12px;">
                    <div style="font-size: 13px; color: #166534; font-weight: 700; margin-bottom: 8px; text-transform: uppercase;">🏆 Front 9 (OUT) Winner</div>
                    ${front9Results.length > 0 ? `
                        <div style="font-size: 20px; font-weight: 800; color: #166534;">${front9Results[0].player.name}</div>
                        <div style="font-size: 14px; color: #047857;">${front9Results[0].front9} (${front9Results[0].front9 - front9Par >= 0 ? '+' : ''}${front9Results[0].front9 - front9Par})</div>
                    ` : '<div style="color: #6b7280;">No scores yet</div>'}
                </div>
            `;
            
            // Display Back 9 Winner
            container.innerHTML += `
                <div style="background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%); border: 2px solid #1e3a5f; border-radius: 6px; padding: 16px; margin-bottom: 12px;">
                    <div style="font-size: 13px; color: #1e3a5f; font-weight: 700; margin-bottom: 8px; text-transform: uppercase;">🏆 Back 9 (IN) Winner</div>
                    ${back9Results.length > 0 ? `
                        <div style="font-size: 20px; font-weight: 800; color: #1e3a5f;">${back9Results[0].player.name}</div>
                        <div style="font-size: 14px; color: #1e3a5f;">${back9Results[0].back9} (${back9Results[0].back9 - back9Par >= 0 ? '+' : ''}${back9Results[0].back9 - back9Par})</div>
                    ` : '<div style="color: #6b7280;">No scores yet</div>'}
                </div>
            `;
            
            // Show all players breakdown
            container.innerHTML += `<div style="font-size: 12px; color: #64748b; font-weight: 600; margin: 16px 0 8px 0; text-transform: uppercase;">All Players</div>`;
            
            results.filter(r => r.front9 > 0 || r.back9 > 0).forEach(r => {
                const div = document.createElement('div');
                div.style.cssText = 'display: flex; justify-content: space-between; padding: 10px 12px; background: #f8fafc; border-radius: 8px; margin-bottom: 6px;';
                div.innerHTML = `
                    <span style="font-weight: 600; color: #1e293b;">${r.player.name}</span>
                    <span style="color: #64748b;">OUT: <strong>${r.front9 || '-'}</strong> | IN: <strong>${r.back9 || '-'}</strong></span>
                `;
                container.appendChild(div);
            });
        }
        
        // Footlong tiebreaker - compare hardest holes within the 9
        function footlongTiebreaker(a, b, startHole, endHole, isNet, method) {
            // Get holes in this range sorted by handicap (hardest first)
            const holesInRange = courseData.holes
                .map((h, idx) => ({ ...h, idx }))
                .filter(h => h.idx >= startHole && h.idx <= endHole)
                .sort((x, y) => x.handicap - y.handicap);
            
            for (const hole of holesInRange) {
                let scoreA = a.player.scores[hole.idx] || 0;
                let scoreB = b.player.scores[hole.idx] || 0;
                
                if (isNet) {
                    scoreA = scoreA > 0 ? getNetScore(scoreA, a.player.handicap, hole.handicap, method) : 0;
                    scoreB = scoreB > 0 ? getNetScore(scoreB, b.player.handicap, hole.handicap, method) : 0;
                }
                
                if (scoreA !== scoreB && scoreA > 0 && scoreB > 0) {
                    return scoreA - scoreB;
                }
            }
            return 0;
        }
        
        // Render Nassau results (Front 9 + Back 9 + Overall winners)
        function renderNassauResults(container, players, method) {
            const isNet = method !== 'gross';
            
            // Calculate totals
            const results = players.map((player, idx) => {
                let front9 = 0, back9 = 0, total = 0;
                
                player.scores.forEach((score, holeIdx) => {
                    if (score > 0) {
                        const netScore = isNet ? 
                            getNetScore(score, player.handicap, courseData.holes[holeIdx].handicap, method) : score;
                        
                        if (holeIdx < 9) front9 += netScore;
                        else back9 += netScore;
                        total += netScore;
                    }
                });
                
                return { player, front9, back9, total, index: idx };
            });
            
            // Sort for each category
            const front9Results = results.filter(r => r.front9 > 0).sort((a, b) => {
                if (a.front9 !== b.front9) return a.front9 - b.front9;
                return footlongTiebreaker(a, b, 0, 8, isNet, method);
            });
            
            const back9Results = results.filter(r => r.back9 > 0).sort((a, b) => {
                if (a.back9 !== b.back9) return a.back9 - b.back9;
                return footlongTiebreaker(a, b, 9, 17, isNet, method);
            });
            
            const overallResults = results.filter(r => r.total > 0).sort((a, b) => {
                if (a.total !== b.total) return a.total - b.total;
                // Overall tiebreaker: all 18 holes by handicap
                for (let hcp = 1; hcp <= 18; hcp++) {
                    const holeIdx = courseData.holes.findIndex(h => h.handicap === hcp);
                    let scoreA = a.player.scores[holeIdx] || 0;
                    let scoreB = b.player.scores[holeIdx] || 0;
                    if (isNet) {
                        scoreA = scoreA > 0 ? getNetScore(scoreA, a.player.handicap, hcp, method) : 0;
                        scoreB = scoreB > 0 ? getNetScore(scoreB, b.player.handicap, hcp, method) : 0;
                    }
                    if (scoreA !== scoreB && scoreA > 0 && scoreB > 0) return scoreA - scoreB;
                }
                return 0;
            });
            
            const front9Par = courseData.holes.slice(0, 9).reduce((sum, h) => sum + h.par, 0);
            const back9Par = courseData.holes.slice(9, 18).reduce((sum, h) => sum + h.par, 0);
            
            // Display winners
            container.innerHTML += `
                <div style="background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%); border: 2px solid #166534; border-radius: 6px; padding: 14px; margin-bottom: 10px;">
                    <div style="font-size: 12px; color: #166534; font-weight: 700; margin-bottom: 6px; text-transform: uppercase;">🏆 Front 9</div>
                    ${front9Results.length > 0 ? `
                        <div style="font-size: 18px; font-weight: 800; color: #166534;">${front9Results[0].player.name} <span style="font-size: 14px; font-weight: 600;">(${front9Results[0].front9})</span></div>
                    ` : '<div style="color: #6b7280;">-</div>'}
                </div>
                
                <div style="background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%); border: 2px solid #1e3a5f; border-radius: 6px; padding: 14px; margin-bottom: 10px;">
                    <div style="font-size: 12px; color: #1e3a5f; font-weight: 700; margin-bottom: 6px; text-transform: uppercase;">🏆 Back 9</div>
                    ${back9Results.length > 0 ? `
                        <div style="font-size: 18px; font-weight: 800; color: #1e3a5f;">${back9Results[0].player.name} <span style="font-size: 14px; font-weight: 600;">(${back9Results[0].back9})</span></div>
                    ` : '<div style="color: #6b7280;">-</div>'}
                </div>
                
                <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border: 2px solid #f59e0b; border-radius: 6px; padding: 14px; margin-bottom: 10px;">
                    <div style="font-size: 12px; color: #92400e; font-weight: 700; margin-bottom: 6px; text-transform: uppercase;">🏆 Overall 18</div>
                    ${overallResults.length > 0 ? `
                        <div style="font-size: 18px; font-weight: 800; color: #92400e;">${overallResults[0].player.name} <span style="font-size: 14px; font-weight: 600;">(${overallResults[0].total})</span></div>
                    ` : '<div style="color: #6b7280;">-</div>'}
                </div>
            `;
            
            // All players breakdown
            container.innerHTML += `<div style="font-size: 12px; color: #64748b; font-weight: 600; margin: 12px 0 8px 0; text-transform: uppercase;">All Players</div>`;
            
            results.filter(r => r.total > 0).sort((a, b) => a.total - b.total).forEach(r => {
                const div = document.createElement('div');
                div.style.cssText = 'display: flex; justify-content: space-between; padding: 10px 12px; background: #f8fafc; border-radius: 8px; margin-bottom: 6px; font-size: 13px;';
                div.innerHTML = `
                    <span style="font-weight: 600; color: #1e293b;">${r.player.name}</span>
                    <span style="color: #64748b;">OUT: <strong>${r.front9 || '-'}</strong> | IN: <strong>${r.back9 || '-'}</strong> | TOT: <strong>${r.total || '-'}</strong></span>
                `;
                container.appendChild(div);
            });
        }
        
        // Render Skins results
        function renderSkinsResults(container, players, method) {
            const useHalf = method === 'half';
            const skinWinners = {};
            const skinDetails = {}; // Now stores {hole: number, score: number}[]
            
            players.forEach((p, idx) => {
                skinWinners[idx] = 0;
                skinDetails[idx] = [];
            });
            
            for (let holeIdx = 0; holeIdx < 18; holeIdx++) {
                const holeScores = players.map((player, pIdx) => {
                    const gross = player.scores[holeIdx];
                    if (!gross || gross === 0) return { pIdx, score: 999, gross: 0 };
                    
                    let score;
                    if (method === 'gross') {
                        score = gross;
                    } else {
                        score = getNetScore(gross, player.handicap, courseData.holes[holeIdx].handicap, method);
                        // For half method, don't round - keep as decimal
                    }
                    return { pIdx, score, gross };
                }).filter(s => s.score < 999);
                
                if (holeScores.length === 0) continue;
                
                const minScore = Math.min(...holeScores.map(s => s.score));
                const winners = holeScores.filter(s => s.score === minScore);
                
                if (winners.length === 1) {
                    skinWinners[winners[0].pIdx]++;
                    // Store hole number AND winning score
                    skinDetails[winners[0].pIdx].push({
                        hole: holeIdx + 1,
                        score: winners[0].score
                    });
                }
            }
            
            // Sort by skins won
            const results = Object.entries(skinWinners)
                .map(([idx, skins]) => ({ 
                    player: players[parseInt(idx)], 
                    skins, 
                    holes: skinDetails[parseInt(idx)] 
                }))
                .filter(r => r.skins > 0)
                .sort((a, b) => b.skins - a.skins);
            
            if (results.length === 0) {
                container.innerHTML += '<div style="text-align: center; padding: 24px; color: #64748b;">No skins won yet</div>';
                return;
            }
            
            results.forEach((r, position) => {
                const medal = position === 0 ? '🥇' : position === 1 ? '🥈' : position === 2 ? '🥉' : `${position + 1}.`;
                // Format holes with scores: "Holes: 1(4), 2(3)" - holes/numbers blue, scores gray
                let holesText = '';
                if (r.holes.length > 0) {
                    const holesList = r.holes.map(h => 
                        `<span style="color: #1e3a5f; font-weight: 600;">${h.hole}</span><span style="color: #6b7280;">(${h.score})</span>`
                    ).join('<span style="color: #1e3a5f;">, </span>');
                    holesText = `<span style="color: #1e3a5f; font-weight: 600;">Holes: </span>${holesList}`;
                }
                
                const div = document.createElement('div');
                div.className = 'results-player card-shadow';
                div.style.animation = 'fadeIn 0.3s ease-out';
                
                let rankHtml = medal === '🥇' ? '<span style="font-size: 28px; margin-right: 10px;">🏆</span>' :
                              medal === '🥈' ? '<span style="font-size: 24px; margin-right: 10px;">🥈</span>' :
                              medal === '🥉' ? '<span style="font-size: 22px; margin-right: 10px;">🥉</span>' :
                              `<span style="font-weight: 700; font-size: 16px; color: #64748b; margin-right: 10px;">${medal}</span>`;
                
                div.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px 14px;">
                        <div style="display: flex; align-items: center; flex: 1; min-width: 0;">
                            ${rankHtml}
                            <div>
                                <div style="color: #1e293b; font-weight: 600; font-size: 15px;">${r.player.name}</div>
                                <div style="font-size: 11px;">${holesText}</div>
                            </div>
                        </div>
                        <div style="font-size: 22px; font-weight: 700; color: #166534;">${r.skins} <span style="font-size: 12px; color: #6b7280;">skin${r.skins !== 1 ? 's' : ''}</span></div>
                    </div>
                `;
                container.appendChild(div);
            });
        }
        
        // Render Stableford results
        function renderStablefordResults(container, players, isModified, method) {
            const isNet = method !== 'gross';
            
            const results = players.map((player, idx) => {
                let points = 0;
                
                player.scores.forEach((score, holeIdx) => {
                    if (score > 0) {
                        const par = courseData.holes[holeIdx].par;
                        let effectiveScore = score;
                        
                        if (isNet) {
                            effectiveScore = getNetScore(score, player.handicap, courseData.holes[holeIdx].handicap, method);
                        }
                        
                        const diff = effectiveScore - par;
                        
                        if (isModified) {
                            // Modified Stableford (PGA style)
                            if (diff <= -3) points += 8;      // Albatross or better
                            else if (diff === -2) points += 5; // Eagle
                            else if (diff === -1) points += 2; // Birdie
                            else if (diff === 0) points += 0;  // Par
                            else if (diff === 1) points -= 1;  // Bogey
                            else points -= 3;                   // Double or worse
                        } else {
                            // Standard Stableford
                            if (diff <= -3) points += 5;       // Albatross or better
                            else if (diff === -2) points += 4; // Eagle
                            else if (diff === -1) points += 3; // Birdie
                            else if (diff === 0) points += 2;  // Par
                            else if (diff === 1) points += 1;  // Bogey
                            else points += 0;                   // Double or worse
                        }
                    }
                });
                
                return { player, points, index: idx };
            }).filter(r => r.points !== 0 || players.some(p => p.scores.some(s => s > 0)));
            
            // Sort by points (highest first for Stableford)
            results.sort((a, b) => b.points - a.points);
            
            results.forEach((r, position) => {
                const medal = position === 0 ? '🥇' : position === 1 ? '🥈' : position === 2 ? '🥉' : `${position + 1}.`;
                container.appendChild(createPlayerResultCard(medal, r.player.name, r.points, 'pts', r.player.handicap, isNet ? 'Net' : 'Gross'));
            });
        }

        function createPlayerResultCard(medal, name, score, toPar, handicap, scoreType = 'Gross') {
            const div = document.createElement('div');
            div.style.cssText = 'background: white; border: 1px solid #e5e7eb; border-radius: 6px; margin-bottom: 6px;';
            
            // Check if scorecard is signed
            const isSigned = isScorecardSigned(name);
            const signedIndicator = isSigned ? '<span style="color: #166534; font-size: 14px; margin-left: 6px;" title="Scorecard signed">✓</span>' : '';
            
            // Handicap display in smaller gray font
            const hcpDisplay = handicap !== 0 ? `<span style="color: #6b7280; font-size: 13px; font-weight: 500; margin-left: 6px;">(${handicap > 0 ? handicap : '+' + Math.abs(handicap)})</span>` : '';
            
            // Medal/rank display
            let rankHtml = '';
            if (medal === '🥇') {
                rankHtml = '<span style="font-size: 24px; margin-right: 10px;">🏆</span>';
            } else if (medal === '🥈') {
                rankHtml = '<span style="font-size: 22px; margin-right: 10px;">🥈</span>';
            } else if (medal === '🥉') {
                rankHtml = '<span style="font-size: 20px; margin-right: 10px;">🥉</span>';
            } else {
                rankHtml = `<span style="font-weight: 700; font-size: 15px; color: #64748b; margin-right: 10px; min-width: 24px;">${medal}</span>`;
            }
            
            div.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px 14px;">
                    <div style="display: flex; align-items: center; flex: 1; min-width: 0;">
                        ${rankHtml}
                        <span style="color: #1e3a5f; font-weight: 600; font-size: 14px;">${name}</span>${hcpDisplay}${signedIndicator}
                    </div>
                    <div style="font-size: 17px; font-weight: 700; color: #1e293b; white-space: nowrap; margin-left: 12px;">${score}</div>
                </div>
            `;
            return div;
        }

        // New round - with custom confirmation dialog
        function confirmNewRound() {
            const modal = document.createElement('div');
            modal.id = 'newRoundConfirmModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 24px; max-width: 340px; width: 100%; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 12px;">⚠️</div>
                    <h2 style="color: #a51c30; margin-bottom: 8px; font-size: 20px;">End Current Round?</h2>
                    <p style="color: #64748b; margin-bottom: 20px; font-size: 14px;">
                        All current scores will be cleared. This cannot be undone.
                    </p>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="executeNewRound()" style="padding: 14px; background: #a51c30; color: white; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            ✓ Confirm New Round
                        </button>
                        <button onclick="saveAndDismissNewRound()" style="padding: 14px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            💾 Save Backup First
                        </button>
                        <button onclick="document.getElementById('newRoundConfirmModal').remove()" style="padding: 14px; background: #e2e8f0; color: #64748b; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function executeNewRound() {
            document.getElementById('newRoundConfirmModal')?.remove();
            newRound();
        }
        
        function saveAndDismissNewRound() {
            document.getElementById('newRoundConfirmModal')?.remove();
            saveTournamentFile();
            showNotification('Saved!', 'Backup downloaded. Tap Finish again to start new round.');
        }

        function newRound() {
            localStorage.removeItem('indianHillsScoring');
            tournamentData = { id: '', date: '', gameType: '', course: '', players: [], teams: [] };
            document.getElementById('tournamentDate').value = ''; // Clear date
            
            // Reset player list to default 1
            const playerList = document.getElementById('playerList');
            playerList.innerHTML = `
                <div class="player-row-wrapper">
                    <div class="player-row-delete" onclick="removePlayer(1)">Delete</div>
                    <div class="player-row" data-player="1">
                        <input type="text" class="player-name-input" placeholder="Player Name" id="player1">
                        <input type="text" class="player-hcp-input" placeholder="H.I." id="hcp1" pattern="-?[0-9.]*" inputmode="decimal" oninput="calculatePlayingHandicap(1)">
                        <input type="text" class="player-ph-input" placeholder="P.H." id="ph1" pattern="-?[0-9]*" inputmode="numeric">
                    </div>
                </div>
            `;
            
            currentPlayerCount = 1;
            nextPlayerId = 2;
            document.getElementById('addPlayerBtn').disabled = false;
            document.getElementById('addPlayerBtn').innerHTML = '<span style="font-size: 16px; font-weight: 700;">+</span> Add Player';
            
            // Reset course and game type selection to directives
            document.getElementById('courseSelect').value = '';
            document.getElementById('gameType').value = '';
            courseData = null;
            
            showPage('setupPage');
        }

        // Load saved data on startup
        window.addEventListener('load', () => {
            // Delay to ensure DOM and Firebase are ready
            setTimeout(() => {
                console.log('🚀 Window load - starting app...');
                
                // ALWAYS start at Host Home page
                // Setup page is ONLY shown when user clicks "New Tournament"
                
                const savedData = localStorage.getItem('indianHillsScoring');
                if (savedData) {
                    try {
                        const data = JSON.parse(savedData);
                        const savedTournamentId = data._activeTournamentId;
                        const savedMode = data._tournamentMode;
                        const savedIsHost = data._isHost;
                        const hasPlayers = data.players && data.players.length > 0;
                        
                        console.log('🔍 Saved data found:', { savedTournamentId, savedMode, savedIsHost, hasPlayers });
                        
                        // Restore state from saved data
                        if (savedTournamentId) {
                            activeTournamentId = savedTournamentId;
                            tournamentMode = savedMode || 'multi';
                            isHost = savedIsHost !== false; // Default to true unless explicitly false
                            hasJoinedTournament = true;
                            
                            // Load tournament data (exclude metadata)
                            const metadataKeys = ['_activeTournamentId', '_tournamentMode', '_isHost', '_hostForTournament', 
                                                '_hasJoinedTournament', '_hostViewMode', '_scoreTimestamps', '_deletedPlayers', '_lastSaved'];
                            const dataCopy = JSON.parse(savedData);
                            metadataKeys.forEach(key => delete dataCopy[key]);
                            tournamentData = dataCopy;
                            
                            // Restore course data
                            courseData = courses[tournamentData.course] || customCourses[tournamentData.course];
                            
                            // Subscribe to Firebase
                            setTimeout(() => subscribToTournamentUpdates(activeTournamentId), 500);
                        }
                        
                        // Check if this is a guest (not host)
                        if (savedTournamentId && savedIsHost === false && data._hasJoinedTournament) {
                            console.log('🏠 Guest detected - navigating to Guest Home');
                            showGuestHomePage();
                            return;
                        }
                    } catch (e) {
                        console.error('Error parsing saved data:', e);
                    }
                }
                
                // ALWAYS go to Host Home - it handles empty state gracefully
                console.log('🏠 Navigating to Host Home');
                updateHostHomePage();
                showPage('hostHomePage');
                
            }, 300);
        });

        // Prevent accidental page refresh
        // Prevent accidental page refresh/close when there's data
        window.addEventListener('beforeunload', (e) => {
            // Force save to localStorage before leaving
            if (tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                saveToLocalStorage();
            }
            
            const hasData = localStorage.getItem('indianHillsScoring');
            const hasPlayers = tournamentData && tournamentData.players && tournamentData.players.length > 0;
            
            if (hasData || hasPlayers) {
                const message = 'You have an active round in progress. Leaving will lose unsaved data.';
                e.preventDefault();
                e.returnValue = message; // For Chrome
                return message; // For other browsers
            }
        });
        
        // iOS Safari specific - save when app goes to background or tab loses focus
        // These events are more reliable on iOS than beforeunload
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                console.log('📱 Page hidden - emergency save triggered');
                if (tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                    saveToLocalStorage();
                }
            } else if (document.visibilityState === 'visible') {
                // CRITICAL FIX: Reconnect to Firebase when app wakes up
                console.log('📱 Page visible - checking Firebase connection...');
                if (tournamentMode === 'multi' && activeTournamentId) {
                    console.log('🔄 Resubscribing to Firebase after wake...');
                    // Small delay to let network reconnect
                    setTimeout(() => {
                        subscribToTournamentUpdates(activeTournamentId);
                        console.log('✅ Firebase resubscription triggered');
                    }, 500);
                }
            }
        });
        
        // Additional iOS Safari handler - pagehide is more reliable than beforeunload
        window.addEventListener('pagehide', () => {
            console.log('📱 Page hide - emergency save triggered');
            if (tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                saveToLocalStorage();
            }
        });

        // Universal button handler for iOS compatibility
        // This uses event delegation on the document level
        function handleButtonClick(e) {
            let target = e.target;
            
            // Find button if clicked on emoji or text inside button
            while (target && target !== document.body) {
                if (target.tagName === 'BUTTON' && target.hasAttribute('data-action')) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const action = target.getAttribute('data-action');
                    
                    // Execute the corresponding function
                    try {
                        switch(action) {
                            case 'confirmBackToSetup':
                                confirmBackToSetup();
                                break;
                            case 'finishRound':
                                finishRound();
                                break;
                            case 'shareResults':
                                shareResults();
                                break;
                            case 'exportToCsv':
                                exportToCsv();
                                break;
                            case 'printScorecard':
                                printScorecard();
                                break;
                            case 'backToScoring':
                                backToScoring();
                                break;
                            case 'confirmNewRound':
                                confirmNewRound();
                                break;
                            default:
                        }
                    } catch (err) {
                        console.error('Error executing button action:', err);
                        alert('Button error: ' + err.message);
                    }
                    
                    return false;
                }
                target = target.parentElement;
            }
        }

        // Attach to both click and touchend for maximum compatibility
        document.addEventListener('click', handleButtonClick, true);
        document.addEventListener('touchend', handleButtonClick, true);

        // Print Scorecard Function
        // Share results as text
        function shareResults() {
            let shareText = `⛳ ${courseData.name} - ${formatDateDisplay(tournamentData.date)}\n`;
            shareText += `Game: ${tournamentData.gameType}\n\n`;
            shareText += `📊 FINAL RESULTS\n`;
            shareText += `${'='.repeat(40)}\n\n`;
            
            // Calculate scores for all players
            const playerResults = tournamentData.players.map(player => {
                const grossScore = player.scores.reduce((sum, s) => sum + s, 0);
                const netScore = grossScore - player.handicap;
                const toPar = grossScore - courseData.totalPar;
                return { player, grossScore, netScore, toPar };
            });
            
            // Sort by appropriate score
            const isNet = tournamentData.gameType.includes('Net');
            playerResults.sort((a, b) => {
                const aScore = isNet ? a.netScore : a.grossScore;
                const bScore = isNet ? b.netScore : b.grossScore;
                return aScore - bScore;
            });
            
            // Format results
            playerResults.forEach((r, idx) => {
                const medal = idx === 0 ? '🥇 ' : idx === 1 ? '🥈 ' : idx === 2 ? '🥉 ' : '';
                const score = isNet ? r.netScore : r.grossScore;
                const toParText = r.toPar === 0 ? 'E' : (r.toPar > 0 ? `+${r.toPar}` : r.toPar);
                shareText += `${medal}${r.player.name}: ${score} (${toParText})\n`;
            });
            
            shareText += `\n---\nCreated with Let's Golf by Otis Williams`;
            
            // Use Web Share API if available
            if (navigator.share) {
                navigator.share({
                    title: `${courseData.name} Results`,
                    text: shareText
                }).catch(err => {
                    copyToClipboard(shareText);
                });
            } else {
                // Fallback to copy to clipboard
                copyToClipboard(shareText);
            }
        }
        
        // Copy to clipboard helper
        function copyToClipboard(text) {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text).then(() => {
                    alert('Results copied to clipboard!');
                }).catch(() => {
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }
        
        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                alert('Results copied to clipboard!');
            } catch (err) {
                alert('Could not copy results. Please try again.');
            }
            document.body.removeChild(textarea);
        }
        
        // ===== PHASE 1: SHARING FEATURES =====
        
        // Get current page URL
        function getCurrentPageURL() {
            return window.location.origin + window.location.pathname;
        }
        
        // Copy shareable tournament link
        
        // Download tournament file (wrapper for button)
        function downloadTournamentFile() {
            if (!tournamentData || !tournamentData.players || tournamentData.players.length === 0) {
                showNotification('No Tournament', 'Start or load a tournament first to download');
                return;
            }
            downloadTournamentData();
        }
        
        // Download tournament data as JSON backup
        function downloadTournamentData() {
            if (!tournamentData.id) {
                alert('No active tournament to download');
                return;
            }
            
            const backup = {
                ...tournamentData,
                courseData: courseData,
                timestamp: new Date().toISOString(),
                version: '1.0'
            };
            
            const dataStr = JSON.stringify(backup, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const dateStr = formatDateDisplay(tournamentData.date).replace(/\//g, '-');
            const filename = `LetsGolf_${tournamentData.id}_${dateStr}.json`;
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            
            URL.revokeObjectURL(url);
            
            alert('✅ Tournament backup downloaded!\n\nYou can import this file later to restore the tournament.');
        }
        
        // Load tournament from URL parameter
        function loadTournamentFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const tournamentId = urlParams.get('tournament');
            
            if (tournamentId) {
                // Try to load from localStorage
                const savedData = localStorage.getItem('indianHillsScoring');
                if (savedData) {
                    const data = JSON.parse(savedData);
                    if (data.id === tournamentId) {
                        // Found matching tournament
                        alert(`📋 Tournament "${tournamentId}" loaded!\n\nViewing shared tournament.`);
                        // Auto-resume if tournament exists
                        const resumeBtn = document.getElementById('resumeScoringBtn');
                        if (resumeBtn && resumeBtn.style.display !== 'none') {
                            resumeScoring();
                        }
                        return true;
                    }
                }
                
                // Tournament not found locally
                alert(`⚠️ Tournament "${tournamentId}" not found on this device.\n\nMake sure you're on the same device where the tournament was created, or import the tournament backup file.`);
                return false;
            }
            return false;
        }
        
        // Import tournament from backup file
        function importTournamentBackup(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const backup = JSON.parse(e.target.result);
                    
                    // Validate backup structure
                    if (!backup.id || !backup.players || !backup.courseData) {
                        alert('❌ Invalid backup file format');
                        return;
                    }
                    
                    // Restore tournament data
                    tournamentData = {
                        id: backup.id,
                        date: backup.date,
                        gameType: backup.gameType,
                        course: backup.course,
                        players: backup.players,
                        teams: backup.teams || []
                    };
                    
                    courseData = backup.courseData;
                    
                    // Save to localStorage
                    saveToLocalStorage();
                    
                    // Show success and offer to resume
                    alert(`✅ Tournament imported successfully!\n\nID: ${backup.id}\nDate: ${formatDateDisplay(backup.date)}\nCourse: ${backup.courseData.name}\nPlayers: ${backup.players.length}`);
                    
                    // Reload page to show resume option
                    location.reload();
                    
                } catch (error) {
                    alert('❌ Error reading backup file. Please make sure it\'s a valid Let\'s Golf backup.');
                    console.error('Import error:', error);
                }
            };
            
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }
        
        // Export to CSV
        function exportToCsv() {
            const dateStr = formatDateDisplay(tournamentData.date).replace(/\//g, '-');
            const filename = `${courseData.name.replace(/\s+/g, '_')}_${dateStr}.csv`;
            
            let csv = `"Course","Game Type","Date"\n`;
            csv += `"${courseData.name}","${tournamentData.gameType}","${formatDateDisplay(tournamentData.date)}"\n\n`;
            
            // Player scores by hole
            csv += `"Player","Handicap"`;
            for (let i = 1; i <= 18; i++) {
                csv += `,"Hole ${i}"`;
            }
            csv += `,"Total","Net","To Par"\n`;
            
            tournamentData.players.forEach(player => {
                const total = player.scores.reduce((sum, s) => sum + s, 0);
                const net = total - player.handicap;
                const toPar = total - courseData.totalPar;
                const toParText = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar);
                
                csv += `"${player.name}","${player.handicap}"`;
                player.scores.forEach(score => {
                    csv += `,"${score || ''}"`;
                });
                csv += `,"${total}","${net}","${toParText}"\n`;
            });
            
            // Download CSV
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        function printScorecard() {
            // Print the current scorecard view
            window.print();
        }
        
        // Full Scorecard Preview - full screen with pinch-to-zoom
        function openFullScorecardPreview() {
            // Get the current scorecard content
            const body = document.getElementById('scorecardBody');
            if (!body) return;
            
            // Create full-screen preview modal
            const existingPreview = document.getElementById('fullScorecardPreview');
            if (existingPreview) existingPreview.remove();
            
            const preview = document.createElement('div');
            preview.id = 'fullScorecardPreview';
            preview.style.cssText = `
                position: fixed;
                inset: 0;
                background: #1a1a2e;
                z-index: 10010;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            `;
            
            preview.innerHTML = `
                <div style="padding: 12px 16px; background: #1e3a5f; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;">
                    <button onclick="closeFullScorecardPreview()" style="padding: 8px 16px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; touch-action: manipulation;">
                        ← Back
                    </button>
                    <h3 style="color: white; margin: 0; font-size: 16px;">📋 Full Scorecard</h3>
                    <button onclick="shareFullScorecard()" style="padding: 8px 16px; background: #166534; color: white; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; touch-action: manipulation;">
                        📤 Share
                    </button>
                </div>
                <div style="padding: 8px 16px; text-align: center; background: rgba(255,255,255,0.05); flex-shrink: 0; display: flex; justify-content: center; align-items: center; gap: 16px;">
                    <span style="color: #94a3b8; font-size: 12px;">📱 Pinch to zoom • Swipe to scroll</span>
                    <button onclick="resetScorecardPreviewZoom()" style="padding: 6px 12px; background: rgba(255,255,255,0.15); color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; touch-action: manipulation;">
                        ↺ Reset Zoom
                    </button>
                </div>
                <div id="scorecardPreviewContainer" style="flex: 1; overflow: auto; -webkit-overflow-scrolling: touch; padding: 16px;">
                    <div id="scorecardPreviewContent" style="background: white; border-radius: 8px; padding: 16px; transform-origin: top left; min-width: fit-content;">
                        ${body.innerHTML}
                    </div>
                </div>
            `;
            
            document.body.appendChild(preview);
            
            // Initialize pinch-to-zoom
            initPreviewPinchZoom();
        }
        
        // Preview zoom state
        let previewZoomLevel = 1;
        let previewPinchStartDistance = 0;
        let previewPinchStartZoom = 1;
        
        function initPreviewPinchZoom() {
            const container = document.getElementById('scorecardPreviewContainer');
            if (!container) return;
            
            container.addEventListener('touchstart', handlePreviewTouchStart, { passive: false });
            container.addEventListener('touchmove', handlePreviewTouchMove, { passive: false });
            container.addEventListener('touchend', handlePreviewTouchEnd, { passive: true });
        }
        
        function handlePreviewTouchStart(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                previewPinchStartDistance = getPreviewPinchDistance(e.touches);
                previewPinchStartZoom = previewZoomLevel;
            }
        }
        
        function handlePreviewTouchMove(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                const currentDistance = getPreviewPinchDistance(e.touches);
                const scale = currentDistance / previewPinchStartDistance;
                
                previewZoomLevel = previewPinchStartZoom * scale;
                previewZoomLevel = Math.max(0.5, Math.min(4, previewZoomLevel));
                
                applyPreviewZoom();
            }
        }
        
        function handlePreviewTouchEnd(e) {
            previewPinchStartDistance = 0;
        }
        
        function getPreviewPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function applyPreviewZoom() {
            const content = document.getElementById('scorecardPreviewContent');
            if (content) {
                content.style.transform = `scale(${previewZoomLevel})`;
            }
        }
        
        function resetScorecardPreviewZoom() {
            previewZoomLevel = 1;
            applyPreviewZoom();
        }
        
        function closeFullScorecardPreview() {
            const preview = document.getElementById('fullScorecardPreview');
            if (preview) {
                preview.remove();
                previewZoomLevel = 1;
            }
        }
        
        function shareFullScorecard() {
            // Use Web Share API if available (includes Print option on iOS)
            if (navigator.share) {
                navigator.share({
                    title: `${tournamentData.name || 'Golf'} Scorecard`,
                    text: `Scorecard from ${courseData?.name || 'Golf Round'} - ${formatDateDisplay(tournamentData.date)}`,
                    url: window.location.href
                }).catch(err => {
                    console.log('Share cancelled or failed:', err);
                    // Fallback to print
                    window.print();
                });
            } else {
                // Fallback to print dialog
                window.print();
            }
        }

        // Open scorecard modal
        function openScorecardModal() {
            const modal = document.getElementById('scorecardModal');
            const select = document.getElementById('scorecardViewSelect');
            
            // Check if user can view all players
            const canViewAll = canViewLeaderboard();
            
            // Get list of players to show in individual options
            let playersToShow = tournamentData.players;
            
            // If privacy restricts viewing, only show claimed/watched players
            if (!canViewAll && tournamentMode === 'multi') {
                loadPlayerOrder();
                playersToShow = tournamentData.players.filter(p => 
                    isClaimedByMe(p) || playerOrder.watching.includes(p.name)
                );
            }
            
            // Populate individual player options (filtered by privacy)
            const playerOptions = playersToShow
                .map((player) => {
                    // Find the actual index in tournamentData.players for the value
                    const idx = tournamentData.players.findIndex(p => p.name === player.name);
                    return `<option value="player-${idx}">${player.name}</option>`;
                })
                .join('');
            
            // Check if we're in multi-device mode (show My Players options)
            const showMyPlayersOptions = tournamentMode === 'multi';
            
            // Rebuild select to include players (hide All Players if privacy restricted)
            select.innerHTML = `
                ${canViewAll ? `
                    <option value="all-summary">All Players - Summary Table</option>
                    <option value="all-individual">All Players - Individual Cards</option>
                ` : `
                    <option value="all-summary" disabled>🔒 All Players - Summary Table</option>
                    <option value="all-individual" disabled>🔒 All Players - Individual Cards</option>
                `}
                ${showMyPlayersOptions ? `
                    <option disabled>─────────────────</option>
                    <option value="mine-summary">My Players - Summary Table</option>
                    <option value="mine-individual">My Players - Individual Cards</option>
                ` : ''}
                <option disabled>─────────────────</option>
                ${playerOptions}
            `;
            
            // If user can't view all, default to mine-summary or first player
            if (!canViewAll) {
                if (showMyPlayersOptions) {
                    select.value = 'mine-summary';
                } else if (playersToShow.length > 0) {
                    const idx = tournamentData.players.findIndex(p => p.name === playersToShow[0].name);
                    select.value = `player-${idx}`;
                }
            }
            
            modal.classList.add('active');
            updateScorecardView();
        }

        // Close scorecard modal
        function closeScorecardModal() {
            const modal = document.getElementById('scorecardModal');
            modal.classList.remove('active');
        }

        // Update scorecard view based on selection
        function updateScorecardView() {
            const select = document.getElementById('scorecardViewSelect');
            const body = document.getElementById('scorecardBody');
            const viewType = select.value;
            
            // Block all-players views if privacy restricted
            if ((viewType === 'all-summary' || viewType === 'all-individual') && !canViewLeaderboard()) {
                body.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px;">
                        <div style="font-size: 48px; margin-bottom: 16px;">🔒</div>
                        <h3 style="color: #1e3a5f; margin: 0 0 8px 0;">Leaderboard Hidden</h3>
                        <p style="color: #64748b; font-size: 14px; margin: 0;">The host has hidden the leaderboard until all scorecards are signed.</p>
                    </div>
                `;
                return;
            }
            
            // Block viewing individual players not in claimed/watched when privacy restricted
            if (viewType.startsWith('player-') && !canViewLeaderboard() && tournamentMode === 'multi') {
                const playerIndex = parseInt(viewType.split('-')[1]);
                const player = tournamentData.players[playerIndex];
                if (player) {
                    loadPlayerOrder();
                    const isMyPlayer = isClaimedByMe(player) || playerOrder.watching.includes(player.name);
                    if (!isMyPlayer) {
                        body.innerHTML = `
                            <div style="text-align: center; padding: 40px 20px;">
                                <div style="font-size: 48px; margin-bottom: 16px;">🔒</div>
                                <h3 style="color: #1e3a5f; margin: 0 0 8px 0;">Scorecard Hidden</h3>
                                <p style="color: #64748b; font-size: 14px; margin: 0;">You can only view scorecards for players you've claimed or are watching.</p>
                            </div>
                        `;
                        return;
                    }
                }
            }
            
            if (viewType === 'all-summary') {
                body.innerHTML = generateSummaryTable(false);
            } else if (viewType === 'mine-summary') {
                body.innerHTML = generateSummaryTable(true);
            } else if (viewType === 'all-individual') {
                body.innerHTML = generateAllIndividualCards(false);
            } else if (viewType === 'mine-individual') {
                body.innerHTML = generateAllIndividualCards(true);
            } else if (viewType.startsWith('player-')) {
                const playerIndex = parseInt(viewType.split('-')[1]);
                body.innerHTML = generateIndividualCard(playerIndex);
            }
        }

        // Generate summary table for all players - single scrollable table with sticky player column
        function generateSummaryTable(myPlayersOnly = false) {
            const currentGameType = document.getElementById('resultsGameType').value;
            
            // Determine handicap method based on game type
            let hcpMethod = 'full';
            if (currentGameType.includes('18 Max')) {
                hcpMethod = '18max';
            } else if (currentGameType.includes('1/2 Pop')) {
                hcpMethod = 'half';
            }
            
            // Check if this is a net or team game (team games use net scores)
            const isNetOrTeam = currentGameType.includes('Net') || 
                                currentGameType.includes('Best Ball') || 
                                currentGameType.includes('Select Shot');
            
            // Check if this is a skins game
            const isSkinsGame = currentGameType.includes('Skins');
            
            // Get skins winners if applicable
            let skinWinners = {};
            if (isSkinsGame) {
                skinWinners = calculateSkinsForScorecard(currentGameType, hcpMethod);
            }
            
            // Load player order for highlighting
            loadPlayerOrder();
            
            // Determine which players to show
            let playersToShow = tournamentData.players;
            let allPlayers = tournamentData.players;
            
            if (myPlayersOnly) {
                playersToShow = tournamentData.players.filter(p => 
                    isClaimedByMe(p) || playerOrder.watching.includes(p.name)
                );
            }
            
            const frontPar = courseData.holes.slice(0, 9).reduce((sum, h) => sum + h.par, 0);
            const backPar = courseData.holes.slice(9).reduce((sum, h) => sum + h.par, 0);
            
            let html = `
                <div style="margin-bottom: 8px; text-align: center;">
                    ${tournamentData.name ? `<h2 style="color: #1e3a5f; margin-bottom: 4px; font-size: 18px; font-weight: 700;">${tournamentData.name}</h2>` : ''}
                    <h3 style="color: #1e3a5f; margin-bottom: 2px; font-size: 16px;">${courseData.name}</h3>
                    <p style="color: #64748b; font-size: 12px; margin: 0;">${currentGameType} - ${formatDateDisplay(tournamentData.date)}${myPlayersOnly ? ' (My Players)' : ''}</p>
                </div>
            `;
            
            // Check which stats columns to show (only if any player has data)
            const showFirColumn = hasAnyStatsData('fir');
            const showGirColumn = hasAnyStatsData('gir');
            const showPuttsColumn = hasAnyStatsData('putts') || hasAnyCompletePuttData();
            const showDotsColumn = hasAnyStatsData('dots');
            
            // Single scrollable table with sticky first column
            html += `<div class="table-wrapper" style="overflow-x: auto; -webkit-overflow-scrolling: touch;">
                <table class="scorecard-table" style="border-collapse: collapse; min-width: 100%;">
                    <thead>
                        <tr>
                            <th style="position: sticky; left: 0; z-index: 2; background: #64748b; min-width: 70px; text-align: left; font-size: 10px; color: white;">Player</th>`;
            
            // Front 9 headers
            for (let i = 0; i < 9; i++) {
                html += `<th style="width: 28px; font-size: 10px; padding: 4px 2px; background: #64748b; color: white;">${i + 1}</th>`;
            }
            html += `<th style="width: 32px; font-size: 10px; background: #475569; padding: 4px 2px; color: white;">OUT</th>`;
            
            // Back 9 headers
            for (let i = 9; i < 18; i++) {
                html += `<th style="width: 28px; font-size: 10px; padding: 4px 2px; background: #64748b; color: white;">${i + 1}</th>`;
            }
            html += `<th style="width: 32px; font-size: 10px; background: #475569; padding: 4px 2px; color: white;">IN</th>`;
            html += `<th style="width: 34px; font-size: 10px; background: #64748b; padding: 4px 2px; color: white;">TOT</th>`;
            
            // Add stats headers at the end
            if (showFirColumn) {
                html += `<th style="width: 36px; font-size: 9px; background: #1e3a5f; padding: 4px 2px;">FIR</th>`;
            }
            if (showGirColumn) {
                html += `<th style="width: 36px; font-size: 9px; background: #1e3a5f; padding: 4px 2px;">GIR</th>`;
            }
            if (showPuttsColumn) {
                html += `<th style="width: 36px; font-size: 9px; background: #1e3a5f; padding: 4px 2px;">Putts</th>`;
            }
            if (showDotsColumn) {
                html += `<th style="width: 36px; font-size: 9px; background: #166534; padding: 4px 2px;">Dots</th>`;
            }
            
            html += `</tr>`;
            
            // Par row
            html += `<tr style="background: #f1f5f9;">
                <td style="position: sticky; left: 0; z-index: 1; background: #f1f5f9; font-size: 9px; font-weight: 600; text-align: left; padding: 2px 4px;">Par</td>`;
            for (let i = 0; i < 9; i++) {
                html += `<td style="font-size: 10px; padding: 2px;">${courseData.holes[i].par}</td>`;
            }
            html += `<td style="font-size: 10px; background: #e2e8f0; font-weight: 600; padding: 2px;">${frontPar}</td>`;
            for (let i = 9; i < 18; i++) {
                html += `<td style="font-size: 10px; padding: 2px;">${courseData.holes[i].par}</td>`;
            }
            html += `<td style="font-size: 10px; background: #e2e8f0; font-weight: 600; padding: 2px;">${backPar}</td>`;
            html += `<td style="font-size: 10px; background: #dbeafe; font-weight: 600; padding: 2px;">${courseData.totalPar}</td>`;
            // Empty cells for stats columns in par row
            if (showFirColumn) html += `<td style="background: #f5f0e8; padding: 2px;"></td>`;
            if (showGirColumn) html += `<td style="background: #f5f0e8; padding: 2px;"></td>`;
            if (showPuttsColumn) html += `<td style="background: #f5f0e8; padding: 2px;"></td>`;
            if (showDotsColumn) html += `<td style="background: #d1fae5; padding: 2px;"></td>`;
            html += `</tr>`;
            
            // Handicap row
            html += `<tr style="background: #f8fafc;">
                <td style="position: sticky; left: 0; z-index: 1; background: #f8fafc; font-size: 8px; font-weight: 500; text-align: left; padding: 2px 4px; color: #64748b;">Hcp</td>`;
            for (let i = 0; i < 9; i++) {
                html += `<td style="font-size: 9px; color: #64748b; padding: 2px;">${courseData.holes[i].handicap}</td>`;
            }
            html += `<td style="background: #e2e8f0; padding: 2px;"></td>`;
            for (let i = 9; i < 18; i++) {
                html += `<td style="font-size: 9px; color: #64748b; padding: 2px;">${courseData.holes[i].handicap}</td>`;
            }
            html += `<td style="background: #e2e8f0; padding: 2px;"></td>`;
            html += `<td style="background: #dbeafe; padding: 2px;"></td>`;
            // Empty cells for stats columns in handicap row
            if (showFirColumn) html += `<td style="background: #f5f0e8; padding: 2px;"></td>`;
            if (showGirColumn) html += `<td style="background: #f5f0e8; padding: 2px;"></td>`;
            if (showPuttsColumn) html += `<td style="background: #f5f0e8; padding: 2px;"></td>`;
            if (showDotsColumn) html += `<td style="background: #d1fae5; padding: 2px;"></td>`;
            html += `</tr></thead><tbody>`;
            
            // Player rows
            playersToShow.forEach(player => {
                const playerIdx = allPlayers.findIndex(p => p.name === player.name);
                
                // Row highlighting - peach/cream for claimed players
                let rowBg = 'white';
                let stickyBg = 'white';
                if (isClaimedByMe(player)) {
                    rowBg = '#fef3e2';
                    stickyBg = '#fef3e2';
                } else if (playerOrder.watching && playerOrder.watching.includes(player.name)) {
                    rowBg = '#f0f9ff';
                    stickyBg = '#f0f9ff';
                }
                
                html += `<tr style="background: ${rowBg}; height: 36px;">`;
                
                // Player name cell (sticky)
                const hcpDisplay = player.handicap > 0 ? player.handicap : player.handicap < 0 ? '+' + Math.abs(player.handicap) : 'Scr';
                html += `<td style="position: sticky; left: 0; z-index: 1; background: ${stickyBg}; font-size: 10px; font-weight: 600; text-align: left; padding: 4px; white-space: nowrap; border-right: 2px solid #e2e8f0; vertical-align: middle; height: 36px;">
                    ${player.name}<br><span style="font-size: 8px; color: #64748b; font-weight: 400;">(${hcpDisplay})</span>
                </td>`;
                
                // Calculate totals
                let frontTotal = 0;
                let frontNetTotal = 0;
                let backTotal = 0;
                let backNetTotal = 0;
                
                // Front 9 scores
                for (let i = 0; i < 9; i++) {
                    const score = player.scores[i] || '';
                    if (score) {
                        frontTotal += score;
                        const netScore = getNetScore(score, player.handicap, courseData.holes[i].handicap, hcpMethod);
                        frontNetTotal += netScore;
                    }
                    
                    let cellStyle = 'vertical-align: middle; height: 36px;';
                    if (isSkinsGame && skinWinners[i] && skinWinners[i].includes(playerIdx)) {
                        cellStyle += ' background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);';
                    }
                    
                    let scoreDisplay = score || '';
                    if (score) {
                        const diff = score - courseData.holes[i].par;
                        let scoreColor = '';
                        if (diff <= -1) scoreColor = 'color: #166534;'; // Green for under par
                        else if (diff === 0) scoreColor = 'color: #1e3a5f;'; // Navy for par
                        else if (diff >= 1) scoreColor = 'color: #a51c30;'; // Red for over par
                        
                        const netScore = getNetScore(score, player.handicap, courseData.holes[i].handicap, hcpMethod);
                        const netStr = Number.isInteger(netScore) ? netScore : netScore.toFixed(1);
                        const netDisplay = player.handicap !== 0 ? `<br><span style="font-size: 8px; color: #6b7280;">${netStr}</span>` : '<br><span style="font-size: 8px; visibility: hidden;">0</span>';
                        scoreDisplay = `<span style="${scoreColor} font-weight: 600; font-size: 11px;">${score}</span>${netDisplay}`;
                    }
                    
                    html += `<td style="${cellStyle} padding: 2px;">${scoreDisplay}</td>`;
                }
                
                // Front 9 OUT
                const frontNetStr = Number.isInteger(frontNetTotal) ? frontNetTotal : frontNetTotal.toFixed(1);
                const frontNetDisplay = player.handicap !== 0 && frontTotal ? `<br><span style="font-size: 8px; color: #6b7280;">${frontNetStr}</span>` : '<br><span style="font-size: 8px; visibility: hidden;">0</span>';
                html += `<td style="background: #e2e8f0; font-weight: 700; font-size: 11px; padding: 2px; vertical-align: middle; height: 36px;">
                    ${frontTotal || ''}${frontTotal ? frontNetDisplay : ''}
                </td>`;
                
                // Back 9 scores
                for (let i = 9; i < 18; i++) {
                    const score = player.scores[i] || '';
                    if (score) {
                        backTotal += score;
                        const netScore = getNetScore(score, player.handicap, courseData.holes[i].handicap, hcpMethod);
                        backNetTotal += netScore;
                    }
                    
                    let cellStyle = 'vertical-align: middle; height: 36px;';
                    if (isSkinsGame && skinWinners[i] && skinWinners[i].includes(playerIdx)) {
                        cellStyle += ' background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);';
                    }
                    
                    let scoreDisplay = score || '';
                    if (score) {
                        const diff = score - courseData.holes[i].par;
                        let scoreColor = '';
                        if (diff <= -1) scoreColor = 'color: #166534;'; // Green for under par
                        else if (diff === 0) scoreColor = 'color: #1e3a5f;'; // Navy for par
                        else if (diff >= 1) scoreColor = 'color: #a51c30;'; // Red for over par
                        
                        const netScore = getNetScore(score, player.handicap, courseData.holes[i].handicap, hcpMethod);
                        const netStr = Number.isInteger(netScore) ? netScore : netScore.toFixed(1);
                        const netDisplay = player.handicap !== 0 ? `<br><span style="font-size: 8px; color: #6b7280;">${netStr}</span>` : '<br><span style="font-size: 8px; visibility: hidden;">0</span>';
                        scoreDisplay = `<span style="${scoreColor} font-weight: 600; font-size: 11px;">${score}</span>${netDisplay}`;
                    }
                    
                    html += `<td style="${cellStyle} padding: 2px;">${scoreDisplay}</td>`;
                }
                
                // Back 9 IN
                const backNetStr = Number.isInteger(backNetTotal) ? backNetTotal : backNetTotal.toFixed(1);
                const backNetDisplay = player.handicap !== 0 && backTotal ? `<br><span style="font-size: 8px; color: #6b7280;">${backNetStr}</span>` : '<br><span style="font-size: 8px; visibility: hidden;">0</span>';
                html += `<td style="background: #e2e8f0; font-weight: 700; font-size: 11px; padding: 2px; vertical-align: middle; height: 36px;">
                    ${backTotal || ''}${backTotal ? backNetDisplay : ''}
                </td>`;
                
                // Total
                const grandTotal = frontTotal + backTotal;
                const grandNetTotal = frontNetTotal + backNetTotal;
                const grandNetStr = Number.isInteger(grandNetTotal) ? grandNetTotal : grandNetTotal.toFixed(1);
                const toPar = grandTotal - courseData.totalPar;
                const toParText = grandTotal ? (toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar)) : '';
                const totalNetDisplay = player.handicap !== 0 && grandTotal ? `<br><span style="font-size: 8px; color: #6b7280;">${grandNetStr}</span>` : '<br><span style="font-size: 8px; visibility: hidden;">0</span>';
                
                html += `<td style="background: #dbeafe; font-weight: 700; font-size: 11px; padding: 2px; vertical-align: middle; height: 36px;">
                    ${grandTotal || ''}${grandTotal ? totalNetDisplay : ''}
                </td>`;
                
                // Get player stats for all columns
                const playerScorecardStats = getPlayerStatsForScorecard(player.name);
                
                // FIR column
                if (showFirColumn) {
                    let firDisplay = '--';
                    if (playerScorecardStats && playerScorecardStats.fir) {
                        firDisplay = `${playerScorecardStats.fir.hit}/${playerScorecardStats.fir.total}`;
                    }
                    html += `<td style="background: #f5f0e8; font-weight: 700; font-size: 10px; padding: 2px; vertical-align: middle; height: 36px; color: #1e3a5f;">
                        ${firDisplay}
                    </td>`;
                }
                
                // GIR column
                if (showGirColumn) {
                    let girDisplay = '--';
                    if (playerScorecardStats && playerScorecardStats.gir) {
                        girDisplay = `${playerScorecardStats.gir.hit}/${playerScorecardStats.gir.total}`;
                    }
                    html += `<td style="background: #f5f0e8; font-weight: 700; font-size: 10px; padding: 2px; vertical-align: middle; height: 36px; color: #1e3a5f;">
                        ${girDisplay}
                    </td>`;
                }
                
                // PUTTS column
                if (showPuttsColumn) {
                    let puttsDisplay = '--';
                    // Try new stats first, then fall back to legacy putts
                    if (playerScorecardStats && playerScorecardStats.putts !== null) {
                        puttsDisplay = playerScorecardStats.putts;
                    } else {
                        const totalPutts = getPlayerTotalPutts(player);
                        if (totalPutts !== null) puttsDisplay = totalPutts;
                    }
                    html += `<td style="background: #f5f0e8; font-weight: 700; font-size: 11px; padding: 2px; vertical-align: middle; height: 36px; color: #1e3a5f;">
                        ${puttsDisplay}
                    </td>`;
                }
                
                // DOTS column
                if (showDotsColumn) {
                    let dotsDisplay = '--';
                    if (playerScorecardStats && playerScorecardStats.dots !== null) {
                        dotsDisplay = playerScorecardStats.dots;
                    }
                    html += `<td style="background: #d1fae5; font-weight: 700; font-size: 11px; padding: 2px; vertical-align: middle; height: 36px; color: #166534;">
                        ${dotsDisplay}
                    </td>`;
                }
                
                html += `</tr>`;
            });
            
            html += `</tbody></table></div>`;
            
            return html;
        }
        
        // Calculate skins winners for scorecard display
        function calculateSkinsForScorecard(gameType, hcpMethod) {
            const skinWinners = {}; // hole index => array of player indices who won
            
            for (let holeIdx = 0; holeIdx < 18; holeIdx++) {
                const hole = courseData.holes[holeIdx];
                let scores = [];
                
                tournamentData.players.forEach((player, pIdx) => {
                    let score = player.scores[holeIdx];
                    if (score > 0) {
                        if (gameType.includes('Net')) {
                            score = getNetScore(score, player.handicap, hole.handicap, hcpMethod);
                        }
                        scores.push({ playerIdx: pIdx, score });
                    }
                });
                
                if (scores.length > 0) {
                    const minScore = Math.min(...scores.map(s => s.score));
                    const winners = scores.filter(s => s.score === minScore);
                    
                    // Only award skin if there's a single winner (no tie)
                    if (winners.length === 1) {
                        skinWinners[holeIdx] = [winners[0].playerIdx];
                    }
                }
            }
            
            return skinWinners;
        }

        // Generate all individual cards
        function generateAllIndividualCards(myPlayersOnly = false) {
            let html = '';
            let playersToShow = tournamentData.players;
            
            if (myPlayersOnly) {
                loadPlayerOrder();
                playersToShow = tournamentData.players.filter(p => 
                    isClaimedByMe(p) || playerOrder.watching.includes(p.name)
                );
            }
            
            playersToShow.forEach((player) => {
                const playerIdx = tournamentData.players.findIndex(p => p.name === player.name);
                html += generateIndividualCard(playerIdx);
            });
            return html;
        }

        // Generate individual scorecard for one player
        function generateIndividualCard(playerIndex) {
            const player = tournamentData.players[playerIndex];
            const currentGameType = document.getElementById('resultsGameType').value;
            
            // Determine handicap method based on game type
            let hcpMethod = 'full';
            if (currentGameType.includes('18 Max')) {
                hcpMethod = '18max';
            } else if (currentGameType.includes('1/2 Pop')) {
                hcpMethod = 'half';
            }
            
            let html = `
                <div class="scorecard-individual">
                    <div class="scorecard-player-header">
                        <div class="scorecard-player-name">${player.name}</div>
                        <div class="scorecard-player-info">
                            ${tournamentData.name ? `<strong>${tournamentData.name}</strong><br>` : ''}
                            ${courseData.name} • ${currentGameType}<br>
                            ${formatDateDisplay(tournamentData.date)} • Handicap: ${player.handicap > 0 ? player.handicap : player.handicap < 0 ? '+' + Math.abs(player.handicap) : 'Scratch'}
                        </div>
                    </div>
                    
                    <div class="table-wrapper">
                    <table class="scorecard-table">
                        <thead>
                            <tr>
                                <th>Hole</th>
            `;
            
            // Front 9
            for (let i = 1; i <= 9; i++) {
                html += `<th>${i}</th>`;
            }
            html += `<th>OUT</th>`;
            
            // Back 9
            for (let i = 10; i <= 18; i++) {
                html += `<th>${i}</th>`;
            }
            html += `<th>IN</th><th>TOT</th>`;
            
            html += `</tr></thead><tbody>`;
            
            // Par row
            html += `<tr><td><strong>Par</strong></td>`;
            let frontPar = 0, backPar = 0;
            for (let i = 0; i < 9; i++) {
                frontPar += courseData.holes[i].par;
                html += `<td>${courseData.holes[i].par}</td>`;
            }
            html += `<td><strong>${frontPar}</strong></td>`;
            for (let i = 9; i < 18; i++) {
                backPar += courseData.holes[i].par;
                html += `<td>${courseData.holes[i].par}</td>`;
            }
            html += `<td><strong>${backPar}</strong></td><td><strong>${courseData.totalPar}</strong></td></tr>`;
            
            // Handicap row
            html += `<tr><td><strong>HCP</strong></td>`;
            for (let i = 0; i < 9; i++) {
                html += `<td style="font-size: 11px;">${courseData.holes[i].handicap}</td>`;
            }
            html += `<td></td>`;
            for (let i = 9; i < 18; i++) {
                html += `<td style="font-size: 11px;">${courseData.holes[i].handicap}</td>`;
            }
            html += `<td></td><td></td></tr>`;
            
            // Gross score row with color coding
            html += `<tr style="background: #f0f9ff;"><td><strong>Gross</strong></td>`;
            let frontGross = 0, backGross = 0;
            for (let i = 0; i < 9; i++) {
                const score = player.scores[i] || '';
                if (score) {
                    frontGross += score;
                    const diff = score - courseData.holes[i].par;
                    let scoreColor = '';
                    if (diff <= -2) scoreColor = 'color: #047857; font-weight: 800;'; // Eagle or better - dark green
                    else if (diff === -1) scoreColor = 'color: #166534;'; // Birdie - green
                    else if (diff === 0) scoreColor = 'color: #1e3a5f;'; // Par - blue
                    else if (diff === 1) scoreColor = 'color: #1e3a5f;'; // Bogey - navy
                    else if (diff >= 2) scoreColor = 'color: #a51c30;'; // Double+ - red
                    html += `<td><strong style="${scoreColor}">${score}</strong></td>`;
                } else {
                    html += `<td><strong>${score}</strong></td>`;
                }
            }
            html += `<td><strong>${frontGross || ''}</strong></td>`;
            for (let i = 9; i < 18; i++) {
                const score = player.scores[i] || '';
                if (score) {
                    backGross += score;
                    const diff = score - courseData.holes[i].par;
                    let scoreColor = '';
                    if (diff <= -2) scoreColor = 'color: #047857; font-weight: 800;'; // Eagle or better
                    else if (diff === -1) scoreColor = 'color: #166534;'; // Birdie
                    else if (diff === 0) scoreColor = 'color: #1e3a5f;'; // Par
                    else if (diff === 1) scoreColor = 'color: #1e3a5f;'; // Bogey - navy
                    else if (diff >= 2) scoreColor = 'color: #a51c30;'; // Double+
                    html += `<td><strong style="${scoreColor}">${score}</strong></td>`;
                } else {
                    html += `<td><strong>${score}</strong></td>`;
                }
            }
            const totalGross = frontGross + backGross;
            html += `<td><strong>${backGross || ''}</strong></td><td><strong>${totalGross || ''}</strong></td></tr>`;
            
            // Net score row (if applicable - for net games OR team games)
            const isNetOrTeam = currentGameType.includes('Net') || 
                                currentGameType.includes('Best Ball') || 
                                currentGameType.includes('Select Shot');
            
            if (isNetOrTeam && player.handicap !== 0) {
                html += `<tr style="background: #dcfce7;"><td><strong>Net</strong></td>`;
                let frontNet = 0, backNet = 0;
                for (let i = 0; i < 9; i++) {
                    const gross = player.scores[i];
                    if (gross) {
                        const net = getNetScore(gross, player.handicap, courseData.holes[i].handicap, hcpMethod);
                        frontNet += net;
                        html += `<td><strong>${net}</strong></td>`;
                    } else {
                        html += `<td></td>`;
                    }
                }
                html += `<td><strong>${frontNet || ''}</strong></td>`;
                for (let i = 9; i < 18; i++) {
                    const gross = player.scores[i];
                    if (gross) {
                        const net = getNetScore(gross, player.handicap, courseData.holes[i].handicap, hcpMethod);
                        backNet += net;
                        html += `<td><strong>${net}</strong></td>`;
                    } else {
                        html += `<td></td>`;
                    }
                }
                const totalNet = frontNet + backNet;
                html += `<td><strong>${backNet || ''}</strong></td><td><strong>${totalNet || ''}</strong></td></tr>`;
            }
            
            // Get player stats from stats tracker
            const playerScorecardStats = getPlayerStatsForScorecard(player.name);
            
            // FIR row (if player has any FIR data)
            if (playerScorecardStats && playerScorecardStats.fir !== null) {
                html += `<tr style="background: #f5f0e8;"><td><strong style="color: #1e3a5f;">FIR</strong></td>`;
                let frontFir = 0, frontFirTotal = 0, backFir = 0, backFirTotal = 0;
                for (let i = 0; i < 9; i++) {
                    const isPar3 = courseData.holes[i].par === 3;
                    const firVal = playerScorecardStats.firByHole[i];
                    let cellContent = '';
                    if (isPar3) {
                        cellContent = '-';
                    } else if (firVal === true) {
                        cellContent = '✓';
                        frontFir++;
                        frontFirTotal++;
                    } else if (firVal === false) {
                        cellContent = '✗';
                        frontFirTotal++;
                    }
                    html += `<td style="color: ${firVal === true ? '#166534' : firVal === false ? '#a51c30' : '#94a3b8'}; font-size: 11px;"><strong>${cellContent}</strong></td>`;
                }
                html += `<td style="color: #1e3a5f; font-size: 10px;"><strong>${frontFirTotal > 0 ? frontFir + '/' + frontFirTotal : ''}</strong></td>`;
                for (let i = 9; i < 18; i++) {
                    const isPar3 = courseData.holes[i].par === 3;
                    const firVal = playerScorecardStats.firByHole[i];
                    let cellContent = '';
                    if (isPar3) {
                        cellContent = '-';
                    } else if (firVal === true) {
                        cellContent = '✓';
                        backFir++;
                        backFirTotal++;
                    } else if (firVal === false) {
                        cellContent = '✗';
                        backFirTotal++;
                    }
                    html += `<td style="color: ${firVal === true ? '#166534' : firVal === false ? '#a51c30' : '#94a3b8'}; font-size: 11px;"><strong>${cellContent}</strong></td>`;
                }
                const totalFir = frontFir + backFir;
                const totalFirTotal = frontFirTotal + backFirTotal;
                html += `<td style="color: #1e3a5f; font-size: 10px;"><strong>${backFirTotal > 0 ? backFir + '/' + backFirTotal : ''}</strong></td>`;
                html += `<td style="color: #1e3a5f; font-size: 10px;"><strong>${totalFirTotal > 0 ? totalFir + '/' + totalFirTotal : ''}</strong></td></tr>`;
            }
            
            // GIR row (if player has any GIR data)
            if (playerScorecardStats && playerScorecardStats.gir !== null) {
                html += `<tr style="background: #f5f0e8;"><td><strong style="color: #1e3a5f;">GIR</strong></td>`;
                let frontGir = 0, frontGirTotal = 0, backGir = 0, backGirTotal = 0;
                for (let i = 0; i < 9; i++) {
                    const girVal = playerScorecardStats.girByHole[i];
                    let cellContent = '';
                    if (girVal === true) {
                        cellContent = '✓';
                        frontGir++;
                        frontGirTotal++;
                    } else if (girVal === false) {
                        cellContent = '✗';
                        frontGirTotal++;
                    }
                    html += `<td style="color: ${girVal === true ? '#166534' : girVal === false ? '#a51c30' : '#94a3b8'}; font-size: 11px;"><strong>${cellContent}</strong></td>`;
                }
                html += `<td style="color: #1e3a5f; font-size: 10px;"><strong>${frontGirTotal > 0 ? frontGir + '/' + frontGirTotal : ''}</strong></td>`;
                for (let i = 9; i < 18; i++) {
                    const girVal = playerScorecardStats.girByHole[i];
                    let cellContent = '';
                    if (girVal === true) {
                        cellContent = '✓';
                        backGir++;
                        backGirTotal++;
                    } else if (girVal === false) {
                        cellContent = '✗';
                        backGirTotal++;
                    }
                    html += `<td style="color: ${girVal === true ? '#166534' : girVal === false ? '#a51c30' : '#94a3b8'}; font-size: 11px;"><strong>${cellContent}</strong></td>`;
                }
                const totalGirCount = frontGir + backGir;
                const totalGirTotal = frontGirTotal + backGirTotal;
                html += `<td style="color: #1e3a5f; font-size: 10px;"><strong>${backGirTotal > 0 ? backGir + '/' + backGirTotal : ''}</strong></td>`;
                html += `<td style="color: #1e3a5f; font-size: 10px;"><strong>${totalGirCount > 0 ? totalGirCount + '/' + totalGirTotal : ''}</strong></td></tr>`;
            }
            
            // Putts row (from stats tracker or legacy)
            const hasPuttsData = (playerScorecardStats && playerScorecardStats.putts !== null) || getPlayerTotalPutts(player) !== null;
            if (hasPuttsData) {
                html += `<tr style="background: #f5f0e8;"><td><strong style="color: #1e3a5f;">Putts</strong></td>`;
                let frontPutts = 0, backPutts = 0;
                for (let i = 0; i < 9; i++) {
                    // Try stats tracker first, then legacy
                    let putt = '';
                    if (playerScorecardStats && playerScorecardStats.puttsByHole[i] !== null && playerScorecardStats.puttsByHole[i] !== undefined) {
                        putt = playerScorecardStats.puttsByHole[i];
                    } else if (player.putts && player.putts[i] !== null) {
                        putt = player.putts[i];
                    }
                    if (putt !== '') frontPutts += putt;
                    html += `<td style="color: #1e3a5f;"><strong>${putt}</strong></td>`;
                }
                html += `<td style="color: #1e3a5f;"><strong>${frontPutts || ''}</strong></td>`;
                for (let i = 9; i < 18; i++) {
                    let putt = '';
                    if (playerScorecardStats && playerScorecardStats.puttsByHole[i] !== null && playerScorecardStats.puttsByHole[i] !== undefined) {
                        putt = playerScorecardStats.puttsByHole[i];
                    } else if (player.putts && player.putts[i] !== null) {
                        putt = player.putts[i];
                    }
                    if (putt !== '') backPutts += putt;
                    html += `<td style="color: #1e3a5f;"><strong>${putt}</strong></td>`;
                }
                const totalPuttsCalc = frontPutts + backPutts;
                html += `<td style="color: #1e3a5f;"><strong>${backPutts || ''}</strong></td><td style="color: #1e3a5f;"><strong>${totalPuttsCalc || ''}</strong></td></tr>`;
            }
            
            // Dots row (if player has any dots data)
            if (playerScorecardStats && playerScorecardStats.dots !== null) {
                html += `<tr style="background: #d1fae5;"><td><strong style="color: #166534;">Dots</strong></td>`;
                let frontDots = 0, backDots = 0;
                for (let i = 0; i < 9; i++) {
                    const dotVal = playerScorecardStats.dotsByHole[i];
                    const cellContent = dotVal !== null && dotVal !== undefined ? dotVal : '';
                    if (cellContent !== '') frontDots += cellContent;
                    html += `<td style="color: #166534;"><strong>${cellContent}</strong></td>`;
                }
                html += `<td style="color: #166534;"><strong>${frontDots || ''}</strong></td>`;
                for (let i = 9; i < 18; i++) {
                    const dotVal = playerScorecardStats.dotsByHole[i];
                    const cellContent = dotVal !== null && dotVal !== undefined ? dotVal : '';
                    if (cellContent !== '') backDots += cellContent;
                    html += `<td style="color: #166534;"><strong>${cellContent}</strong></td>`;
                }
                const totalDotsCalc = frontDots + backDots;
                html += `<td style="color: #166534;"><strong>${backDots || ''}</strong></td><td style="color: #166534;"><strong>${totalDotsCalc || ''}</strong></td></tr>`;
            }
            
            // To Par row
            const toPar = totalGross - courseData.totalPar;
            const toParText = toPar === 0 ? 'Even' : (toPar > 0 ? `+${toPar}` : toPar);
            html += `<tr class="total-row"><td colspan="11"><strong>To Par:</strong></td><td colspan="10"><strong>${toParText}</strong></td></tr>`;
            
            html += `</tbody></table>`;
            html += `</div>`; // Close table-wrapper
            html += `</div>`; // Close scorecard-individual
            
            return html;
        }
        // Check for saved round on page load
        let initialLoadComplete = false;
        function checkForSavedRound(allowNavigation = false) {
            const savedData = localStorage.getItem('indianHillsScoring');
            
            // If no saved data and we're allowing navigation, go to Host Home (fresh start)
            if (!savedData && allowNavigation && !initialLoadComplete) {
                initialLoadComplete = true;
                console.log('🏠 No saved tournament - showing Host Home for fresh start');
                updateHostHomePage();
                showPage('hostHomePage');
                return;
            }
            
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    
                    // CRITICAL: Restore activeTournamentId and tournamentMode first
                    activeTournamentId = data._activeTournamentId || null;
                    tournamentMode = data._tournamentMode || 'single';
                    
                    // IMPROVED HOST RESTORATION: Same logic as loadFromLocalStorage
                    const savedHostForTournament = data._hostForTournament || null;
                    if (savedHostForTournament && savedHostForTournament === activeTournamentId) {
                        isHost = data._isHost || false;
                        console.log('🔑 checkForSavedRound - Host status restored for tournament:', activeTournamentId);
                    } else if (data._isHost && activeTournamentId) {
                        // Fallback for old data format
                        isHost = data._isHost;
                        console.log('🔑 checkForSavedRound - Host status restored (legacy format)');
                    } else {
                        isHost = false;
                    }
                    
                    // AUTO-FIX: If there's a Firebase tournament ID, it MUST be multi-device mode
                    // Firebase IDs look like T1768522029360yc63i0 (T + 13-digit timestamp + random)
                    // Local IDs look like Tmkhhwu1sfr3ql (T + base36 timestamp, shorter)
                    const isFirebaseIdCheck = activeTournamentId && /^T\d{13}/.test(activeTournamentId);
                    if (isFirebaseIdCheck && tournamentMode !== 'multi') {
                        console.log('🔧 AUTO-FIX: Detected Firebase tournament ID, forcing multi-device mode');
                        tournamentMode = 'multi';
                        isHost = true;
                    }
                    
                    hasJoinedTournament = data._hasJoinedTournament || false;
                    hostViewMode = data._hostViewMode || 'host';
                    
                    // Hosts are always considered joined
                    if (isHost) {
                        hasJoinedTournament = true;
                    }
                    
                    // Debug logging
                    console.log('🔄 checkForSavedRound - tournamentMode:', tournamentMode);
                    console.log('🔄 checkForSavedRound - activeTournamentId:', activeTournamentId);
                    console.log('🔄 checkForSavedRound - isHost:', isHost);
                    console.log('🔄 checkForSavedRound - hasJoinedTournament:', hasJoinedTournament);
                    console.log('🔄 checkForSavedRound - players count:', data.players?.length || 0);
                    console.log('🔄 checkForSavedRound - allowNavigation:', allowNavigation);
                    
                    // Only navigate on initial load, not when called from showPage
                    if (allowNavigation && !initialLoadComplete) {
                        initialLoadComplete = true;
                        
                        // AUTO-NAVIGATE: If this is a host with an active tournament, go to Host Home
                        if (activeTournamentId && tournamentMode === 'multi' && isHost) {
                            console.log('🏠 Host detected with active tournament - navigating to Host Home');
                            
                            // Load tournament data first (exclude metadata)
                            const metadataKeys = ['_activeTournamentId', '_tournamentMode', '_isHost', '_hostForTournament', 
                                                '_hasJoinedTournament', '_hostViewMode', '_scoreTimestamps', '_deletedPlayers', '_lastSaved'];
                            metadataKeys.forEach(key => delete data[key]);
                            tournamentData = data;
                            
                            // Restore course data
                            courseData = courses[tournamentData.course] || customCourses[tournamentData.course];
                            
                            // Reconnect to Firebase (with delay to ensure Firebase is ready)
                            setTimeout(() => {
                                subscribToTournamentUpdates(activeTournamentId);
                            }, 500);
                            
                            // Navigate to Host Home immediately
                            updateHostHomePage();
                            const currentTournamentCard = document.getElementById('hostCurrentTournament');
                            if (currentTournamentCard) currentTournamentCard.style.display = 'none';
                            showPage('hostHomePage');
                            console.log('✅ Auto-navigated to Host Home');
                            return; // Don't show setup page
                        }
                        
                        // AUTO-NAVIGATE: If this is a non-host with joined tournament, go to Guest Home
                        if (activeTournamentId && tournamentMode === 'multi' && hasJoinedTournament && !isHost) {
                            console.log('🏠 Guest detected with joined tournament - navigating to Guest Home');
                            
                            // Load tournament data
                            const metadataKeys = ['_activeTournamentId', '_tournamentMode', '_isHost', '_hostForTournament', 
                                                '_hasJoinedTournament', '_hostViewMode', '_scoreTimestamps', '_deletedPlayers', '_lastSaved'];
                            metadataKeys.forEach(key => delete data[key]);
                            tournamentData = data;
                            
                            // Restore course data
                            courseData = courses[tournamentData.course] || customCourses[tournamentData.course];
                            
                            // Reconnect to Firebase
                            setTimeout(() => {
                                subscribToTournamentUpdates(activeTournamentId);
                            }, 500);
                            
                            // Navigate to Guest Home
                            showGuestHomePage();
                            console.log('✅ Auto-navigated to Guest Home');
                            return; // Don't show setup page
                        }
                    }
                    
                    // Fallback: Show resume section on setup page (for non-multi mode or no tournament)
                    const resumeSection = document.getElementById('resumeRoundSection');
                    const resumeInfo = document.getElementById('resumeRoundInfo');
                    const shareButtons = document.getElementById('resumeShareButtons');
                    const manageBtn = document.getElementById('resumeManageBtn');
                    
                    if (data.players && data.players.length > 0) {
                        // Show resume section (if element exists)
                        if (resumeSection) {
                            resumeSection.classList.add('active');
                        }
                        
                        // Update Manage button text based on role
                        if (manageBtn) {
                            if (isHost || isCoHost) {
                                manageBtn.textContent = 'Manage';
                            } else {
                                manageBtn.textContent = 'My Players';
                            }
                        }
                        
                        // Format info
                        const playerCount = data.players.length;
                        const date = data.date ? new Date(data.date).toLocaleDateString() : 'Today';
                        const gametype = data.gameType || 'Round';
                        const tournamentName = data.name || '';
                        
                        let infoText = `${playerCount} player${playerCount > 1 ? 's' : ''} • ${gametype}`;
                        if (tournamentName) {
                            infoText = `${tournamentName} • ${infoText}`;
                        }
                        if (resumeInfo) resumeInfo.textContent = infoText;
                        
                        // Show share buttons in multi-device mode (even if tournament creation failed)
                        if (shareButtons && tournamentMode === 'multi' && activeTournamentId) {
                            console.log('✅ Showing share buttons - activeTournamentId:', activeTournamentId);
                            
                            // Add class for CSS-based visibility (better for iOS)
                            shareButtons.classList.add('visible');
                            
                            // Also set inline styles with !important
                            shareButtons.style.setProperty('display', 'grid', 'important');
                            shareButtons.style.setProperty('visibility', 'visible', 'important');
                            shareButtons.style.setProperty('opacity', '1', 'important');
                            
                            // Triple-check with multiple delays (for iOS)
                            setTimeout(() => {
                                if (shareButtons) {
                                    shareButtons.classList.add('visible');
                                    shareButtons.style.setProperty('display', 'grid', 'important');
                                    console.log('✅ Re-confirmed share buttons visible (100ms)');
                                }
                            }, 100);
                            
                            setTimeout(() => {
                                if (shareButtons) {
                                    shareButtons.classList.add('visible');
                                    shareButtons.style.setProperty('display', 'grid', 'important');
                                    console.log('✅ Re-confirmed share buttons visible (500ms)');
                                }
                            }, 500);
                        } else if (shareButtons) {
                            console.log('❌ Hiding share buttons - mode:', tournamentMode, 'tournamentId:', activeTournamentId);
                            shareButtons.classList.remove('visible');
                            shareButtons.style.display = 'none';
                        }
                    }
                } catch (e) {
                    console.error('Error loading saved round:', e);
                }
            }
        }

        // Resume saved round
        function resumeSavedRound() {
            if (loadFromLocalStorage()) {
                // Restore the course data
                courseData = courses[tournamentData.course];
                
                // Re-save to persist any auto-fixes
                saveToLocalStorage();
                
                // CRITICAL FIX: Reconnect to Firebase in multi-device mode
                if (tournamentMode === 'multi' && activeTournamentId) {
                    console.log('🔄 Reconnecting to Firebase after resume...');
                    subscribToTournamentUpdates(activeTournamentId);
                }
                
                renderScoringPage();
                showPage('scoringPage');
                showRoundIndicator();
            }
        }

        // Discard saved round and start fresh
        function discardSavedRound() {
            showConfirm(
                'Discard Saved Round?',
                'This will permanently delete your saved round. Are you sure?',
                function() {
                    localStorage.removeItem('indianHillsScoring');
                    document.getElementById('resumeRoundSection').classList.remove('active');
                    
                    // Hide Resume Scoring button
                    const resumeBtn = document.getElementById('resumeScoringBtn');
                    if (resumeBtn) {
                        resumeBtn.style.display = 'none';
                    }
                    
                    hideConfirmDialog();
                }
            );
        }

        // Show round in progress indicator
        function showRoundIndicator() {
            const indicator = document.getElementById('roundIndicator');
            if (indicator) {
                indicator.classList.add('active');
            }
        }

        // Hide round in progress indicator
        function hideRoundIndicator() {
            const indicator = document.getElementById('roundIndicator');
            if (indicator) {
                indicator.classList.remove('active');
            }
        }

        // Show auto-save toast
        function showAutoSaveToast() {
            const toast = document.getElementById('autoSaveToast');
            if (toast) {
                toast.classList.add('show');
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 800);
            }
        }

        // Override saveToLocalStorage to add visual feedback
        const originalSave = saveToLocalStorage;
        saveToLocalStorage = function() {
            originalSave();
            showAutoSaveToast();
        };

        // Disable pull-to-refresh on iOS during active round
        function disablePullToRefresh() {
            document.body.style.overscrollBehavior = 'none';
            document.documentElement.style.overscrollBehavior = 'none';
        }

        // Enable pull-to-refresh
        function enablePullToRefresh() {
            document.body.style.overscrollBehavior = 'auto';
            document.documentElement.style.overscrollBehavior = 'auto';
        }

        // Switch to player view
        function switchToPlayerView() {
            currentView = 'player';
            document.getElementById('playerCards').style.display = 'block';
            document.getElementById('holeView').style.display = 'none';
            
            // Lock vertical scrolling - only allow horizontal carousel swipe
            document.getElementById('scoringPage').classList.add('players-view-active');
            
            // Update toggle button visual state
            const holeBtn = document.getElementById('toggleHoleView');
            const playerBtn = document.getElementById('togglePlayerView');
            if (playerBtn) {
                playerBtn.classList.add('active');
                playerBtn.style.background = '#1e3a5f';
                playerBtn.style.color = 'white';
            }
            if (holeBtn) {
                holeBtn.classList.remove('active');
                holeBtn.style.background = 'transparent';
                holeBtn.style.color = '#6b7280';
            }
            
            // Use compact view rendering with sorted players (claimed first, then watched)
            renderCompactPlayerView(getPlayersToShow());
        }
        
        // Player carousel state
        let currentCarouselIndex = 0;
        let carouselTouchStartX = 0;
        let carouselTouchEndX = 0;
        
        // Input mode state
        let inputMode = 'keyboard'; // 'keyboard' or 'voice'
        let currentVoiceTarget = null; // { playerIndex, holeIndex }
        let recognition = null;
        
        // Set input mode
        function setInputMode(mode) {
            inputMode = mode;
            const keyboardBtn = document.getElementById('keyboardModeBtn');
            const voiceBtn = document.getElementById('voiceModeBtn');
            
            keyboardBtn.classList.toggle('active', mode === 'keyboard');
            voiceBtn.classList.toggle('active', mode === 'voice');
            voiceBtn.classList.toggle('voice-active', mode === 'voice');
            
            // Update visual state for inline styles
            if (mode === 'keyboard') {
                if (keyboardBtn) {
                    keyboardBtn.style.background = '#1e3a5f';
                    keyboardBtn.style.color = 'white';
                }
                if (voiceBtn) {
                    voiceBtn.style.background = 'transparent';
                    voiceBtn.style.color = '#6b7280';
                }
            } else {
                if (voiceBtn) {
                    voiceBtn.style.background = '#1e3a5f';
                    voiceBtn.style.color = 'white';
                }
                if (keyboardBtn) {
                    keyboardBtn.style.background = 'transparent';
                    keyboardBtn.style.color = '#6b7280';
                }
            }
            
            // Check if voice is supported
            if (mode === 'voice' && !('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                alert('Voice input is not supported in this browser. Please use Chrome or Safari.');
                setInputMode('keyboard');
            }
        }
        
        // Initialize speech recognition
        function initSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) return null;
            
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';
            recognition.maxAlternatives = 3;
            
            recognition.onresult = (event) => {
                const result = event.results[0][0].transcript.toLowerCase().trim();
                console.log('Voice result:', result);
                processVoiceResult(result);
            };
            
            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                hideVoiceListening();
                if (event.error === 'not-allowed') {
                    alert('Microphone access denied. Please enable microphone permissions.');
                    setInputMode('keyboard');
                }
            };
            
            recognition.onend = () => {
                // Auto-hide after timeout if no result
                setTimeout(() => {
                    hideVoiceListening();
                }, 500);
            };
            
            return recognition;
        }
        
        // Process voice input result
        function processVoiceResult(result) {
            if (!currentVoiceTarget) {
                console.log('No voice target, ignoring result:', result);
                return;
            }
            
            // Capture target immediately in case it gets cleared
            const targetPlayerIndex = currentVoiceTarget.playerIndex;
            const targetHoleIndex = currentVoiceTarget.holeIndex;
            
            let score = null;
            
            // Direct number parsing
            const numMatch = result.match(/\d+/);
            if (numMatch) {
                score = parseInt(numMatch[0]);
            }
            
            // Word to number mapping
            const wordNumbers = {
                'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,
                'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9,
                'ten': 10, 'eleven': 11, 'twelve': 12
            };
            
            for (const [word, num] of Object.entries(wordNumbers)) {
                if (result.includes(word)) {
                    score = num;
                    break;
                }
            }
            
            // Golf terms (relative to par)
            if (courseData && courseData.holes[targetHoleIndex]) {
                const hole = courseData.holes[targetHoleIndex];
                const par = hole.par;
                
                if (result.includes('ace') || result.includes('hole in one')) {
                    score = 1;
                } else if (result.includes('double eagle') || result.includes('albatross')) {
                    score = par - 3;
                } else if (result.includes('eagle')) {
                    score = par - 2;
                } else if (result.includes('birdie')) {
                    score = par - 1;
                } else if (result.includes('par')) {
                    score = par;
                } else if (result.includes('bogey') && !result.includes('double') && !result.includes('triple')) {
                    score = par + 1;
                } else if (result.includes('double bogey') || result.includes('double')) {
                    score = par + 2;
                } else if (result.includes('triple bogey') || result.includes('triple')) {
                    score = par + 3;
                }
            }
            
            // Show result and save
            if (score !== null && score >= 1 && score <= 15) {
                document.getElementById('voiceResult').textContent = score;
                
                setTimeout(() => {
                    updateScore(targetPlayerIndex, targetHoleIndex, score);
                    hideVoiceListening();
                    // Refresh appropriate view
                    if (currentView === 'hole') {
                        renderHoleView();
                    } else {
                        switchToPlayerView();
                    }
                }, 800);
            } else {
                document.getElementById('voiceResult').textContent = '?';
                setTimeout(hideVoiceListening, 1000);
            }
        }
        
        // Show voice listening overlay
        function showVoiceListening(playerIndex, holeIndex) {
            currentVoiceTarget = { playerIndex, holeIndex };
            document.getElementById('voiceResult').textContent = '';
            document.getElementById('voiceListening').classList.add('active');
            
            if (!recognition) {
                recognition = initSpeechRecognition();
            }
            
            if (recognition) {
                try {
                    recognition.start();
                } catch (e) {
                    console.error('Could not start recognition:', e);
                }
            }
            
            // Auto-timeout after 4 seconds
            setTimeout(() => {
                if (document.getElementById('voiceListening').classList.contains('active')) {
                    hideVoiceListening();
                }
            }, 4000);
        }
        
        // Hide voice listening overlay
        function hideVoiceListening() {
            document.getElementById('voiceListening').classList.remove('active');
            currentVoiceTarget = null;
            if (recognition) {
                try {
                    recognition.stop();
                } catch (e) {}
            }
        }
        
        // Handle score cell click (keyboard or voice based on mode)
        function handleScoreCellClick(playerIndex, holeIndex, currentScore) {
            if (inputMode === 'voice') {
                showVoiceListening(playerIndex, holeIndex);
            } else {
                // Keyboard mode - show prompt
                const hole = courseData.holes[holeIndex];
                const newScore = prompt(`Hole ${hole.number} (Par ${hole.par}) - Enter score:`, currentScore || hole.par);
                if (newScore !== null) {
                    const score = parseInt(newScore);
                    if (!isNaN(score) && score >= 0 && score <= 15) {
                        updateScore(playerIndex, holeIndex, score);
                        renderScoringPage();
                    }
                }
            }
        }
        
        // Render compact player view (9-column grid)
        function renderCompactPlayerView(playersToShow) {
            const container = document.getElementById('playerCards');
            
            // Safety check - ensure courseData is available
            if (!courseData || !courseData.holes) {
                console.warn('⚠️ renderCompactPlayerView: courseData not loaded yet');
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: #6b7280;">Loading course data...</div>';
                // Try again after a short delay
                setTimeout(() => {
                    if (courseData && courseData.holes) {
                        renderCompactPlayerView(playersToShow);
                    }
                }, 500);
                return;
            }
            
            // Build carousel with compact cards (6 columns x 3 rows)
            let slidesHTML = playersToShow.map((player, idx) => {
                const actualPlayerIndex = tournamentData.players.indexOf(player);
                const total = player.scores.reduce((sum, score) => sum + (score || 0), 0);
                
                // Calculate running to-par based only on holes played
                let holesPlayed = 0;
                let parForPlayedHoles = 0;
                for (let i = 0; i < 18; i++) {
                    if (player.scores[i] && player.scores[i] > 0) {
                        holesPlayed++;
                        parForPlayedHoles += courseData.holes[i].par;
                    }
                }
                const toPar = holesPlayed > 0 ? total - parForPlayedHoles : 0;
                const toParText = holesPlayed === 0 ? '-' : (toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar));
                // Display handicap: negative internally means plus handicap (e.g., -1 shows as +1)
                const hcpDisplay = player.handicap !== 0 ? ` (${player.handicap > 0 ? player.handicap : '+' + Math.abs(player.handicap)})` : '';
                
                // Check if this is a watched player (view only)
                // Hosts/co-hosts in HOST mode can edit all players
                // Hosts/co-hosts in PLAYER mode can only edit their claimed players
                const isHostInHostModeCompact = canManageTournament() && !isHostInPlayerMode();
                const isMyClaimedPlayerCompact = isClaimedByMe(player);
                const isWatchedPlayer = tournamentMode === 'multi' && !isHostInHostModeCompact && !isMyClaimedPlayerCompact;
                const watchIndicator = isWatchedPlayer ? ' 👁' : '';
                
                // Calculate front/back 9 totals
                const front9 = player.scores.slice(0, 9).reduce((sum, s) => sum + (s || 0), 0);
                const back9 = player.scores.slice(9, 18).reduce((sum, s) => sum + (s || 0), 0);
                
                // Generate hole cells in 3 rows of 6
                let row1Cells = ''; // Holes 1-6
                let row2Cells = ''; // Holes 7-12
                let row3Cells = ''; // Holes 13-18
                
                // Determine net method for dots
                let netMethod = 'full';
                const gameTypeLower = tournamentData.gameType.toLowerCase();
                if (gameTypeLower.includes('18 max')) {
                    netMethod = '18max';
                } else if (gameTypeLower.includes('1/2 pop') || gameTypeLower.includes('half pop')) {
                    netMethod = 'half';
                }
                
                for (let i = 0; i < 18; i++) {
                    const hole = courseData.holes[i];
                    const score = player.scores[i];
                    const diff = score ? score - hole.par : 0;
                    let scoreClass = 'empty';
                    if (score > 0) {
                        if (diff <= -2) scoreClass = 'eagle-better';
                        else if (diff === -1) scoreClass = 'birdie';
                        else if (diff === 0) scoreClass = 'par';
                        else if (diff === 1) scoreClass = 'bogey';
                        else scoreClass = 'double-plus';
                    }
                    
                    // Calculate handicap dots
                    let hcpDotsHtml = '';
                    if (player.handicap !== 0) {
                        const strokes = getHandicapStrokesForHole(player.handicap, hole.handicap, netMethod);
                        if (strokes !== 0) {
                            const isHalfPop = netMethod === 'half';
                            const dotCount = isHalfPop ? Math.abs(strokes * 2) : Math.abs(strokes);
                            const dotColor = strokes > 0 ? 'green' : 'red';
                            
                            hcpDotsHtml = '<div class="hcp-dots-compact">';
                            for (let d = 0; d < Math.min(dotCount, 3); d++) {
                                hcpDotsHtml += `<span class="hcp-dot-compact ${dotColor}"></span>`;
                            }
                            hcpDotsHtml += '</div>';
                        }
                    }
                    
                    // Calculate net score for display
                    let netScoreHTML = '';
                    if (score > 0 && player.handicap !== 0) {
                        const netScore = getNetScore(score, player.handicap, hole.handicap, netMethod);
                        netScoreHTML = `<div class="net-score">(${netScore})</div>`;
                    }
                    
                    const cellHTML = `
                        <div class="hole-cell" onclick="handleCompactCellClick(${actualPlayerIndex}, ${i}, ${score || 0}, '${player.name}')">
                            <div class="hole-num">${hole.number}</div>
                            <div class="par-hcp-stack">
                                <div class="par-hcp-line">
                                    <span class="label">Par</span>
                                    <span class="value">${hole.par}</span>
                                </div>
                                <div class="par-hcp-line">
                                    <span class="label">Hcp</span>
                                    <span class="value">${hole.handicap}</span>
                                </div>
                            </div>
                            ${hcpDotsHtml}
                            <div class="score-cell ${scoreClass}">
                                ${score || '-'}
                            </div>
                            ${netScoreHTML}
                        </div>
                    `;
                    
                    if (i < 6) row1Cells += cellHTML;
                    else if (i < 12) row2Cells += cellHTML;
                    else row3Cells += cellHTML;
                }
                
                return `
                    <div class="player-carousel-slide" data-index="${idx}">
                        <div class="player-card-compact ${isWatchedPlayer ? 'watched' : ''}">
                            <div class="player-header-compact">
                                <div class="player-name-compact">
                                    <span>${player.name}${watchIndicator}</span>
                                </div>
                                ${(() => {
                                    const signed = isScorecardSigned(player.name);
                                    if (signed) {
                                        return `<button onclick="showSignScorecardModal('${player.name.replace(/'/g, "\\'")}', ${player.handicap}, ${actualPlayerIndex})" style="padding: 4px 8px; background: #166534; color: white; border: none; border-radius: 6px; font-size: 11px; font-weight: 700; cursor: pointer;">✓</button>`;
                                    } else {
                                        return `<button onclick="showSignScorecardModal('${player.name.replace(/'/g, "\\'")}', ${player.handicap}, ${actualPlayerIndex})" style="padding: 4px 8px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 11px; font-weight: 700; cursor: pointer;">Sign</button>`;
                                    }
                                })()}
                                <div class="player-total-compact">${total > 0 ? total : '-'} (${toParText})</div>
                            </div>
                            
                            <div class="nine-section">
                                <div class="nine-section-label">
                                    <span>HOLES 1-6</span>
                                </div>
                                <div class="holes-grid-6">
                                    ${row1Cells}
                                </div>
                            </div>
                            
                            <div class="nine-section">
                                <div class="nine-section-label">
                                    <span>HOLES 7-12</span>
                                </div>
                                <div class="holes-grid-6">
                                    ${row2Cells}
                                </div>
                            </div>
                            
                            <div class="nine-section">
                                <div class="nine-section-label">
                                    <span>HOLES 13-18</span>
                                </div>
                                <div class="holes-grid-6">
                                    ${row3Cells}
                                </div>
                            </div>
                            
                            <div class="totals-row">
                                <div class="total-item">
                                    <div class="total-label">OUT</div>
                                    <div class="total-value">${front9 > 0 ? front9 : '-'}</div>
                                </div>
                                <div class="total-item">
                                    <div class="total-label">IN</div>
                                    <div class="total-value">${back9 > 0 ? back9 : '-'}</div>
                                </div>
                                <div class="total-item">
                                    <div class="total-label">TOTAL</div>
                                    <div class="total-value">${total > 0 ? total : '-'}</div>
                                </div>
                                <div class="total-item">
                                    <div class="total-label">TO PAR</div>
                                    <div class="total-value">${toParText}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Single player - no carousel needed
            if (playersToShow.length === 1) {
                container.innerHTML = `
                    <div style="padding: 0 8px;">
                        <div style="display: flex; justify-content: center; gap: 8px; padding: 6px 8px; background: rgba(255,255,255,0.95); border-radius: 6px; margin-bottom: 8px;">
                            <button id="fullscreenToggleBtn" onclick="toggleFullscreenPlayerView()" title="Toggle fullscreen" style="padding: 8px 14px; background: #1e3a5f; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">⛶</button>
                        </div>
                        ${slidesHTML.replace('class="player-carousel-slide"', '')}
                    </div>
                `;
                return;
            }
            
            // Store players globally for nav access
            window.carouselPlayers = playersToShow;
            
            // Get prev/next player names for initial state (infinite wrap)
            const getFirstName = (name) => name ? name.split(' ')[0] : '';
            // At first player: prev wraps to last, next goes to second
            const prevPlayerName = playersToShow.length > 1 ? getFirstName(playersToShow[playersToShow.length - 1].name) : '';
            const nextPlayerName = playersToShow.length > 1 ? getFirstName(playersToShow[1].name) : '';
            
            // Multiple players - use carousel with player names in nav (infinite - always enabled)
            const carouselHTML = `
                <div class="carousel-nav" style="display: flex; align-items: center; justify-content: space-between; padding: 6px 8px; background: rgba(255,255,255,0.95); border-radius: 6px; margin: 0 8px 8px 8px; gap: 4px;">
                    <button class="carousel-nav-btn" id="carouselPrev" onclick="carouselPrev()" style="display: flex; align-items: center; gap: 3px; padding: 8px 10px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; flex: 1; justify-content: center; max-width: 110px;">
                        <span>←</span> <span id="prevPlayerName" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${prevPlayerName}</span>
                    </button>
                    <button onclick="showPlayerSearchModal()" title="Search players" style="padding: 8px 10px; background: #f1f5f9; border: 1px solid #d1d5db; border-radius: 6px; cursor: pointer; font-size: 14px;">🔍</button>
                    <button id="fullscreenToggleBtn" onclick="toggleFullscreenPlayerView()" title="Toggle fullscreen" style="padding: 8px 10px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">⛶</button>
                    <button class="carousel-nav-btn" id="carouselNext" onclick="carouselNext()" style="display: flex; align-items: center; gap: 3px; padding: 8px 10px; background: #1e3a5f; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; flex: 1; justify-content: center; max-width: 110px;">
                        <span id="nextPlayerName" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${nextPlayerName}</span> <span>→</span>
                    </button>
                </div>
                <div class="player-carousel" id="playerCarousel">
                    <div class="player-carousel-track" id="carouselTrack">
                        ${slidesHTML}
                    </div>
                </div>
                <div class="carousel-dots" id="carouselDots">
                    ${playersToShow.map((_, idx) => `
                        <div class="carousel-dot ${idx === 0 ? 'active' : ''}" onclick="goToCarouselSlide(${idx})"></div>
                    `).join('')}
                </div>
            `;
            
            container.innerHTML = carouselHTML;
            
            // Setup swipe listeners
            const carousel = document.getElementById('playerCarousel');
            
            carousel.addEventListener('touchstart', (e) => {
                carouselTouchStartX = e.changedTouches[0].screenX;
            }, { passive: true });
            
            carousel.addEventListener('touchend', (e) => {
                carouselTouchEndX = e.changedTouches[0].screenX;
                handleCarouselSwipe();
            }, { passive: true });
            
            // CRITICAL: Apply current carousel position after DOM rebuild
            // Use requestAnimationFrame to ensure DOM is fully rendered
            requestAnimationFrame(() => {
                updateCarouselPosition();
            });
        }
        
        // Player search modal
        function showPlayerSearchModal() {
            const players = window.carouselPlayers || [];
            if (players.length === 0) return;
            
            let listHTML = players.map((p, idx) => `
                <button onclick="goToCarouselSlide(${idx}); closePlayerSearchModal();" style="
                    display: block;
                    width: 100%;
                    padding: 14px 16px;
                    margin-bottom: 8px;
                    background: ${idx === currentCarouselIndex ? '#1e3a5f' : '#f1f5f9'};
                    color: ${idx === currentCarouselIndex ? 'white' : '#1e293b'};
                    border: none;
                    border-radius: 8px;
                    font-size: 16px;
                    font-weight: 600;
                    text-align: left;
                    cursor: pointer;
                ">${p.name}</button>
            `).join('');
            
            const modal = document.createElement('div');
            modal.id = 'playerSearchModal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;';
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; padding: 20px; width: 100%; max-width: 320px; max-height: 70vh; overflow-y: auto;">
                    <h3 style="margin: 0 0 16px 0; color: #1e3a5f; font-size: 18px;">Jump to Player</h3>
                    ${listHTML}
                    <button onclick="closePlayerSearchModal()" style="width: 100%; padding: 14px; background: #e2e8f0; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 8px;">Cancel</button>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function closePlayerSearchModal() {
            const modal = document.getElementById('playerSearchModal');
            if (modal) modal.remove();
        }
        
        // Fullscreen state
        let isFullscreenPlayerView = false;
        
        function toggleFullscreenPlayerView() {
            const container = document.getElementById('playerCards');
            const scoringHeader = document.querySelector('.scoring-header');
            const btn = document.getElementById('fullscreenToggleBtn');
            
            if (isFullscreenPlayerView) {
                // Exit fullscreen
                container.style.position = '';
                container.style.top = '';
                container.style.left = '';
                container.style.right = '';
                container.style.bottom = '';
                container.style.zIndex = '';
                container.style.background = '';
                container.style.paddingTop = '';
                container.style.overflow = '';
                container.style.overflowY = '';
                container.style.overflowX = '';
                container.style.touchAction = '';
                container.classList.remove('fullscreen-mode');
                document.body.style.overflow = '';
                if (scoringHeader) scoringHeader.style.display = '';
                if (btn) btn.textContent = '⛶';
                isFullscreenPlayerView = false;
            } else {
                // Enter fullscreen
                container.style.position = 'fixed';
                container.style.top = '0';
                container.style.left = '0';
                container.style.right = '0';
                container.style.bottom = '0';
                container.style.zIndex = '9999';
                container.style.background = 'linear-gradient(135deg, #166534 0%, #166534 20%, #1e3a5f 60%, #1e3a5f 100%)';
                container.style.paddingTop = '20px';
                container.style.overflow = 'hidden'; // Lock all scroll
                container.style.overflowY = 'hidden'; // Lock vertical scroll
                container.style.overflowX = 'hidden'; // Lock horizontal scroll (swipe handled by JS)
                container.style.touchAction = 'pan-x'; // Only allow horizontal touch
                container.classList.add('fullscreen-mode');
                document.body.style.overflow = 'hidden'; // Prevent body scroll
                if (scoringHeader) scoringHeader.style.display = 'none';
                if (btn) btn.textContent = '✕';
                isFullscreenPlayerView = true;
            }
        }
        
        // Handle compact cell click - voice or expanded view
        function handleCompactCellClick(playerIndex, holeIndex, currentScore, playerName) {
            // Check if scorecard is signed (locked)
            if (isScorecardSigned(playerName)) {
                showNotification('Scorecard Signed', `${playerName}'s scorecard is locked. Tap ✓ to unsign.`);
                return;
            }
            
            // Check if this is a watched player (view only, no scoring) - doesn't apply to hosts/co-hosts
            if (tournamentMode === 'multi' && !canManageTournament()) {
                const player = tournamentData.players[playerIndex];
                // If player is not claimed by this device, they're being watched - no interaction
                if (player && !isClaimedByMe(player)) {
                    // Just viewing - no popup
                    return;
                }
            }
            
            if (inputMode === 'voice') {
                showVoiceListening(playerIndex, holeIndex);
            } else {
                showExpandedScoreInput(playerIndex, holeIndex, currentScore, playerName);
            }
        }
        
        // Expanded score input state
        let expandedTarget = null;
        let expandedCurrentScore = 0;
        
        // Putt tracking state
        let puttTarget = null; // { playerIndex, holeIndex }
        
        // Initialize putts array for a player if not exists
        function initPlayerPutts(player) {
            if (!player.putts) {
                player.putts = new Array(18).fill(null);
            }
        }
        
        // Show putt input popup
        function showPuttPopup(playerIndex, holeIndex) {
            const player = tournamentData.players[playerIndex];
            initPlayerPutts(player);
            
            puttTarget = { playerIndex, holeIndex };
            
            const hole = courseData.holes[holeIndex];
            const currentPutt = player.putts[holeIndex];
            
            document.getElementById('puttPopupInfo').textContent = `Hole ${holeIndex + 1} • Par ${hole.par}`;
            
            // Generate putt option buttons (0-7 in 4x2 grid)
            let optionsHtml = '';
            for (let i = 0; i <= 7; i++) {
                const isSelected = currentPutt === i;
                optionsHtml += `<button class="putt-option-btn ${isSelected ? 'selected' : ''}" onclick="setPutt(${i})">${i}</button>`;
            }
            document.getElementById('puttOptions').innerHTML = optionsHtml;
            
            document.getElementById('puttPopup').classList.add('active');
        }
        
        // Set putt value and close popup
        function setPutt(value) {
            if (!puttTarget) return;
            
            const { playerIndex, holeIndex } = puttTarget;
            const player = tournamentData.players[playerIndex];
            initPlayerPutts(player);
            
            player.putts[holeIndex] = value;
            
            // Save and sync
            saveToLocalStorage();
            
            // Sync to Firebase if in multi-device mode
            if (activeTournamentId && tournamentMode === 'multi') {
                updatePlayerPutts(activeTournamentId, player.name, holeIndex, value);
            }
            
            closePuttPopup();
            
            // Refresh the current view
            if (currentView === 'hole') {
                renderHoleView();
            }
        }
        
        // Clear putt for current hole
        function clearPutt() {
            if (!puttTarget) return;
            
            const { playerIndex, holeIndex } = puttTarget;
            const player = tournamentData.players[playerIndex];
            initPlayerPutts(player);
            
            player.putts[holeIndex] = null;
            
            // Save and sync
            saveToLocalStorage();
            
            // Sync to Firebase if in multi-device mode
            if (activeTournamentId && tournamentMode === 'multi') {
                updatePlayerPutts(activeTournamentId, player.name, holeIndex, null);
            }
            
            closePuttPopup();
            
            // Refresh the current view
            if (currentView === 'hole') {
                renderHoleView();
            }
        }
        
        // Close putt popup
        function closePuttPopup() {
            document.getElementById('puttPopup').classList.remove('active');
            puttTarget = null;
        }
        
        // Update player putts in Firebase
        async function updatePlayerPutts(tournamentId, playerName, holeIndex, puttValue) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                if (!tournamentDoc.exists) return;
                
                const tournament = tournamentDoc.data();
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                
                if (playerIndex === -1) return;
                
                // Initialize putts array if needed
                if (!tournament.players[playerIndex].putts) {
                    tournament.players[playerIndex].putts = new Array(18).fill(null);
                }
                
                tournament.players[playerIndex].putts[holeIndex] = puttValue;
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                console.log(`✅ Putt synced: ${playerName} hole ${holeIndex + 1} = ${puttValue}`);
            } catch (error) {
                console.error('Error updating putts:', error);
            }
        }
        
        // Get total putts for a player (returns null if incomplete)
        function getPlayerTotalPutts(player) {
            if (!player.putts) return null;
            
            // Check if all 18 holes have putts entered
            for (let i = 0; i < 18; i++) {
                if (player.putts[i] === null || player.putts[i] === undefined) {
                    return null;
                }
            }
            
            // Sum all putts
            return player.putts.reduce((sum, p) => sum + (p || 0), 0);
        }
        
        // Check if any player has complete putt data
        function hasAnyCompletePuttData() {
            if (!tournamentData || !tournamentData.players) return false;
            
            return tournamentData.players.some(player => getPlayerTotalPutts(player) !== null);
        }
        
        // Get player stats totals from playerStats storage
        function getPlayerStatsForScorecard(playerName) {
            loadPlayerStatsFromLocalStorage();
            initPlayerStats(playerName);
            
            const stats = playerStats[playerName];
            if (!stats) return null;
            
            // Calculate FIR stats (exclude par 3s)
            let firHit = 0, firTotal = 0;
            for (let i = 0; i < 18; i++) {
                if (courseData.holes[i].par !== 3) {
                    if (stats.fir[i] !== null && stats.fir[i] !== undefined) {
                        firTotal++;
                        if (stats.fir[i] === true) firHit++;
                    }
                }
            }
            
            // Calculate GIR stats
            let girHit = 0, girTotal = 0;
            for (let i = 0; i < 18; i++) {
                if (stats.gir[i] !== null && stats.gir[i] !== undefined) {
                    girTotal++;
                    if (stats.gir[i] === true) girHit++;
                }
            }
            
            // Calculate Putts total
            let puttsTotal = 0, puttsCount = 0;
            for (let i = 0; i < 18; i++) {
                if (stats.putts[i] !== null && stats.putts[i] !== undefined) {
                    puttsTotal += stats.putts[i];
                    puttsCount++;
                }
            }
            
            // Calculate Dots total
            let dotsTotal = 0, dotsCount = 0;
            for (let i = 0; i < 18; i++) {
                if (stats.dots[i] !== null && stats.dots[i] !== undefined) {
                    dotsTotal += stats.dots[i];
                    dotsCount++;
                }
            }
            
            return {
                fir: firTotal > 0 ? { hit: firHit, total: firTotal } : null,
                gir: girTotal > 0 ? { hit: girHit, total: girTotal } : null,
                putts: puttsCount > 0 ? puttsTotal : null,
                dots: dotsCount > 0 ? dotsTotal : null,
                // Per-hole data for individual cards
                firByHole: stats.fir,
                girByHole: stats.gir,
                puttsByHole: stats.putts,
                dotsByHole: stats.dots
            };
        }
        
        // Check if any player has stats data for a specific stat type
        function hasAnyStatsData(statType) {
            if (!tournamentData || !tournamentData.players) return false;
            
            return tournamentData.players.some(player => {
                const stats = getPlayerStatsForScorecard(player.name);
                if (!stats) return false;
                
                if (statType === 'fir') return stats.fir !== null;
                if (statType === 'gir') return stats.gir !== null;
                if (statType === 'putts') return stats.putts !== null;
                if (statType === 'dots') return stats.dots !== null;
                return false;
            });
        }
        
        // Show expanded score input modal
        function showExpandedScoreInput(playerIndex, holeIndex, currentScore, playerName) {
            expandedTarget = { playerIndex, holeIndex };
            expandedCurrentScore = currentScore || 0;
            
            const hole = courseData.holes[holeIndex];
            const par = hole.par;
            
            document.getElementById('expandedHoleNumber').textContent = `HOLE ${hole.number}`;
            document.getElementById('expandedHoleInfo').textContent = `Par ${par} • HCP ${hole.handicap}`;
            document.getElementById('expandedPlayerName').textContent = playerName;
            document.getElementById('expandedScoreValue').textContent = expandedCurrentScore || '-';
            
            // Generate quick score buttons based on par (8 buttons: Eagle through +5)
            const quickScores = document.getElementById('expandedQuickScores');
            let quickHTML = '';
            for (let s = Math.max(1, par - 2); s <= par + 5; s++) {
                const label = s === par - 2 ? `${s} (Eagle)` : 
                              s === par - 1 ? `${s} (Birdie)` : 
                              s === par ? `${s} (Par)` : 
                              s === par + 1 ? `${s} (Bogey)` : 
                              s === par + 2 ? `${s} (Dbl)` :
                              s === par + 3 ? `${s} (Trpl)` :
                              s === par + 4 ? `${s} (Quad)` :
                              s === par + 5 ? `${s} (Qunt)` : s;
                quickHTML += `<button class="quick-score-btn" onclick="setExpandedScore(${s})">${label}</button>`;
            }
            quickScores.innerHTML = quickHTML;
            
            document.getElementById('expandedScoreModal').classList.add('active');
        }
        
        function closeExpandedScore() {
            document.getElementById('expandedScoreModal').classList.remove('active');
            expandedTarget = null;
        }
        
        // Quick score tap - auto save and close immediately
        async function setExpandedScore(score) {
            expandedCurrentScore = score;
            document.getElementById('expandedScoreValue').textContent = score;
            
            // Auto-save and close for quick score taps
            if (expandedTarget && score > 0) {
                // Capture values BEFORE closing (in case async operations are slow)
                const playerIndex = expandedTarget.playerIndex;
                const holeIndex = expandedTarget.holeIndex;
                const par = (courseData?.holes?.[holeIndex]?.par) || 4;
                
                // Close modal first for responsive feel
                closeExpandedScore();
                
                // Save WITHOUT re-rendering (skipRender = true)
                await updateScore(playerIndex, holeIndex, score, true);
                
                // Just update the display in place - NO carousel movement
                if (currentView === 'hole') {
                    renderHoleView();
                } else {
                    // Update only the specific score cell in COMPACT view
                    updateCompactScoreDisplay(playerIndex, holeIndex, score);
                    // Also refresh the player view to ensure totals and colors are correct
                    setTimeout(() => refreshPlayerView(), 100);
                }
            }
        }
        
        function expandedIncrement() {
            if (expandedCurrentScore < 15) {
                expandedCurrentScore++;
                document.getElementById('expandedScoreValue').textContent = expandedCurrentScore;
            }
        }
        
        function expandedDecrement() {
            if (expandedCurrentScore > 0) {
                expandedCurrentScore--;
                document.getElementById('expandedScoreValue').textContent = expandedCurrentScore || '-';
            }
        }
        
        // Manual save - for when user adjusts with +/- buttons or wants to clear
        async function saveExpandedScore() {
            if (expandedTarget) {
                const playerIndex = expandedTarget.playerIndex;
                const holeIndex = expandedTarget.holeIndex;
                const scoreToSave = expandedCurrentScore;
                
                // Close modal first for responsive feel
                closeExpandedScore();
                
                if (scoreToSave > 0) {
                    // Save WITHOUT re-rendering (skipRender = true)
                    await updateScore(playerIndex, holeIndex, scoreToSave, true);
                } else {
                    // Clear the score (set to 0/null)
                    tournamentData.players[playerIndex].scores[holeIndex] = 0;
                    saveToLocalStorage();
                    
                    // Also sync to Firebase if in multi-device mode
                    if (activeTournamentId && tournamentMode === 'multi') {
                        const playerName = tournamentData.players[playerIndex].name;
                        await updatePlayerScore(activeTournamentId, playerName, holeIndex, 0);
                    }
                }
                
                // Just update the display in place - NO carousel movement
                if (currentView === 'hole') {
                    renderHoleView();
                } else {
                    // Update only the specific score cell in COMPACT view
                    updateCompactScoreDisplay(playerIndex, holeIndex, scoreToSave);
                    // Also refresh the player view to ensure totals and colors are correct
                    setTimeout(() => refreshPlayerView(), 100);
                }
            } else {
                closeExpandedScore();
            }
        }
        
        // Initialize player carousel for swipe navigation
        
        function handleCarouselSwipe() {
            const swipeThreshold = 50;
            const diff = carouselTouchStartX - carouselTouchEndX;
            
            if (Math.abs(diff) > swipeThreshold) {
                if (diff > 0) {
                    // Swiped left - go next
                    carouselNext();
                } else {
                    // Swiped right - go prev
                    carouselPrev();
                }
            }
        }
        
        function carouselNext() {
            const track = document.getElementById('carouselTrack');
            const slides = track?.querySelectorAll('.player-carousel-slide');
            if (!slides || slides.length === 0) return;
            
            // Infinite wrap - go to first if at end
            if (currentCarouselIndex >= slides.length - 1) {
                currentCarouselIndex = 0;
            } else {
                currentCarouselIndex++;
            }
            updateCarouselPosition();
        }
        
        function carouselPrev() {
            const track = document.getElementById('carouselTrack');
            const slides = track?.querySelectorAll('.player-carousel-slide');
            if (!slides || slides.length === 0) return;
            
            // Infinite wrap - go to last if at beginning
            if (currentCarouselIndex <= 0) {
                currentCarouselIndex = slides.length - 1;
            } else {
                currentCarouselIndex--;
            }
            updateCarouselPosition();
        }
        
        function goToCarouselSlide(index) {
            const track = document.getElementById('carouselTrack');
            const slides = track?.querySelectorAll('.player-carousel-slide');
            if (!slides || index < 0 || index >= slides.length) return;
            
            currentCarouselIndex = index;
            updateCarouselPosition();
        }
        
        function resetCarousel() {
            currentCarouselIndex = 0;
            updateCarouselPosition();
        }
        
        function updateCarouselPosition() {
            const track = document.getElementById('carouselTrack');
            const slides = track?.querySelectorAll('.player-carousel-slide');
            if (!track || !slides) return;
            
            // Move track
            track.style.transform = `translateX(-${currentCarouselIndex * 100}%)`;
            
            // Update dots
            const dots = document.querySelectorAll('.carousel-dot');
            dots.forEach((dot, idx) => {
                dot.classList.toggle('active', idx === currentCarouselIndex);
            });
            
            // Update nav buttons with player names
            updateCarouselNav();
        }
        
        function updateCarouselNav() {
            const players = window.carouselPlayers || [];
            if (players.length === 0) return;
            
            const prevBtn = document.getElementById('carouselPrev');
            const nextBtn = document.getElementById('carouselNext');
            const prevName = document.getElementById('prevPlayerName');
            const nextName = document.getElementById('nextPlayerName');
            
            // Infinite carousel - buttons always enabled
            if (prevBtn) {
                prevBtn.disabled = false;
                prevBtn.style.opacity = '1';
            }
            if (nextBtn) {
                nextBtn.disabled = false;
                nextBtn.style.opacity = '1';
            }
            
            // Update player names in nav buttons (wrap around)
            if (prevName && players.length > 0) {
                // Previous player wraps to last if at beginning
                const prevIndex = currentCarouselIndex === 0 ? players.length - 1 : currentCarouselIndex - 1;
                const prevPlayer = players[prevIndex];
                prevName.textContent = prevPlayer ? prevPlayer.name.split(' ')[0] : '';
            }
            if (nextName && players.length > 0) {
                // Next player wraps to first if at end
                const nextIndex = currentCarouselIndex >= players.length - 1 ? 0 : currentCarouselIndex + 1;
                const nextPlayer = players[nextIndex];
                nextName.textContent = nextPlayer ? nextPlayer.name.split(' ')[0] : '';
            }
        }

        // Switch to hole view
        function switchToHoleView() {
            currentView = 'hole';
            document.getElementById('playerCards').style.display = 'none';
            document.getElementById('holeView').style.display = 'block';
            
            // Unlock vertical scrolling for hole view
            document.getElementById('scoringPage').classList.remove('players-view-active');
            
            // Update toggle button visual state
            const holeBtn = document.getElementById('toggleHoleView');
            const playerBtn = document.getElementById('togglePlayerView');
            if (holeBtn) {
                holeBtn.classList.add('active');
                holeBtn.style.background = '#1e3a5f';
                holeBtn.style.color = 'white';
            }
            if (playerBtn) {
                playerBtn.classList.remove('active');
                playerBtn.style.background = 'transparent';
                playerBtn.style.color = '#6b7280';
            }
            
            renderHoleView();
        }

        // Render hole view
        async function renderHoleView() {
            console.log('=== RENDER HOLE VIEW CALLED ===');
            console.log('tournamentData:', tournamentData);
            console.log('tournamentData.players:', tournamentData?.players);
            console.log('currentHole:', currentHole);
            console.log('courseData:', courseData);
            console.log('isHost:', isHost, 'tournamentMode:', tournamentMode);
            
            // Safety check for tournament data
            if (!tournamentData || !tournamentData.players || tournamentData.players.length === 0) {
                console.error('❌ No tournament data or players available');
                document.getElementById('holeViewContent').innerHTML = '<p style="text-align:center;padding:20px;">No players found. Go back and add players.</p>';
                return;
            }
            
            // Safety check for course data - try multiple sources
            if (!courseData || !courseData.holes) {
                console.error('❌ No course data available, attempting to load...');
                console.log('Looking for course:', tournamentData.course);
                console.log('Built-in courses available:', Object.keys(courses));
                
                // Try built-in courses first
                courseData = courses[tournamentData.course];
                console.log('From built-in courses:', !!courseData);
                
                // Try custom courses
                if (!courseData) {
                    courseData = customCourses[tournamentData.course];
                    console.log('From custom courses:', !!courseData);
                }
                
                // Try embedded course data from tournament
                if (!courseData && tournamentData.courseData) {
                    console.log('📍 Loading course data from tournament embed');
                    courseData = tournamentData.courseData;
                    customCourses[tournamentData.course] = tournamentData.courseData;
                }
                
                // For API courses, try to fetch directly from Golf API
                if (!courseData && tournamentData.course && tournamentData.course.startsWith('api_')) {
                    const apiCourseId = tournamentData.course.replace('api_', '');
                    console.log('🌐 Attempting to fetch from Golf API for course:', apiCourseId);
                    try {
                        const response = await fetch(`https://api.golfcourseapi.com/v1/courses/${apiCourseId}`, {
                            headers: { 'Authorization': `Key ${GOLF_API_KEY}` }
                        });
                        if (response.ok) {
                            const data = await response.json();
                            const course = data.course || data;
                            console.log('✅ Got course from Golf API:', course.club_name);
                            
                            // Convert to our format
                            const convertedCourse = {
                                name: course.club_name || course.course_name,
                                totalPar: 72,
                                tees: {},
                                holes: []
                            };
                            
                            let teesArray = course.tees?.male || course.tees?.female || (Array.isArray(course.tees) ? course.tees : []);
                            let holesFromTee = null;
                            
                            teesArray.forEach(tee => {
                                const teeKey = tee.tee_name?.toLowerCase().replace(/\s+/g, '_') || 'default';
                                convertedCourse.tees[teeKey] = {
                                    name: tee.tee_name || 'Default',
                                    rating: parseFloat(tee.course_rating) || 72,
                                    slope: parseInt(tee.slope_rating) || 113,
                                    yardage: parseInt(tee.total_yards) || 6000,
                                    par: parseInt(tee.par_total) || 72
                                };
                                if (!holesFromTee && tee.holes?.length > 0) {
                                    holesFromTee = tee.holes;
                                }
                            });
                            
                            if (Object.keys(convertedCourse.tees).length === 0) {
                                convertedCourse.tees.default = { name: 'Default', rating: 72, slope: 113, yardage: 6000, par: 72 };
                            }
                            convertedCourse.defaultTee = Object.keys(convertedCourse.tees)[0];
                            
                            if (holesFromTee?.length > 0) {
                                convertedCourse.holes = holesFromTee.map((h, i) => ({
                                    number: i + 1,
                                    par: parseInt(h.par) || 4,
                                    handicap: parseInt(h.handicap) || (i + 1)
                                }));
                                convertedCourse.totalPar = convertedCourse.holes.reduce((sum, h) => sum + h.par, 0);
                            } else {
                                const defaultPars = [4,4,3,4,5,4,3,4,5,4,4,3,4,5,4,3,4,4];
                                for (let i = 0; i < 18; i++) {
                                    convertedCourse.holes.push({ number: i + 1, par: defaultPars[i] || 4, handicap: i + 1 });
                                }
                            }
                            
                            courseData = convertedCourse;
                            customCourses[tournamentData.course] = convertedCourse;
                            tournamentData.courseData = convertedCourse;
                            
                            // Also update Firebase with this course data for future use
                            if (activeTournamentId) {
                                db.collection('tournaments').doc(activeTournamentId).update({
                                    courseData: convertedCourse
                                }).catch(e => console.log('Could not update Firebase with courseData:', e));
                            }
                            
                            // Re-render now that we have data
                            renderHoleView();
                            return;
                        }
                    } catch (apiErr) {
                        console.error('Golf API fetch error:', apiErr);
                    }
                }
                
                // Final check
                if (!courseData || !courseData.holes) {
                    console.error('❌ Could not load course data for:', tournamentData.course);
                    console.log('tournamentData.courseData:', tournamentData.courseData);
                    console.log('customCourses keys:', Object.keys(customCourses));
                    
                    // Last resort: Try to fetch from Firebase directly
                    if (activeTournamentId) {
                        console.log('🔄 Attempting to fetch courseData from Firebase...');
                        try {
                            const doc = await db.collection('tournaments').doc(activeTournamentId).get();
                            if (doc.exists) {
                                const fbTournament = doc.data();
                                if (fbTournament.courseData && fbTournament.courseData.holes) {
                                    console.log('✅ Got courseData from Firebase!');
                                    courseData = fbTournament.courseData;
                                    customCourses[tournamentData.course] = fbTournament.courseData;
                                    tournamentData.courseData = fbTournament.courseData;
                                    // Re-render now that we have data
                                    renderHoleView();
                                    return;
                                }
                            }
                        } catch (err) {
                            console.error('Firebase fetch error:', err);
                        }
                    }
                    
                    document.getElementById('holeViewContent').innerHTML = `
                        <div style="text-align:center;padding:20px;">
                            <p>Course data not loaded.</p>
                            <p style="font-size: 12px; color: #64748b; margin-top: 8px;">Course: ${tournamentData.course || 'Unknown'}</p>
                            <button onclick="location.reload()" style="margin-top: 12px; padding: 10px 20px; background: #1e3a5f; color: white; border: none; border-radius: 8px; cursor: pointer;">
                                Reload Page
                            </button>
                        </div>
                    `;
                    return;
                }
            }
            
            const hole = courseData.holes[currentHole];
            const holeNumber = currentHole + 1;
            
            // Calculate prev/next for infinite carousel
            const prevHole = currentHole === 0 ? 18 : currentHole;
            const nextHole = currentHole === 17 ? 1 : currentHole + 2;
            
            // Check if this hole has notes
            const hasNotes = getCourseNote(tournamentData.course, holeNumber);
            const notesButtonStyle = hasNotes 
                ? 'background: #fbbf24; color: #78350f; border: 2px solid #f59e0b;' 
                : 'background: #d4b896; color: #1e3a5f; border: 1.5px solid rgba(180, 130, 80, 0.5);';
            
            let html = `
                <div class="hole-view-container" id="holeViewContainer">
                    <div class="hole-header">
                        <div class="hole-nav-top">
                            <button type="button" class="hole-nav-btn-compact" onclick="goToPrevHole()">
                                ← ${prevHole}
                            </button>
                            <div style="display: flex; align-items: center; flex: 1; justify-content: center; gap: 6px;">
                                <div class="hole-title-section" onclick="showHoleJumpModal()" style="flex: 0;">
                                    <div class="hole-number">HOLE ${holeNumber}</div>
                                    <div class="hole-info">Par ${hole.par} • HCP ${hole.handicap}</div>
                                </div>
                                <button type="button" onclick="event.stopPropagation(); showCourseNoteModal(${holeNumber})" style="padding: 6px 10px; border-radius: 6px; font-size: 14px; cursor: pointer; ${notesButtonStyle}" title="${hasNotes ? 'View/Edit Notes' : 'Add Notes'}">📝</button>
                            </div>
                            <button type="button" class="hole-nav-btn-compact" onclick="goToNextHole()">
                                ${nextHole} →
                            </button>
                        </div>
                    </div>
            `;
            
            // Determine net scoring method from game type
            // ALWAYS show net scores, using full handicap by default
            let netMethod = 'full'; // Default to full handicap
            const gameTypeLower = tournamentData.gameType.toLowerCase();
            
            // Override with specific methods if applicable
            if (gameTypeLower.includes('18 max')) {
                netMethod = '18max';
            } else if (gameTypeLower.includes('1/2 pop') || gameTypeLower.includes('half pop')) {
                netMethod = 'half';
            }
            // Otherwise stays as 'full' for all other games
            
            console.log('renderHoleView - gameType:', tournamentData.gameType);
            console.log('renderHoleView - netMethod:', netMethod);
            
            // Filter players based on multi-device mode and claims (same as scoring page)
            let playersToShow = tournamentData.players;
            
            // Show filtered view for non-hosts OR when host is in player mode
            if (tournamentMode === 'multi' && (!canManageTournament() || isHostInPlayerMode())) {
                // Non-hosts/non-co-hosts (or host in player mode) only see their claimed players AND watched players
                const claimedPlayers = tournamentData.players.filter(p => isClaimedByMe(p));
                const watchedPlayers = tournamentData.players.filter(p => 
                    playerOrder.watching && playerOrder.watching.includes(p.name) && !isClaimedByMe(p)
                );
                
                // Sort each group by their saved order
                const sortedClaimed = sortPlayersByOrder(claimedPlayers, playerOrder.claimed || []);
                const sortedWatched = sortPlayersByOrder(watchedPlayers, playerOrder.watching || []);
                
                // Claimed players first, then watched players
                playersToShow = [...sortedClaimed, ...sortedWatched];
                console.log('🔒 Hole View - Claimed players:', sortedClaimed.map(p => p.name));
                console.log('👁 Hole View - Watched players:', sortedWatched.map(p => p.name));
                
                // DON'T fallback - show message if no claims
                if (playersToShow.length === 0) {
                    console.log('ℹ️ No claimed/watched players');
                    document.getElementById('holeViewContent').innerHTML = `
                        <div style="text-align: center; padding: 40px 20px;">
                            <div style="font-size: 48px; margin-bottom: 16px;">👤</div>
                            <h3 style="color: #1e3a5f; margin-bottom: 8px;">No Players to Score</h3>
                            <p style="color: #64748b; margin-bottom: 20px;">Claim or watch players to see their scorecards here.</p>
                            <button onclick="showMyPlayersPage()" style="padding: 12px 24px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                                👤 Go to My Players
                            </button>
                        </div>
                    `;
                    return;
                }
            }
            
            // Add player rows with inline ticker
            playersToShow.forEach((player, index) => {
                // Get actual index in full players array for score updates
                const playerIndex = tournamentData.players.indexOf(player);
                
                const score = player.scores[currentHole]; // Don't default to par - allow blank
                const hasScore = score !== undefined && score !== null && score !== 0;
                const displayScore = hasScore ? score : '';
                
                let scoreClass = '';
                
                if (hasScore) {
                    const diff = score - hole.par;
                    
                    if (diff >= 2) {
                        scoreClass = 'double-bogey-plus';
                    } else if (diff === 1) {
                        scoreClass = 'bogey';
                    } else if (diff === 0) {
                        scoreClass = 'par';
                    } else if (diff === -1) {
                        scoreClass = 'birdie';
                    } else if (diff <= -2) {
                        scoreClass = 'eagle-better';
                    }
                }
                
                // Calculate handicap dots
                let hcpDotsHtml = '';
                if (player.handicap !== 0) {
                    const strokes = getHandicapStrokesForHole(player.handicap, hole.handicap, netMethod);
                    if (strokes !== 0) {
                        const isHalfPop = netMethod === 'half';
                        const dotCount = isHalfPop ? Math.abs(strokes * 2) : Math.abs(strokes); // For half pop, show dots for half strokes
                        const dotColor = strokes > 0 ? 'green' : 'red'; // Green = subtract (getting strokes), Red = add (plus handicap)
                        
                        hcpDotsHtml = '<div class="hole-hcp-dots">';
                        for (let d = 0; d < Math.min(dotCount, 4); d++) {
                            hcpDotsHtml += `<div class="hcp-dot ${dotColor}"></div>`;
                        }
                        hcpDotsHtml += '</div>';
                    }
                }
                
                // Check if this is a watched player (view only)
                // Hosts/co-hosts in HOST mode can edit all players
                // Hosts/co-hosts in PLAYER mode can only edit their claimed players
                // Regular players can only edit their claimed players
                const isHostInHostMode = canManageTournament() && !isHostInPlayerMode();
                const isMyClaimedPlayer = isClaimedByMe(player);
                const isWatchedPlayer = tournamentMode === 'multi' && !isHostInHostMode && !isMyClaimedPlayer;
                
                // Load player stats
                loadStatsConfig();
                loadPlayerStatsFromLocalStorage();
                initPlayerStats(player.name);
                const playerStatsData = playerStats[player.name];
                const statTotals = getPlayerStatTotals(player.name);
                
                // Check if any stats are enabled
                const anyStatsEnabled = statsTrackerConfig.putts || statsTrackerConfig.dots || statsTrackerConfig.fir || statsTrackerConfig.gir;
                
                // FIR is not applicable on par 3s
                const isPar3 = hole.par === 3;
                
                // Build stats row HTML for claimed players - Order: FIR, GIR, Putts, Dots - compact for single row
                let statsRowHtml = '';
                if (!isWatchedPlayer && anyStatsEnabled) {
                    statsRowHtml = `<div style="display: flex; gap: 6px; flex-wrap: nowrap;">`;
                    
                    // FIR stat box (not on par 3s) - 3-state toggle: green checkmark -> red X -> dash
                    if (statsTrackerConfig.fir && !isPar3) {
                        const firVal = playerStatsData.fir[currentHole];
                        const hasFirStat = firVal !== null && firVal !== undefined;
                        const firBg = firVal === true ? '#166534' : firVal === false ? '#a51c30' : 'white';
                        const firBorder = '#d1d5db';
                        const firIcon = firVal === true ? '✓' : firVal === false ? '✗' : '—';
                        statsRowHtml += `
                            <div style="display: flex; flex-direction: column; align-items: center; border: 1px solid ${firBorder}; border-radius: 6px; padding: 4px 6px; background: white;">
                                <span style="font-size: 9px; color: #6b7280; font-weight: 600;">FIR</span>
                                <button onclick="event.stopPropagation(); toggleBooleanStat('${player.name}', 'fir', ${currentHole})" 
                                    style="width: 28px; height: 22px; border-radius: 4px; border: none; background: ${firBg}; color: ${hasFirStat ? 'white' : '#6b7280'}; font-size: 12px; font-weight: 700; cursor: pointer; padding: 0;">
                                    ${firIcon}
                                </button>
                                <span style="font-size: 9px; color: #6b7280; font-weight: 500;">${statTotals.firHit}/${statTotals.firTotal}</span>
                            </div>
                        `;
                    }
                    
                    // GIR stat box - 3-state toggle
                    if (statsTrackerConfig.gir) {
                        const girVal = playerStatsData.gir[currentHole];
                        const hasGirStat = girVal !== null && girVal !== undefined;
                        const girBg = girVal === true ? '#166534' : girVal === false ? '#a51c30' : 'white';
                        const girBorder = '#d1d5db';
                        const girIcon = girVal === true ? '✓' : girVal === false ? '✗' : '—';
                        statsRowHtml += `
                            <div style="display: flex; flex-direction: column; align-items: center; border: 1px solid ${girBorder}; border-radius: 6px; padding: 4px 6px; background: white;">
                                <span style="font-size: 9px; color: #6b7280; font-weight: 600;">GIR</span>
                                <button onclick="event.stopPropagation(); toggleBooleanStat('${player.name}', 'gir', ${currentHole})" 
                                    style="width: 28px; height: 22px; border-radius: 4px; border: none; background: ${girBg}; color: ${hasGirStat ? 'white' : '#6b7280'}; font-size: 12px; font-weight: 700; cursor: pointer; padding: 0;">
                                    ${girIcon}
                                </button>
                                <span style="font-size: 9px; color: #6b7280; font-weight: 500;">${statTotals.girHit}/${statTotals.girTotal}</span>
                            </div>
                        `;
                    }
                    
                    // Putts stat box - show number or dash, green < 3, red >= 3
                    if (statsTrackerConfig.putts) {
                        const puttVal = playerStatsData.putts[currentHole];
                        const hasPuttStat = puttVal !== null && puttVal !== undefined;
                        let puttBg = 'white';
                        let puttColor = '#1e3a5f';
                        if (hasPuttStat) {
                            if (puttVal < 3) {
                                puttBg = '#166534'; // Green for < 3
                                puttColor = 'white';
                            } else {
                                puttBg = '#a51c30'; // Red for 3+
                                puttColor = 'white';
                            }
                        }
                        const puttBorder = '#d1d5db';
                        statsRowHtml += `
                            <div style="display: flex; flex-direction: column; align-items: center; border: 1px solid ${puttBorder}; border-radius: 6px; padding: 4px 6px; background: white;">
                                <span style="font-size: 9px; color: #6b7280; font-weight: 600;">PUTT</span>
                                <button onclick="event.stopPropagation(); showStatPopup('${player.name}', 'putts', ${currentHole})" 
                                    style="width: 28px; height: 22px; border-radius: 4px; border: none; background: ${puttBg}; color: ${puttColor}; font-size: 13px; font-weight: 700; cursor: pointer; padding: 0;">
                                    ${hasPuttStat ? puttVal : '—'}
                                </button>
                                <span style="font-size: 9px; color: #6b7280; font-weight: 500;">(${statTotals.puttsTotal})</span>
                            </div>
                        `;
                    }
                    
                    // Dots stat box - show number or dash
                    if (statsTrackerConfig.dots) {
                        const dotVal = playerStatsData.dots[currentHole];
                        const hasDotStat = dotVal !== null && dotVal !== undefined;
                        let dotBg = 'white';
                        let dotColor = '#1e3a5f';
                        if (hasDotStat) {
                            if (dotVal === 0) {
                                dotBg = '#a51c30'; // Red for 0
                                dotColor = 'white';
                            } else {
                                dotBg = '#166534'; // Green for 1+
                                dotColor = 'white';
                            }
                        }
                        const dotBorder = '#d1d5db';
                        statsRowHtml += `
                            <div style="display: flex; flex-direction: column; align-items: center; border: 1px solid ${dotBorder}; border-radius: 6px; padding: 4px 6px; background: white;">
                                <span style="font-size: 9px; color: #6b7280; font-weight: 600;">DOT</span>
                                <button onclick="event.stopPropagation(); showStatPopup('${player.name}', 'dots', ${currentHole})" 
                                    style="width: 28px; height: 22px; border-radius: 4px; border: none; background: ${dotBg}; color: ${dotColor}; font-size: 13px; font-weight: 700; cursor: pointer; padding: 0;">
                                    ${hasDotStat ? dotVal : '—'}
                                </button>
                                <span style="font-size: 9px; color: #6b7280; font-weight: 500;">${statTotals.dotsTotal}</span>
                            </div>
                        `;
                    }
                    
                    statsRowHtml += `</div>`;
                }
                
                // Calculate running totals for bottom row
                const runningGross = player.scores.slice(0, currentHole + 1).reduce((sum, s) => sum + (s || 0), 0);
                const coursePar = courseData.holes.slice(0, currentHole + 1).reduce((sum, h) => sum + h.par, 0);
                const runningToPar = runningGross - coursePar;
                const toParDisplay = runningToPar === 0 ? 'E' : (runningToPar > 0 ? '+' + runningToPar : runningToPar);
                
                // Calculate running net total using current scoring method
                let runningNet = 0;
                let netStrokesUsed = 0;
                for (let h = 0; h <= currentHole; h++) {
                    const holeScore = player.scores[h] || 0;
                    if (holeScore > 0) {
                        const holeData = courseData.holes[h];
                        const netScore = getNetScore(holeScore, player.handicap, holeData.handicap, netMethod);
                        runningNet += netScore;
                        netStrokesUsed += (holeScore - netScore);
                    }
                }
                const netToPar = runningNet - coursePar;
                const netToParDisplay = netToPar === 0 ? 'E' : (netToPar > 0 ? '+' + netToPar : netToPar);
                
                // Calculate net score for display
                let netScoreDisplay = '';
                if (hasScore && netMethod) {
                    const netScore = getNetScore(score, player.handicap, hole.handicap, netMethod);
                    netScoreDisplay = `<div class="hole-net-score">${netScore}</div>`;
                }
                
                // Build running totals HTML - only show if player has entered a score on THIS hole
                let runningTotalsHtml = '';
                if (hasScore) {
                    const grossToParColor = runningGross - (currentHole * 4) <= 0 ? '#166534' : '#a51c30';
                    const netToParColor = runningNet - (currentHole * 4) <= 0 ? '#166534' : '#a51c30';
                    runningTotalsHtml = `
                        <div style="display: grid; grid-template-columns: auto auto auto; gap: 2px 4px; margin-top: 4px; align-items: center;">
                            <span style="font-size: 11px; color: #1e3a5f; font-weight: 600; text-align: right;">Gross</span>
                            <span style="font-size: 11px; color: #1e3a5f; font-weight: 600;">:</span>
                            <span style="font-size: 11px; color: #1e3a5f; font-weight: 600;">${runningGross} <span style="color: ${grossToParColor};">(${toParDisplay})</span></span>
                            <span style="font-size: 11px; color: #64748b; font-weight: 500; text-align: right;">Net</span>
                            <span style="font-size: 11px; color: #64748b; font-weight: 500;">:</span>
                            <span style="font-size: 11px; color: #64748b; font-weight: 500;">${runningNet} <span style="color: ${netToParColor};">(${netToParDisplay})</span></span>
                        </div>
                    `;
                }
                
                // Check if this player is linked for tracking
                const trackingLink = isPlayerLinkedForTracking(player.name);
                const isTracking = !!trackingLink;
                const trackingBtnStyle = isTracking 
                    ? 'background: #166534; color: white; border: 2px solid #166534;' 
                    : 'background: #f1f5f9; color: #64748b; border: 2px solid #e2e8f0;';
                const trackingTitle = isTracking ? 'Tracking stats for your profile' : 'Track stats for your profile';
                
                // Build the player row with layout:
                // LEFT: Name, HCP, Stats (vertically stacked)
                // RIGHT: Scores at top, Running totals below
                html += `
                    <div class="hole-player-row-ticker ${isWatchedPlayer ? 'watch-only' : ''}" style="padding: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                            <!-- LEFT: Name, HCP, Stats vertically stacked -->
                            <div style="display: flex; flex-direction: column;">
                                <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 2px;">
                                    <div class="hole-player-name" style="font-size: 17px; font-weight: 700; color: #1e293b;">${player.name}${isWatchedPlayer ? ' 👁' : ''}</div>
                                    <button onclick="event.stopPropagation(); togglePlayerTracking('${player.name.replace(/'/g, "\\'")}')" 
                                        style="padding: 2px 6px; ${trackingBtnStyle} border-radius: 4px; font-size: 11px; cursor: pointer;" title="${trackingTitle}">📊</button>
                                </div>
                                <div class="hole-player-hcp" style="font-size: 12px; color: #64748b; margin-bottom: 8px;">HCP: ${player.handicap > 0 ? player.handicap : player.handicap < 0 ? '+' + Math.abs(player.handicap) : '0'}</div>
                                ${!isWatchedPlayer && anyStatsEnabled ? statsRowHtml : ''}
                            </div>
                            
                            <!-- RIGHT: Scores and Running Totals -->
                            <div style="display: flex; flex-direction: column; align-items: flex-end;">
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    ${isWatchedPlayer ? `
                                        <div class="hole-score-display" style="display: flex; align-items: center; gap: 4px;">
                                            ${hcpDotsHtml}
                                            <div class="hole-score-ticker">
                                                <div class="score-input ${scoreClass}" style="pointer-events: none; width: 52px; height: 52px; font-size: 24px; display: flex; align-items: center; justify-content: center;">
                                                    ${displayScore || '−'}
                                                </div>
                                            </div>
                                        </div>
                                    ` : `
                                        <div class="hole-score-ticker" style="display: flex; align-items: center; gap: 4px;">
                                            ${hcpDotsHtml}
                                            <input type="number" 
                                                   class="score-input ${scoreClass}" 
                                                   id="holeScore_${playerIndex}_${currentHole}"
                                                   value="${displayScore}" 
                                                   placeholder="−"
                                                   readonly
                                                   onclick="handleHoleInputFocus(${playerIndex}, ${currentHole}, this)"
                                                   style="width: 56px; height: 56px; font-size: 26px; text-align: center; cursor: pointer;">
                                        </div>
                                    `}
                                    ${netScoreDisplay}
                                </div>
                                ${runningTotalsHtml}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            // Close container
            html += `
                </div>
            `;
            
            document.getElementById('holeViewContent').innerHTML = html;
            setupHoleViewSwipe();
        }

        // Handle input focus in hole view - voice or touch based on mode
        function handleHoleInputFocus(playerIndex, holeIndex, inputElement) {
            // Always blur to prevent keyboard
            inputElement.blur();
            
            // If voice mode, use voice input
            if (inputMode === 'voice') {
                showVoiceListening(playerIndex, holeIndex);
                return;
            }
            
            // Touch mode - use expanded input modal
            const currentScore = tournamentData.players[playerIndex].scores[holeIndex] || 0;
            const playerName = tournamentData.players[playerIndex].name;
            showExpandedScoreInput(playerIndex, holeIndex, currentScore, playerName);
        }

        // Adjust score directly in hole view (inline ticker)
        async function adjustHoleScoreDirect(playerIndex, holeIndex, delta) {
            console.log('=== ADJUST HOLE SCORE CALLED ===');
            console.log('playerIndex:', playerIndex, 'holeIndex:', holeIndex, 'delta:', delta);
            
            const currentScore = tournamentData.players[playerIndex].scores[holeIndex];
            const hole = courseData.holes[holeIndex];
            let newScore;
            
            console.log('Current score:', currentScore);
            console.log('Player:', tournamentData.players[playerIndex].name);
            
            // If no score yet (blank), first press sets to par
            if (currentScore === undefined || currentScore === null || currentScore === 0) {
                newScore = hole.par;
            } else {
                // Score exists, adjust by delta
                if (delta > 0) {
                    newScore = currentScore + 1;
                } else {
                    newScore = Math.max(currentScore - 1, 1); // Min score is 1
                }
            }
            
            console.log('New score:', newScore);
            
            tournamentData.players[playerIndex].scores[holeIndex] = newScore;
            
            // IMMEDIATE SAVE with verification
            console.log('💾 Attempting localStorage save...');
            const saveSuccess = saveToLocalStorage();
            console.log('💾 Save result:', saveSuccess);
            
            // VERIFY the score was actually saved
            if (saveSuccess) {
                const verified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                if (!verified) {
                    console.error('❌ HOLE VIEW: Score verification failed! Retrying save...');
                    tournamentData.players[playerIndex].scores[holeIndex] = newScore;
                    const retrySuccess = saveToLocalStorage();
                    console.log('💾 Retry save result:', retrySuccess);
                    
                    // Verify again
                    const reVerified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                    if (!reVerified) {
                        console.error('🚨 CRITICAL: Score still not saved after retry!');
                        // Don't alert - just log. Score is in Firebase anyway.
                    }
                }
            } else {
                console.error('🚨 CRITICAL: Initial save failed!');
                // Don't alert - just log. Score is in Firebase anyway.
            }
            
            // Sync to Firebase if in multi-device mode
            if (activeTournamentId && tournamentMode === 'multi') {
                const playerName = tournamentData.players[playerIndex].name;
                console.log('🔥 FIREBASE SYNC STARTING');
                console.log('   Player:', playerName);
                console.log('   Hole:', holeIndex + 1);
                console.log('   Score:', newScore);
                
                updatePlayerScore(activeTournamentId, playerName, holeIndex, newScore);
            } else {
                console.log('ℹ️ Skipping Firebase sync (single-device mode)');
            }
            
            // Update hole view
            updateHoleViewScore(playerIndex, holeIndex, newScore);
            
            // Update player view if visible
            renderScoringPage();
        }

        // Helper function to update hole view score display
        function updateHoleViewScore(playerIndex, holeIndex, newScore) {
            const input = document.getElementById(`holeScore_${playerIndex}_${holeIndex}`);
            if (!input) return;
            
            input.value = newScore;
            
            // Update color class
            const hole = courseData.holes[holeIndex];
            const diff = newScore - hole.par;
            
            input.classList.remove('birdie-better', 'par', 'bogey', 'double-bogey-plus');
            
            if (diff >= 2) {
                input.classList.add('double-bogey-plus');
            } else if (diff === 1) {
                input.classList.add('bogey');
            } else if (diff === 0) {
                input.classList.add('par');
            } else if (diff <= -1) {
                input.classList.add('birdie-better');
            }
            
            // Update net score if applicable
            const player = tournamentData.players[playerIndex];
            let netMethod = null;
            const gameTypeLower = tournamentData.gameType.toLowerCase();
            
            // Check for any net game
            if (gameTypeLower.includes('net')) {
                if (gameTypeLower.includes('full') || gameTypeLower.includes('full hcp')) {
                    netMethod = 'full';
                } else if (gameTypeLower.includes('18 max')) {
                    netMethod = '18max';
                } else if (gameTypeLower.includes('1/2 pop') || gameTypeLower.includes('half pop')) {
                    netMethod = 'half';
                } else {
                    // Default to full handicap for any other net game
                    netMethod = 'full';
                }
            }
            
            if (netMethod) {
                const netScore = getNetScore(newScore, player.handicap, hole.handicap, netMethod);
                const netDisplay = input.parentElement.parentElement.querySelector('.hole-net-score');
                
                if (netDisplay) {
                    netDisplay.textContent = `${netScore}`;
                } else {
                    // Add net score display if it doesn't exist
                    const netDiv = document.createElement('div');
                    netDiv.className = 'hole-net-score';
                    netDiv.textContent = `${netScore}`;
                    input.parentElement.parentElement.appendChild(netDiv);
                }
            }
        }

        // Update score from manual input in hole view
        function updateHoleScore(playerIndex, holeIndex, value) {
            const numValue = parseInt(value);
            
            // If empty or invalid, delete the score
            if (!value || isNaN(numValue) || numValue === 0) {
                tournamentData.players[playerIndex].scores[holeIndex] = 0;
                
                // Clear display
                const input = document.getElementById(`holeScore_${playerIndex}_${holeIndex}`);
                if (input) {
                    input.value = '';
                    input.classList.remove('birdie-better', 'par', 'bogey', 'double-bogey-plus');
                }
                
                // Remove net score
                const netDisplay = input?.parentElement?.parentElement?.querySelector('.hole-net-score');
                if (netDisplay) {
                    netDisplay.remove();
                }
                
                // Update player view
                renderScoringPage();
                saveToLocalStorage();
                return;
            }
            
            tournamentData.players[playerIndex].scores[holeIndex] = numValue;
            
            // Update hole view
            updateHoleViewScore(playerIndex, holeIndex, numValue);
            
            // Update player view
            renderScoringPage();
            
            saveToLocalStorage();
        }

        // Navigate to previous hole
        function goToPrevHole() {
            // Cancel any pending auto-advance
            cancelAutoAdvance();
            
            // Infinite carousel - wrap from hole 1 to hole 18
            if (currentHole === 0) {
                currentHole = 17;
            } else {
                currentHole--;
            }
            renderHoleView();
        }

        // Navigate to next hole
        function goToNextHole() {
            // Cancel any pending auto-advance
            cancelAutoAdvance();
            
            // Infinite carousel - wrap from hole 18 to hole 1
            if (currentHole === 17) {
                currentHole = 0;
            } else {
                currentHole++;
            }
            renderHoleView();
        }
        
        // Jump to specific hole
        function jumpToHole(holeIndex) {
            // Cancel any pending auto-advance
            cancelAutoAdvance();
            
            currentHole = holeIndex;
            renderHoleView();
            closeHoleJumpModal();
        }
        
        // Show hole jump modal
        function showHoleJumpModal() {
            const modal = document.createElement('div');
            modal.id = 'holeJumpModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                padding: 20px;
            `;
            
            let holesGrid = '';
            for (let i = 0; i < 18; i++) {
                const isCurrentHole = i === currentHole;
                holesGrid += `
                    <button onclick="jumpToHole(${i})" style="
                        width: 48px;
                        height: 48px;
                        border-radius: 6px;
                        border: 2px solid ${isCurrentHole ? '#1e3a5f' : '#e2e8f0'};
                        background: ${isCurrentHole ? '#1e3a5f' : 'white'};
                        color: ${isCurrentHole ? 'white' : '#1e3a5f'};
                        font-size: 18px;
                        font-weight: 700;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        padding: 0;
                        line-height: 1;
                    ">${i + 1}</button>
                `;
            }
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 6px; padding: 24px; max-width: 340px; width: 90%; text-align: center;">
                    <h2 style="color: #1e3a5f; margin-bottom: 20px; font-size: 22px; font-weight: 700;">Jump to Hole</h2>
                    <div style="display: grid; grid-template-columns: repeat(6, 48px); gap: 8px; margin-bottom: 24px; justify-content: center;">
                        ${holesGrid}
                    </div>
                    <button onclick="closeHoleJumpModal()" style="padding: 14px 32px; background: #d4b896; color: #1e3a5f; border: none; border-radius: 4px; font-size: 16px; font-weight: 600; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function closeHoleJumpModal() {
            const modal = document.getElementById('holeJumpModal');
            if (modal) modal.remove();
        }

        // Setup swipe gestures for hole view
        function setupHoleViewSwipe() {
            const container = document.getElementById('holeViewContainer');
            if (!container) return;
            
            let touchStartX = 0;
            let touchEndX = 0;
            
            container.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
            }, { passive: true });
            
            container.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].screenX;
                handleSwipe();
            }, { passive: true });
            
            function handleSwipe() {
                const swipeThreshold = 50;
                const diff = touchStartX - touchEndX;
                
                if (Math.abs(diff) > swipeThreshold) {
                    if (diff > 0) {
                        // Swipe left - next hole
                        goToNextHole();
                    } else {
                        // Swipe right - previous hole
                        goToPrevHole();
                    }
                }
            }
        }

        // Update startScoring to show indicator and disable pull-to-refresh
        const originalStartScoring = startScoring;
        startScoring = function() {
            originalStartScoring();
            showRoundIndicator();
            disablePullToRefresh();
        };

        // Confirm finish tournament from Host Home
        function confirmFinishTournament() {
            showConfirm(
                '🏁 Finish Tournament?',
                'This will mark the tournament as finished. Players will no longer be able to edit scores or player info, but can still view results.',
                async function() {
                    // Store IDs before clearing
                    const tournamentId = activeTournamentId;
                    const historyEntry = {
                        id: tournamentId,
                        joinCode: tournamentData?.joinCode || '',
                        name: tournamentData?.name || 'Tournament',
                        course: tournamentData?.course || '',
                        date: tournamentData?.date || new Date().toISOString().split('T')[0],
                        gameType: tournamentData?.gameType || '',
                        role: 'host',
                        isFinished: true
                    };
                    
                    // Save to tournament history FIRST (synchronous, shouldn't fail)
                    try {
                        addToTournamentHistory(historyEntry);
                        console.log('✅ Saved to tournament history:', historyEntry);
                    } catch (historyError) {
                        console.error('Failed to save history:', historyError);
                    }
                    
                    // Try to mark tournament as finished in Firebase
                    let firebaseSuccess = false;
                    if (tournamentId && db) {
                        try {
                            const tournamentRef = db.collection('tournaments').doc(tournamentId);
                            await tournamentRef.update({ isFinished: true });
                            console.log('✅ Firebase updated');
                            firebaseSuccess = true;
                        } catch (fbError) {
                            console.error('Firebase update failed:', fbError);
                        }
                    }
                    
                    // Mark locally
                    if (tournamentData) {
                        tournamentData.isFinished = true;
                    }
                    
                    // Hide Current Tournament card
                    const currentTournamentCard = document.getElementById('hostCurrentTournament');
                    if (currentTournamentCard) {
                        currentTournamentCard.style.display = 'none';
                    }
                    
                    // CLEAR ALL ACTIVE TOURNAMENT STATE
                    activeTournamentId = null;
                    isHost = false;
                    tournamentMode = 'single';
                    
                    // Clear localStorage
                    localStorage.removeItem('activeTournamentId');
                    localStorage.removeItem('indianHillsScoring');
                    localStorage.removeItem('currentTournamentId');
                    localStorage.removeItem('pendingPurchase');
                    
                    // Reset tournamentData
                    tournamentData = {
                        id: '',
                        date: '',
                        gameType: '',
                        course: '',
                        players: [],
                        teams: []
                    };
                    
                    // Safely unsubscribe from listeners
                    try {
                        unsubscribeFunctions.forEach(fn => {
                            if (typeof fn === 'function') fn();
                        });
                        unsubscribeFunctions = [];
                    } catch (unsubError) {
                        console.error('Unsubscribe error:', unsubError);
                    }
                    
                    hideConfirmDialog();
                    
                    if (firebaseSuccess) {
                        showNotification('✅ Finished', 'Tournament saved');
                    } else {
                        showNotification('✅ Saved', 'Tournament saved locally');
                    }
                    
                    showPage('hostHomePage');
                    updateHostHomeDisplay();
                }
            );
        }
        
        // Check if tournament is finished (for disabling edits)
        function isTournamentFinished() {
            return tournamentData?.isFinished === true;
        }
        
        // Check if current user can edit (host can always edit in View mode)
        function canEditTournament() {
            if (!isTournamentFinished()) return true;
            // If finished, only host can edit (View mode)
            return isHost || isCoHost;
        }

        // Update confirmNewRound to hide indicator and enable pull-to-refresh
        const originalConfirmNewRound = confirmNewRound;
        confirmNewRound = function() {
            showConfirm(
                'End Current Round?',
                'This will end the current round and clear all data. Make sure you\'ve saved your results!',
                function() {
                    localStorage.removeItem('indianHillsScoring');
                    tournamentData = {
                        date: '',
                        gameType: '',
                        course: 'indian_hills',
                        players: [],
                        teams: []
                    };
                    hideRoundIndicator();
                    enablePullToRefresh();
                    showPage('setupPage');
                    hideConfirmDialog();
                    location.reload(); // Reload to reset everything
                }
            );
        };

        // iOS Install Prompt - Show if not running as standalone app
        function showInstallPrompt() {
            // Check if running as standalone (home screen app)
            const isStandalone = window.matchMedia('(display-mode: standalone)').matches || 
                               window.navigator.standalone === true;
            
            // Check if on iOS
            const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
            
            // Check if already dismissed
            const dismissed = localStorage.getItem('installPromptDismissed');
            
            if (!isStandalone && isIOS && !dismissed) {
                // Show after 3 seconds
                setTimeout(() => {
                    const banner = document.createElement('div');
                    banner.style.cssText = `
                        position: fixed;
                        bottom: 0;
                        left: 0;
                        right: 0;
                        background: rgba(30, 64, 175, 0.95);
                        color: white;
                        padding: 16px;
                        text-align: center;
                        z-index: 10000;
                        font-size: 14px;
                        line-height: 1.4;
                        box-shadow: 0 -4px 12px rgba(0,0,0,0.3);
                    `;
                    banner.innerHTML = `
                        <div style="margin-bottom: 8px;">📱 <strong>Install for Full Screen</strong></div>
                        <div style="font-size: 12px; opacity: 0.9; margin-bottom: 12px;">
                            Tap <strong>Share</strong> → <strong>Add to Home Screen</strong> to hide browser controls
                        </div>
                        <button onclick="this.closest('div').remove(); localStorage.setItem('installPromptDismissed', 'true');" 
                                style="background: white; color: #1e3a5f; border: none; padding: 8px 20px; border-radius: 6px; font-weight: 600; font-size: 13px;">
                            Got it
                        </button>
                    `;
                    document.body.appendChild(banner);
                    
                    // Auto-dismiss after 10 seconds
                    setTimeout(() => {
                        if (banner.parentNode) {
                            banner.remove();
                        }
                    }, 10000);
                }, 3000);
            }
        }
        
        // DISABLED: Homescreen install notification - will bring back later
        // showInstallPrompt();
        
        // ==================== SERVICE WORKER REGISTRATION ====================
        
        // Register service worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', async () => {
                try {
                    const registration = await navigator.serviceWorker.register('./sw.js', {
                        scope: './'
                    });
                    
                    console.log('✅ Service Worker registered successfully:', registration.scope);
                    
                    // Check for updates
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        console.log('🔄 Service Worker update found');
                        
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                // New version available
                                showUpdateAvailableBanner();
                            }
                        });
                    });
                    
                } catch (error) {
                    console.log('⚠️ Service Worker registration failed:', error);
                    // App still works, just without offline capability
                }
            });
            
            // Handle controller change (when new SW takes over)
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                console.log('🔄 New Service Worker activated');
            });
        }
        
        // Show update available banner
        function showUpdateAvailableBanner() {
            const banner = document.createElement('div');
            banner.id = 'updateBanner';
            banner.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background: linear-gradient(135deg, #166534, #15803d);
                color: white;
                padding: 12px 16px;
                text-align: center;
                z-index: 10001;
                font-size: 14px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 12px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            `;
            banner.innerHTML = `
                <span>🎉 New version available!</span>
                <button onclick="applyUpdate()" style="background: white; color: #166534; border: none; padding: 6px 16px; border-radius: 4px; font-weight: 600; font-size: 13px; cursor: pointer;">
                    Update Now
                </button>
                <button onclick="this.closest('#updateBanner').remove()" style="background: transparent; color: white; border: 1px solid white; padding: 6px 12px; border-radius: 4px; font-size: 13px; cursor: pointer;">
                    Later
                </button>
            `;
            document.body.prepend(banner);
        }
        
        // Apply update by refreshing
        function applyUpdate() {
            if (navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({ type: 'SKIP_WAITING' });
            }
            window.location.reload();
        }
        
        // ==================== PWA INSTALL PROMPT ====================
        
        let deferredInstallPrompt = null;
        
        // Capture the install prompt event (Android/Desktop Chrome)
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredInstallPrompt = e;
            console.log('📱 Install prompt captured');
            
            // Show custom install button after a delay
            setTimeout(showCustomInstallPrompt, 5000);
        });
        
        // Show custom install prompt
        function showCustomInstallPrompt() {
            if (!deferredInstallPrompt) return;
            
            // Don't show if already installed or dismissed recently
            if (window.matchMedia('(display-mode: standalone)').matches) return;
            if (sessionStorage.getItem('installPromptDismissed')) return;
            
            const banner = document.createElement('div');
            banner.id = 'installPromptBanner';
            banner.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 20px;
                right: 20px;
                background: white;
                border-radius: 12px;
                padding: 16px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.25);
                z-index: 10001;
                display: flex;
                align-items: center;
                gap: 12px;
            `;
            banner.innerHTML = `
                <div style="font-size: 32px;">⛳</div>
                <div style="flex: 1;">
                    <div style="font-weight: 700; color: #1e3a5f; font-size: 15px;">Install Let's Golf</div>
                    <div style="font-size: 13px; color: #6b7280;">Add to home screen for the best experience</div>
                </div>
                <button onclick="triggerInstallPrompt()" style="background: #1e3a5f; color: white; border: none; padding: 10px 16px; border-radius: 6px; font-weight: 600; font-size: 13px; cursor: pointer; white-space: nowrap;">
                    Install
                </button>
                <button onclick="dismissInstallPrompt()" style="background: transparent; border: none; color: #9ca3af; font-size: 18px; cursor: pointer; padding: 4px;">
                    ✕
                </button>
            `;
            document.body.appendChild(banner);
        }
        
        // Trigger the native install prompt
        async function triggerInstallPrompt() {
            if (!deferredInstallPrompt) return;
            
            deferredInstallPrompt.prompt();
            const { outcome } = await deferredInstallPrompt.userChoice;
            
            console.log('📱 Install prompt outcome:', outcome);
            
            deferredInstallPrompt = null;
            document.getElementById('installPromptBanner')?.remove();
        }
        
        // Dismiss install prompt
        function dismissInstallPrompt() {
            sessionStorage.setItem('installPromptDismissed', 'true');
            document.getElementById('installPromptBanner')?.remove();
        }
        
        // Track successful installation
        window.addEventListener('appinstalled', () => {
            console.log('✅ App installed successfully!');
            deferredInstallPrompt = null;
            document.getElementById('installPromptBanner')?.remove();
        });
    </script>
</body>
</html>
