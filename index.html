<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Let's Golf">
    <meta name="theme-color" content="#1e40af">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <title>Let's Golf</title>
    <!-- QR Code Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging-compat.js"></script>
    
    <!-- VERSION: 2025-01-02-PHASE2-FIREBASE-COLLABORATIVE -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #059669 0%, #10b981 20%, #3b82f6 60%, #1e40af 100%);
            min-height: 100vh;
            min-height: -webkit-fill-available; /* iOS Safari fix */
            padding: 0;
            overflow-x: hidden;
            touch-action: pan-y; /* Allow vertical scrolling */
        }

        html {
            height: -webkit-fill-available; /* iOS Safari fix */
        }

        /* Page Container */
        .page {
            display: none;
            min-height: 100vh;
            padding: 20px;
        }

        .page.active {
            display: block;
            animation: slideIn 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        @keyframes slideIn {
            from { 
                opacity: 0; 
                transform: translateX(20px);
            }
            to { 
                opacity: 1; 
                transform: translateX(0);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Header */
        .header {
            background: white;
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
        }

        .header h1 {
            color: #1e40af;
            font-size: 24px;
            margin-bottom: 5px;
        }

        .header p {
            color: #64748b;
            font-size: 14px;
        }

        /* Setup Page */
        .setup-container {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 
                        0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            color: #1e40af;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            max-width: 100%;
            padding: 14px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.2s;
            -webkit-appearance: none;
            appearance: none;
        }

        .form-group input[type="date"] {
            padding: 12px 14px;
            font-size: 15px;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #3b82f6;
            background: #f8fafc;
        }

        /* Player Input Grid */
        .player-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: hidden;
        }

        .player-row {
            display: grid;
            grid-template-columns: 1fr 80px;
            gap: 10px;
            align-items: center;
            position: relative;
            background: white;
            border-radius: 12px;
            overflow: visible;
            z-index: 1;
            transition: transform 0.3s ease;
        }

        .player-row.has-suggestions {
            z-index: 100;
        }

        .player-row::after {
            content: 'Delete';
            position: absolute;
            right: -100px;
            top: 0;
            bottom: 0;
            width: 100px;
            background: #ef4444;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 15px;
            border-radius: 12px;
            z-index: -1;
        }

        .player-row.swiped {
            transform: translateX(-100px);
        }

        .player-row.deleting {
            opacity: 0;
            transform: translateX(-300px);
            transition: all 0.3s ease;
        }

        .player-row::before {
            content: 'Delete';
            position: absolute;
            right: -100px;
            top: 0;
            bottom: 0;
            width: 100px;
            background: #ef4444;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 15px;
            border-radius: 12px;
            z-index: -1;
        }

        .player-row.swiped {
            transform: translateX(-100px);
        }

        .player-row.deleting {
            opacity: 0;
            transform: translateX(-300px);
            transition: all 0.3s ease;
        }

        .player-name-input {
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 15px;
            width: 100%;
            background: white;
            position: relative;
            z-index: 1;
        }

        .player-name-input::placeholder {
            color: #94a3b8;
        }

        .player-hcp-input {
            width: 80px;
            padding: 12px 8px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 15px;
            text-align: center;
            background: white;
            position: relative;
            z-index: 1;
        }

        .player-hcp-input::placeholder {
            color: #94a3b8;
            font-size: 13px;
        }

        /* Autocomplete Suggestions */
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 90px;
            background: white;
            border: 2px solid #3b82f6;
            border-top: none;
            border-radius: 0 0 12px 12px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: none;
        }

        .autocomplete-suggestions.show {
            display: block;
        }

        .suggestion-item {
            padding: 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e2e8f0;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover,
        .suggestion-item:active {
            background: #eff6ff;
        }

        .suggestion-name {
            font-weight: 600;
            color: #1e40af;
        }

        .suggestion-hcp {
            color: #64748b;
            font-size: 14px;
        }

        .btn-add-player {
            width: auto;
            min-width: 140px;
            padding: 10px 20px;
            background: white;
            color: #3b82f6;
            border: 2px solid #3b82f6;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            margin: 10px auto 0;
            transition: all 0.2s;
            display: block;
        }

        .btn-add-player:active {
            background: #eff6ff;
        }

        .btn-add-player:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Quick Add Player Buttons */
        .quick-add-btn {
            padding: 8px 12px;
            background: #eff6ff;
            color: #3b82f6;
            border: 2px solid #3b82f6;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            position: relative;
        }

        .quick-add-btn:active {
            background: #dbeafe;
            transform: scale(0.95);
        }

        .quick-add-btn.show-delete {
            padding-right: 36px;
        }

        .quick-add-delete {
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .quick-add-btn.show-delete .quick-add-delete {
            display: flex;
        }

        /* Team Setup */
        .team-container {
            background: #f8fafc;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .team-header {
            color: #1e40af;
            font-weight: 700;
            margin-bottom: 12px;
            font-size: 16px;
        }

        .team-member-select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 8px;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 10px;
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto;
            position: relative;
            z-index: 10;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.3), 
                        0 2px 4px -1px rgba(59, 130, 246, 0.2);
        }

        .btn-primary:active {
            background: #2563eb;
            transform: scale(0.98);
            box-shadow: 0 2px 4px -1px rgba(59, 130, 246, 0.3);
        }

        .btn-primary::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn-primary:active::after {
            width: 300px;
            height: 300px;
        }

        .btn-secondary {
            background: #64748b;
            color: white;
            -webkit-user-select: none;
            user-select: none;
            z-index: 1000 !important;
        }

        .btn-secondary:active {
            background: #475569;
            transform: scale(0.98);
        }

        /* Game Toggle Tabs */
        .game-tab {
            flex: 1;
            min-width: 80px;
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            text-align: center;
        }

        .game-tab.active {
            background: white;
            color: #1e40af;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .game-tab:active {
            transform: scale(0.95);
        }

        /* Player Device Item */
        .player-device-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .player-device-item h4 {
            color: white;
            font-size: 16px;
            margin-bottom: 4px;
        }

        .player-device-item p {
            color: #cbd5e1;
            font-size: 13px;
            margin-bottom: 8px;
        }

        .player-device-item button {
            padding: 6px 12px;
            font-size: 13px;
            margin-right: 8px;
        }

        /* Leaderboard Styles */
        .leaderboard-entry {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .leaderboard-entry.first {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
        }

        .leaderboard-entry.second {
            background: linear-gradient(135deg, #94a3b8, #64748b);
        }

        .leaderboard-entry.third {
            background: linear-gradient(135deg, #fb923c, #ea580c);
        }

        .leaderboard-rank {
            font-size: 20px;
            font-weight: 700;
            min-width: 40px;
        }

        .leaderboard-name {
            flex: 1;
            font-weight: 600;
            color: white;
        }

        .leaderboard-score {
            font-size: 18px;
            font-weight: 700;
            color: white;
        }

        /* Scoring Page */
        .scoring-header {
            background: white;
            padding: 12px 16px;
            border-radius: 12px;
            margin-bottom: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: sticky;
            top: 20px;
            z-index: 50;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: top 0.3s;
        }

        .header-top-row {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 12px;
            align-items: center;
        }

        .header-bottom-row {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .tournament-info-centered {
            text-align: center;
        }

        .tournament-info-centered h2 {
            font-size: 16px;
            font-weight: 700;
            color: #1e293b;
            margin: 0;
            line-height: 1.2;
        }

        .tournament-info-centered p {
            font-size: 12px;
            color: #64748b;
            margin: 2px 0 0 0;
        }

        /* Results page header - simple single row */
        .results-page-header {
            background: white;
            padding: 12px 16px;
            border-radius: 12px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 12px;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .tournament-info-simple {
            flex: 1;
            min-width: 0;
        }

        .tournament-info-simple h2 {
            color: #1e40af;
            font-size: 16px;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .tournament-info-simple p {
            color: #64748b;
            font-size: 12px;
            margin: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .scoring-content {
            padding-top: 76px;
            padding-left: 0;
            padding-right: 0;
        }

        .round-indicator.active ~ .scoring-header,
        #scoringPage .round-indicator.active ~ .scoring-header {
            top: 52px;
        }

        .round-indicator.active ~ .scoring-content,
        #scoringPage .round-indicator.active ~ .scoring-content {
            padding-top: 108px;
        }


        .finish-btn {
            padding: 8px 16px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 13px;
            white-space: nowrap;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            pointer-events: auto;
            position: relative;
            z-index: 10;
        }

        .finish-btn:active {
            background: #059669;
        }

        .back-btn {
            padding: 8px 12px;
            background: #64748b;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            white-space: nowrap;
            -webkit-tap-highlight-color: rgba(100, 116, 139, 0.3);
            touch-action: manipulation;
            pointer-events: auto;
            position: relative;
            z-index: 1000;
            -webkit-user-select: none;
            user-select: none;
        }

        .back-btn:active {
            background: #475569;
        }

        /* Player Card */
        .player-card {
            background: white;
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        }

        .player-name {
            font-size: 20px;
            font-weight: 700;
            color: #1e40af;
        }

        .player-total {
            font-size: 24px;
            font-weight: 700;
            color: #3b82f6;
        }

        /* Hole Grid */
        .holes-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
            box-sizing: border-box;
        }

        .hole-input-group {
            background: #f8fafc;
            border-radius: 10px;
            padding: 8px 5px;
            min-width: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hole-label {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
            font-size: 11px;
            color: #64748b;
            font-weight: 600;
            min-height: 32px;
        }

        .par-badge {
            background: #dbeafe;
            color: #1e40af;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 9px;
            white-space: nowrap;
        }

        .score-input-wrapper {
            display: flex;
            align-items: center;
            gap: 3px;
            min-width: 0;
        }

        .score-btn {
            width: 28px;
            height: 28px;
            min-width: 28px;
            border: none;
            background: #3b82f6;
            color: white;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        .score-btn:active {
            background: #2563eb;
            transform: scale(0.95);
        }

        .score-input {
            width: 100%;
            max-width: 100%;
            min-width: 0;
            text-align: center;
            padding: 6px 2px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 700;
            color: #1e40af;
            box-sizing: border-box;
        }

        .score-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        /* Score coloring */
        .score-input.birdie-better {
            background: #dcfce7;
            border-color: #10b981;
            color: #059669;
            font-weight: 600;
        }

        .score-input.par {
            background: #dbeafe;
            border-color: #3b82f6;
            color: #1e40af;
            font-weight: 600;
        }

        .score-input.bogey {
            background: #fef3c7;
            border-color: #f59e0b;
            color: #d97706;
            font-weight: 600;
        }

        .score-input.double-bogey-plus {
            background: #fef2f2;
            border-color: #ef4444;
            color: #dc2626;
            font-weight: 600;
        }

        /* Results Page */
        .results-container {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .results-title {
            color: #1e40af;
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
            text-align: center;
        }

        .results-player {
            background: #f8fafc;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .results-player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .results-player-name {
            font-size: 18px;
            font-weight: 700;
            color: #1e40af;
        }

        .results-score {
            font-size: 24px;
            font-weight: 700;
            color: #3b82f6;
        }

        .results-details {
            display: flex;
            gap: 16px;
            font-size: 13px;
            color: #64748b;
        }

        .results-stat {
            display: flex;
            flex-direction: column;
        }

        .results-stat-label {
            font-weight: 600;
            margin-bottom: 2px;
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: 40px;
            color: #64748b;
        }

        /* Share Tournament Section */
        .share-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .share-section h3 {
            color: #1e40af;
            margin-bottom: 16px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .share-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .share-btn {
            background: white;
            color: #3b82f6;
            border: 2px solid #3b82f6;
            padding: 12px 8px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .share-btn:active {
            transform: scale(0.98);
            background: #f8fafc;
        }

        .share-btn.copy {
            color: #10b981;
            border-color: #10b981;
        }

        .share-btn.qr {
            color: #a855f7;
            border-color: #a855f7;
        }

        .share-btn.download {
            color: #f59e0b;
            border-color: #f59e0b;
        }

        #qrCodeContainer {
            text-align: center;
            padding: 20px;
            background: #f8fafc;
            border-radius: 8px;
            margin-top: 16px;
        }

        #qrCodeContainer canvas {
            margin: 0 auto;
            display: block;
        }

        .tournament-id {
            font-family: monospace;
            background: #f1f5f9;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            color: #475569;
            margin-top: 10px;
            word-break: break-all;
        }

        /* ===== UI ENHANCEMENTS ===== */
        
        /* Player Avatar Circles */
        .player-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 12px;
            color: white;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .player-avatar-large {
            width: 48px;
            height: 48px;
            font-size: 18px;
        }

        /* Score Color Coding */
        .score-eagle {
            background: linear-gradient(135deg, #059669, #10b981);
            color: white;
            font-weight: 700;
        }

        .score-birdie {
            background: linear-gradient(135deg, #10b981, #34d399);
            color: white;
            font-weight: 700;
        }

        .score-par {
            background: #f1f5f9;
            color: #475569;
        }

        .score-bogey {
            background: linear-gradient(135deg, #f59e0b, #fbbf24);
            color: white;
            font-weight: 700;
        }

        .score-double {
            background: linear-gradient(135deg, #ef4444, #f87171);
            color: white;
            font-weight: 700;
        }

        /* Enhanced Shadows */
        .card-shadow {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 
                        0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .card-shadow-lg {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 
                        0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .card-shadow-xl {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 
                        0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        /* Pulse Animation for Score Changes */
        @keyframes scorePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .score-changed {
            animation: scorePulse 0.3s ease-out;
        }

        /* Trophy Icons */
        .trophy-gold {
            color: #fbbf24;
            font-size: 24px;
            margin-right: 8px;
        }

        .trophy-silver {
            color: #d1d5db;
            font-size: 22px;
            margin-right: 8px;
        }

        .trophy-bronze {
            color: #c27803;
            font-size: 20px;
            margin-right: 8px;
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 12px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #3b82f6);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        /* Confetti Animation */
        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            z-index: 9999;
            pointer-events: none;
        }

        /* Ripple Effect */
        .ripple {
            position: relative;
            overflow: hidden;
        }

        .ripple::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .ripple:active::after {
            width: 300px;
            height: 300px;
        }

        /* Number Count Animation */
        @keyframes numberCount {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .number-animate {
            animation: numberCount 0.3s ease-out;
        }

        /* Scorecard Modal */
        .scorecard-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .scorecard-modal.active {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 20px;
        }

        .scorecard-content {
            background: white;
            border-radius: 16px;
            max-width: 900px;
            width: 100%;
            margin: 20px auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .scorecard-header {
            padding: 20px;
            border-bottom: 2px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .scorecard-body {
            padding: 12px;
            max-height: 75vh;
            overflow-y: auto;
        }

        .scorecard-footer {
            padding: 16px;
            border-top: 2px solid #e2e8f0;
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .scorecard-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 11px;
            table-layout: auto;
        }

        .scorecard-table th,
        .scorecard-table td {
            border: 1px solid #cbd5e1;
            padding: 4px 2px;
            text-align: center;
            min-width: 35px;
            line-height: 1.2;
        }

        .scorecard-table th {
            background: #3b82f6;
            color: white;
            font-weight: 600;
            font-size: 10px;
            padding: 3px 2px;
        }

        .scorecard-table .player-name-cell {
            background: #dbeafe;
            font-weight: 600;
            color: #1e40af;
        }

        .scorecard-table .total-row {
            background: #f1f5f9;
            font-weight: 600;
        }

        .scorecard-individual {
            background: white;
            border: 2px solid #cbd5e1;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            page-break-inside: avoid;
            break-inside: avoid;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .scorecard-player-header {
            text-align: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        }

        .scorecard-player-name {
            font-size: 20px;
            font-weight: 700;
            color: #1e40af;
            margin-bottom: 4px;
        }

        .scorecard-player-info {
            font-size: 14px;
            color: #64748b;
        }

        /* Round in Progress Indicator */
        .round-indicator {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); /* Bright orange/amber */
            color: white;
            padding: 12px 16px; /* Slightly taller */
            text-align: center;
            font-size: 14px; /* Larger text */
            font-weight: 700; /* Bolder */
            z-index: 9998;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4); /* Stronger shadow with orange tint */
            display: none;
            border-bottom: 2px solid #fff; /* White bottom border */
        }

        .round-indicator.active {
            display: block;
        }

        .round-indicator-icon {
            display: inline-block;
            width: 10px; /* Slightly larger dot */
            height: 10px;
            background: #fff;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1.5s infinite; /* Faster pulse */
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .auto-save-toast {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 9999;
            pointer-events: none;
        }

        .auto-save-toast.show {
            opacity: 1;
        }

        .resume-round-section {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            color: white;
            display: none;
        }

        .resume-round-section.active {
            display: block;
        }

        .resume-round-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .resume-round-info {
            font-size: 14px;
            margin-bottom: 16px;
            opacity: 0.9;
        }

        .resume-round-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .resume-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
        }

        .discard-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* View Toggle Buttons in Header */
        .view-toggle-btn-header {
            padding: 8px 16px;
            background: #f1f5f9;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            color: #64748b;
            flex: 1;
            justify-content: center;
        }

        .view-toggle-btn-header.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }

        /* Old toggle buttons - can remove */
        .view-toggle-btn {
            flex: 1;
            padding: 8px 16px;
            background: white;
            border: 2px solid #cbd5e1;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #64748b;
            cursor: pointer;
            transition: all 0.2s;
        }

        .view-toggle-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }

        /* Hole View Styles */
        .hole-view-container {
            background: white;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .hole-header {
            text-align: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px solid #e2e8f0;
        }

        .hole-number {
            font-size: 28px;
            font-weight: 700;
            color: #1e40af;
            margin-bottom: 4px;
        }

        .hole-info {
            font-size: 16px;
            color: #64748b;
            font-weight: 600;
        }

        .hole-player-row-ticker {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            padding: 16px;
            margin-bottom: 12px;
            background: #f8fafc;
            border-radius: 12px;
            gap: 16px;
        }

        .hole-player-info {
            flex: 1;
        }

        .hole-player-name {
            font-size: 16px;
            font-weight: 600;
            color: #1e40af;
        }

        .hole-player-hcp {
            font-size: 13px;
            color: #64748b;
            margin-top: 2px;
        }

        .hole-score-section {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        .hole-score-ticker {
            display: grid;
            grid-template-columns: auto auto auto;
            gap: 8px;
            align-items: center;
        }

        .hole-net-score {
            font-size: 12px;
            color: #065f46;
            font-weight: 700;
            text-align: center;
            width: 100%;
        }

        .hole-score-ticker .score-btn {
            width: 44px;
            height: 44px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 24px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .hole-score-ticker .score-btn:active {
            background: #2563eb;
        }

        .hole-score-ticker .score-input {
            width: 60px;
            height: 44px;
            font-size: 20px;
            font-weight: 700;
            text-align: center;
            border: 2px solid #cbd5e1;
            border-radius: 10px;
            background: white;
            color: #1e40af;
        }

        .hole-score-ticker .score-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        /* Score coloring for hole view */
        .hole-score-ticker .score-input.birdie-better {
            background: #dcfce7;
            border-color: #86efac;
            color: #166534;
        }

        .hole-score-ticker .score-input.par {
            background: #dbeafe;
            border-color: #60a5fa;
            color: #1e40af;
        }

        .hole-score-ticker .score-input.bogey {
            background: #fef9c3;
            border-color: #fde047;
            color: #854d0e;
        }

        .hole-score-ticker .score-input.double-bogey-plus {
            background: #fee2e2;
            border-color: #fca5a5;
            color: #991b1b;
        }

        .hole-player-row {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            padding: 12px;
            margin-bottom: 12px;
            background: #f8fafc;
            border-radius: 12px;
            gap: 12px;
        }

        .hole-player-name {
            font-size: 16px;
            font-weight: 600;
            color: #1e40af;
        }

        .hole-player-hcp {
            font-size: 13px;
            color: #64748b;
            margin-top: 2px;
        }

        .hole-score-input {
            width: 60px;
            height: 60px;
            font-size: 24px;
            font-weight: 700;
            text-align: center;
            border: 2px solid #cbd5e1;
            border-radius: 12px;
            background: white;
            color: #1e40af;
        }

        .hole-score-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .hole-navigation {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 12px;
            align-items: center;
            margin-top: 24px;
        }

        .hole-nav-btn {
            padding: 12px 20px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .hole-nav-btn:disabled {
            background: #e2e8f0;
            color: #94a3b8;
            cursor: not-allowed;
        }

        .hole-counter {
            text-align: center;
            font-size: 16px;
            font-weight: 600;
            color: #64748b;
        }

        /* Swipe gesture support */
        .hole-view-container {
            touch-action: pan-y;
            position: relative;
        }

        /* Score Picker Overlay */
        .score-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 20px;
        }

        .score-picker {
            background: white;
            border-radius: 20px;
            padding: 24px;
            width: 100%;
            max-width: 320px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .score-picker-header {
            text-align: center;
            font-size: 16px;
            color: #1e40af;
            margin-bottom: 16px;
        }

        .score-display {
            text-align: center;
            font-size: 48px;
            font-weight: 700;
            color: #3b82f6;
            margin: 20px 0;
        }

        .score-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }

        .score-btn {
            padding: 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            transition: background 0.2s;
        }

        .score-btn:active {
            background: #2563eb;
        }

        .score-close {
            width: 100%;
            padding: 14px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        /* Wrapper for table to enable horizontal scroll */
        .table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin-bottom: 20px;
        }

        @media print {
            .scorecard-modal {
                display: block !important;
                position: static;
                background: white;
            }

            .scorecard-content {
                box-shadow: none;
                max-width: 100%;
            }

            .scorecard-header,
            .scorecard-footer {
                display: none !important;
            }

            .scorecard-body {
                max-height: none;
                overflow: visible;
            }
            
            .scorecard-individual {
                page-break-inside: avoid;
                break-inside: avoid;
            }
            
            .table-wrapper {
                overflow: visible;
            }
            
            .scorecard-table {
                font-size: 10px;
            }
            
            .scorecard-table th,
            .scorecard-table td {
                padding: 4px 2px;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
                padding: 0;
            }

            .page {
                display: none;
            }

            #printableScorecard {
                display: block !important;
            }

            .btn, .form-group, #resultsGameType {
                display: none !important;
            }

            .print-scorecard {
                display: block;
                padding: 20px;
                font-family: Arial, sans-serif;
                color: black;
            }

            .print-header {
                text-align: center;
                margin-bottom: 20px;
                border-bottom: 2px solid black;
                padding-bottom: 10px;
            }

            .print-table {
                width: 100%;
                border-collapse: collapse;
                margin-bottom: 20px;
                page-break-inside: avoid;
            }

            .print-table th,
            .print-table td {
                border: 1px solid black;
                padding: 6px;
                text-align: center;
                font-size: 11px;
            }

            .print-table th {
                background: #e0e0e0;
                font-weight: bold;
            }

            .print-results {
                margin-top: 20px;
                page-break-before: avoid;
            }

            .print-results h3 {
                border-bottom: 2px solid black;
                padding-bottom: 5px;
                margin-bottom: 10px;
            }
        }

        .print-scorecard {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Setup Page -->
    <div id="setupPage" class="page active">
        <div class="header">
            <h1>â›³ Let's Golf <span style="font-size: 12px; font-weight: 400; color: #64748b;">by Otis Williams</span></h1>
            <p>Golf Games and Tournaments</p>
        </div>

        <div class="setup-container">
            <!-- Scoring Mode Toggle -->
            <div class="form-group" style="margin-bottom: 20px;">
                <label style="color: white; margin-bottom: 8px; display: block; font-weight: 600; font-size: 14px;">Scoring Mode</label>
                <div class="header-bottom-row" style="justify-content: stretch; background: rgba(255,255,255,0.15); border-radius: 8px; padding: 4px;">
                    <button type="button" class="view-toggle-btn active" id="multiDeviceBtn" onclick="selectScoringMode('multi')" style="flex: 1;">
                        Multi-Device
                    </button>
                    <button type="button" class="view-toggle-btn" id="singleDeviceBtn" onclick="selectScoringMode('single')" style="flex: 1;">
                        Single-Device
                    </button>
                </div>
            </div>

            <!-- Resume Round Section (hidden by default) -->
            <div id="resumeRoundSection" class="resume-round-section">
                <div class="resume-round-title">ðŸ”„ Round in Progress</div>
                <div class="resume-round-info" id="resumeRoundInfo">Continue your saved round or start fresh</div>
                <div class="resume-round-buttons">
                    <button type="button" class="resume-btn" onclick="resumeSavedRound()" style="background: #10b981; border-color: #10b981;">Resume</button>
                    <button type="button" class="resume-btn discard-btn" onclick="discardSavedRound()" style="background: #ef4444; border-color: #ef4444;">Delete</button>
                </div>
                <!-- Share buttons (only shown in multi-device mode) -->
                <div id="resumeShareButtons" class="resume-round-buttons" style="display: none; margin-top: 12px; grid-template-columns: 1fr 1fr 1fr;">
                    <button type="button" class="resume-btn" onclick="copyLinkFromResume()" style="background: white !important; color: #10b981; border: 2px solid #10b981; padding: 8px 6px; font-size: 12px;">ðŸ”— Link</button>
                    <button type="button" class="resume-btn" onclick="showQRFromResume()" style="background: white !important; color: #8b5cf6; border: 2px solid #8b5cf6; padding: 8px 6px; font-size: 12px;">ðŸ“± QR</button>
                    <button type="button" class="resume-btn" onclick="saveTournamentFile()" style="background: white !important; color: #f97316; border: 2px solid #f97316; padding: 8px 6px; font-size: 12px;">ðŸ’¾ Save</button>
                </div>
            </div>

            <div class="form-group">
                <label>Tournament Date</label>
                <input type="date" id="tournamentDate" placeholder="Select a Date" required>
            </div>

            <div class="form-group">
                <label>Tournament Name <span style="color: #94a3b8; font-weight: 400; font-size: 13px;">(Optional)</span></label>
                <input type="text" id="tournamentName" placeholder="e.g., Saturday Morning Scramble" style="color: #1e293b;">
            </div>

            <div class="form-group">
                <label>Course</label>
                <select id="courseSelect" onchange="updateCourse()">
                    <option value="" selected>Select a Course</option>
                    <option value="hidden_valley">Hidden Valley Golf Club</option>
                    <option value="indian_hills">Indian Hills Golf Club</option>
                    <option value="jurupa_hills">Jurupa Hills Country Club</option>
                </select>
            </div>

            <div class="form-group">
                <label>Game Type</label>
                <select id="gameType" onchange="handleGameTypeChange()">
                    <option value="" selected>Select a Game Type</option>
                    <option value="Stroke Play Gross">Stroke Play Gross</option>
                    <option value="Stroke Play Net">Stroke Play Net</option>
                    <option value="Gross Skins">Gross Skins</option>
                    <option value="Net Skins (Full Hcp)">Net Skins (Full Hcp)</option>
                    <option value="Net Skins (18 Max)">Net Skins (18 Max)</option>
                    <option value="Net Skins (1/2 Pop)">Net Skins (1/2 Pop)</option>
                    <option value="Stableford">Stableford</option>
                    <option value="Stableford (Modified)">Stableford (Modified)</option>
                    <option value="2-Man Best Ball">2-Man Best Ball</option>
                    <option value="3-Man Best Ball">3-Man Best Ball</option>
                    <option value="4-Man Best Ball">4-Man Best Ball</option>
                </select>
            </div>

            <div id="teamSetupSection" class="form-group" style="display: none;">
                <label>Team Setup</label>
                <div id="teamSetupContent"></div>
            </div>

            <div class="form-group">
                <label>Players & Handicaps</label>
                
                <!-- Quick Add Frequent Players -->
                <div id="quickAddSection" style="margin-bottom: 15px; display: none;">
                    <div style="font-size: 13px; color: #64748b; margin-bottom: 8px; font-weight: 600;">Quick Add:</div>
                    <div id="quickAddButtons" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
                </div>
                
                <div class="player-list" id="playerList">
                    <div class="player-row" data-player="1">
                        <input type="text" class="player-name-input" placeholder="Player Name" id="player1">
                        <input type="text" class="player-hcp-input" placeholder="HCP" id="hcp1" pattern="-?[0-9]*" inputmode="numeric">
                    </div>
                </div>
                
                <!-- Add Player and Load Game Side by Side -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                    <button type="button" class="btn-add-player" onclick="addPlayerRow()" id="addPlayerBtn"><span style="font-size: 20px; font-weight: 600;">+</span> Add Player</button>
                    <button type="button" class="btn-add-player" onclick="document.getElementById('importFile').click()" style="background: white; color: #3b82f6; border-color: #3b82f6;">
                        <span style="font-weight: 900; font-size: 18px;">â†“</span> Load Game
                    </button>
                </div>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importTournamentBackup(event)">
            </div>

            <button type="button" class="btn btn-primary" id="resumeScoringBtn" style="background: #10b981; display: none;" onclick="resumeScoring()">Resume Scoring</button>
            <button type="button" class="btn btn-primary" onclick="startScoring()">Start Scoring</button>
        </div>
    </div>

    <!-- Scoring Page -->
    <div id="scoringPage" class="page">
        <!-- Round in Progress Indicator -->
        <div id="roundIndicator" class="round-indicator">
            <span class="round-indicator-icon"></span>
            <span>Round in Progress â€¢ Auto-saved</span>
        </div>
        
        <div class="scoring-header">
            <div class="header-top-row">
                <button type="button" class="back-btn" id="backToSetupBtn" data-action="confirmBackToSetup">â† Back</button>
                <div class="tournament-info-centered">
                    <p id="scoringTournamentName" style="font-size: 13px; color: #64748b; margin-bottom: 2px; font-weight: 600;"></p>
                    <h2 id="scoringGameType">Individual Stroke Play</h2>
                    <p id="scoringDate">Today</p>
                </div>
                <button type="button" class="finish-btn" id="finishRoundBtn" data-action="finishRound">Results</button>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="tournamentProgress" style="width: 0%"></div>
            </div>
            <div class="header-bottom-row">
                <button type="button" id="toggleHoleView" class="view-toggle-btn-header active" onclick="switchToHoleView()">
                    â›³ Holes
                </button>
                <button type="button" id="togglePlayerView" class="view-toggle-btn-header" onclick="switchToPlayerView()">
                    ðŸ‘¤ Players
                </button>
            </div>
        </div>

        <div class="scoring-content">

            <div id="playerCards"></div>
            
            <!-- By Hole View (hidden by default) -->
            <div id="holeView" style="display: none;">
                <div id="holeViewContent"></div>
            </div>
        </div>
    </div>

    <!-- Results Page -->
    <div id="resultsPage" class="page">
        <div class="results-page-header">
            <button class="back-btn" data-action="backToScoring">â† Back</button>
            <div class="tournament-info-simple" style="text-align: center;">
                <h2>â›³ Let's Golf <span style="font-size: 10px; font-weight: 400; color: #64748b;">by Otis Williams</span></h2>
                <p id="resultsTournamentName" style="font-size: 14px; color: #1e40af; font-weight: 600; margin-bottom: 2px;"></p>
                <p id="resultsSubtitle">Final Scores</p>
            </div>
            <button class="finish-btn" id="newRoundBtnTop" data-action="confirmNewRound" style="background: #ef4444;">Finish</button>
        </div>

        <div class="results-container">
            <div class="form-group" style="margin-bottom: 20px;">
                <label>View Results As:</label>
                <select id="resultsGameType" onchange="updateResultsGameType()">
                    <option value="Stroke Play Gross">Stroke Play Gross</option>
                    <option value="Stroke Play Net">Stroke Play Net</option>
                    <option value="Gross Skins">Gross Skins</option>
                    <option value="Net Skins (Full Hcp)">Net Skins (Full Hcp)</option>
                    <option value="Net Skins (18 Max)">Net Skins (18 Max)</option>
                    <option value="Net Skins (1/2 Pop)">Net Skins (1/2 Pop)</option>
                    <option value="Stableford">Stableford</option>
                    <option value="Stableford (Modified)">Stableford (Modified)</option>
                    <option value="2-Man Best Ball">2-Man Best Ball</option>
                    <option value="3-Man Best Ball">3-Man Best Ball</option>
                    <option value="4-Man Best Ball">4-Man Best Ball</option>
                </select>
            </div>
            <div id="resultsContent"></div>
            
            <!-- View Scorecards Button -->
            <div style="display: grid; gap: 10px; margin-top: 20px;">
                <button type="button" class="btn btn-primary" onclick="openScorecardModal()" style="background: #3b82f6; margin-top: 0;">ðŸ“‹ View Scorecards</button>
            </div>
            
            <!-- Share Tournament Section -->
            <div class="share-section">
                <h3>ðŸ”— Let's Share Golf</h3>
                <div class="share-buttons">
                    <button class="share-btn copy" onclick="copyShareLink()">
                        Copy Link
                    </button>
                    <button class="share-btn qr" onclick="showQRCode()">
                        QR Code
                    </button>
                    <button class="share-btn download" onclick="downloadTournamentData()">
                        Save Game
                    </button>
                </div>
                <div id="qrCodeContainer" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <p style="color: #64748b; font-size: 14px; margin: 0;">Scan to join tournament:</p>
                        <button onclick="hideQRCode()" style="background: #ef4444; color: white; border: none; border-radius: 6px; padding: 6px 12px; font-size: 13px; font-weight: 600; cursor: pointer;">âœ• Close</button>
                    </div>
                    <div id="qrcode"></div>
                    <div class="tournament-id" id="tournamentIdDisplay"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scorecard Modal -->
    <div id="scorecardModal" class="scorecard-modal">
        <div class="scorecard-content">
            <div class="scorecard-header">
                <h2 style="color: #1e40af; margin: 0;">ðŸ“‹ Scorecards</h2>
                <button onclick="closeScorecardModal()" style="background: #ef4444; color: white; border: none; border-radius: 8px; padding: 8px 16px; font-weight: 600; cursor: pointer;">âœ• Close</button>
            </div>
            <div style="padding: 20px; border-bottom: 1px solid #e2e8f0;">
                <label style="font-weight: 600; color: #1e40af; margin-bottom: 8px; display: block;">Select View:</label>
                <select id="scorecardViewSelect" onchange="updateScorecardView()" style="width: 100%; padding: 12px; border: 2px solid #cbd5e1; border-radius: 8px; font-size: 16px;">
                    <option value="all-summary">All Players - Summary Table</option>
                    <option value="all-individual">All Players - Individual Cards</option>
                    <option disabled>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</option>
                </select>
            </div>
            <div class="scorecard-body" id="scorecardBody">
                <!-- Scorecard content will be populated here -->
            </div>
            <div class="scorecard-footer">
                <button onclick="printScorecard()" class="btn btn-primary" style="background: #10b981; margin: 0;">ðŸ“¤ Share / Print</button>
            </div>
        </div>
    </div>

    <!-- Printable Scorecard (Hidden, only shows when printing) -->
    <div id="printableScorecard" class="print-scorecard"></div>

    <!-- Auto-save Toast -->
    <div id="autoSaveToast" class="auto-save-toast">âœ“ Saved</div>

    <!-- Join Tournament Page -->
    <div id="joinPage" class="page">
        <div class="card">
            <div class="tournament-info-centered">
                <p style="font-size: 32px;">â›³</p>
                <h2>Join Tournament</h2>
                <p id="joinTournamentInfo" style="margin-top: 8px;">Loading...</p>
            </div>

            <form id="joinTournamentForm" style="margin-top: 24px;">
                <div class="form-group">
                    <label>Your Name</label>
                    <input type="text" id="joinPlayerName" placeholder="Enter your name" required>
                </div>

                <div class="form-group">
                    <label>Handicap Index</label>
                    <input type="number" id="joinPlayerHandicap" min="0" max="54" step="0.1" placeholder="0.0" required>
                </div>

                <div class="form-group">
                    <label>Contact for Notifications (Optional)</label>
                    <input type="email" id="joinPlayerEmail" placeholder="Email address">
                    <p style="text-align: center; margin: 8px 0; color: #64748b; font-size: 14px;">OR</p>
                    <input type="tel" id="joinPlayerPhone" placeholder="Phone number">
                    <p style="font-size: 12px; color: #64748b; margin-top: 4px;">Used for tournament updates if push notifications are disabled</p>
                </div>

                <button type="submit" class="btn-primary" style="width: 100%; margin-top: 8px;">
                    Join Tournament
                </button>

                <button type="button" class="btn-secondary" onclick="showPage('setupPage')" style="width: 100%; margin-top: 8px;">
                    Cancel
                </button>
            </form>

            <div id="joinExistingPlayers" style="margin-top: 24px; display: none;">
                <div style="border-top: 1px solid #e2e8f0; padding-top: 16px; margin-top: 16px;">
                    <p style="color: #64748b; font-size: 14px; margin-bottom: 12px;">Already in tournament? Select yourself:</p>
                    <div id="existingPlayersList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Live Leaderboard Page (for spectators) -->
    <div id="liveLeaderboardPage" class="page">
        <div class="card">
            <div class="tournament-info-centered">
                <p style="font-size: 32px;">ðŸ†</p>
                <h2>Live Leaderboard</h2>
                <p id="liveLeaderboardInfo"></p>
            </div>

            <!-- Game Toggle Tabs -->
            <div id="gameToggleTabs" style="display: flex; gap: 4px; margin: 20px 0; overflow-x: auto; -webkit-overflow-scrolling: touch; flex-wrap: nowrap;">
                <!-- Tabs will be generated dynamically -->
            </div>

            <div id="liveLeaderboardContent" style="margin-top: 16px;">
                <!-- Leaderboard will be generated here -->
            </div>

            <div style="margin-top: 20px; padding: 16px; background: rgba(255,255,255,0.1); border-radius: 12px; text-align: center;">
                <p style="color: #64748b; font-size: 14px; margin-bottom: 8px;">
                    <span id="lastUpdateTime">Just now</span> â€¢ <span id="activePlayersCount">0</span> players
                </p>
                <label style="display: flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="autoRefreshToggle" checked style="width: 20px; height: 20px;">
                    <span style="color: white; font-size: 14px;">Auto-refresh</span>
                </label>
            </div>

            <button type="button" class="btn-secondary" onclick="showPage('setupPage')" style="width: 100%; margin-top: 16px;">
                Back to Home
            </button>
        </div>
    </div>

    <!-- Host Dashboard Page -->
    <div id="hostDashboardPage" class="page">
        <div class="card">
            <div class="tournament-info-centered">
                <p style="font-size: 32px;">ðŸŽ®</p>
                <h2>Tournament Admin</h2>
                <p id="hostDashboardInfo"></p>
            </div>

            <div style="margin-top: 24px;">
                <h3 style="color: #1e40af; margin-bottom: 12px; font-size: 18px;">Players & Devices</h3>
                <div id="playerDeviceList">
                    <!-- Will be populated dynamically -->
                </div>
            </div>

            <div style="margin-top: 24px;">
                <h3 style="color: #1e40af; margin-bottom: 12px; font-size: 18px;">Tournament Controls</h3>
                <button type="button" class="btn-secondary" onclick="addPlayerManually()" style="width: 100%; margin-bottom: 8px;">
                    âž• Add Player Manually
                </button>
                <button type="button" class="btn-secondary" onclick="lockTournament(activeTournamentId)" style="width: 100%; margin-bottom: 8px;">
                    ðŸ”’ Lock Tournament (No More Joins)
                </button>
                <button type="button" class="btn-primary" onclick="endTournament(activeTournamentId)" style="width: 100%; margin-bottom: 8px; background: #ef4444;">
                    ðŸ End Tournament
                </button>
            </div>

            <button type="button" class="btn-secondary" onclick="showPage('scoringPage')" style="width: 100%; margin-top: 16px;">
                Back to Scoring
            </button>
        </div>
    </div>

    <!-- Custom Confirmation Dialog (iOS-friendly) -->
    <div id="confirmDialog" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; border-radius: 16px; padding: 24px; margin: 20px; max-width: 400px; box-shadow: 0 8px 16px rgba(0,0,0,0.3);">
            <h3 id="confirmTitle" style="color: #1e40af; margin-bottom: 12px; font-size: 20px;">Confirm Action</h3>
            <p id="confirmMessage" style="color: #64748b; margin-bottom: 24px; font-size: 16px; line-height: 1.5;"></p>
            <div style="display: flex; gap: 12px;">
                <button type="button" id="confirmCancel" style="flex: 1; padding: 12px; background: #e2e8f0; color: #475569; border: none; border-radius: 8px; font-size: 16px; font-weight: 600;">Cancel</button>
                <button type="button" id="confirmOk" style="flex: 1; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600;">Confirm</button>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // FIREBASE CONFIGURATION & INITIALIZATION
        // ========================================
        
        // Wait for Firebase scripts to load
        function initializeFirebase() {
            if (typeof firebase === 'undefined') {
                console.error('âš ï¸ Firebase scripts not loaded! Retrying...');
                setTimeout(initializeFirebase, 500);
                return;
            }
            
            console.log('âœ… Firebase scripts loaded successfully!');
            
            const firebaseConfig = {
                apiKey: "AIzaSyDXgnAjWT0Csd0gu9D6JUbghz149hLhb90",
                authDomain: "u-lik-golf.firebaseapp.com",
                projectId: "u-lik-golf",
                storageBucket: "u-lik-golf.firebasestorage.app",
                messagingSenderId: "637984857306",
                appId: "1:637984857306:web:7d7ff315a360c3544b59e3"
            };

            // Initialize Firebase
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
            auth = firebase.auth();
            
            console.log('âœ… Firebase initialized!');
            
            // Enable offline persistence
            db.enablePersistence({synchronizeTabs: true})
                .catch((err) => {
                    if (err.code == 'failed-precondition') {
                        console.warn('Multiple tabs open, persistence only in one tab');
                    } else if (err.code == 'unimplemented') {
                        console.warn('Browser doesn\'t support persistence');
                    }
                });

            // Anonymous authentication for device identification
            console.log('ðŸ” Starting anonymous authentication...');
            auth.signInAnonymously().catch((error) => {
                console.error('Auth error:', error);
            });

            // Auth state listener
            auth.onAuthStateChanged((user) => {
                authCompleted = true;
                if (user) {
                    currentUserId = user.uid;
                    // Generate a unique device ID (stored in localStorage)
                    if (!localStorage.getItem('deviceId')) {
                        localStorage.setItem('deviceId', 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
                    }
                    currentDeviceId = localStorage.getItem('deviceId');
                    console.log('âœ… Firebase authenticated successfully!');
                    console.log('User ID:', currentUserId);
                    console.log('Device ID:', currentDeviceId);
                } else {
                    console.log('âš ï¸ No Firebase user - attempting anonymous sign-in...');
                }
            });
        }
        
        // Start initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeFirebase);
        } else {
            initializeFirebase();
        }

        // Global Firebase state
        let db = null;
        let auth = null;
        let currentUserId = null;
        let currentDeviceId = null;
        let unsubscribeFunctions = [];
        let authCompleted = false;

        // CRITICAL FALLBACK: Set timer immediately on page load
        // This ensures local-only mode activates even if Firebase completely crashes
        console.log('â° Starting 3-second fallback timer...');
        setTimeout(() => {
            if (!authCompleted && !currentUserId) {
                console.warn('â±ï¸ Firebase auth timeout - switching to local-only mode');
                authCompleted = true;
                currentUserId = 'local_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                if (!localStorage.getItem('deviceId')) {
                    localStorage.setItem('deviceId', 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
                }
                currentDeviceId = localStorage.getItem('deviceId');
                console.log('âœ… Local-only mode activated');
                console.log('   Local User ID:', currentUserId);
                console.log('   Device ID:', currentDeviceId);
            } else {
                console.log('âœ“ Auth already completed, no fallback needed');
            }
        }, 3000);

        // ========================================
        // COURSE DATA
        // ========================================
        
        // Course data
        const courses = {
            hidden_valley: {
                name: "Hidden Valley Golf Club",
                totalPar: 72,
                holes: [
                    { number: 1, par: 5, handicap: 9 },
                    { number: 2, par: 4, handicap: 5 },
                    { number: 3, par: 4, handicap: 13 },
                    { number: 4, par: 4, handicap: 11 },
                    { number: 5, par: 3, handicap: 1 },
                    { number: 6, par: 5, handicap: 7 },
                    { number: 7, par: 4, handicap: 17 },
                    { number: 8, par: 3, handicap: 15 },
                    { number: 9, par: 4, handicap: 3 },
                    { number: 10, par: 4, handicap: 6 },
                    { number: 11, par: 5, handicap: 10 },
                    { number: 12, par: 4, handicap: 8 },
                    { number: 13, par: 3, handicap: 16 },
                    { number: 14, par: 4, handicap: 18 },
                    { number: 15, par: 5, handicap: 4 },
                    { number: 16, par: 3, handicap: 12 },
                    { number: 17, par: 4, handicap: 14 },
                    { number: 18, par: 4, handicap: 2 }
                ]
            },
            indian_hills: {
                name: "Indian Hills Golf Club",
                totalPar: 70,
                holes: [
                    { number: 1, par: 4, handicap: 5 },
                    { number: 2, par: 4, handicap: 15 },
                    { number: 3, par: 3, handicap: 7 },
                    { number: 4, par: 4, handicap: 3 },
                    { number: 5, par: 3, handicap: 11 },
                    { number: 6, par: 4, handicap: 9 },
                    { number: 7, par: 4, handicap: 17 },
                    { number: 8, par: 5, handicap: 13 },
                    { number: 9, par: 4, handicap: 1 },
                    { number: 10, par: 4, handicap: 8 },
                    { number: 11, par: 3, handicap: 16 },
                    { number: 12, par: 4, handicap: 18 },
                    { number: 13, par: 4, handicap: 12 },
                    { number: 14, par: 4, handicap: 6 },
                    { number: 15, par: 3, handicap: 14 },
                    { number: 16, par: 4, handicap: 4 },
                    { number: 17, par: 4, handicap: 2 },
                    { number: 18, par: 5, handicap: 10 }
                ]
            },
            jurupa_hills: {
                name: "Jurupa Hills Country Club",
                totalPar: 70,
                holes: [
                    { number: 1, par: 4, handicap: 7 },
                    { number: 2, par: 4, handicap: 3 },
                    { number: 3, par: 3, handicap: 15 },
                    { number: 4, par: 4, handicap: 11 },
                    { number: 5, par: 4, handicap: 13 },
                    { number: 6, par: 4, handicap: 5 },
                    { number: 7, par: 5, handicap: 1 },
                    { number: 8, par: 3, handicap: 17 },
                    { number: 9, par: 4, handicap: 9 },
                    { number: 10, par: 4, handicap: 8 },
                    { number: 11, par: 4, handicap: 2 },
                    { number: 12, par: 4, handicap: 14 },
                    { number: 13, par: 4, handicap: 4 },
                    { number: 14, par: 3, handicap: 18 },
                    { number: 15, par: 5, handicap: 6 },
                    { number: 16, par: 4, handicap: 12 },
                    { number: 17, par: 4, handicap: 10 },
                    { number: 18, par: 3, handicap: 16 }
                ]
            }
        };

        let courseData = null; // No default course - user must select

        let currentPlayerCount = 1;
        let nextPlayerId = 2;
        const maxPlayers = 40;

        // Swipe-to-delete functionality
        let touchStartX = 0;
        let touchStartY = 0;
        let touchCurrentX = 0;
        let swipingRow = null;
        let isScrolling = null;

        // Initialize autocomplete, quick add, and swipe after page loads
        window.addEventListener('load', function() {
            // Set today's date as default
            const dateInput = document.getElementById('tournamentDate');
            if (dateInput) {
                dateInput.valueAsDate = new Date();
            }
            
            initializeAutocomplete();
            renderQuickAddButtons();
            initializeSwipeGestures();
            
            // Check for shared tournament in URL
            loadTournamentFromURL();
        });

        function initializeSwipeGestures() {
            // Setup swipe-to-delete for player rows
            const playerList = document.getElementById('playerList');
            if (!playerList) return;

            let touchStartX = 0;
            let touchStartY = 0;
            let touchCurrentX = 0;
            let swipingRow = null;
            let isScrolling = null;

            playerList.addEventListener('touchstart', function(e) {
                const row = e.target.closest('.player-row');
                if (!row) return;

                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                swipingRow = row;
                isScrolling = null;
            }, { passive: true });

            playerList.addEventListener('touchmove', function(e) {
                if (!swipingRow) return;

                touchCurrentX = e.touches[0].clientX;
                const touchCurrentY = e.touches[0].clientY;
                const diffX = touchStartX - touchCurrentX;
                const diffY = touchStartY - touchCurrentY;

                // Determine if scrolling vertically or swiping horizontally
                if (isScrolling === null) {
                    isScrolling = Math.abs(diffY) > Math.abs(diffX);
                }

                // If scrolling vertically, don't swipe
                if (isScrolling) return;

                // Prevent vertical scroll while swiping
                e.preventDefault();

                // Only allow swipe left
                if (diffX > 0 && diffX <= 100) {
                    swipingRow.style.transform = `translateX(-${diffX}px)`;
                }
            }, { passive: false });

            playerList.addEventListener('touchend', function(e) {
                if (!swipingRow) return;

                const diffX = touchStartX - touchCurrentX;

                // If swiped more than 50px, snap to delete position
                if (diffX > 50) {
                    swipingRow.classList.add('swiped');
                    swipingRow.style.transform = 'translateX(-100px)';
                } else {
                    // Snap back
                    swipingRow.classList.remove('swiped');
                    swipingRow.style.transform = 'translateX(0)';
                }

                // Reset
                swipingRow = null;
                isScrolling = null;
                touchStartX = 0;
                touchCurrentX = 0;
            }, { passive: true });

            // Click on delete area to delete
            playerList.addEventListener('click', function(e) {
                const row = e.target.closest('.player-row.swiped');
                if (!row) return;

                const rect = row.getBoundingClientRect();
                const clickX = e.clientX;

                // If clicked on the revealed delete button area
                if (clickX > rect.right - 20) {
                    const playerId = row.getAttribute('data-player');
                    deletePlayerRow(playerId);
                } else {
                    // Clicked elsewhere, close the swipe
                    row.classList.remove('swiped');
                    row.style.transform = 'translateX(0)';
                }
            });
        }

        // Delete player row with animation
        function deletePlayerRow(playerId) {
            const row = document.querySelector(`[data-player="${playerId}"]`);
            if (!row) return;
            
            // Don't allow deleting if only 1 player remains
            if (currentPlayerCount <= 1) {
                alert('You must have at least one player');
                row.classList.remove('swiped');
                row.style.transform = 'translateX(0)';
                return;
            }
            
            // Add deleting animation
            row.classList.add('deleting');
            
            // Remove after animation
            setTimeout(() => {
                row.remove();
                currentPlayerCount--;
                
                // Re-enable Add button if was at max
                if (currentPlayerCount < maxPlayers) {
                    document.getElementById('addPlayerBtn').disabled = false;
                    document.getElementById('addPlayerBtn').innerHTML = '<span style="font-size: 20px; font-weight: 600;">+</span> Add Player';
                }
                
                // CRITICAL: Reset all swipe state variables
                swipingRow = null;
                isScrolling = null;
                touchStartX = 0;
                touchCurrentX = 0;
                touchStartY = 0;
                
                // Remove swiped class from any other rows that might have it
                const allRows = document.querySelectorAll('.player-row.swiped');
                allRows.forEach(r => {
                    r.classList.remove('swiped');
                    r.style.transform = 'translateX(0)';
                });
            }, 300);
        }

        // Render quick add buttons for frequent players
        function renderQuickAddButtons() {
            const quickAddSection = document.getElementById('quickAddSection');
            const quickAddButtons = document.getElementById('quickAddButtons');
            
            // Safety check - these elements only exist on setup page
            if (!quickAddSection || !quickAddButtons) {
                return;
            }
            
            // Get top 8 most used players
            const frequentPlayers = Object.values(playerHistory)
                .sort((a, b) => b.usageCount - a.usageCount)
                .slice(0, 8);
            
            if (frequentPlayers.length === 0) {
                quickAddSection.style.display = 'none';
                return;
            }
            
            quickAddSection.style.display = 'block';
            quickAddButtons.innerHTML = '';
            
            frequentPlayers.forEach(player => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'quick-add-btn';
                btn.textContent = `${player.name} (${player.handicap})`;
                
                // Create delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'quick-add-delete';
                deleteBtn.innerHTML = 'Ã—';
                deleteBtn.onclick = function(e) {
                    e.stopPropagation();
                    deleteQuickAddPlayer(player.name);
                };
                
                // Long press detection
                let pressTimer = null;
                let touchMoved = false;
                
                btn.addEventListener('touchstart', function(e) {
                    touchMoved = false;
                    pressTimer = setTimeout(() => {
                        if (!touchMoved) {
                            btn.classList.add('show-delete');
                            // Vibrate if supported
                            if (navigator.vibrate) {
                                navigator.vibrate(50);
                            }
                        }
                    }, 500); // 500ms long press
                });
                
                btn.addEventListener('touchmove', function() {
                    touchMoved = true;
                    if (pressTimer) {
                        clearTimeout(pressTimer);
                    }
                });
                
                btn.addEventListener('touchend', function() {
                    if (pressTimer) {
                        clearTimeout(pressTimer);
                    }
                });
                
                btn.onclick = function(e) {
                    if (!btn.classList.contains('show-delete')) {
                        quickAddPlayer(player.name, player.handicap);
                    }
                };
                
                btn.appendChild(deleteBtn);
                quickAddButtons.appendChild(btn);
            });
            
            // Click outside to hide delete buttons
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.quick-add-btn')) {
                    document.querySelectorAll('.quick-add-btn.show-delete').forEach(btn => {
                        btn.classList.remove('show-delete');
                    });
                }
            });
        }
        
        // Delete a player from quick-add history
        function deleteQuickAddPlayer(playerName) {
            if (confirm(`Remove ${playerName} from quick add?`)) {
                delete playerHistory[playerName];
                localStorage.setItem('indianHillsPlayerHistory', JSON.stringify(playerHistory));
                renderQuickAddButtons();
            }
        }

        // Quick add a player to the first empty row or create new row
        function quickAddPlayer(name, handicap) {
            // Find first empty player row
            const playerRows = document.querySelectorAll('.player-row');
            let emptyRow = null;
            
            for (let row of playerRows) {
                const playerId = row.getAttribute('data-player');
                const nameInput = document.getElementById(`player${playerId}`);
                if (nameInput && nameInput.value.trim() === '') {
                    emptyRow = { row, playerId };
                    break;
                }
            }
            
            if (emptyRow) {
                // Fill empty row
                document.getElementById(`player${emptyRow.playerId}`).value = name;
                document.getElementById(`hcp${emptyRow.playerId}`).value = handicap;
            } else {
                // Add new row
                if (currentPlayerCount >= maxPlayers) {
                    alert(`Maximum of ${maxPlayers} players reached`);
                    return;
                }
                
                addPlayerRow();
                // Fill the newly added row
                document.getElementById(`player${nextPlayerId - 1}`).value = name;
                document.getElementById(`hcp${nextPlayerId - 1}`).value = handicap;
            }
            
            // Refresh team setup if team game is selected
            refreshTeamSetupIfNeeded();
        }

        // Warn before page refresh if there's active data
        // Initialize autocomplete on all player name inputs
        function initializeAutocomplete() {
            const playerList = document.getElementById('playerList');
            if (!playerList) return;

            playerList.addEventListener('input', function(e) {
                // Refresh team setup if player name or handicap changes
                if (e.target.classList.contains('player-name-input') || e.target.classList.contains('player-hcp-input')) {
                    refreshTeamSetupIfNeeded();
                }
                
                if (!e.target.classList.contains('player-name-input')) return;
                
                const input = e.target;
                const row = input.closest('.player-row');
                if (!row) return;
                
                const query = input.value;
                
                // Remove existing suggestions
                const existingSuggestions = row.querySelector('.autocomplete-suggestions');
                if (existingSuggestions) {
                    existingSuggestions.remove();
                }
                
                if (!query || query.length < 1) {
                    row.classList.remove('has-suggestions');
                    return;
                }
                
                const suggestions = getPlayerSuggestions(query);
                if (suggestions.length === 0) {
                    row.classList.remove('has-suggestions');
                    return;
                }
                
                // Create suggestions dropdown
                const suggestionsDiv = document.createElement('div');
                suggestionsDiv.className = 'autocomplete-suggestions show';
                
                suggestions.forEach(player => {
                    const item = document.createElement('div');
                    item.className = 'suggestion-item';
                    item.innerHTML = `
                        <span class="suggestion-name">${player.name}</span>
                        <span class="suggestion-hcp">HCP: ${player.handicap}</span>
                    `;
                    
                    item.addEventListener('click', function(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        input.value = player.name;
                        
                        // Auto-fill handicap
                        const playerId = row.getAttribute('data-player');
                        const hcpInput = document.getElementById(`hcp${playerId}`);
                        if (hcpInput) {
                            hcpInput.value = player.handicap;
                        }
                        
                        suggestionsDiv.remove();
                        row.classList.remove('has-suggestions');
                        
                        // Refresh team setup
                        refreshTeamSetupIfNeeded();
                    });
                    
                    suggestionsDiv.appendChild(item);
                });
                
                row.appendChild(suggestionsDiv);
                row.classList.add('has-suggestions');
            });
            
            // Close suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.classList.contains('player-name-input') && 
                    !e.target.closest('.autocomplete-suggestions')) {
                    document.querySelectorAll('.autocomplete-suggestions').forEach(s => s.remove());
                    document.querySelectorAll('.player-row').forEach(r => r.classList.remove('has-suggestions'));
                }
            });
        }


        // Add new player row
        function addPlayerRow() {
            if (currentPlayerCount >= maxPlayers) {
                alert(`Maximum of ${maxPlayers} players reached`);
                return;
            }

            currentPlayerCount++;
            const playerList = document.getElementById('playerList');
            
            const newRow = document.createElement('div');
            newRow.className = 'player-row';
            newRow.setAttribute('data-player', nextPlayerId);
            newRow.innerHTML = `
                <input type="text" class="player-name-input" placeholder="Player Name" id="player${nextPlayerId}">
                <input type="text" class="player-hcp-input" placeholder="HCP" id="hcp${nextPlayerId}" pattern="-?[0-9]*" inputmode="numeric">
            `;
            
            playerList.appendChild(newRow);
            nextPlayerId++;
            
            // Disable button if at max
            if (currentPlayerCount >= maxPlayers) {
                document.getElementById('addPlayerBtn').disabled = true;
                document.getElementById('addPlayerBtn').textContent = `Maximum ${maxPlayers} Players`;
            }
        }

        // Delete player row with animation

        let tournamentData = {
            id: '',
            date: '',
            gameType: '',
            course: '',
            players: [],
            teams: []
        };

        // Generate unique tournament ID
        function generateTournamentId() {
            return 'T' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }

        // ===== UI ENHANCEMENT FUNCTIONS =====
        
        // Generate player avatar color based on name
        function getPlayerColor(playerName) {
            const colors = [
                '#3b82f6', // Blue
                '#10b981', // Green
                '#f59e0b', // Orange
                '#8b5cf6', // Purple
                '#ef4444', // Red
                '#06b6d4', // Cyan
                '#ec4899', // Pink
                '#f97316', // Deep Orange
                '#14b8a6', // Teal
                '#a855f7'  // Violet
            ];
            
            // Hash the name to get consistent color
            let hash = 0;
            for (let i = 0; i < playerName.length; i++) {
                hash = playerName.charCodeAt(i) + ((hash << 5) - hash);
            }
            return colors[Math.abs(hash) % colors.length];
        }

        // Get player initials
        function getPlayerInitials(playerName) {
            const words = playerName.trim().split(' ');
            if (words.length === 1) {
                return words[0].substring(0, 2).toUpperCase();
            }
            return (words[0][0] + words[words.length - 1][0]).toUpperCase();
        }

        // Create player avatar HTML
        function createPlayerAvatar(playerName, large = false) {
            const initials = getPlayerInitials(playerName);
            const color = getPlayerColor(playerName);
            const sizeClass = large ? 'player-avatar-large' : 'player-avatar';
            return `<span class="player-avatar ${sizeClass}" style="background: ${color};">${initials}</span>`;
        }

        // Get score color class based on par
        function getScoreClass(score, par) {
            if (score === 0) return 'score-par';
            const diff = score - par;
            if (diff <= -2) return 'score-eagle';
            if (diff === -1) return 'score-birdie';
            if (diff === 0) return 'score-par';
            if (diff === 1) return 'score-bogey';
            return 'score-double';
        }

        // Trigger confetti animation
        function showConfetti() {
            const colors = ['#fbbf24', '#3b82f6', '#10b981', '#ef4444', '#8b5cf6'];
            const confettiCount = 50;
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
                confetti.style.animationDelay = (Math.random() * 0.5) + 's';
                confetti.style.animation = 'confetti-fall linear forwards';
                
                document.body.appendChild(confetti);
                
                setTimeout(() => confetti.remove(), 5000);
            }
        }

        // Add pulse animation to element
        function pulseElement(element) {
            element.classList.add('score-changed');
            setTimeout(() => element.classList.remove('score-changed'), 300);
        }

        // Calculate tournament progress
        function getTournamentProgress() {
            if (!tournamentData.players || tournamentData.players.length === 0) return 0;
            
            let totalHoles = 0;
            let completedHoles = 0;
            
            tournamentData.players.forEach(player => {
                player.scores.forEach(score => {
                    totalHoles++;
                    if (score > 0) completedHoles++;
                });
            });
            
            return totalHoles > 0 ? (completedHoles / totalHoles) * 100 : 0;
        }
        
        // Current hole for hole view
        let currentHole = 0; // 0-17 (holes 1-18)
        let currentView = 'player'; // 'player' or 'hole'

        // Format date from YYYY-MM-DD string without timezone issues
        function formatDateDisplay(dateString) {
            if (!dateString) return '';
            const [year, month, day] = dateString.split('-');
            const date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
            return date.toLocaleDateString();
        }

        // Player history for auto-complete and handicap memory
        let playerHistory = JSON.parse(localStorage.getItem('indianHillsPlayerHistory') || '{}');
        // Format: { "PlayerName": { name: "PlayerName", handicap: 10, lastUsed: timestamp, usageCount: 5 } }

        // Save player history
        function savePlayerHistory() {
            localStorage.setItem('indianHillsPlayerHistory', JSON.stringify(playerHistory));
        }

        // Update player in history
        function updatePlayerHistory(name, handicap) {
            if (!name || name.trim() === '') return;
            
            const normalizedName = name.trim();
            if (!playerHistory[normalizedName]) {
                playerHistory[normalizedName] = {
                    name: normalizedName,
                    handicap: handicap || 0,
                    lastUsed: Date.now(),
                    usageCount: 1
                };
            } else {
                playerHistory[normalizedName].handicap = handicap || playerHistory[normalizedName].handicap;
                playerHistory[normalizedName].lastUsed = Date.now();
                playerHistory[normalizedName].usageCount++;
            }
            savePlayerHistory();
        }

        // Get player suggestions sorted by usage and recency
        function getPlayerSuggestions(query) {
            query = query.toLowerCase().trim();
            if (!query) {
                // Return most recent players
                return Object.values(playerHistory)
                    .sort((a, b) => b.lastUsed - a.lastUsed)
                    .slice(0, 5);
            }
            
            // Filter and sort by match quality
            return Object.values(playerHistory)
                .filter(p => p.name.toLowerCase().includes(query))
                .sort((a, b) => {
                    // Exact match first
                    const aExact = a.name.toLowerCase() === query ? 1 : 0;
                    const bExact = b.name.toLowerCase() === query ? 1 : 0;
                    if (aExact !== bExact) return bExact - aExact;
                    
                    // Then by usage count
                    if (a.usageCount !== b.usageCount) return b.usageCount - a.usageCount;
                    
                    // Then by recency
                    return b.lastUsed - a.lastUsed;
                })
                .slice(0, 5);
        }

        // Update course when selection changes
        function updateCourse() {
            const selectedCourse = document.getElementById('courseSelect').value;
            if (selectedCourse) {
                courseData = courses[selectedCourse];
            } else {
                courseData = null;
            }
        }

        // Handle game type changes to show/hide team setup
        function handleGameTypeChange() {
            const gameType = document.getElementById('gameType').value;
            const teamSection = document.getElementById('teamSetupSection');
            
            if (gameType.includes('Best Ball')) {
                teamSection.style.display = 'block';
                renderTeamSetup(gameType);
            } else {
                teamSection.style.display = 'none';
            }
        }

        // Refresh team setup if a team game is currently selected
        function refreshTeamSetupIfNeeded() {
            const gameType = document.getElementById('gameType').value;
            if (gameType.includes('Best Ball')) {
                renderTeamSetup(gameType);
            }
        }

        // Render team setup based on game type
        function renderTeamSetup(gameType) {
            const content = document.getElementById('teamSetupContent');
            
            // Determine players per team from game type
            let playersPerTeam;
            if (gameType.includes('2-Man')) {
                playersPerTeam = 2;
            } else if (gameType.includes('3-Man')) {
                playersPerTeam = 3;
            } else if (gameType.includes('4-Man')) {
                playersPerTeam = 4;
            }
            
            // Get current player names from the player list
            const playerNames = [];
            const playerRows = document.querySelectorAll('.player-row');
            playerRows.forEach((row, index) => {
                const nameInput = row.querySelector('.player-name-input');
                const hcpInput = row.querySelector('.player-hcp-input');
                if (nameInput && nameInput.value.trim()) {
                    playerNames.push({
                        index: index,
                        name: nameInput.value.trim(),
                        handicap: hcpInput ? hcpInput.value : '0'
                    });
                }
            });
            
            // Calculate number of teams based on player count
            // Example: 8 players in 3-Man teams = 2 full teams (6 players) + 1 team with 2 players = 3 teams
            const totalPlayers = playerNames.length;
            const numTeams = totalPlayers > 0 ? Math.ceil(totalPlayers / playersPerTeam) : 2;
            
            content.innerHTML = '';
            
            if (totalPlayers === 0) {
                content.innerHTML = '<p style="color: #64748b; font-size: 14px; padding: 12px;">Add players first to create teams</p>';
                return;
            }
            
            // Create team selection dropdowns
            for (let t = 0; t < numTeams; t++) {
                const teamDiv = document.createElement('div');
                teamDiv.className = 'team-container';
                
                let teamHtml = `<div class="team-header">Team ${t + 1}</div>`;
                
                for (let p = 0; p < playersPerTeam; p++) {
                    teamHtml += `
                        <select class="team-member-select" id="team${t}_player${p}">
                            <option value="">Select Player ${p + 1}</option>
                    `;
                    
                    // Add options for each added player
                    playerNames.forEach(player => {
                        teamHtml += `<option value="${player.index}">${player.name} (${player.handicap})</option>`;
                    });
                    
                    teamHtml += `</select>`;
                }
                
                teamDiv.innerHTML = teamHtml;
                content.appendChild(teamDiv);
            }
        }

        // Auto-save functionality
        function saveToLocalStorage() {
            localStorage.setItem('indianHillsScoring', JSON.stringify(tournamentData));
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('indianHillsScoring');
            if (saved) {
                tournamentData = JSON.parse(saved);
                return true;
            }
            return false;
        }

        // ========================================
        // FIREBASE TOURNAMENT MANAGEMENT SYSTEM
        // ========================================
        
        // Current tournament state
        let activeTournamentId = null;
        let isHost = false;
        let claimedPlayers = []; // Players this device can edit
        let tournamentUnsubscribe = null;
        
        // Create a new cloud tournament
        async function createCloudTournament(tournamentConfig) {
            try {
                // Wait for authentication if not ready
                if (!currentUserId || !currentDeviceId) {
                    console.log('Waiting for Firebase authentication...');
                    console.log('currentUserId:', currentUserId, 'currentDeviceId:', currentDeviceId);
                    
                    await new Promise((resolve) => {
                        let attempts = 0;
                        const checkAuth = setInterval(() => {
                            attempts++;
                            console.log(`Auth check attempt ${attempts}:`, currentUserId, currentDeviceId);
                            if (currentUserId && currentDeviceId) {
                                console.log('Authentication successful!');
                                clearInterval(checkAuth);
                                resolve();
                            }
                        }, 100);
                        // Timeout after 10 seconds
                        setTimeout(() => {
                            console.log('Authentication timeout after 10 seconds');
                            clearInterval(checkAuth);
                            resolve();
                        }, 10000);
                    });
                }
                
                // If still not authenticated, throw error
                if (!currentUserId || !currentDeviceId) {
                    console.error('Auth failed - currentUserId:', currentUserId, 'currentDeviceId:', currentDeviceId);
                    throw new Error('Firebase authentication failed. Please refresh the page and wait 3 seconds before starting.');
                }
                
                const tournamentId = 'T' + Date.now() + Math.random().toString(36).substr(2, 6);
                
                // Check if we're in local-only mode (userId starts with 'local_')
                const isLocalMode = currentUserId.startsWith('local_');
                
                if (isLocalMode) {
                    console.log('âš ï¸ Running in local-only mode - skipping Firebase sync');
                    activeTournamentId = tournamentId;
                    isHost = true;
                    console.log('Tournament created locally:', tournamentId);
                    return tournamentId;
                }
                
                // Normal Firebase mode
                const tournament = {
                    id: tournamentId,
                    ...tournamentConfig,
                    hostDeviceId: currentDeviceId,
                    hostUserId: currentUserId,
                    status: 'open', // open, active, locked, ended
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    // Keep players from tournamentConfig (don't overwrite with empty array)
                    devices: {
                        [currentDeviceId]: {
                            name: getDeviceName(),
                            userId: currentUserId,
                            connectedAt: firebase.firestore.FieldValue.serverTimestamp(),
                            lastActive: firebase.firestore.FieldValue.serverTimestamp(),
                            isHost: true
                        }
                    },
                    enabledGames: tournamentConfig.enabledGames || [tournamentConfig.gameType]
                };
                
                console.log('Creating tournament:', tournamentId);
                await db.collection('tournaments').doc(tournamentId).set(tournament);
                
                activeTournamentId = tournamentId;
                isHost = true;
                
                console.log('Tournament created successfully!');
                return tournamentId;
            } catch (error) {
                console.error('Error creating tournament:', error);
                // Don't show alert here - let the calling function handle it
                throw error; // Re-throw so the catch in startScoring can handle it
            }
        }
        
        // Join existing tournament
        async function joinTournament(tournamentId, playerInfo) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                
                if (!tournamentDoc.exists) {
                    alert('Tournament not found!');
                    return false;
                }
                
                const tournament = tournamentDoc.data();
                
                if (tournament.status === 'ended') {
                    alert('This tournament has ended!');
                    return false;
                }
                
                // Add player and register device
                await tournamentRef.update({
                    players: firebase.firestore.FieldValue.arrayUnion({
                        ...playerInfo,
                        joinedAt: new Date().toISOString(),
                        claimedBy: currentDeviceId,
                        scores: new Array(18).fill(null)
                    }),
                    [`devices.${currentDeviceId}`]: {
                        name: getDeviceName(),
                        userId: currentUserId,
                        connectedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastActive: firebase.firestore.FieldValue.serverTimestamp(),
                        isHost: false
                    }
                });
                
                activeTournamentId = tournamentId;
                claimedPlayers = [playerInfo.name];
                
                // Subscribe to tournament updates
                subscribToTournamentUpdates(tournamentId);
                
                return true;
            } catch (error) {
                console.error('Error joining tournament:', error);
                alert('Failed to join tournament. Please try again.');
                return false;
            }
        }
        
        // Claim additional players (for scoring a foursome)
        async function claimAdditionalPlayer(tournamentId, playerName) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Find the player
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) {
                    alert('Player not found!');
                    return false;
                }
                
                const player = tournament.players[playerIndex];
                
                // Check if already claimed
                if (player.claimedBy && player.claimedBy !== currentDeviceId) {
                    alert(`${playerName} is already being scored by another device!`);
                    return false;
                }
                
                // Claim the player
                tournament.players[playerIndex].claimedBy = currentDeviceId;
                
                await tournamentRef.update({
                    players: tournament.players
                });
                
                claimedPlayers.push(playerName);
                return true;
            } catch (error) {
                console.error('Error claiming player:', error);
                return false;
            }
        }
        
        // Update player score
        async function updatePlayerScore(tournamentId, playerName, holeIndex, score) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) return false;
                
                // Check permissions
                if (!isHost && tournament.players[playerIndex].claimedBy !== currentDeviceId) {
                    alert('You cannot edit this player\'s scores!');
                    return false;
                }
                
                tournament.players[playerIndex].scores[holeIndex] = score;
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                return true;
            } catch (error) {
                console.error('Error updating score:', error);
                return false;
            }
        }
        
        // Subscribe to real-time tournament updates
        function subscribToTournamentUpdates(tournamentId) {
            if (tournamentUnsubscribe) {
                tournamentUnsubscribe();
            }
            
            tournamentUnsubscribe = db.collection('tournaments')
                .doc(tournamentId)
                .onSnapshot((doc) => {
                    if (doc.exists) {
                        const tournament = doc.data();
                        updateLocalTournamentState(tournament);
                        updateLiveLeaderboard(tournament);
                        
                        // Check for notifications
                        if (tournament.status === 'ended' && !sessionStorage.getItem('tournamentEndedNotified_' + tournamentId)) {
                            sessionStorage.setItem('tournamentEndedNotified_' + tournamentId, 'true');
                            showNotification('Tournament Complete!', 'Tap to view final results');
                        }
                    }
                }, (error) => {
                    console.error('Error listening to tournament:', error);
                });
        }
        
        // Update local state from cloud data
        function updateLocalTournamentState(tournament) {
            // Sync cloud data to local tournamentData object
            // This keeps existing UI working while using cloud as source of truth
            if (tournamentData) {
                tournamentData.players = tournament.players.map(p => ({
                    name: p.name,
                    handicap: p.handicap,
                    scores: p.scores || new Array(18).fill(null)
                }));
                tournamentData.date = tournament.date;
                tournamentData.course = tournament.course;
                tournamentData.gameType = tournament.gameType;
                tournamentData.enabledGames = tournament.enabledGames || [tournament.gameType];
            }
        }
        
        // Host: Reassign player to different device
        async function reassignPlayer(tournamentId, playerName, newDeviceId) {
            if (!isHost) {
                alert('Only the host can reassign players!');
                return false;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) return false;
                
                tournament.players[playerIndex].claimedBy = newDeviceId;
                
                await tournamentRef.update({
                    players: tournament.players
                });
                
                return true;
            } catch (error) {
                console.error('Error reassigning player:', error);
                return false;
            }
        }
        
        // Host: Lock tournament (no more joins)
        async function lockTournament(tournamentId) {
            if (!isHost) return false;
            
            try {
                await db.collection('tournaments').doc(tournamentId).update({
                    status: 'locked',
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error locking tournament:', error);
                return false;
            }
        }
        
        // Host: End tournament
        async function endTournament(tournamentId) {
            if (!isHost) return false;
            
            try {
                await db.collection('tournaments').doc(tournamentId).update({
                    status: 'ended',
                    endedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Send notifications to all players
                sendTournamentEndNotification(tournamentId);
                
                return true;
            } catch (error) {
                console.error('Error ending tournament:', error);
                return false;
            }
        }
        
        // Get device name for display
        function getDeviceName() {
            const deviceType = /iPhone/i.test(navigator.userAgent) ? 'iPhone' :
                              /iPad/i.test(navigator.userAgent) ? 'iPad' :
                              /Android/i.test(navigator.userAgent) ? 'Android' :
                              'Device';
            
            // Try to get a friendly name from localStorage
            const customName = localStorage.getItem('deviceName');
            return customName || deviceType;
        }
        
        // Send tournament end notification
        function sendTournamentEndNotification(tournamentId) {
            // This will use web push notifications if permitted
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification('ðŸ Tournament Complete!', {
                    body: 'Tap to view final results',
                    icon: '/apple-touch-icon.png',
                    badge: '/apple-touch-icon.png',
                    tag: 'tournament-ended-' + tournamentId
                });
            }
        }
        
        // Request notification permission
        function requestNotificationPermission() {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        console.log('Notifications enabled');
                    }
                });
            }
        }
        
        // Show in-app notification
        function showNotification(title, message, requireDismiss = false) {
            // Create notification UI element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #1e40af;
                color: white;
                padding: 16px 24px;
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                max-width: 90%;
                text-align: center;
                animation: slideDown 0.3s ease;
            `;
            
            notification.innerHTML = `
                <div style="font-weight: 700; margin-bottom: 4px;">${title}</div>
                <div style="font-size: 14px;">${message}</div>
                ${requireDismiss ? '<button onclick="this.parentElement.remove()" style="margin-top: 12px; background: white; color: #1e40af; border: none; padding: 8px 16px; border-radius: 6px; font-weight: 600; cursor: pointer;">OK</button>' : ''}
            `;
            
            document.body.appendChild(notification);
            
            // Auto-dismiss after 4 seconds only if not requiring manual dismissal
            if (!requireDismiss) {
                setTimeout(() => {
                    notification.style.animation = 'slideUp 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }, 4000);
            }
        }
        
        // Generate shareable tournament link
        function getShareLink(tournamentId) {
            return window.location.origin + window.location.pathname + '?join=' + tournamentId;
        }
        
        // Check URL for join parameter on page load
        function checkForJoinLink() {
            const urlParams = new URLSearchParams(window.location.search);
            const joinId = urlParams.get('join');
            if (joinId) {
                // Show join tournament screen
                showJoinTournamentScreen(joinId);
            }
        }
        
        // Generate share link and display it
        function generateShareLink(tournamentId) {
            const shareLink = getShareLink(tournamentId);
            
            // Show notification with option to view
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: white;
                color: #1e40af;
                padding: 16px 24px;
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                max-width: 90%;
                text-align: center;
            `;
            notification.innerHTML = `
                <div style="font-weight: 700; margin-bottom: 8px;">ðŸ”— Tournament Ready!</div>
                <div style="font-size: 14px; margin-bottom: 12px;">Share this link or QR code for others to join</div>
                <button onclick="copyShareLink('${shareLink}')" style="padding: 8px 16px; background: #1e40af; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; margin-right: 8px;">
                    ðŸ“‹ Copy Link
                </button>
                <button onclick="showQRCode('${tournamentId}')" style="padding: 8px 16px; background: #10b981; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
                    ðŸ“± Show QR
                </button>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideDown 0.3s ease reverse';
                setTimeout(() => notification.remove(), 300);
            }, 8000);
        }
        
        // Copy share link to clipboard
        function copyShareLink(link) {
            navigator.clipboard.writeText(link).then(() => {
                showNotification('Copied!', 'Share link copied to clipboard');
            }).catch(() => {
                // Fallback for older browsers
                const input = document.createElement('input');
                input.value = link;
                document.body.appendChild(input);
                input.select();
                document.execCommand('copy');
                document.body.removeChild(input);
                showNotification('Copied!', 'Share link copied to clipboard');
            });
        }
        
        // Show QR code for tournament
        function showQRCode(tournamentId) {
            const link = getShareLink(tournamentId);
            
            // Create modal with QR code
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 10001;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; padding: 24px; border-radius: 16px; max-width: 400px; text-align: center;">
                    <h2 style="color: #1e40af; margin-bottom: 16px;">Scan to Join Tournament</h2>
                    <div id="tempQRCode" style="display: inline-block; padding: 16px; background: white;"></div>
                    <p style="color: #64748b; font-size: 14px; margin-top: 16px; word-break: break-all;">${link}</p>
                    <button onclick="this.closest('div[style*=fixed]').remove()" style="margin-top: 16px; padding: 12px 24px; background: #ef4444; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; width: 100%;">
                        Close
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Generate QR code
            new QRCode(document.getElementById('tempQRCode'), {
                text: link,
                width: 256,
                height: 256
            });
            
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
        }
        
        // Show share buttons on scoring page (for multi-device mode)
        
        // Show QR code for active tournament (legacy - kept for compatibility)
        function showQRCodeForActiveTournament() {
            if (activeTournamentId) {
                showQRCode(activeTournamentId);
            } else {
                alert('No active tournament!');
            }
        }
        
        // Copy active tournament link (legacy - kept for compatibility)
        function copyActiveTournamentLink() {
            if (activeTournamentId) {
                const link = getShareLink(activeTournamentId);
                copyShareLink(link);
            } else {
                alert('No active tournament!');
            }
        }
        
        // Show QR code from Resume section
        function showQRFromResume() {
            if (activeTournamentId) {
                showQRCode(activeTournamentId);
            } else {
                showNotification('No Active Tournament', 'Please start a multi-device tournament first');
            }
        }
        
        // Copy link from Resume section
        function copyLinkFromResume() {
            if (activeTournamentId) {
                const link = getShareLink(activeTournamentId);
                navigator.clipboard.writeText(link).then(() => {
                    showNotification('Link Copied!', 'Share link copied to clipboard');
                }).catch(() => {
                    showNotification('Copy Failed', 'Please try again');
                });
            } else {
                showNotification('No Active Tournament', 'Please start a multi-device tournament first');
            }
        }
        
        // Save tournament to file
        function saveTournamentFile() {
            if (!activeTournamentId) {
                showNotification('No Active Tournament', 'Please start a multi-device tournament first');
                return;
            }
            
            try {
                // Create tournament export object
                const exportData = {
                    tournamentId: activeTournamentId,
                    tournamentData: tournamentData,
                    tournamentMode: tournamentMode,
                    savedAt: new Date().toISOString(),
                    version: '1.0'
                };
                
                // Convert to JSON
                const jsonStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                
                // Create download link
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                // Create filename with tournament info
                const date = tournamentData.date || new Date().toISOString().split('T')[0];
                const name = tournamentData.name ? tournamentData.name.replace(/[^a-z0-9]/gi, '_') : 'tournament';
                a.download = `${name}_${date}_${activeTournamentId}.json`;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification('Tournament Saved!', 'File downloaded successfully');
            } catch (error) {
                console.error('Error saving tournament:', error);
                showNotification('Save Failed', 'Could not save tournament file');
            }
        }

        // ========================================
        // END FIREBASE FUNCTIONS
        // ========================================

        // Page navigation
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId).classList.add('active');
            
            // Refresh quick add buttons and check for saved round when returning to setup page
            if (pageId === 'setupPage') {
                renderQuickAddButtons();
                checkForSavedRound(); // Update resume section with share buttons if needed
            }
        }

        // Custom confirmation dialog (iOS-friendly)
        function showConfirm(title, message, onConfirm) {
            const dialog = document.getElementById('confirmDialog');
            const titleEl = document.getElementById('confirmTitle');
            const messageEl = document.getElementById('confirmMessage');
            const okBtn = document.getElementById('confirmOk');
            const cancelBtn = document.getElementById('confirmCancel');
            
            titleEl.textContent = title;
            messageEl.textContent = message;
            dialog.style.display = 'flex';
            
            // Remove old listeners
            const newOkBtn = okBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
            
            // Add new listeners
            newOkBtn.addEventListener('click', function() {
                dialog.style.display = 'none';
                onConfirm();
            });
            
            newCancelBtn.addEventListener('click', function() {
                dialog.style.display = 'none';
            });
        }

        // Back button - shows resume option if there's an active game
        function confirmBackToSetup() {
            showPage('setupPage');
            
            // Show Resume Scoring button if there are active scores
            if (tournamentData.players && tournamentData.players.length > 0) {
                const resumeBtn = document.getElementById('resumeScoringBtn');
                if (resumeBtn) {
                    resumeBtn.style.display = 'block';
                }
            }
            
        }

        // Resume scoring - go back to scoring page with existing data
        function resumeScoring() {
            renderScoringPage();
            showPage('scoringPage');
            
            // Start in Holes view by default
            switchToHoleView();
        }

        // Start scoring from setup page
        // ========================================
        // TOURNAMENT MODE SELECTION & UI HANDLERS
        // ========================================
        
        let tournamentMode = 'multi'; // 'multi' or 'single' (default: multi-device)
        
        function selectScoringMode(mode) {
            tournamentMode = mode;
            
            const multiBtn = document.getElementById('multiDeviceBtn');
            const singleBtn = document.getElementById('singleDeviceBtn');
            
            if (mode === 'multi') {
                multiBtn.classList.add('active');
                singleBtn.classList.remove('active');
                
                // Request notification permission when multi-device mode selected
                requestNotificationPermission();
            } else {
                singleBtn.classList.add('active');
                multiBtn.classList.remove('active');
            }
        }
        
        // Show join tournament screen
        function showJoinTournamentScreen(tournamentId) {
            // Load tournament info
            db.collection('tournaments').doc(tournamentId).get()
                .then(doc => {
                    if (doc.exists) {
                        const tournament = doc.data();
                        const infoEl = document.getElementById('joinTournamentInfo');
                        infoEl.textContent = `${tournament.course} â€¢ ${tournament.date} â€¢ ${tournament.gameType}`;
                        
                        // Show existing players if any
                        if (tournament.players && tournament.players.length > 0) {
                            document.getElementById('joinExistingPlayers').style.display = 'block';
                            const listEl = document.getElementById('existingPlayersList');
                            listEl.innerHTML = tournament.players.map(p => `
                                <button type="button" class="btn-secondary" style="width: 100%; margin-bottom: 8px;" onclick="selectExistingPlayer('${tournamentId}', '${p.name}')">
                                    ${p.name} (HCP ${p.handicap})
                                </button>
                            `).join('');
                        }
                        
                        showPage('joinPage');
                        
                        // Store tournament ID for form submission
                        document.getElementById('joinTournamentForm').dataset.tournamentId = tournamentId;
                    } else {
                        alert('Tournament not found!');
                    }
                })
                .catch(error => {
                    console.error('Error loading tournament:', error);
                    alert('Failed to load tournament');
                });
        }
        
        // Handle join tournament form submission
        document.addEventListener('DOMContentLoaded', () => {
            // Check if URL has join parameter
            checkForJoinLink();
            
            const joinForm = document.getElementById('joinTournamentForm');
            if (joinForm) {
                joinForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const tournamentId = joinForm.dataset.tournamentId;
                    const playerInfo = {
                        name: document.getElementById('joinPlayerName').value.trim(),
                        handicap: parseFloat(document.getElementById('joinPlayerHandicap').value) || 0,
                        email: document.getElementById('joinPlayerEmail').value.trim(),
                        phone: document.getElementById('joinPlayerPhone').value.trim()
                    };
                    
                    const success = await joinTournament(tournamentId, playerInfo);
                    
                    if (success) {
                        showNotification('Joined!', 'You\'ve joined the tournament');
                        // Navigate to scoring or spectator view
                        showPage('liveLeaderboardPage');
                    }
                });
            }
        });
        
        // Select existing player when joining
        async function selectExistingPlayer(tournamentId, playerName) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const player = tournament.players.find(p => p.name === playerName);
                if (!player) {
                    alert('Player not found!');
                    return;
                }
                
                // Check if already claimed
                if (player.claimedBy) {
                    alert(`${playerName} is already being scored by another device!`);
                    return;
                }
                
                // Claim this player
                const claimed = await claimAdditionalPlayer(tournamentId, playerName);
                if (claimed) {
                    activeTournamentId = tournamentId;
                    claimedPlayers = [playerName];
                    subscribToTournamentUpdates(tournamentId);
                    showNotification('Success!', `You're now scoring for ${playerName}`);
                    showPage('liveLeaderboardPage');
                }
            } catch (error) {
                console.error('Error selecting player:', error);
                alert('Failed to select player');
            }
        }
        
        // Update live leaderboard display
        function updateLiveLeaderboard(tournament) {
            if (!tournament || !tournament.players) return;
            
            // Update tournament info header
            const infoEl = document.getElementById('liveLeaderboardInfo');
            if (infoEl) {
                let infoText = tournament.date || '';
                if (tournament.name) {
                    infoText = tournament.name + (tournament.date ? ' â€¢ ' + tournament.date : '');
                }
                infoEl.textContent = infoText;
            }
            
            const content = document.getElementById('liveLeaderboardContent');
            if (!content) return;
            
            // Get current game type from tabs or use first enabled game
            const enabledGames = tournament.enabledGames || [tournament.gameType];
            const currentGame = document.querySelector('.game-tab.active')?.dataset.gameType || enabledGames[0];
            
            // Calculate results for current game
            const results = calculateGameResults(tournament.players, currentGame, tournament.course);
            
            // Render leaderboard
            content.innerHTML = results.map((player, index) => {
                const medal = index === 0 ? 'ðŸ¥‡' : index === 1 ? 'ðŸ¥ˆ' : index === 2 ? 'ðŸ¥‰' : '';
                const rankClass = index === 0 ? 'first' : index === 1 ? 'second' : index === 2 ? 'third' : '';
                
                return `
                    <div class="leaderboard-entry ${rankClass}">
                        <div class="leaderboard-rank">${medal || (index + 1) + '.'}</div>
                        <div class="leaderboard-name">${player.name}</div>
                        <div class="leaderboard-score">${player.displayScore}</div>
                    </div>
                `;
            }).join('');
            
            // Update info
            document.getElementById('activePlayersCount').textContent = tournament.players.length;
            document.getElementById('lastUpdateTime').textContent = 'Just now';
        }
        
        // Calculate game results (simplified version)
        function calculateGameResults(players, gameType, course) {
            // This is a simplified calculation - full logic would match your existing results calculation
            return players.map(player => {
                const totalScore = player.scores.reduce((sum, score) => sum + (score || 0), 0);
                const par = courses[course]?.totalPar || 72;
                const toPar = totalScore - par;
                const displayScore = toPar >= 0 ? `+${toPar}` : toPar;
                
                return {
                    name: player.name,
                    totalScore,
                    toPar,
                    displayScore: `${totalScore} (${displayScore})`
                };
            }).sort((a, b) => a.totalScore - b.totalScore);
        }
        
        // Render game toggle tabs
        function renderGameTabs(enabledGames) {
            const tabsContainer = document.getElementById('gameToggleTabs');
            if (!tabsContainer) return;
            
            const gameLabels = {
                'Stroke Play Gross': 'Gross',
                'Stroke Play Net': 'Net',
                'Gross Skins': 'Skins',
                'Net Skins (Full Hcp)': 'Net Skins',
                'Stableford': 'Stableford'
            };
            
            tabsContainer.innerHTML = enabledGames.map((game, index) => `
                <button class="game-tab ${index === 0 ? 'active' : ''}" data-game-type="${game}" onclick="switchGameTab('${game}')">
                    ${gameLabels[game] || game}
                </button>
            `).join('');
        }
        
        // Switch active game tab
        function switchGameTab(gameType) {
            document.querySelectorAll('.game-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.gameType === gameType);
            });
            
            // Reload leaderboard for new game type
            if (activeTournamentId) {
                db.collection('tournaments').doc(activeTournamentId).get()
                    .then(doc => {
                        if (doc.exists) {
                            updateLiveLeaderboard(doc.data());
                        }
                    });
            }
        }

        // ========================================
        // MAIN SCORING FUNCTION (MODIFIED FOR CLOUD)
        // ========================================
        
        function startScoring() {
            const date = document.getElementById('tournamentDate').value;
            const tournamentName = document.getElementById('tournamentName').value.trim();
            const gameType = document.getElementById('gameType').value;
            const selectedCourse = document.getElementById('courseSelect').value;
            
            // Validate date selection
            if (!date) {
                alert('Please select a date');
                return;
            }
            
            // Validate game type selection
            if (!gameType) {
                alert('Please select a game type');
                return;
            }
            
            // Validate course selection
            if (!selectedCourse) {
                alert('Please select a course');
                return;
            }
            
            // Update course data
            courseData = courses[selectedCourse];
            
            const players = [];
            // Loop through all player rows (they may not be sequential)
            const playerRows = document.querySelectorAll('.player-row');
            playerRows.forEach(row => {
                const playerId = row.getAttribute('data-player');
                const nameInput = document.getElementById(`player${playerId}`);
                const hcpInput = document.getElementById(`hcp${playerId}`);
                
                if (nameInput && hcpInput) {
                    const name = nameInput.value.trim();
                    const hcp = parseInt(hcpInput.value) || 0;
                    if (name) {
                        players.push({
                            name: name,
                            handicap: hcp,
                            scores: new Array(18).fill(0)
                        });
                    }
                }
            });

            if (players.length === 0) {
                alert('Please enter at least one player name');
                return;
            }

            // Save players to history
            players.forEach(player => {
                updatePlayerHistory(player.name, player.handicap);
            });

            // Capture team assignments for Best Ball games
            let teams = [];
            if (gameType.includes('Best Ball')) {
                const numTeams = 2;
                const playersPerTeam = gameType === '2-Man Best Ball' ? 2 : gameType === '3-Man Best Ball' ? 3 : 4;
                
                for (let t = 0; t < numTeams; t++) {
                    const teamPlayers = [];
                    for (let p = 0; p < playersPerTeam; p++) {
                        const playerIndex = document.getElementById(`team${t}_player${p}`).value;
                        if (playerIndex !== '') {
                            teamPlayers.push(parseInt(playerIndex));
                        }
                    }
                    if (teamPlayers.length > 0) {
                        teams.push(teamPlayers);
                    }
                }
                
                if (teams.length < 2) {
                    alert('Please assign players to both teams');
                    return;
                }
            }

            tournamentData = {
                id: generateTournamentId(),
                name: tournamentName || '', // Optional tournament name
                date: date,
                gameType: gameType,
                course: selectedCourse,
                players: players,
                teams: teams
            };

            // Hide Resume button when starting fresh
            const resumeBtn = document.getElementById('resumeScoringBtn');
            if (resumeBtn) {
                resumeBtn.style.display = 'none';
            }

            // Handle based on scoring mode
            if (tournamentMode === 'multi') {
                // Create cloud tournament
                createCloudTournament({
                    name: tournamentName || '', // Optional tournament name
                    date: date,
                    gameType: gameType,
                    course: selectedCourse,
                    players: players.map(p => ({
                        ...p,
                        scores: new Array(18).fill(null),
                        claimedBy: null // No one claimed yet
                    })),
                    teams: teams,
                    enabledGames: [gameType] // Can add more games later
                }).then(tournamentId => {
                    if (tournamentId) {
                        activeTournamentId = tournamentId;
                        isHost = true;
                        
                        // Subscribe to real-time updates
                        subscribToTournamentUpdates(tournamentId);
                        
                        // Continue to scoring
                        saveToLocalStorage();
                        renderScoringPage();
                        showPage('scoringPage');
                        switchToHoleView();
                        
                        // Show notification
                        showNotification('Tournament Created!', 'Go back to Setup page to share QR/Link');
                    } else {
                        // If tournament creation returned null (shouldn't happen with throw, but just in case)
                        console.error('Tournament creation returned null');
                        throw new Error('Tournament creation failed');
                    }
                }).catch(error => {
                    console.error('Tournament creation error:', error);
                    
                    // Show single consolidated error message
                    const errorMsg = error.message || 'Unknown error';
                    showNotification('Multi-Device Mode Failed', `Switching to Single-Device mode. Error: ${errorMsg}`, true);
                    
                    // Fall back to single-device mode
                    tournamentMode = 'single';
                    document.getElementById('singleDeviceBtn').classList.add('active');
                    document.getElementById('multiDeviceBtn').classList.remove('active');
                    
                    saveToLocalStorage();
                    renderScoringPage();
                    showPage('scoringPage');
                    switchToHoleView();
                });
            } else {
                // Single-device mode - existing behavior
                saveToLocalStorage();
                renderScoringPage();
                showPage('scoringPage');
                switchToHoleView();
            }
        }

        // Render the scoring page
        function renderScoringPage() {
            // Load the correct course data
            courseData = courses[tournamentData.course];
            
            // Display tournament name if provided
            const tournamentNameEl = document.getElementById('scoringTournamentName');
            if (tournamentNameEl) {
                if (tournamentData.name) {
                    tournamentNameEl.textContent = tournamentData.name;
                    tournamentNameEl.style.display = 'block';
                } else {
                    tournamentNameEl.style.display = 'none';
                }
            }
            
            document.getElementById('scoringGameType').textContent = tournamentData.gameType;
            document.getElementById('scoringDate').textContent = `${courseData.name} - ${formatDateDisplay(tournamentData.date)}`;

            const container = document.getElementById('playerCards');
            container.innerHTML = '';

            tournamentData.players.forEach((player, playerIndex) => {
                const card = document.createElement('div');
                card.className = 'player-card';
                
                const total = player.scores.reduce((sum, score) => sum + score, 0);
                const toPar = total - courseData.totalPar;
                const toParText = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar);
                const hcpDisplay = player.handicap !== 0 ? ` (${player.handicap > 0 ? player.handicap : '+' + Math.abs(player.handicap)})` : '';

                card.innerHTML = `
                    <div class="player-header">
                        <div class="player-name" style="display: flex; align-items: center;">
                            ${createPlayerAvatar(player.name)}
                            <span>${player.name}${hcpDisplay}</span>
                        </div>
                        <div class="player-total">${total > 0 ? total : '-'} <span style="font-size: 16px; color: #64748b;">(${toParText})</span></div>
                    </div>
                    <div class="holes-grid" id="player${playerIndex}Grid"></div>
                `;

                container.appendChild(card);

                const grid = document.getElementById(`player${playerIndex}Grid`);
                courseData.holes.forEach((hole, holeIndex) => {
                    const holeDiv = document.createElement('div');
                    holeDiv.className = 'hole-input-group';
                    
                    const score = player.scores[holeIndex];
                    const diff = score - hole.par;
                    let scoreClass = '';
                    if (score > 0) {
                        if (diff >= 2) {
                            scoreClass = 'double-bogey-plus'; // Red
                        } else if (diff === 1) {
                            scoreClass = 'bogey'; // Yellow
                        } else if (diff === 0) {
                            scoreClass = 'par'; // Blue
                        } else if (diff <= -1) {
                            scoreClass = 'birdie-better'; // Green
                        }
                    }

                    holeDiv.innerHTML = `
                        <div class="hole-label">
                            <span>Hole ${hole.number}</span>
                            <span class="par-badge">Par ${hole.par} â€¢ HCP ${hole.handicap}</span>
                        </div>
                        <div class="score-input-wrapper">
                            <button class="score-btn" onclick="decrementScore(${playerIndex}, ${holeIndex})">âˆ’</button>
                            <input type="number" 
                                   class="score-input ${scoreClass}" 
                                   value="${score || ''}" 
                                   onchange="updateScore(${playerIndex}, ${holeIndex}, this.value)"
                                   onclick="this.select()"
                                   min="0"
                                   max="15"
                                   inputmode="numeric">
                            <button class="score-btn" onclick="incrementScore(${playerIndex}, ${holeIndex})">+</button>
                        </div>
                    `;
                    
                    grid.appendChild(holeDiv);
                });
            });
        }

        // Score modification functions
        function updateScore(playerIndex, holeIndex, value) {
            const score = parseInt(value) || 0;
            tournamentData.players[playerIndex].scores[holeIndex] = score;
            saveToLocalStorage();
            
            // Sync to Firebase if in cloud mode
            if (activeTournamentId && tournamentMode === 'multi') {
                const playerName = tournamentData.players[playerIndex].name;
                updatePlayerScore(activeTournamentId, playerName, holeIndex, score);
            }
            
            updateProgressBar();
            renderScoringPage();
        }

        function incrementScore(playerIndex, holeIndex) {
            const currentScore = tournamentData.players[playerIndex].scores[holeIndex];
            const par = courseData.holes[holeIndex].par;
            
            // If score is 0, set to par first
            if (currentScore === 0) {
                tournamentData.players[playerIndex].scores[holeIndex] = par;
            } else {
                tournamentData.players[playerIndex].scores[holeIndex] = Math.min(currentScore + 1, 15);
            }
            
            saveToLocalStorage();
            
            // Sync to Firebase if in cloud mode
            if (activeTournamentId && tournamentMode === 'multi') {
                const playerName = tournamentData.players[playerIndex].name;
                const newScore = tournamentData.players[playerIndex].scores[holeIndex];
                updatePlayerScore(activeTournamentId, playerName, holeIndex, newScore);
            }
            
            updateProgressBar();
            renderScoringPage();
        }

        function decrementScore(playerIndex, holeIndex) {
            const currentScore = tournamentData.players[playerIndex].scores[holeIndex];
            const par = courseData.holes[holeIndex].par;
            
            // If score is 0, set to par first
            if (currentScore === 0) {
                tournamentData.players[playerIndex].scores[holeIndex] = par;
            } else {
                tournamentData.players[playerIndex].scores[holeIndex] = Math.max(currentScore - 1, 0);
            }
            
            saveToLocalStorage();
            
            // Sync to Firebase if in cloud mode
            if (activeTournamentId && tournamentMode === 'multi') {
                const playerName = tournamentData.players[playerIndex].name;
                const newScore = tournamentData.players[playerIndex].scores[holeIndex];
                updatePlayerScore(activeTournamentId, playerName, holeIndex, newScore);
            }
            
            updateProgressBar();
            renderScoringPage();
        }

        // Update progress bar
        function updateProgressBar() {
            const progressBar = document.getElementById('tournamentProgress');
            if (progressBar) {
                const progress = getTournamentProgress();
                progressBar.style.width = progress + '%';
            }
        }

        // Finish round and show results
        function finishRound() {
            renderResultsPage();
            showPage('resultsPage');
            // Celebrate with confetti!
            setTimeout(() => showConfetti(), 300);
        }

        function backToScoring() {
            showPage('scoringPage');
        }

        // Helper functions for net score calculations
        function getNetScore(grossScore, playerHcp, holeHcp, method = 'full') {
            if (grossScore === 0) return 0;
            
            let strokes = 0;
            
            // Handle plus handicaps (negative values)
            if (playerHcp < 0) {
                const absHcp = Math.abs(playerHcp);
                
                if (method === 'full') {
                    // Plus handicap: add strokes on EASIEST holes (18, 17, 16...)
                    strokes = -Math.floor(absHcp / 18); // Negative = add to score
                    if (holeHcp > (18 - (absHcp % 18))) {
                        strokes -= 1; // Add another stroke on easier holes
                    }
                } else if (method === '18max') {
                    // 18 Max: max 1 stroke added per hole on easiest holes
                    if (holeHcp > (18 - Math.min(absHcp, 18))) {
                        strokes = -1;
                    }
                } else if (method === 'half') {
                    // Half Pop: 0.5 stroke added per allocated stroke
                    const fullStrokes = Math.floor(absHcp / 18);
                    const extraStroke = holeHcp > (18 - (absHcp % 18)) ? 1 : 0;
                    strokes = -(fullStrokes + extraStroke) * 0.5;
                }
            } 
            // Handle regular (positive) handicaps
            else if (playerHcp > 0) {
                if (method === 'full') {
                    // Regular handicap: subtract strokes on HARDEST holes (1, 2, 3...)
                    strokes = Math.floor(playerHcp / 18);
                    if (holeHcp <= (playerHcp % 18)) {
                        strokes += 1;
                    }
                } else if (method === '18max') {
                    // 18 Max: max 1 stroke per hole
                    if (holeHcp <= Math.min(playerHcp, 18)) {
                        strokes = 1;
                    }
                } else if (method === 'half') {
                    // Half Pop: 0.5 stroke per allocated stroke
                    const fullStrokes = Math.floor(playerHcp / 18);
                    const extraStroke = holeHcp <= (playerHcp % 18) ? 1 : 0;
                    strokes = (fullStrokes + extraStroke) * 0.5;
                }
            }
            
            return grossScore - strokes;
        }

        function getStablefordPoints(netScore, par, modified = false) {
            const diff = netScore - par;
            
            if (modified) {
                // Modified Stableford
                if (diff <= -4) return 11;  // Condor
                if (diff === -3) return 8;   // Albatross
                if (diff === -2) return 5;   // Eagle
                if (diff === -1) return 2;   // Birdie
                if (diff === 0) return 0;    // Par
                if (diff === 1) return -1;   // Bogey
                return -3;                    // Double bogey or worse
            } else {
                // Standard Stableford
                if (diff <= -4) return 6;    // Condor
                if (diff === -3) return 5;   // Albatross
                if (diff === -2) return 4;   // Eagle
                if (diff === -1) return 3;   // Birdie
                if (diff === 0) return 2;    // Par
                if (diff === 1) return 1;    // Bogey
                return 0;                     // Double bogey or worse
            }
        }

        function renderResultsPage() {
            // Load the correct course data
            courseData = courses[tournamentData.course];
            
            // Display tournament name if provided
            const tournamentNameEl = document.getElementById('resultsTournamentName');
            if (tournamentNameEl) {
                if (tournamentData.name) {
                    tournamentNameEl.textContent = tournamentData.name;
                    tournamentNameEl.style.display = 'block';
                } else {
                    tournamentNameEl.style.display = 'none';
                }
            }
            
            const subtitle = `${courseData.name} - ${tournamentData.gameType} - ${formatDateDisplay(tournamentData.date)}`;
            document.getElementById('resultsSubtitle').textContent = subtitle;
            
            // Set the dropdown to match current game type
            document.getElementById('resultsGameType').value = tournamentData.gameType;
            
            updateResultsDisplay();
        }

        function updateResultsGameType() {
            const newGameType = document.getElementById('resultsGameType').value;
            
            // Update the tournament data
            tournamentData.gameType = newGameType;
            
            // Update the scoring page header
            document.getElementById('scoringGameType').textContent = newGameType;
            
            // Save to local storage
            saveToLocalStorage();
            
            // Update results display
            updateResultsDisplay(newGameType);
        }

        function updateResultsDisplay(displayGameType) {
            const gameType = displayGameType || tournamentData.gameType;
            const container = document.getElementById('resultsContent');
            container.innerHTML = `<h3 class="results-title">${gameType} Results</h3>`;

            // Stroke Play Gross
            if (gameType === 'Stroke Play Gross') {
                const results = tournamentData.players.map((player, idx) => {
                    const total = player.scores.reduce((sum, s) => sum + s, 0);
                    const toPar = total - courseData.totalPar;
                    return { player, total, toPar, index: idx };
                }).filter(r => r.total > 0);

                // Sort by total, then by back-nine tiebreaker using handicap holes
                results.sort((a, b) => {
                    if (a.total !== b.total) return a.total - b.total;
                    
                    // Tiebreaker: lowest score on hardest holes (hcp 1, 2, 3...)
                    for (let hcp = 1; hcp <= 18; hcp++) {
                        const holeIdx = courseData.holes.findIndex(h => h.handicap === hcp);
                        const scoreA = a.player.scores[holeIdx];
                        const scoreB = b.player.scores[holeIdx];
                        if (scoreA !== scoreB) return scoreA - scoreB;
                    }
                    return 0;
                });

                results.forEach((r, position) => {
                    const medal = position === 0 ? 'ðŸ¥‡' : position === 1 ? 'ðŸ¥ˆ' : position === 2 ? 'ðŸ¥‰' : `${position + 1}.`;
                    const toParText = r.toPar === 0 ? 'E' : (r.toPar > 0 ? `+${r.toPar}` : `${r.toPar}`);
                    
                    container.appendChild(createPlayerResultCard(medal, r.player.name, r.total, toParText, r.player.handicap));
                });
            }

            // Stroke Play Net
            else if (gameType === 'Stroke Play Net') {
                const results = tournamentData.players.map((player, idx) => {
                    let netTotal = 0;
                    player.scores.forEach((score, holeIdx) => {
                        if (score > 0) {
                            const netScore = getNetScore(score, player.handicap, courseData.holes[holeIdx].handicap, 'full');
                            netTotal += netScore;
                        }
                    });
                    const toPar = netTotal - courseData.totalPar;
                    return { player, netTotal, toPar, index: idx };
                }).filter(r => r.netTotal > 0);

                results.sort((a, b) => {
                    if (a.netTotal !== b.netTotal) return a.netTotal - b.netTotal;
                    
                    // Tiebreaker: lowest net score on hardest holes
                    for (let hcp = 1; hcp <= 18; hcp++) {
                        const holeIdx = courseData.holes.findIndex(h => h.handicap === hcp);
                        const netA = getNetScore(a.player.scores[holeIdx], a.player.handicap, hcp, 'full');
                        const netB = getNetScore(b.player.scores[holeIdx], b.player.handicap, hcp, 'full');
                        if (netA !== netB) return netA - netB;
                    }
                    return 0;
                });

                results.forEach((r, position) => {
                    const medal = position === 0 ? 'ðŸ¥‡' : position === 1 ? 'ðŸ¥ˆ' : position === 2 ? 'ðŸ¥‰' : `${position + 1}.`;
                    const toParText = r.toPar === 0 ? 'E' : (r.toPar > 0 ? `+${r.toPar}` : `${r.toPar}`);
                    
                    container.appendChild(createPlayerResultCard(medal, r.player.name, r.netTotal, toParText, r.player.handicap, 'Net'));
                });
            }

            // Skins Games
            else if (gameType.includes('Skins')) {
                const method = gameType === 'Gross Skins' ? 'gross' : 
                              gameType === 'Net Skins (Full Hcp)' ? 'full' :
                              gameType === 'Net Skins (18 Max)' ? '18max' : 'half';
                
                const skinWinners = {};
                const skinDetails = {}; // Track which holes each player won
                
                tournamentData.players.forEach((p, idx) => {
                    skinWinners[idx] = 0;
                    skinDetails[idx] = [];
                });
                
                for (let holeIdx = 0; holeIdx < 18; holeIdx++) {
                    const holeScores = tournamentData.players.map((player, pIdx) => {
                        const gross = player.scores[holeIdx];
                        if (gross === 0) return { pIdx, score: 999, gross: 0 };
                        
                        const score = method === 'gross' ? gross : 
                                     getNetScore(gross, player.handicap, courseData.holes[holeIdx].handicap, 
                                               method === 'full' ? 'full' : method === '18max' ? '18max' : 'half');
                        return { pIdx, score, gross };
                    }).filter(s => s.score < 999);
                    
                    if (holeScores.length === 0) continue;
                    
                    const minScore = Math.min(...holeScores.map(s => s.score));
                    const winners = holeScores.filter(s => s.score === minScore);
                    
                    // Only award skin if there's a sole winner
                    if (winners.length === 1) {
                        const winnerIdx = winners[0].pIdx;
                        skinWinners[winnerIdx]++;
                        skinDetails[winnerIdx].push({
                            hole: holeIdx + 1,
                            score: winners[0].score
                        });
                    }
                }
                
                const results = tournamentData.players.map((player, idx) => ({
                    player,
                    skins: skinWinners[idx] || 0,
                    details: skinDetails[idx] || []
                })).sort((a, b) => b.skins - a.skins);
                
                results.forEach((r, position) => {
                    const medal = position === 0 ? 'ðŸ¥‡' : position === 1 ? 'ðŸ¥ˆ' : position === 2 ? 'ðŸ¥‰' : `${position + 1}.`;
                    const hcpDisplay = r.player.handicap !== 0 ? `(HCP ${r.player.handicap > 0 ? r.player.handicap : '+' + Math.abs(r.player.handicap)})` : '';
                    
                    // Format hole details
                    const holeList = r.details.map(d => `#${d.hole}(${d.score})`).join(', ');
                    
                    const div = document.createElement('div');
                    div.className = 'results-player';
                    div.innerHTML = `
                        <div class="results-player-header">
                            <div class="results-player-name">${medal} ${r.player.name} ${hcpDisplay}</div>
                            <div class="results-score">${r.skins} skin${r.skins !== 1 ? 's' : ''}</div>
                        </div>
                        ${holeList ? `<div style="padding: 8px 0; color: #059669; font-size: 17px; font-weight: 600;">${holeList}</div>` : ''}
                    `;
                    container.appendChild(div);
                });
            }

            // Stableford
            else if (gameType.includes('Stableford')) {
                const modified = gameType.includes('Modified');
                
                const results = tournamentData.players.map((player, idx) => {
                    let points = 0;
                    player.scores.forEach((score, holeIdx) => {
                        if (score > 0) {
                            const netScore = getNetScore(score, player.handicap, courseData.holes[holeIdx].handicap, 'full');
                            const par = courseData.holes[holeIdx].par;
                            points += getStablefordPoints(netScore, par, modified);
                        }
                    });
                    return { player, points };
                }).sort((a, b) => b.points - a.points);

                results.forEach((r, position) => {
                    const medal = position === 0 ? 'ðŸ¥‡' : position === 1 ? 'ðŸ¥ˆ' : position === 2 ? 'ðŸ¥‰' : `${position + 1}.`;
                    const hcpDisplay = r.player.handicap !== 0 ? `(HCP ${r.player.handicap > 0 ? r.player.handicap : '+' + Math.abs(r.player.handicap)})` : '';
                    const div = document.createElement('div');
                    div.className = 'results-player';
                    div.innerHTML = `
                        <div class="results-player-header">
                            <div class="results-player-name">${medal} ${r.player.name} ${hcpDisplay}</div>
                            <div class="results-score">${r.points} pts</div>
                        </div>
                    `;
                    container.appendChild(div);
                });
            }

            // Best Ball Games
            else if (gameType.includes('Best Ball')) {
                const teamsPerRound = gameType === '2-Man Best Ball' ? 2 : gameType === '3-Man Best Ball' ? 2 : 2;
                const scoreCount = gameType === '2-Man Best Ball' ? 1 : 2;
                
                const teamResults = tournamentData.teams.map((team, teamIdx) => {
                    let teamTotal = 0;
                    
                    for (let holeIdx = 0; holeIdx < 18; holeIdx++) {
                        const holeScores = team.map(playerIdx => {
                            const player = tournamentData.players[playerIdx];
                            const gross = player.scores[holeIdx];
                            if (gross === 0) return 999;
                            return getNetScore(gross, player.handicap, courseData.holes[holeIdx].handicap, 'full');
                        }).filter(s => s < 999).sort((a, b) => a - b);
                        
                        // Take best 1 score (2-man) or best 2 scores (3-man, 4-man)
                        const scoresToCount = holeScores.slice(0, scoreCount);
                        teamTotal += scoresToCount.reduce((sum, s) => sum + s, 0);
                    }
                    
                    const teamNames = team.map(pIdx => tournamentData.players[pIdx].name).join(' & ');
                    return { teamNames, teamTotal, teamIdx };
                }).sort((a, b) => a.teamTotal - b.teamTotal);

                teamResults.forEach((r, position) => {
                    const medal = position === 0 ? 'ðŸ¥‡' : position === 1 ? 'ðŸ¥ˆ' : `${position + 1}.`;
                    const toPar = r.teamTotal - courseData.totalPar;
                    const toParText = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : `${toPar}`);
                    
                    const div = document.createElement('div');
                    div.className = 'results-player';
                    div.innerHTML = `
                        <div class="results-player-header">
                            <div class="results-player-name">${medal} ${r.teamNames}</div>
                            <div class="results-score">${r.teamTotal} (${toParText})</div>
                        </div>
                    `;
                    container.appendChild(div);
                });
            }
        }

        function createPlayerResultCard(medal, name, score, toPar, handicap, scoreType = 'Gross') {
            const div = document.createElement('div');
            div.className = 'results-player card-shadow';
            div.style.animation = 'fadeIn 0.3s ease-out';
            
            const hcpDisplay = handicap !== 0 ? ` (HCP ${handicap > 0 ? handicap : '+' + Math.abs(handicap)})` : '';
            
            // Enhanced trophy display
            let trophyHtml = '';
            if (medal === 'ðŸ¥‡') {
                trophyHtml = '<span class="trophy-gold">ðŸ†</span>';
            } else if (medal === 'ðŸ¥ˆ') {
                trophyHtml = '<span class="trophy-silver">ðŸ¥ˆ</span>';
            } else if (medal === 'ðŸ¥‰') {
                trophyHtml = '<span class="trophy-bronze">ðŸ¥‰</span>';
            } else {
                trophyHtml = `<span style="font-weight: 700; color: #64748b; margin-right: 8px;">${medal}</span>`;
            }
            
            div.innerHTML = `
                <div class="results-player-header">
                    <div class="results-player-name" style="display: flex; align-items: center;">
                        ${trophyHtml}
                        ${createPlayerAvatar(name)}
                        <span>${name}${hcpDisplay}</span>
                    </div>
                    <div class="results-score">${score}</div>
                </div>
                <div class="results-details">
                    <div class="results-stat">
                        <span class="results-stat-label">${scoreType} To Par</span>
                        <span>${toPar}</span>
                    </div>
                </div>
            `;
            return div;
        }

        // New round - with custom confirmation dialog
        function confirmNewRound() {
            showConfirm(
                'Start New Round?',
                'All current scores will be lost. This cannot be undone.',
                function() {
                    newRound();
                }
            );
        }

        function newRound() {
            localStorage.removeItem('indianHillsScoring');
            tournamentData = { id: '', date: '', gameType: '', course: '', players: [], teams: [] };
            document.getElementById('tournamentDate').value = ''; // Clear date
            
            // Reset player list to default 1
            const playerList = document.getElementById('playerList');
            playerList.innerHTML = `
                <div class="player-row" data-player="1">
                    <input type="text" class="player-name-input" placeholder="Player Name" id="player1">
                    <input type="text" class="player-hcp-input" placeholder="HCP" id="hcp1" pattern="-?[0-9]*" inputmode="numeric">
                </div>
            `;
            
            currentPlayerCount = 1;
            nextPlayerId = 2;
            document.getElementById('addPlayerBtn').disabled = false;
            document.getElementById('addPlayerBtn').textContent = '+ Add Player';
            
            // Reset course and game type selection to directives
            document.getElementById('courseSelect').value = '';
            document.getElementById('gameType').value = '';
            courseData = null;
            
            showPage('setupPage');
        }

        // Load saved data on startup
        window.addEventListener('load', () => {
            checkForSavedRound();
        });

        // Prevent accidental page refresh
        // Prevent accidental page refresh/close when there's data
        window.addEventListener('beforeunload', (e) => {
            const hasData = localStorage.getItem('indianHillsScoring');
            const hasPlayers = tournamentData && tournamentData.players && tournamentData.players.length > 0;
            
            if (hasData || hasPlayers) {
                const message = 'You have an active round in progress. Leaving will lose unsaved data.';
                e.preventDefault();
                e.returnValue = message; // For Chrome
                return message; // For other browsers
            }
        });

        // Universal button handler for iOS compatibility
        // This uses event delegation on the document level
        function handleButtonClick(e) {
            let target = e.target;
            
            // Find button if clicked on emoji or text inside button
            while (target && target !== document.body) {
                if (target.tagName === 'BUTTON' && target.hasAttribute('data-action')) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const action = target.getAttribute('data-action');
                    
                    // Execute the corresponding function
                    try {
                        switch(action) {
                            case 'confirmBackToSetup':
                                confirmBackToSetup();
                                break;
                            case 'finishRound':
                                finishRound();
                                break;
                            case 'shareResults':
                                shareResults();
                                break;
                            case 'exportToCsv':
                                exportToCsv();
                                break;
                            case 'printScorecard':
                                printScorecard();
                                break;
                            case 'backToScoring':
                                backToScoring();
                                break;
                            case 'confirmNewRound':
                                confirmNewRound();
                                break;
                            default:
                        }
                    } catch (err) {
                        console.error('Error executing button action:', err);
                        alert('Button error: ' + err.message);
                    }
                    
                    return false;
                }
                target = target.parentElement;
            }
        }

        // Attach to both click and touchend for maximum compatibility
        document.addEventListener('click', handleButtonClick, true);
        document.addEventListener('touchend', handleButtonClick, true);

        // Print Scorecard Function
        // Share results as text
        function shareResults() {
            let shareText = `â›³ ${courseData.name} - ${formatDateDisplay(tournamentData.date)}\n`;
            shareText += `Game: ${tournamentData.gameType}\n\n`;
            shareText += `ðŸ“Š FINAL RESULTS\n`;
            shareText += `${'='.repeat(40)}\n\n`;
            
            // Calculate scores for all players
            const playerResults = tournamentData.players.map(player => {
                const grossScore = player.scores.reduce((sum, s) => sum + s, 0);
                const netScore = grossScore - player.handicap;
                const toPar = grossScore - courseData.totalPar;
                return { player, grossScore, netScore, toPar };
            });
            
            // Sort by appropriate score
            const isNet = tournamentData.gameType.includes('Net');
            playerResults.sort((a, b) => {
                const aScore = isNet ? a.netScore : a.grossScore;
                const bScore = isNet ? b.netScore : b.grossScore;
                return aScore - bScore;
            });
            
            // Format results
            playerResults.forEach((r, idx) => {
                const medal = idx === 0 ? 'ðŸ¥‡ ' : idx === 1 ? 'ðŸ¥ˆ ' : idx === 2 ? 'ðŸ¥‰ ' : '';
                const score = isNet ? r.netScore : r.grossScore;
                const toParText = r.toPar === 0 ? 'E' : (r.toPar > 0 ? `+${r.toPar}` : r.toPar);
                shareText += `${medal}${r.player.name}: ${score} (${toParText})\n`;
            });
            
            shareText += `\n---\nCreated with Let's Golf by Otis Williams`;
            
            // Use Web Share API if available
            if (navigator.share) {
                navigator.share({
                    title: `${courseData.name} Results`,
                    text: shareText
                }).catch(err => {
                    copyToClipboard(shareText);
                });
            } else {
                // Fallback to copy to clipboard
                copyToClipboard(shareText);
            }
        }
        
        // Copy to clipboard helper
        function copyToClipboard(text) {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text).then(() => {
                    alert('Results copied to clipboard!');
                }).catch(() => {
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }
        
        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                alert('Results copied to clipboard!');
            } catch (err) {
                alert('Could not copy results. Please try again.');
            }
            document.body.removeChild(textarea);
        }
        
        // ===== PHASE 1: SHARING FEATURES =====
        
        // Get current page URL
        function getCurrentPageURL() {
            return window.location.origin + window.location.pathname;
        }
        
        // Copy shareable tournament link
        function copyShareLink() {
            if (!tournamentData.id) {
                alert('No active tournament to share');
                return;
            }
            
            const shareURL = `${getCurrentPageURL()}?tournament=${tournamentData.id}`;
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(shareURL).then(() => {
                    alert('âœ… Share link copied!\n\nAnyone with this link can view the tournament results.');
                }).catch(() => {
                    fallbackCopy(shareURL);
                });
            } else {
                fallbackCopy(shareURL);
            }
        }
        
        // Show QR code for tournament
        function showQRCode() {
            if (!tournamentData.id) {
                alert('No active tournament to share');
                return;
            }
            
            const container = document.getElementById('qrCodeContainer');
            const qrcodeDiv = document.getElementById('qrcode');
            const idDisplay = document.getElementById('tournamentIdDisplay');
            
            // Clear previous QR code
            qrcodeDiv.innerHTML = '';
            
            // Generate share URL
            const shareURL = `${getCurrentPageURL()}?tournament=${tournamentData.id}`;
            
            // Generate QR code
            try {
                new QRCode(qrcodeDiv, {
                    text: shareURL,
                    width: 200,
                    height: 200,
                    colorDark: "#1e40af",
                    colorLight: "#ffffff",
                    correctLevel: QRCode.CorrectLevel.H
                });
                
                idDisplay.textContent = `ID: ${tournamentData.id}`;
                container.style.display = 'block';
                
                // Scroll to QR code
                container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            } catch (error) {
                alert('Error generating QR code. Please try copying the link instead.');
            }
        }
        
        // Hide QR code
        function hideQRCode() {
            const container = document.getElementById('qrCodeContainer');
            container.style.display = 'none';
        }
        
        // Download tournament data as JSON backup
        function downloadTournamentData() {
            if (!tournamentData.id) {
                alert('No active tournament to download');
                return;
            }
            
            const backup = {
                ...tournamentData,
                courseData: courseData,
                timestamp: new Date().toISOString(),
                version: '1.0'
            };
            
            const dataStr = JSON.stringify(backup, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const dateStr = formatDateDisplay(tournamentData.date).replace(/\//g, '-');
            const filename = `LetsGolf_${tournamentData.id}_${dateStr}.json`;
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            
            URL.revokeObjectURL(url);
            
            alert('âœ… Tournament backup downloaded!\n\nYou can import this file later to restore the tournament.');
        }
        
        // Load tournament from URL parameter
        function loadTournamentFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const tournamentId = urlParams.get('tournament');
            
            if (tournamentId) {
                // Try to load from localStorage
                const savedData = localStorage.getItem('indianHillsScoring');
                if (savedData) {
                    const data = JSON.parse(savedData);
                    if (data.id === tournamentId) {
                        // Found matching tournament
                        alert(`ðŸ“‹ Tournament "${tournamentId}" loaded!\n\nViewing shared tournament.`);
                        // Auto-resume if tournament exists
                        const resumeBtn = document.getElementById('resumeScoringBtn');
                        if (resumeBtn && resumeBtn.style.display !== 'none') {
                            resumeScoring();
                        }
                        return true;
                    }
                }
                
                // Tournament not found locally
                alert(`âš ï¸ Tournament "${tournamentId}" not found on this device.\n\nMake sure you're on the same device where the tournament was created, or import the tournament backup file.`);
                return false;
            }
            return false;
        }
        
        // Import tournament from backup file
        function importTournamentBackup(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const backup = JSON.parse(e.target.result);
                    
                    // Validate backup structure
                    if (!backup.id || !backup.players || !backup.courseData) {
                        alert('âŒ Invalid backup file format');
                        return;
                    }
                    
                    // Restore tournament data
                    tournamentData = {
                        id: backup.id,
                        date: backup.date,
                        gameType: backup.gameType,
                        course: backup.course,
                        players: backup.players,
                        teams: backup.teams || []
                    };
                    
                    courseData = backup.courseData;
                    
                    // Save to localStorage
                    saveToLocalStorage();
                    
                    // Show success and offer to resume
                    alert(`âœ… Tournament imported successfully!\n\nID: ${backup.id}\nDate: ${formatDateDisplay(backup.date)}\nCourse: ${backup.courseData.name}\nPlayers: ${backup.players.length}`);
                    
                    // Reload page to show resume option
                    location.reload();
                    
                } catch (error) {
                    alert('âŒ Error reading backup file. Please make sure it\'s a valid Let\'s Golf backup.');
                    console.error('Import error:', error);
                }
            };
            
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }
        
        // Export to CSV
        function exportToCsv() {
            const dateStr = formatDateDisplay(tournamentData.date).replace(/\//g, '-');
            const filename = `${courseData.name.replace(/\s+/g, '_')}_${dateStr}.csv`;
            
            let csv = `"Course","Game Type","Date"\n`;
            csv += `"${courseData.name}","${tournamentData.gameType}","${formatDateDisplay(tournamentData.date)}"\n\n`;
            
            // Player scores by hole
            csv += `"Player","Handicap"`;
            for (let i = 1; i <= 18; i++) {
                csv += `,"Hole ${i}"`;
            }
            csv += `,"Total","Net","To Par"\n`;
            
            tournamentData.players.forEach(player => {
                const total = player.scores.reduce((sum, s) => sum + s, 0);
                const net = total - player.handicap;
                const toPar = total - courseData.totalPar;
                const toParText = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar);
                
                csv += `"${player.name}","${player.handicap}"`;
                player.scores.forEach(score => {
                    csv += `,"${score || ''}"`;
                });
                csv += `,"${total}","${net}","${toParText}"\n`;
            });
            
            // Download CSV
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        function printScorecard() {
            // Print the current scorecard view
            window.print();
        }

        // Open scorecard modal
        function openScorecardModal() {
            const modal = document.getElementById('scorecardModal');
            const select = document.getElementById('scorecardViewSelect');
            
            // Populate individual player options
            const playerOptions = tournamentData.players
                .map((player, idx) => `<option value="player-${idx}">${player.name}</option>`)
                .join('');
            
            // Rebuild select to include players
            select.innerHTML = `
                <option value="all-summary">All Players - Summary Table</option>
                <option value="all-individual">All Players - Individual Cards</option>
                <option disabled>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</option>
                ${playerOptions}
            `;
            
            modal.classList.add('active');
            updateScorecardView();
        }

        // Close scorecard modal
        function closeScorecardModal() {
            const modal = document.getElementById('scorecardModal');
            modal.classList.remove('active');
        }

        // Update scorecard view based on selection
        function updateScorecardView() {
            const select = document.getElementById('scorecardViewSelect');
            const body = document.getElementById('scorecardBody');
            const viewType = select.value;
            
            if (viewType === 'all-summary') {
                body.innerHTML = generateSummaryTable();
            } else if (viewType === 'all-individual') {
                body.innerHTML = generateAllIndividualCards();
            } else if (viewType.startsWith('player-')) {
                const playerIndex = parseInt(viewType.split('-')[1]);
                body.innerHTML = generateIndividualCard(playerIndex);
            }
        }

        // Generate summary table for all players
        function generateSummaryTable() {
            const currentGameType = document.getElementById('resultsGameType').value;
            
            // Determine handicap method based on game type
            let hcpMethod = 'full';
            if (currentGameType.includes('18 Max')) {
                hcpMethod = '18max';
            } else if (currentGameType.includes('1/2 Pop')) {
                hcpMethod = 'half';
            }
            
            // Check if this is a net or team game (team games use net scores)
            const isNetOrTeam = currentGameType.includes('Net') || 
                                currentGameType.includes('Best Ball') || 
                                currentGameType.includes('Select Shot');
            
            let html = `
                <div style="margin-bottom: 8px; text-align: center;">
                    ${tournamentData.name ? `<h2 style="color: #1e40af; margin-bottom: 4px; font-size: 18px; font-weight: 700;">${tournamentData.name}</h2>` : ''}
                    <h3 style="color: #1e40af; margin-bottom: 2px; font-size: 16px;">${courseData.name}</h3>
                    <p style="color: #64748b; font-size: 12px; margin: 0;">${currentGameType} - ${formatDateDisplay(tournamentData.date)}</p>
                </div>
                <div class="table-wrapper">
                <table class="scorecard-table">
                    <thead>
                        <tr>
                            <th style="width: 70px;">Hole</th>
            `;
            
            // Add player name columns
            tournamentData.players.forEach(player => {
                html += `<th>${player.name}<br><span style="font-size: 11px;">(${player.handicap > 0 ? player.handicap : player.handicap < 0 ? '+' + Math.abs(player.handicap) : 'Scratch'})</span></th>`;
            });
            
            html += `</tr></thead><tbody>`;
            
            // Add hole rows
            for (let i = 0; i < 18; i++) {
                const hole = courseData.holes[i];
                html += `<tr>`;
                html += `<td style="font-size: 10px; line-height: 1.1;"><strong style="font-size: 11px;">${hole.number}</strong><br>Par ${hole.par}<br>Hcp ${hole.handicap}</td>`;
                
                tournamentData.players.forEach(player => {
                    const score = player.scores[i] || '';
                    let netScore = '';
                    
                    if (score && isNetOrTeam) {
                        netScore = getNetScore(score, player.handicap, hole.handicap, hcpMethod);
                    }
                    
                    html += `<td>`;
                    if (score) {
                        html += `<strong>${score}</strong>`;
                        if (netScore !== '' && netScore !== score) {
                            html += `<br><span style="font-size: 9px; color: #10b981;">(${netScore})</span>`;
                        }
                    }
                    html += `</td>`;
                });
                
                html += `</tr>`;
                
                // Add subtotal after hole 9
                if (i === 8) {
                    html += `<tr class="total-row">`;
                    html += `<td><strong>OUT</strong></td>`;
                    
                    tournamentData.players.forEach(player => {
                        const outGross = player.scores.slice(0, 9).reduce((sum, s) => sum + (s || 0), 0);
                        html += `<td><strong>${outGross || ''}</strong></td>`;
                    });
                    
                    html += `</tr>`;
                }
            }
            
            // Add total row
            html += `<tr class="total-row">`;
            html += `<td><strong>IN</strong></td>`;
            
            tournamentData.players.forEach(player => {
                const inGross = player.scores.slice(9).reduce((sum, s) => sum + (s || 0), 0);
                html += `<td><strong>${inGross || ''}</strong></td>`;
            });
            
            html += `</tr>`;
            
            // Add grand total
            html += `<tr class="total-row" style="background: #dbeafe;">`;
            html += `<td><strong>TOTAL</strong></td>`;
            
            tournamentData.players.forEach(player => {
                const totalGross = player.scores.reduce((sum, s) => sum + (s || 0), 0);
                const totalNet = totalGross - player.handicap;
                const toPar = totalGross - courseData.totalPar;
                const toParText = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar);
                
                html += `<td><strong>${totalGross}</strong>`;
                if (currentGameType.includes('Net')) {
                    html += `<br><span style="font-size: 9px; color: #10b981;">(Net: ${totalNet})</span>`;
                }
                html += `<br><span style="font-size: 9px;">${toParText}</span>`;
                html += `</td>`;
            });
            
            html += `</tr>`;
            html += `</tbody></table>`;
            html += `</div>`; // Close table-wrapper
            
            return html;
        }

        // Generate all individual cards
        function generateAllIndividualCards() {
            let html = '';
            tournamentData.players.forEach((player, idx) => {
                html += generateIndividualCard(idx);
            });
            return html;
        }

        // Generate individual scorecard for one player
        function generateIndividualCard(playerIndex) {
            const player = tournamentData.players[playerIndex];
            const currentGameType = document.getElementById('resultsGameType').value;
            
            // Determine handicap method based on game type
            let hcpMethod = 'full';
            if (currentGameType.includes('18 Max')) {
                hcpMethod = '18max';
            } else if (currentGameType.includes('1/2 Pop')) {
                hcpMethod = 'half';
            }
            
            let html = `
                <div class="scorecard-individual">
                    <div class="scorecard-player-header">
                        <div class="scorecard-player-name">${player.name}</div>
                        <div class="scorecard-player-info">
                            ${tournamentData.name ? `<strong>${tournamentData.name}</strong><br>` : ''}
                            ${courseData.name} â€¢ ${currentGameType}<br>
                            ${formatDateDisplay(tournamentData.date)} â€¢ Handicap: ${player.handicap > 0 ? player.handicap : player.handicap < 0 ? '+' + Math.abs(player.handicap) : 'Scratch'}
                        </div>
                    </div>
                    
                    <div class="table-wrapper">
                    <table class="scorecard-table">
                        <thead>
                            <tr>
                                <th>Hole</th>
            `;
            
            // Front 9
            for (let i = 1; i <= 9; i++) {
                html += `<th>${i}</th>`;
            }
            html += `<th>OUT</th>`;
            
            // Back 9
            for (let i = 10; i <= 18; i++) {
                html += `<th>${i}</th>`;
            }
            html += `<th>IN</th><th>TOT</th>`;
            
            html += `</tr></thead><tbody>`;
            
            // Par row
            html += `<tr><td><strong>Par</strong></td>`;
            let frontPar = 0, backPar = 0;
            for (let i = 0; i < 9; i++) {
                frontPar += courseData.holes[i].par;
                html += `<td>${courseData.holes[i].par}</td>`;
            }
            html += `<td><strong>${frontPar}</strong></td>`;
            for (let i = 9; i < 18; i++) {
                backPar += courseData.holes[i].par;
                html += `<td>${courseData.holes[i].par}</td>`;
            }
            html += `<td><strong>${backPar}</strong></td><td><strong>${courseData.totalPar}</strong></td></tr>`;
            
            // Handicap row
            html += `<tr><td><strong>HCP</strong></td>`;
            for (let i = 0; i < 9; i++) {
                html += `<td style="font-size: 11px;">${courseData.holes[i].handicap}</td>`;
            }
            html += `<td></td>`;
            for (let i = 9; i < 18; i++) {
                html += `<td style="font-size: 11px;">${courseData.holes[i].handicap}</td>`;
            }
            html += `<td></td><td></td></tr>`;
            
            // Gross score row
            html += `<tr style="background: #f0f9ff;"><td><strong>Gross</strong></td>`;
            let frontGross = 0, backGross = 0;
            for (let i = 0; i < 9; i++) {
                const score = player.scores[i] || '';
                if (score) frontGross += score;
                html += `<td><strong>${score}</strong></td>`;
            }
            html += `<td><strong>${frontGross || ''}</strong></td>`;
            for (let i = 9; i < 18; i++) {
                const score = player.scores[i] || '';
                if (score) backGross += score;
                html += `<td><strong>${score}</strong></td>`;
            }
            const totalGross = frontGross + backGross;
            html += `<td><strong>${backGross || ''}</strong></td><td><strong>${totalGross || ''}</strong></td></tr>`;
            
            // Net score row (if applicable - for net games OR team games)
            const isNetOrTeam = currentGameType.includes('Net') || 
                                currentGameType.includes('Best Ball') || 
                                currentGameType.includes('Select Shot');
            
            if (isNetOrTeam && player.handicap !== 0) {
                html += `<tr style="background: #dcfce7;"><td><strong>Net</strong></td>`;
                let frontNet = 0, backNet = 0;
                for (let i = 0; i < 9; i++) {
                    const gross = player.scores[i];
                    if (gross) {
                        const net = getNetScore(gross, player.handicap, courseData.holes[i].handicap, hcpMethod);
                        frontNet += net;
                        html += `<td><strong>${net}</strong></td>`;
                    } else {
                        html += `<td></td>`;
                    }
                }
                html += `<td><strong>${frontNet || ''}</strong></td>`;
                for (let i = 9; i < 18; i++) {
                    const gross = player.scores[i];
                    if (gross) {
                        const net = getNetScore(gross, player.handicap, courseData.holes[i].handicap, hcpMethod);
                        backNet += net;
                        html += `<td><strong>${net}</strong></td>`;
                    } else {
                        html += `<td></td>`;
                    }
                }
                const totalNet = frontNet + backNet;
                html += `<td><strong>${backNet || ''}</strong></td><td><strong>${totalNet || ''}</strong></td></tr>`;
            }
            
            // To Par row
            const toPar = totalGross - courseData.totalPar;
            const toParText = toPar === 0 ? 'Even' : (toPar > 0 ? `+${toPar}` : toPar);
            html += `<tr class="total-row"><td colspan="11"><strong>To Par:</strong></td><td colspan="10"><strong>${toParText}</strong></td></tr>`;
            
            html += `</tbody></table>`;
            html += `</div>`; // Close table-wrapper
            html += `</div>`; // Close scorecard-individual
            
            return html;
        }
        // Check for saved round on page load
        function checkForSavedRound() {
            const savedData = localStorage.getItem('indianHillsScoring');
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    const resumeSection = document.getElementById('resumeRoundSection');
                    const resumeInfo = document.getElementById('resumeRoundInfo');
                    const shareButtons = document.getElementById('resumeShareButtons');
                    
                    if (data.players && data.players.length > 0) {
                        // Show resume section
                        resumeSection.classList.add('active');
                        
                        // Format info
                        const playerCount = data.players.length;
                        const date = data.date ? new Date(data.date).toLocaleDateString() : 'Today';
                        const gametype = data.gameType || 'Round';
                        const tournamentName = data.name || '';
                        
                        let infoText = `${playerCount} player${playerCount > 1 ? 's' : ''} â€¢ ${gametype}`;
                        if (tournamentName) {
                            infoText = `${tournamentName} â€¢ ${infoText}`;
                        }
                        resumeInfo.textContent = infoText;
                        
                        // Debug logging
                        console.log('checkForSavedRound - tournamentMode:', tournamentMode);
                        console.log('checkForSavedRound - activeTournamentId:', activeTournamentId);
                        
                        // Show share buttons in multi-device mode (even if tournament creation failed)
                        if (shareButtons && tournamentMode === 'multi') {
                            console.log('Showing share buttons (Multi-Device mode)');
                            shareButtons.style.display = 'grid';
                        } else if (shareButtons) {
                            console.log('Hiding share buttons - mode:', tournamentMode);
                            shareButtons.style.display = 'none';
                        }
                    }
                } catch (e) {
                    console.error('Error loading saved round:', e);
                }
            }
        }

        // Resume saved round
        function resumeSavedRound() {
            if (loadFromLocalStorage()) {
                // Restore the course data
                courseData = courses[tournamentData.course];
                renderScoringPage();
                showPage('scoringPage');
                showRoundIndicator();
            }
        }

        // Discard saved round and start fresh
        function discardSavedRound() {
            showConfirm(
                'Discard Saved Round?',
                'This will permanently delete your saved round. Are you sure?',
                function() {
                    localStorage.removeItem('indianHillsScoring');
                    document.getElementById('resumeRoundSection').classList.remove('active');
                    hideConfirmDialog();
                }
            );
        }

        // Show round in progress indicator
        function showRoundIndicator() {
            const indicator = document.getElementById('roundIndicator');
            if (indicator) {
                indicator.classList.add('active');
            }
        }

        // Hide round in progress indicator
        function hideRoundIndicator() {
            const indicator = document.getElementById('roundIndicator');
            if (indicator) {
                indicator.classList.remove('active');
            }
        }

        // Show auto-save toast
        function showAutoSaveToast() {
            const toast = document.getElementById('autoSaveToast');
            if (toast) {
                toast.classList.add('show');
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 800);
            }
        }

        // Override saveToLocalStorage to add visual feedback
        const originalSave = saveToLocalStorage;
        saveToLocalStorage = function() {
            originalSave();
            showAutoSaveToast();
        };

        // Disable pull-to-refresh on iOS during active round
        function disablePullToRefresh() {
            document.body.style.overscrollBehavior = 'none';
            document.documentElement.style.overscrollBehavior = 'none';
        }

        // Enable pull-to-refresh
        function enablePullToRefresh() {
            document.body.style.overscrollBehavior = 'auto';
            document.documentElement.style.overscrollBehavior = 'auto';
        }

        // Switch to player view
        function switchToPlayerView() {
            currentView = 'player';
            document.getElementById('playerCards').style.display = 'block';
            document.getElementById('holeView').style.display = 'none';
            document.getElementById('togglePlayerView').classList.add('active');
            document.getElementById('toggleHoleView').classList.remove('active');
            
            // Refresh player view to show any changes from hole view
            renderScoringPage();
        }

        // Switch to hole view
        function switchToHoleView() {
            currentView = 'hole';
            document.getElementById('playerCards').style.display = 'none';
            document.getElementById('holeView').style.display = 'block';
            document.getElementById('togglePlayerView').classList.remove('active');
            document.getElementById('toggleHoleView').classList.add('active');
            renderHoleView();
        }

        // Render hole view
        function renderHoleView() {
            const hole = courseData.holes[currentHole];
            const holeNumber = currentHole + 1;
            
            let html = `
                <div class="hole-view-container" id="holeViewContainer">
                    <div class="hole-header">
                        <div class="hole-number">HOLE ${holeNumber}</div>
                        <div class="hole-info">Par ${hole.par} â€¢ HCP ${hole.handicap}</div>
                    </div>
            `;
            
            // Determine net scoring method from game type
            // ALWAYS show net scores, using full handicap by default
            let netMethod = 'full'; // Default to full handicap
            const gameTypeLower = tournamentData.gameType.toLowerCase();
            
            // Override with specific methods if applicable
            if (gameTypeLower.includes('18 max')) {
                netMethod = '18max';
            } else if (gameTypeLower.includes('1/2 pop') || gameTypeLower.includes('half pop')) {
                netMethod = 'half';
            }
            // Otherwise stays as 'full' for all other games
            
            console.log('renderHoleView - gameType:', tournamentData.gameType);
            console.log('renderHoleView - netMethod:', netMethod);
            
            // Add player rows with inline ticker
            tournamentData.players.forEach((player, playerIndex) => {
                const score = player.scores[currentHole]; // Don't default to par - allow blank
                const hasScore = score !== undefined && score !== null && score !== 0;
                const displayScore = hasScore ? score : '';
                
                let scoreClass = '';
                let netScoreDisplay = '';
                
                if (hasScore) {
                    const diff = score - hole.par;
                    
                    if (diff >= 2) {
                        scoreClass = 'double-bogey-plus';
                    } else if (diff === 1) {
                        scoreClass = 'bogey';
                    } else if (diff === 0) {
                        scoreClass = 'par'; // Add par class
                    } else if (diff <= -1) {
                        scoreClass = 'birdie-better';
                    }
                    
                    // Calculate net score if this is a net game
                    if (netMethod) {
                        const netScore = getNetScore(score, player.handicap, hole.handicap, netMethod);
                        netScoreDisplay = `<div class="hole-net-score">${netScore}</div>`;
                    }
                }
                
                html += `
                    <div class="hole-player-row-ticker">
                        <div class="hole-player-info">
                            <div class="hole-player-name">${player.name}</div>
                            <div class="hole-player-hcp">Handicap: ${player.handicap > 0 ? player.handicap : player.handicap < 0 ? '+' + Math.abs(player.handicap) : 'Scratch'}</div>
                        </div>
                        <div class="hole-score-section">
                            <div class="hole-score-ticker">
                                <button type="button" class="score-btn" onclick="adjustHoleScoreDirect(${playerIndex}, ${currentHole}, -1)">âˆ’</button>
                                <input type="number" 
                                       class="score-input ${scoreClass}" 
                                       id="holeScore_${playerIndex}_${currentHole}"
                                       value="${displayScore}" 
                                       placeholder="âˆ’"
                                       onchange="updateHoleScore(${playerIndex}, ${currentHole}, this.value)"
                                       onfocus="handleHoleInputFocus(${playerIndex}, ${currentHole}, this)"
                                       min="0"
                                       max="15"
                                       inputmode="numeric">
                                <button type="button" class="score-btn" onclick="adjustHoleScoreDirect(${playerIndex}, ${currentHole}, 1)">+</button>
                            </div>
                            ${netScoreDisplay}
                        </div>
                    </div>
                `;
            });
            
            // Add navigation
            html += `
                    <div class="hole-navigation">
                        <button type="button" class="hole-nav-btn" onclick="goToPrevHole()" ${currentHole === 0 ? 'disabled' : ''}>
                            â† Hole ${currentHole > 0 ? currentHole : 1}
                        </button>
                        <div class="hole-counter">${holeNumber}/18</div>
                        <button type="button" class="hole-nav-btn" onclick="goToNextHole()" ${currentHole === 17 ? 'disabled' : ''}>
                            Hole ${currentHole < 17 ? holeNumber + 1 : 18} â†’
                        </button>
                    </div>
                </div>
            `;
            
            document.getElementById('holeViewContent').innerHTML = html;
            setupHoleViewSwipe();
        }

        // Handle input focus in hole view - set to par if blank
        function handleHoleInputFocus(playerIndex, holeIndex, inputElement) {
            const currentScore = tournamentData.players[playerIndex].scores[holeIndex];
            const hole = courseData.holes[holeIndex];
            
            // If no score yet, set to par
            if (currentScore === undefined || currentScore === null || currentScore === 0) {
                tournamentData.players[playerIndex].scores[holeIndex] = hole.par;
                inputElement.value = hole.par;
                
                // Update color class for par
                inputElement.classList.remove('birdie-better', 'bogey', 'double-bogey-plus');
                inputElement.classList.add('par');
                
                // Save and update
                saveToLocalStorage();
                renderScoringPage(); // Update player view
            }
            
            // Select all text for easy editing
            inputElement.select();
        }

        // Adjust score directly in hole view (inline ticker)
        function adjustHoleScoreDirect(playerIndex, holeIndex, delta) {
            const currentScore = tournamentData.players[playerIndex].scores[holeIndex];
            const hole = courseData.holes[holeIndex];
            let newScore;
            
            // If no score yet (blank), first press sets to par
            if (currentScore === undefined || currentScore === null || currentScore === 0) {
                newScore = hole.par;
            } else {
                // Score exists, adjust by delta
                if (delta > 0) {
                    newScore = currentScore + 1;
                } else {
                    newScore = Math.max(currentScore - 1, 1); // Min score is 1
                }
            }
            
            tournamentData.players[playerIndex].scores[holeIndex] = newScore;
            
            // Update hole view
            updateHoleViewScore(playerIndex, holeIndex, newScore);
            
            // Update player view if visible
            renderScoringPage();
            
            saveToLocalStorage();
        }

        // Helper function to update hole view score display
        function updateHoleViewScore(playerIndex, holeIndex, newScore) {
            const input = document.getElementById(`holeScore_${playerIndex}_${holeIndex}`);
            if (!input) return;
            
            input.value = newScore;
            
            // Update color class
            const hole = courseData.holes[holeIndex];
            const diff = newScore - hole.par;
            
            input.classList.remove('birdie-better', 'par', 'bogey', 'double-bogey-plus');
            
            if (diff >= 2) {
                input.classList.add('double-bogey-plus');
            } else if (diff === 1) {
                input.classList.add('bogey');
            } else if (diff === 0) {
                input.classList.add('par');
            } else if (diff <= -1) {
                input.classList.add('birdie-better');
            }
            
            // Update net score if applicable
            const player = tournamentData.players[playerIndex];
            let netMethod = null;
            const gameTypeLower = tournamentData.gameType.toLowerCase();
            
            // Check for any net game
            if (gameTypeLower.includes('net')) {
                if (gameTypeLower.includes('full') || gameTypeLower.includes('full hcp')) {
                    netMethod = 'full';
                } else if (gameTypeLower.includes('18 max')) {
                    netMethod = '18max';
                } else if (gameTypeLower.includes('1/2 pop') || gameTypeLower.includes('half pop')) {
                    netMethod = 'half';
                } else {
                    // Default to full handicap for any other net game
                    netMethod = 'full';
                }
            }
            
            if (netMethod) {
                const netScore = getNetScore(newScore, player.handicap, hole.handicap, netMethod);
                const netDisplay = input.parentElement.parentElement.querySelector('.hole-net-score');
                
                if (netDisplay) {
                    netDisplay.textContent = `${netScore}`;
                } else {
                    // Add net score display if it doesn't exist
                    const netDiv = document.createElement('div');
                    netDiv.className = 'hole-net-score';
                    netDiv.textContent = `${netScore}`;
                    input.parentElement.parentElement.appendChild(netDiv);
                }
            }
        }

        // Update score from manual input in hole view
        function updateHoleScore(playerIndex, holeIndex, value) {
            const numValue = parseInt(value);
            
            // If empty or invalid, delete the score
            if (!value || isNaN(numValue) || numValue === 0) {
                tournamentData.players[playerIndex].scores[holeIndex] = 0;
                
                // Clear display
                const input = document.getElementById(`holeScore_${playerIndex}_${holeIndex}`);
                if (input) {
                    input.value = '';
                    input.classList.remove('birdie-better', 'par', 'bogey', 'double-bogey-plus');
                }
                
                // Remove net score
                const netDisplay = input?.parentElement?.parentElement?.querySelector('.hole-net-score');
                if (netDisplay) {
                    netDisplay.remove();
                }
                
                // Update player view
                renderScoringPage();
                saveToLocalStorage();
                return;
            }
            
            tournamentData.players[playerIndex].scores[holeIndex] = numValue;
            
            // Update hole view
            updateHoleViewScore(playerIndex, holeIndex, numValue);
            
            // Update player view
            renderScoringPage();
            
            saveToLocalStorage();
        }

        // Navigate to previous hole
        function goToPrevHole() {
            if (currentHole > 0) {
                currentHole--;
                renderHoleView();
            }
        }

        // Navigate to next hole
        function goToNextHole() {
            if (currentHole < 17) {
                currentHole++;
                renderHoleView();
            }
        }

        // Setup swipe gestures for hole view
        function setupHoleViewSwipe() {
            const container = document.getElementById('holeViewContainer');
            if (!container) return;
            
            let touchStartX = 0;
            let touchEndX = 0;
            
            container.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
            }, { passive: true });
            
            container.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].screenX;
                handleSwipe();
            }, { passive: true });
            
            function handleSwipe() {
                const swipeThreshold = 50;
                const diff = touchStartX - touchEndX;
                
                if (Math.abs(diff) > swipeThreshold) {
                    if (diff > 0) {
                        // Swipe left - next hole
                        goToNextHole();
                    } else {
                        // Swipe right - previous hole
                        goToPrevHole();
                    }
                }
            }
        }

        // Update startScoring to show indicator and disable pull-to-refresh
        const originalStartScoring = startScoring;
        startScoring = function() {
            originalStartScoring();
            showRoundIndicator();
            disablePullToRefresh();
        };

        // Update confirmNewRound to hide indicator and enable pull-to-refresh
        const originalConfirmNewRound = confirmNewRound;
        confirmNewRound = function() {
            showConfirm(
                'Start New Round?',
                'This will end the current round and clear all data. Make sure you\'ve saved your results!',
                function() {
                    localStorage.removeItem('indianHillsScoring');
                    tournamentData = {
                        date: '',
                        gameType: '',
                        course: 'indian_hills',
                        players: [],
                        teams: []
                    };
                    hideRoundIndicator();
                    enablePullToRefresh();
                    showPage('setupPage');
                    hideConfirmDialog();
                    location.reload(); // Reload to reset everything
                }
            );
        };

        // iOS Install Prompt - Show if not running as standalone app
        function showInstallPrompt() {
            // Check if running as standalone (home screen app)
            const isStandalone = window.matchMedia('(display-mode: standalone)').matches || 
                               window.navigator.standalone === true;
            
            // Check if on iOS
            const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
            
            // Check if already dismissed
            const dismissed = localStorage.getItem('installPromptDismissed');
            
            if (!isStandalone && isIOS && !dismissed) {
                // Show after 3 seconds
                setTimeout(() => {
                    const banner = document.createElement('div');
                    banner.style.cssText = `
                        position: fixed;
                        bottom: 0;
                        left: 0;
                        right: 0;
                        background: rgba(30, 64, 175, 0.95);
                        color: white;
                        padding: 16px;
                        text-align: center;
                        z-index: 10000;
                        font-size: 14px;
                        line-height: 1.4;
                        box-shadow: 0 -4px 12px rgba(0,0,0,0.3);
                    `;
                    banner.innerHTML = `
                        <div style="margin-bottom: 8px;">ðŸ“± <strong>Install for Full Screen</strong></div>
                        <div style="font-size: 12px; opacity: 0.9; margin-bottom: 12px;">
                            Tap <strong>Share</strong> â†’ <strong>Add to Home Screen</strong> to hide browser controls
                        </div>
                        <button onclick="this.closest('div').remove(); localStorage.setItem('installPromptDismissed', 'true');" 
                                style="background: white; color: #1e40af; border: none; padding: 8px 20px; border-radius: 6px; font-weight: 600; font-size: 13px;">
                            Got it
                        </button>
                    `;
                    document.body.appendChild(banner);
                    
                    // Auto-dismiss after 10 seconds
                    setTimeout(() => {
                        if (banner.parentNode) {
                            banner.remove();
                        }
                    }, 10000);
                }, 3000);
            }
        }
        
        // Show install prompt on page load
        showInstallPrompt();
    </script>
</body>
</html>
