<!--
================================================================================
    Let's Golf - Golf Tournament Scoring Application
    
    Â© 2026 Otis Williams. All Rights Reserved.
    
    This software and its source code are the intellectual property of 
    Otis Williams. Unauthorized copying, modification, distribution, or use 
    of this code, in whole or in part, is strictly prohibited without prior 
    written permission from the copyright holder.
    
    For licensing inquiries, contact the author.
================================================================================
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Let's Golf">
    <meta name="theme-color" content="#1e40af">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <title>Let's Golf</title>
    <!-- QR Code Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging-compat.js"></script>
    
    <!-- VERSION: 2025-01-07-UI-REFINEMENTS-v5 -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #059669 0%, #10b981 20%, #3b82f6 60%, #1e40af 100%);
            min-height: 100vh;
            min-height: -webkit-fill-available; /* iOS Safari fix */
            padding: 0;
            overflow-x: hidden;
            touch-action: pan-y; /* Allow vertical scrolling */
        }

        html {
            height: -webkit-fill-available; /* iOS Safari fix */
        }

        /* Page Container */
        .page {
            display: none;
            min-height: 100vh;
            padding: 20px;
        }

        .page.active {
            display: block;
            animation: slideIn 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        @keyframes slideIn {
            from { 
                opacity: 0; 
                transform: translateX(20px);
            }
            to { 
                opacity: 1; 
                transform: translateX(0);
            }
        }
        
        @keyframes slideOut {
            from { 
                opacity: 1; 
                transform: translateX(0);
            }
            to { 
                opacity: 0; 
                transform: translateX(20px);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Header */
        .header {
            background: white;
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
        }

        .header h1 {
            color: #1e40af;
            font-size: 24px;
            margin-bottom: 5px;
        }

        .header p {
            color: #64748b;
            font-size: 14px;
        }

        /* Setup Page */
        .setup-container {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 
                        0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            color: #1e40af;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            max-width: 100%;
            padding: 14px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.2s;
            -webkit-appearance: none;
            appearance: none;
        }

        .form-group input[type="date"] {
            padding: 12px 14px;
            font-size: 15px;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #3b82f6;
            background: #f8fafc;
        }

        /* Player Input Grid */
        .player-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: hidden;
        }

        .player-row {
            display: grid;
            grid-template-columns: 1fr 80px;
            gap: 10px;
            align-items: center;
            position: relative;
            background: white;
            border-radius: 12px;
            overflow: visible;
            z-index: 1;
            transition: transform 0.3s ease;
        }

        .player-row.has-suggestions {
            z-index: 100;
        }

        .player-row::after {
            content: 'Delete';
            position: absolute;
            right: -100px;
            top: 0;
            bottom: 0;
            width: 100px;
            background: #ef4444;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 15px;
            border-radius: 12px;
            z-index: -1;
        }

        .player-row.swiped {
            transform: translateX(-100px);
        }

        .player-row.deleting {
            opacity: 0;
            transform: translateX(-300px);
            transition: all 0.3s ease;
        }

        .player-row::before {
            content: 'Delete';
            position: absolute;
            right: -100px;
            top: 0;
            bottom: 0;
            width: 100px;
            background: #ef4444;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 15px;
            border-radius: 12px;
            z-index: -1;
        }

        .player-row.swiped {
            transform: translateX(-100px);
        }

        .player-row.deleting {
            opacity: 0;
            transform: translateX(-300px);
            transition: all 0.3s ease;
        }

        .player-name-input {
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 15px;
            width: 100%;
            background: white;
            position: relative;
            z-index: 1;
        }

        .player-name-input::placeholder {
            color: #94a3b8;
        }

        .player-hcp-input {
            width: 80px;
            padding: 12px 8px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 15px;
            text-align: center;
            background: white;
            position: relative;
            z-index: 1;
        }

        .player-hcp-input::placeholder {
            color: #94a3b8;
            font-size: 13px;
        }

        /* Autocomplete Suggestions */
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 90px;
            background: white;
            border: 2px solid #3b82f6;
            border-top: none;
            border-radius: 0 0 12px 12px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: none;
        }

        .autocomplete-suggestions.show {
            display: block;
        }

        .suggestion-item {
            padding: 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e2e8f0;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover,
        .suggestion-item:active {
            background: #eff6ff;
        }

        .suggestion-name {
            font-weight: 600;
            color: #1e40af;
        }

        .suggestion-hcp {
            color: #64748b;
            font-size: 14px;
        }

        .btn-add-player {
            width: auto;
            min-width: 140px;
            padding: 10px 20px;
            background: white;
            color: #3b82f6;
            border: 2px solid #3b82f6;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            margin: 10px auto 0;
            transition: all 0.2s;
            display: block;
        }

        .btn-add-player:active {
            background: #eff6ff;
        }

        .btn-add-player:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Quick Add Player Buttons */
        .quick-add-btn {
            padding: 8px 12px;
            background: #eff6ff;
            color: #3b82f6;
            border: 2px solid #3b82f6;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            position: relative;
        }

        .quick-add-btn:active {
            background: #dbeafe;
            transform: scale(0.95);
        }

        .quick-add-btn.show-delete {
            padding-right: 36px;
        }

        .quick-add-delete {
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .quick-add-btn.show-delete .quick-add-delete {
            display: flex;
        }

        /* Team Setup */
        .team-container {
            background: #f8fafc;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .team-header {
            color: #1e40af;
            font-weight: 700;
            margin-bottom: 12px;
            font-size: 16px;
        }

        .team-member-select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 8px;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 10px;
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto;
            position: relative;
            z-index: 10;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.3), 
                        0 2px 4px -1px rgba(59, 130, 246, 0.2);
        }

        .btn-primary:active {
            background: #2563eb;
            transform: scale(0.98);
            box-shadow: 0 2px 4px -1px rgba(59, 130, 246, 0.3);
        }

        .btn-primary::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn-primary:active::after {
            width: 300px;
            height: 300px;
        }

        .btn-secondary {
            background: #64748b;
            color: white;
            -webkit-user-select: none;
            user-select: none;
            z-index: 1000 !important;
        }

        .btn-secondary:active {
            background: #475569;
            transform: scale(0.98);
        }

        /* Game Toggle Tabs */
        .game-tab {
            flex: 1;
            min-width: 80px;
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            text-align: center;
        }

        .game-tab.active {
            background: white;
            color: #1e40af;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .game-tab:active {
            transform: scale(0.95);
        }

        /* Player Device Item */
        .player-device-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .player-device-item h4 {
            color: white;
            font-size: 16px;
            margin-bottom: 4px;
        }

        .player-device-item p {
            color: #cbd5e1;
            font-size: 13px;
            margin-bottom: 8px;
        }

        .player-device-item button {
            padding: 6px 12px;
            font-size: 13px;
            margin-right: 8px;
        }

        /* Leaderboard Styles */
        .leaderboard-entry {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .leaderboard-entry.first {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
        }

        .leaderboard-entry.second {
            background: linear-gradient(135deg, #94a3b8, #64748b);
        }

        .leaderboard-entry.third {
            background: linear-gradient(135deg, #fb923c, #ea580c);
        }

        .leaderboard-rank {
            font-size: 20px;
            font-weight: 700;
            min-width: 40px;
        }

        .leaderboard-name {
            flex: 1;
            font-weight: 600;
            color: white;
        }

        .leaderboard-score {
            font-size: 18px;
            font-weight: 700;
            color: white;
        }

        /* Scoring Page */
        .scoring-header {
            background: white;
            padding: 12px 16px;
            border-radius: 12px;
            margin-bottom: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: sticky;
            top: 20px;
            z-index: 50;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: top 0.3s;
        }

        .header-top-row {
            display: none; /* Deprecated - using new layout */
        }

        .header-bottom-row {
            display: flex; /* Changed from none - needed for setup page toggle */
        }
        
        /* Hide old row only in scoring header */
        .scoring-header .header-bottom-row {
            display: none; /* Old row - replaced by button grid */
        }
        
        .scoring-button-grid {
            display: flex;
            justify-content: center;
            gap: 8px;
            padding: 0 8px;
        }
        
        /* Grouped toggle button pairs */
        .btn-toggle-group {
            display: flex;
            background: #e2e8f0;
            border-radius: 8px;
            padding: 2px;
            gap: 0;
        }
        
        .btn-toggle-group .toggle-btn {
            flex: 1;
            padding: 6px 10px;
            background: transparent;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 4px;
            color: #64748b;
            white-space: nowrap;
        }
        
        .btn-toggle-group .toggle-btn.active {
            background: white;
            color: #1e40af;
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }
        
        .btn-toggle-group .toggle-btn.voice-active {
            background: #10b981;
            color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }
        
        .scoring-grid-btn {
            padding: 10px 8px;
            background: #f1f5f9;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            color: #64748b;
        }
        
        .scoring-grid-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }
        
        .scoring-grid-btn.voice-btn.active {
            background: #10b981;
            border-color: #10b981;
            color: white;
        }
        
        .scoring-grid-btn.card-btn {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }
        
        .scoring-grid-btn.myplayers-btn {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            border-color: #f59e0b;
            color: #78350f;
        }
        
        .scoring-grid-btn.manage-btn {
            background: #f59e0b;
            border-color: #f59e0b;
            color: white;
        }

        .tournament-info-centered {
            text-align: center;
        }

        .tournament-info-centered h2 {
            font-size: 16px;
            font-weight: 700;
            color: #1e293b;
            margin: 0;
            line-height: 1.2;
        }

        .tournament-info-centered p {
            font-size: 12px;
            color: #64748b;
            margin: 2px 0 0 0;
        }

        /* Results page header - simple single row */
        .results-sticky-header {
            position: sticky;
            top: 0;
            z-index: 50;
            background: linear-gradient(135deg, #1e3a5f 0%, #3b82f6 100%);
            margin: -20px -20px 16px -20px;
            padding: 12px;
            border-radius: 0 0 12px 12px;
        }
        
        .results-page-header {
            background: white;
            padding: 12px 16px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: stretch;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .tournament-info-simple {
            flex: 1;
            min-width: 0;
        }

        .tournament-info-simple h2 {
            color: #1e40af;
            font-size: 16px;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .tournament-info-simple p {
            color: #64748b;
            font-size: 12px;
            margin: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .scoring-content {
            padding-top: 76px;
            padding-left: 0;
            padding-right: 0;
        }

        .round-indicator.active ~ .scoring-header,
        #scoringPage .round-indicator.active ~ .scoring-header {
            top: 52px;
        }

        .round-indicator.active ~ .scoring-content,
        #scoringPage .round-indicator.active ~ .scoring-content {
            padding-top: 108px;
        }


        .finish-btn {
            padding: 8px 16px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 13px;
            white-space: nowrap;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            pointer-events: auto;
            position: relative;
            z-index: 10;
        }

        .finish-btn:active {
            background: #059669;
        }

        .back-btn {
            padding: 8px 12px;
            background: #64748b;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            white-space: nowrap;
            -webkit-tap-highlight-color: rgba(100, 116, 139, 0.3);
            touch-action: manipulation;
            pointer-events: auto;
            position: relative;
            z-index: 1000;
            -webkit-user-select: none;
            user-select: none;
        }

        .back-btn:active {
            background: #475569;
        }

        /* Player Card */
        .player-card {
            background: white;
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        /* Swipe Carousel for Player View */
        .player-carousel {
            position: relative;
            overflow: hidden;
            width: 100%;
        }
        
        .player-carousel-track {
            display: flex;
            transition: transform 0.3s ease-out;
            touch-action: pan-y pinch-zoom;
        }
        
        .player-carousel-slide {
            flex: 0 0 100%;
            width: 100%;
            padding: 0 8px;
            box-sizing: border-box;
        }
        
        .player-card-fit {
            background: white;
            border-radius: 16px;
            padding: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 220px);
        }
        
        .player-card-fit .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            border-bottom: 2px solid #e2e8f0;
            margin-bottom: 8px;
            flex-shrink: 0;
        }
        
        .player-card-fit .player-name {
            font-size: 18px;
            font-weight: 700;
            color: #1e40af;
        }
        
        .player-card-fit .player-total {
            font-size: 20px;
            font-weight: 700;
            color: #3b82f6;
        }
        
        /* Compact holes grid for auto-fit */
        .holes-grid-fit {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
            width: 100%;
            box-sizing: border-box;
            flex: 1;
            overflow-y: auto;
        }
        
        .hole-input-fit {
            background: #f8fafc;
            border-radius: 8px;
            padding: 4px;
            min-width: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .hole-input-fit .hole-num {
            font-size: 10px;
            font-weight: 700;
            color: #1e40af;
        }
        
        .hole-input-fit .hole-par {
            font-size: 8px;
            color: #64748b;
        }
        
        .hole-input-fit .score-display {
            font-size: 18px;
            font-weight: 700;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            margin: 2px 0;
        }
        
        .hole-input-fit .score-btns {
            display: flex;
            gap: 2px;
        }
        
        .hole-input-fit .score-btn-sm {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .hole-input-fit .score-btn-sm.minus {
            background: #fee2e2;
            color: #dc2626;
        }
        
        .hole-input-fit .score-btn-sm.plus {
            background: #dbeafe;
            color: #2563eb;
        }
        
        /* Carousel navigation dots */
        .carousel-dots {
            display: flex;
            justify-content: center;
            gap: 8px;
            padding: 12px 0;
        }
        
        .carousel-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #cbd5e1;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .carousel-dot.active {
            background: #3b82f6;
            transform: scale(1.2);
        }
        
        /* Carousel nav arrows */
        .carousel-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }
        
        .carousel-nav-btn {
            padding: 8px 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .carousel-nav-btn:disabled {
            background: #e2e8f0;
            color: #94a3b8;
            cursor: not-allowed;
        }
        
        .carousel-player-name {
            font-size: 16px;
            font-weight: 700;
            color: #1e40af;
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        }

        .player-name {
            font-size: 20px;
            font-weight: 700;
            color: #1e40af;
        }

        .player-total {
            font-size: 24px;
            font-weight: 700;
            color: #3b82f6;
        }

        /* Hole Grid */
        .holes-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
            box-sizing: border-box;
        }

        .hole-input-group {
            background: #f8fafc;
            border-radius: 10px;
            padding: 8px 5px;
            min-width: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hole-label {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
            font-size: 11px;
            color: #64748b;
            font-weight: 600;
            min-height: 32px;
        }

        .par-badge {
            background: #dbeafe;
            color: #1e40af;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 9px;
            white-space: nowrap;
        }

        .score-input-wrapper {
            display: flex;
            align-items: center;
            gap: 3px;
            min-width: 0;
        }

        .score-btn {
            width: 28px;
            height: 28px;
            min-width: 28px;
            border: none;
            background: #3b82f6;
            color: white;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        .score-btn:active {
            background: #2563eb;
            transform: scale(0.95);
        }

        .score-input {
            width: 100%;
            max-width: 100%;
            min-width: 0;
            text-align: center;
            padding: 6px 2px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 700;
            color: #1e40af;
            box-sizing: border-box;
        }

        .score-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        /* Score coloring */
        .score-input.birdie-better {
            background: #dcfce7;
            border-color: #10b981;
            color: #059669;
            font-weight: 600;
        }

        .score-input.par {
            background: #dbeafe;
            border-color: #3b82f6;
            color: #1e40af;
            font-weight: 600;
        }

        .score-input.bogey {
            background: #fef3c7;
            border-color: #f59e0b;
            color: #d97706;
            font-weight: 600;
        }

        .score-input.double-bogey-plus {
            background: #fef2f2;
            border-color: #ef4444;
            color: #dc2626;
            font-weight: 600;
        }

        /* Results Page */
        .results-container {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .results-title {
            color: #1e293b;
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
            text-align: center;
        }

        .results-player {
            background: #f8fafc;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .results-player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .results-player-name {
            font-size: 18px;
            font-weight: 700;
            color: #1e40af;
        }

        .results-score {
            font-size: 24px;
            font-weight: 700;
            color: #3b82f6;
        }

        .results-details {
            display: flex;
            gap: 16px;
            font-size: 13px;
            color: #64748b;
        }

        .results-stat {
            display: flex;
            flex-direction: column;
        }

        .results-stat-label {
            font-weight: 600;
            margin-bottom: 2px;
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: 40px;
            color: #64748b;
        }

        /* Share Tournament Section */
        .share-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .share-section h3 {
            color: #1e40af;
            margin-bottom: 16px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .share-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .share-btn {
            background: white;
            color: #3b82f6;
            border: 2px solid #3b82f6;
            padding: 12px 8px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .share-btn:active {
            transform: scale(0.98);
            background: #f8fafc;
        }

        .share-btn.copy {
            color: #10b981;
            border-color: #10b981;
        }

        .share-btn.qr {
            color: #a855f7;
            border-color: #a855f7;
        }

        .share-btn.download {
            color: #f59e0b;
            border-color: #f59e0b;
        }

        #qrCodeContainer {
            text-align: center;
            padding: 20px;
            background: #f8fafc;
            border-radius: 8px;
            margin-top: 16px;
        }

        #qrCodeContainer canvas {
            margin: 0 auto;
            display: block;
        }

        .tournament-id {
            font-family: monospace;
            background: #f1f5f9;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            color: #475569;
            margin-top: 10px;
            word-break: break-all;
        }

        /* ===== UI ENHANCEMENTS ===== */
        
        /* Player Avatar Circles */
        .player-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 12px;
            color: white;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .player-avatar-large {
            width: 48px;
            height: 48px;
            font-size: 18px;
        }

        /* Score Color Coding */
        .score-eagle {
            background: linear-gradient(135deg, #059669, #10b981);
            color: white;
            font-weight: 700;
        }

        .score-birdie {
            background: linear-gradient(135deg, #10b981, #34d399);
            color: white;
            font-weight: 700;
        }

        .score-par {
            background: #f1f5f9;
            color: #475569;
        }

        .score-bogey {
            background: linear-gradient(135deg, #f59e0b, #fbbf24);
            color: white;
            font-weight: 700;
        }

        .score-double {
            background: linear-gradient(135deg, #ef4444, #f87171);
            color: white;
            font-weight: 700;
        }

        /* Enhanced Shadows */
        .card-shadow {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 
                        0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .card-shadow-lg {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 
                        0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .card-shadow-xl {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 
                        0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        /* Pulse Animation for Score Changes */
        @keyframes scorePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .score-changed {
            animation: scorePulse 0.3s ease-out;
        }

        /* Trophy Icons */
        .trophy-gold {
            color: #fbbf24;
            font-size: 24px;
            margin-right: 8px;
        }

        .trophy-silver {
            color: #d1d5db;
            font-size: 22px;
            margin-right: 8px;
        }

        .trophy-bronze {
            color: #c27803;
            font-size: 20px;
            margin-right: 8px;
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 0;
        }
        
        /* Progress bar in scoring header uses gradient background */
        .scoring-header .progress-bar {
            background: #e2e8f0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #3b82f6);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        /* Confetti Animation */
        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            z-index: 9999;
            pointer-events: none;
        }

        /* Ripple Effect */
        .ripple {
            position: relative;
            overflow: hidden;
        }

        .ripple::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .ripple:active::after {
            width: 300px;
            height: 300px;
        }

        /* Number Count Animation */
        @keyframes numberCount {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .number-animate {
            animation: numberCount 0.3s ease-out;
        }

        /* Scorecard Modal */
        .scorecard-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .scorecard-modal.active {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 20px;
        }

        .scorecard-content {
            background: white;
            border-radius: 16px;
            max-width: 900px;
            width: 100%;
            margin: 20px auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .scorecard-header {
            padding: 20px;
            border-bottom: 2px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .scorecard-body {
            padding: 12px;
            max-height: 75vh;
            overflow-y: auto;
        }

        .scorecard-footer {
            padding: 16px;
            border-top: 2px solid #e2e8f0;
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .scorecard-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 11px;
            table-layout: auto;
        }

        .scorecard-table th,
        .scorecard-table td {
            border: 1px solid #cbd5e1;
            padding: 4px 2px;
            text-align: center;
            min-width: 35px;
            line-height: 1.2;
        }

        .scorecard-table th {
            background: #3b82f6;
            color: white;
            font-weight: 600;
            font-size: 10px;
            padding: 3px 2px;
        }

        .scorecard-table .player-name-cell {
            background: #dbeafe;
            font-weight: 600;
            color: #1e40af;
        }

        .scorecard-table .total-row {
            background: #f1f5f9;
            font-weight: 600;
        }

        .scorecard-individual {
            background: white;
            border: 2px solid #cbd5e1;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            page-break-inside: avoid;
            break-inside: avoid;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .scorecard-player-header {
            text-align: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        }

        .scorecard-player-name {
            font-size: 20px;
            font-weight: 700;
            color: #1e40af;
            margin-bottom: 4px;
        }

        .scorecard-player-info {
            font-size: 14px;
            color: #64748b;
        }

        /* Round in Progress Indicator */
        .round-indicator {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); /* Bright orange/amber */
            color: white;
            padding: 12px 16px; /* Slightly taller */
            text-align: center;
            font-size: 14px; /* Larger text */
            font-weight: 700; /* Bolder */
            z-index: 9998;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4); /* Stronger shadow with orange tint */
            display: none;
            border-bottom: 2px solid #fff; /* White bottom border */
        }

        .round-indicator.active {
            display: block;
        }

        .round-indicator-icon {
            display: inline-block;
            width: 10px; /* Slightly larger dot */
            height: 10px;
            background: #fff;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1.5s infinite; /* Faster pulse */
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .auto-save-toast {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 9999;
            pointer-events: none;
        }

        .auto-save-toast.show {
            opacity: 1;
        }

        .resume-round-section {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            color: white;
            display: none;
        }

        .resume-round-section.active {
            display: block;
        }

        .resume-round-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .resume-round-info {
            font-size: 14px;
            margin-bottom: 16px;
            opacity: 0.9;
        }

        .resume-round-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        /* Force share buttons to be visible on all devices including iPhone */
        #resumeShareButtons {
            min-height: 44px !important; /* iOS minimum tap target */
            overflow: visible !important;
        }
        
        #resumeShareButtons.visible {
            display: grid !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .resume-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
        }

        .discard-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* View Toggle Buttons in Header */
        .view-toggle-btn-header {
            padding: 8px 16px;
            background: #f1f5f9;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            color: #64748b;
            flex: 1;
            justify-content: center;
        }

        .view-toggle-btn-header.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }

        /* Old toggle buttons - can remove */
        .view-toggle-btn {
            flex: 1;
            padding: 8px 16px;
            background: white;
            border: 2px solid #cbd5e1;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #64748b;
            cursor: pointer;
            transition: all 0.2s;
        }

        .view-toggle-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }

        /* Hole View Styles */
        .hole-view-container {
            background: white;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .hole-header {
            text-align: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        }
        
        .hole-nav-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        
        .hole-nav-btn-compact {
            padding: 8px 14px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            min-width: 60px;
        }
        
        .hole-nav-btn-compact:active {
            transform: scale(0.95);
        }
        
        .hole-title-section {
            flex: 1;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 8px;
            transition: background 0.2s;
        }
        
        .hole-title-section:active {
            background: #f1f5f9;
        }

        .hole-number {
            font-size: 32px;
            font-weight: 700;
            color: #1e40af;
            margin-bottom: 2px;
        }

        .hole-info {
            font-size: 15px;
            color: #64748b;
            font-weight: 600;
        }

        .hole-player-row-ticker {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            padding: 16px;
            margin-bottom: 12px;
            background: #f8fafc;
            border-radius: 12px;
            gap: 16px;
        }

        .hole-player-info {
            flex: 1;
        }

        .hole-player-name {
            font-size: 34px;
            font-weight: 700;
            color: #1e40af;
        }

        .hole-player-hcp {
            font-size: 17px;
            color: #64748b;
            margin-top: 4px;
            font-weight: 500;
        }

        .hole-score-section {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 12px;
        }

        .hole-score-ticker {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .hole-hcp-dots {
            display: flex;
            gap: 3px;
            justify-content: center;
            margin-bottom: 4px;
            min-height: 10px;
            width: 100%;
        }
        
        .hcp-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .hcp-dot.green {
            background: #10b981;
        }
        
        .hcp-dot.red {
            background: #ef4444;
        }

        .hole-net-score {
            font-size: 18px;
            color: #475569;
            font-weight: 700;
            background: #e2e8f0;
            padding: 6px 12px;
            border-radius: 8px;
            min-width: 45px;
            text-align: center;
        }

        .hole-score-ticker .score-btn {
            display: none; /* Hide +/- buttons - using quick tap popup instead */
        }

        .hole-score-ticker .score-input {
            width: 70px;
            height: 70px;
            font-size: 32px;
            font-weight: 700;
            text-align: center;
            border: 3px solid #cbd5e1;
            border-radius: 50%;
            background: white;
            color: #1e40af;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            -webkit-appearance: none;
            -moz-appearance: textfield;
        }

        .hole-score-ticker .score-input:focus {
            outline: none;
            border-color: #3b82f6;
        }
        
        /* Watch-only row styling */
        .hole-player-row-ticker.watch-only {
            opacity: 0.85;
            background: #f8fafc;
        }
        
        .hole-score-display {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* Score coloring for hole view */
        .hole-score-ticker .score-input.birdie-better {
            background: #dcfce7;
            border-color: #86efac;
            color: #166534;
        }

        .hole-score-ticker .score-input.par {
            background: #dbeafe;
            border-color: #60a5fa;
            color: #1e40af;
        }

        .hole-score-ticker .score-input.bogey {
            background: #fef9c3;
            border-color: #fde047;
            color: #854d0e;
        }

        .hole-score-ticker .score-input.double-bogey-plus {
            background: #fee2e2;
            border-color: #fca5a5;
            color: #991b1b;
        }

        .hole-player-row {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            padding: 12px;
            margin-bottom: 12px;
            background: #f8fafc;
            border-radius: 12px;
            gap: 12px;
        }

        .hole-player-name {
            font-size: 16px;
            font-weight: 600;
            color: #1e40af;
        }

        .hole-player-hcp {
            font-size: 13px;
            color: #64748b;
            margin-top: 2px;
        }

        .hole-score-input {
            width: 60px;
            height: 60px;
            font-size: 24px;
            font-weight: 700;
            text-align: center;
            border: 2px solid #cbd5e1;
            border-radius: 12px;
            background: white;
            color: #1e40af;
        }

        .hole-score-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .hole-navigation {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 12px;
            align-items: center;
            margin-top: 24px;
        }

        .hole-nav-btn {
            padding: 12px 20px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .hole-nav-btn:disabled {
            background: #e2e8f0;
            color: #94a3b8;
            cursor: not-allowed;
        }

        .hole-counter {
            text-align: center;
            font-size: 16px;
            font-weight: 600;
            color: #64748b;
        }

        /* Swipe gesture support */
        .hole-view-container {
            touch-action: pan-y;
            position: relative;
        }

        /* Score Picker Overlay */
        .score-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 20px;
        }

        .score-picker {
            background: white;
            border-radius: 20px;
            padding: 24px;
            width: 100%;
            max-width: 320px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .score-picker-header {
            text-align: center;
            font-size: 16px;
            color: #1e40af;
            margin-bottom: 16px;
        }

        .score-display {
            text-align: center;
            font-size: 48px;
            font-weight: 700;
            color: #3b82f6;
            margin: 20px 0;
        }

        .score-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }

        .score-btn {
            padding: 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            transition: background 0.2s;
        }

        .score-btn:active {
            background: #2563eb;
        }

        .score-close {
            width: 100%;
            padding: 14px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        /* Wrapper for table to enable horizontal scroll */
        .table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin-bottom: 20px;
        }

        @media print {
            .scorecard-modal {
                display: block !important;
                position: static;
                background: white;
            }

            .scorecard-content {
                box-shadow: none;
                max-width: 100%;
            }

            .scorecard-header,
            .scorecard-footer {
                display: none !important;
            }

            .scorecard-body {
                max-height: none;
                overflow: visible;
            }
            
            .scorecard-individual {
                page-break-inside: avoid;
                break-inside: avoid;
            }
            
            .table-wrapper {
                overflow: visible;
            }
            
            .scorecard-table {
                font-size: 10px;
            }
            
            .scorecard-table th,
            .scorecard-table td {
                padding: 4px 2px;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
                padding: 0;
            }

            .page {
                display: none;
            }

            #printableScorecard {
                display: block !important;
            }

            .btn, .form-group, #resultsGameType {
                display: none !important;
            }

            .print-scorecard {
                display: block;
                padding: 20px;
                font-family: Arial, sans-serif;
                color: black;
            }

            .print-header {
                text-align: center;
                margin-bottom: 20px;
                border-bottom: 2px solid black;
                padding-bottom: 10px;
            }

            .print-table {
                width: 100%;
                border-collapse: collapse;
                margin-bottom: 20px;
                page-break-inside: avoid;
            }

            .print-table th,
            .print-table td {
                border: 1px solid black;
                padding: 6px;
                text-align: center;
                font-size: 11px;
            }

            .print-table th {
                background: #e0e0e0;
                font-weight: bold;
            }

            .print-results {
                margin-top: 20px;
                page-break-before: avoid;
            }

            .print-results h3 {
                border-bottom: 2px solid black;
                padding-bottom: 5px;
                margin-bottom: 10px;
            }
            
            /* Make scorecard table fit on one page */
            .scorecard-table {
                font-size: 9px !important;
                width: 100%;
                page-break-inside: avoid;
            }
            
            .scorecard-table th,
            .scorecard-table td {
                padding: 4px 2px !important;
                font-size: 9px !important;
            }
            
            .scorecard-table th {
                font-size: 8px !important;
                font-weight: 700;
            }
            
            /* Hide modal chrome in print */
            .scorecard-header,
            .scorecard-footer {
                display: none !important;
            }
            
            .scorecard-modal {
                position: static !important;
                background: white !important;
            }
            
            .scorecard-content {
                max-width: 100% !important;
                margin: 0 !important;
                box-shadow: none !important;
            }
            
            .scorecard-body {
                padding: 10px !important;
            }
        }

        .print-scorecard {
            display: none;
        }
        
        /* Voice/Keyboard Input Toggle */
        .input-mode-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f1f5f9;
            border-radius: 8px;
            margin: 8px 0;
        }
        
        .input-mode-toggle label {
            font-size: 12px;
            color: #64748b;
            font-weight: 600;
        }
        
        .input-mode-btn {
            padding: 6px 12px;
            border: 2px solid #e2e8f0;
            background: white;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .input-mode-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }
        
        .input-mode-btn:hover:not(.active) {
            border-color: #3b82f6;
        }
        
        /* Voice listening indicator */
        .voice-listening {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 32px 48px;
            border-radius: 16px;
            z-index: 10001;
            text-align: center;
            display: none;
        }
        
        .voice-listening.active {
            display: block;
        }
        
        .voice-listening .mic-icon {
            font-size: 48px;
            animation: pulse 1s infinite;
        }
        
        .voice-listening .voice-text {
            font-size: 18px;
            margin-top: 12px;
            font-weight: 600;
        }
        
        .voice-listening .voice-result {
            font-size: 48px;
            margin-top: 16px;
            font-weight: 700;
            color: #10b981;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        /* Compact Player Card (9-column grid for auto-fit) */
        .player-card-compact {
            background: white;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .player-card-compact.watched {
            background: #f8fafc;
            border: 2px dashed #94a3b8;
        }
        
        .player-card-compact .player-header-compact {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            border-bottom: 2px solid #e2e8f0;
            margin-bottom: 8px;
        }
        
        .player-card-compact .player-name-compact {
            font-size: 16px;
            font-weight: 700;
            color: #1e40af;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .player-card-compact .player-total-compact {
            font-size: 18px;
            font-weight: 700;
            color: #3b82f6;
        }
        
        .nine-section {
            margin-bottom: 8px;
        }
        
        .nine-section-label {
            font-size: 11px;
            font-weight: 700;
            color: #64748b;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .nine-section-total {
            font-size: 12px;
            font-weight: 700;
            color: #1e40af;
        }
        
        .holes-grid-6 {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
        }
        
        /* Expanded score input modal */
        .expanded-score-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 10002;
            align-items: center;
            justify-content: center;
        }
        
        .expanded-score-modal.active {
            display: flex;
        }
        
        .expanded-score-content {
            background: white;
            border-radius: 16px;
            padding: 20px;
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .expanded-hole-header {
            text-align: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        }
        
        .expanded-hole-number {
            font-size: 24px;
            font-weight: 700;
            color: #1e40af;
        }
        
        .expanded-hole-info {
            font-size: 14px;
            color: #64748b;
        }
        
        .expanded-player-name {
            font-size: 18px;
            font-weight: 600;
            color: #1e40af;
            margin-bottom: 16px;
            text-align: center;
        }
        
        .expanded-score-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            margin-bottom: 20px;
        }
        
        .expanded-score-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            font-size: 28px;
            font-weight: 700;
            cursor: pointer;
        }
        
        .expanded-score-btn.minus {
            background: #fee2e2;
            color: #dc2626;
        }
        
        .expanded-score-btn.plus {
            background: #dbeafe;
            color: #2563eb;
        }
        
        .expanded-score-value {
            font-size: 48px;
            font-weight: 700;
            width: 80px;
            text-align: center;
            color: #1e40af;
        }
        
        .expanded-quick-scores {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .quick-score-btn {
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .quick-score-btn:active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
        
        .expanded-actions {
            display: flex;
            gap: 12px;
        }
        
        .expanded-actions button {
            flex: 1;
            padding: 14px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .hole-cell {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 3px 2px;
            background: #f8fafc;
            border-radius: 6px;
            min-width: 0;
            min-height: 95px;
        }
        
        .hole-cell .hole-num {
            font-size: 12px;
            font-weight: 700;
            color: #1e40af;
        }
        
        .hole-cell .hole-par {
            font-size: 10px;
            color: #64748b;
            font-weight: 600;
        }
        
        .hole-cell .hole-hcp {
            font-size: 8px;
            color: #64748b;
            font-weight: 500;
            margin-bottom: 2px;
        }
        
        .hole-cell .score-cell {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 700;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s;
        }
        
        .hole-cell .score-cell:active {
            transform: scale(0.95);
        }
        
        .hole-cell .score-cell.empty {
            background: #e2e8f0;
            color: #94a3b8;
        }
        
        .hole-cell .score-cell.birdie-better {
            background: #d1fae5;
            color: #059669;
            border-color: #10b981;
        }
        
        .hole-cell .score-cell.par {
            background: #dbeafe;
            color: #2563eb;
            border-color: #3b82f6;
        }
        
        .hole-cell .score-cell.bogey {
            background: #fef3c7;
            color: #d97706;
            border-color: #f59e0b;
        }
        
        .hole-cell .score-cell.double-plus {
            background: #fee2e2;
            color: #dc2626;
            border-color: #ef4444;
        }
        
        .hole-cell .net-score {
            font-size: 9px;
            color: #64748b;
            font-weight: 600;
            margin-top: 1px;
        }
        
        .hcp-dots-compact {
            display: flex;
            gap: 2px;
            justify-content: center;
            height: 8px;
            margin-bottom: 2px;
        }
        
        .hcp-dot-compact {
            width: 5px;
            height: 5px;
            border-radius: 50%;
        }
        
        .hcp-dot-compact.green {
            background: #10b981;
        }
        
        .hcp-dot-compact.red {
            background: #ef4444;
        }
        
        .hole-cell .score-btns-mini {
            display: flex;
            gap: 2px;
        }
        
        .hole-cell .btn-mini {
            width: 20px;
            height: 18px;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        
        .hole-cell .btn-mini.minus {
            background: #fee2e2;
            color: #dc2626;
        }
        
        .hole-cell .btn-mini.plus {
            background: #dbeafe;
            color: #2563eb;
        }
        
        /* Fullscreen mode - expanded scorecard */
        .fullscreen-mode .player-card-compact {
            max-width: 100%;
            margin: 0 8px;
            padding: 20px;
            min-height: calc(100vh - 140px);
        }
        
        .fullscreen-mode .holes-grid-6 {
            gap: 8px;
        }
        
        .fullscreen-mode .hole-cell {
            padding: 8px 6px;
            border-radius: 10px;
        }
        
        .fullscreen-mode .hole-cell .hole-num {
            font-size: 16px;
        }
        
        .fullscreen-mode .hole-cell .hole-par {
            font-size: 12px;
        }
        
        .fullscreen-mode .hole-cell .hole-hcp {
            font-size: 10px;
            color: #64748b;
            font-weight: 500;
        }
        
        .fullscreen-mode .hole-cell .score-cell {
            width: 44px;
            height: 44px;
            font-size: 22px;
        }
        
        .fullscreen-mode .hole-cell .net-score {
            font-size: 13px;
            color: #475569;
            margin-top: 4px;
            font-weight: 700;
        }
        
        .fullscreen-mode .nine-section {
            margin-bottom: 16px;
        }
        
        .fullscreen-mode .nine-section-label {
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .fullscreen-mode .totals-row {
            padding: 14px;
            margin-top: 16px;
        }
        
        .fullscreen-mode .total-value {
            font-size: 18px;
        }
        
        .fullscreen-mode .carousel-nav {
            margin: 8px 12px 12px 12px !important;
        }
        
        .totals-row {
            display: flex;
            justify-content: space-around;
            padding: 8px;
            background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
            border-radius: 8px;
            margin-top: 8px;
        }
        
        .totals-row .total-item {
            text-align: center;
            color: white;
        }
        
        .totals-row .total-label {
            font-size: 10px;
            opacity: 0.8;
        }
        
        .totals-row .total-value {
            font-size: 16px;
            font-weight: 700;
        }
        
        /* Scorecard Color Coding */
        .scorecard-col-claimed {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%) !important;
        }
        
        .scorecard-col-watching {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%) !important;
        }
        
        .scorecard-cell-skin {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%) !important;
            font-weight: 700 !important;
            position: relative;
        }
        
        .scorecard-cell-skin::after {
            content: "ð";
            position: absolute;
            right: 4px;
            top: 2px;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <!-- Setup Page -->
    <div id="setupPage" class="page active">
        <div class="header">
            <h1>â³ Let's Golf <span style="font-size: 12px; font-weight: 400; color: #64748b;">by Otis Williams</span></h1>
            <p>Golf Games and Tournaments</p>
        </div>

        <div class="setup-container">
            <!-- Connection Status Indicator -->
            <div id="connectionStatus" style="display: flex; align-items: center; justify-content: center; gap: 8px; padding: 8px 16px; background: rgba(255,255,255,0.15); border-radius: 8px; margin-bottom: 16px;">
                <span id="connectionDot" style="width: 10px; height: 10px; border-radius: 50%; background: #10b981;"></span>
                <span id="connectionText" style="color: white; font-size: 13px; font-weight: 500;">Online - Scores sync across devices</span>
            </div>

            <!-- Resume Round Section (hidden by default) -->
            <div id="resumeRoundSection" class="resume-round-section">
                <div class="resume-round-title">ð Round in Progress</div>
                <div class="resume-round-info" id="resumeRoundInfo">Continue your saved round or start fresh</div>
                <div class="resume-round-buttons">
                    <button type="button" class="resume-btn" onclick="resumeSavedRound()" style="background: #10b981; border-color: #10b981;">Resume</button>
                    <button type="button" class="resume-btn discard-btn" onclick="discardSavedRound()" style="background: #ef4444; border-color: #ef4444;">Delete</button>
                </div>
                <!-- Share buttons (only shown in multi-device mode) -->
                <div id="resumeShareButtons" class="resume-round-buttons" style="display: none; margin-top: 12px; grid-template-columns: 1fr 1fr 1fr;">
                    <button type="button" class="resume-btn" onclick="copyLinkFromResume()" style="background: white !important; color: #10b981; border: 2px solid #10b981; padding: 8px 6px; font-size: 12px;">ð Link</button>
                    <button type="button" class="resume-btn" onclick="showQRFromResume()" style="background: white !important; color: #8b5cf6; border: 2px solid #8b5cf6; padding: 8px 6px; font-size: 12px;">ð± QR</button>
                    <button type="button" class="resume-btn" onclick="saveTournamentFile()" style="background: white !important; color: #f97316; border: 2px solid #f97316; padding: 8px 6px; font-size: 12px;">ð¾ Save</button>
                </div>
            </div>

            <div class="form-group">
                <label>Tournament Date</label>
                <input type="date" id="tournamentDate" placeholder="Select a Date" required>
            </div>

            <div class="form-group">
                <label>Tournament Name <span style="color: #94a3b8; font-weight: 400; font-size: 13px;">(Optional)</span></label>
                <input type="text" id="tournamentName" placeholder="e.g., Saturday Morning Scramble" style="color: #1e293b;">
            </div>

            <div class="form-group">
                <label>Course</label>
                <select id="courseSelect" onchange="updateCourse()">
                    <option value="" selected>Select a Course</option>
                    <option value="green_river">Green River Golf Club</option>
                    <option value="hidden_valley">Hidden Valley Golf Club</option>
                    <option value="indian_hills">Indian Hills Golf Club</option>
                    <option value="jurupa_hills">Jurupa Hills Country Club</option>
                </select>
            </div>

            <div class="form-group">
                <label>Game Type</label>
                <select id="gameType" onchange="handleGameTypeChange()">
                    <option value="" selected>Select a Game Type</option>
                    <option value="Stroke Play Gross">Stroke Play Gross</option>
                    <option value="Stroke Play Net">Stroke Play Net</option>
                    <option value="Gross Skins">Gross Skins</option>
                    <option value="Net Skins (Full Hcp)">Net Skins (Full Hcp)</option>
                    <option value="Net Skins (18 Max)">Net Skins (18 Max)</option>
                    <option value="Net Skins (1/2 Pop)">Net Skins (1/2 Pop)</option>
                    <option value="Stableford">Stableford</option>
                    <option value="Stableford (Modified)">Stableford (Modified)</option>
                    <option value="2-Man Best Ball">2-Man Best Ball</option>
                    <option value="3-Man Best Ball">3-Man Best Ball</option>
                    <option value="4-Man Best Ball">4-Man Best Ball</option>
                </select>
            </div>

            <div id="teamSetupSection" class="form-group" style="display: none;">
                <label>Team Setup</label>
                <div id="teamSetupContent"></div>
            </div>

            <div class="form-group">
                <label>Players & Handicaps</label>
                
                <!-- Quick Add Frequent Players -->
                <div id="quickAddSection" style="margin-bottom: 15px; display: none;">
                    <div style="font-size: 13px; color: #64748b; margin-bottom: 8px; font-weight: 600;">Quick Add:</div>
                    <div id="quickAddButtons" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
                </div>
                
                <div class="player-list" id="playerList">
                    <div class="player-row" data-player="1">
                        <input type="text" class="player-name-input" placeholder="Player Name" id="player1">
                        <input type="text" class="player-hcp-input" placeholder="HCP" id="hcp1" pattern="-?[0-9]*" inputmode="numeric">
                    </div>
                </div>
                
                <!-- Add Player and Load Game Side by Side -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                    <button type="button" class="btn-add-player" onclick="addPlayerRow()" id="addPlayerBtn"><span style="font-size: 20px; font-weight: 600;">+</span> Add Player</button>
                    <button type="button" class="btn-add-player" onclick="document.getElementById('importFile').click()" style="background: white; color: #3b82f6; border-color: #3b82f6;">
                        <span style="font-weight: 900; font-size: 18px;">â</span> Load Game
                    </button>
                </div>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importTournamentBackup(event)">
            </div>

            <button type="button" class="btn btn-primary" id="resumeScoringBtn" style="background: #10b981; display: none;" onclick="resumeScoring()">Resume Scoring</button>
            <button type="button" class="btn btn-primary" onclick="startScoring()">Start Scoring</button>
        </div>
    </div>

    <!-- Scoring Page -->
    <div id="scoringPage" class="page">
        <!-- Round in Progress Indicator -->
        <div id="roundIndicator" class="round-indicator">
            <span class="round-indicator-icon"></span>
            <span>Round in Progress â¢ Auto-saved</span>
        </div>
        
        <!-- Voice Listening Overlay -->
        <div id="voiceListening" class="voice-listening">
            <div class="mic-icon">ð¤</div>
            <div class="voice-text">Listening...</div>
            <div class="voice-result" id="voiceResult"></div>
        </div>
        
        <!-- Expanded Score Input Modal -->
        <div id="expandedScoreModal" class="expanded-score-modal">
            <div class="expanded-score-content">
                <div class="expanded-hole-header">
                    <div class="expanded-hole-number" id="expandedHoleNumber">HOLE 1</div>
                    <div class="expanded-hole-info" id="expandedHoleInfo">Par 4 â¢ HCP 5</div>
                </div>
                <div class="expanded-player-name" id="expandedPlayerName">Player Name</div>
                <div class="expanded-score-display">
                    <button class="expanded-score-btn minus" onclick="expandedDecrement()">â</button>
                    <div class="expanded-score-value" id="expandedScoreValue">-</div>
                    <button class="expanded-score-btn plus" onclick="expandedIncrement()">+</button>
                </div>
                <div class="expanded-quick-scores" id="expandedQuickScores">
                    <!-- Quick score buttons populated dynamically -->
                </div>
                <div class="expanded-actions">
                    <button onclick="closeExpandedScore()" style="background: #e2e8f0; color: #475569; border: none;">Cancel</button>
                    <button onclick="saveExpandedScore()" style="background: #10b981; color: white; border: none;">Save</button>
                </div>
            </div>
        </div>
        
        <div class="scoring-header">
            <!-- Row 1: Title with Connection Dot -->
            <div style="text-align: center; display: flex; align-items: center; justify-content: center; gap: 8px;">
                <h2 style="color: #1e40af; font-size: 18px; margin: 0;">â³ Let's Golf <span style="font-size: 10px; font-weight: 400; color: #64748b;">by Otis Williams</span></h2>
                <span id="scoringConnectionDot" title="Connection status" style="width: 12px; height: 12px; border-radius: 50%; background: #10b981; flex-shrink: 0;"></span>
            </div>
            
            <!-- Row 2: Smart Info Line -->
            <div style="text-align: center;">
                <p id="scoringSmartInfo" style="font-size: 12px; color: #1e40af; font-weight: 600; margin: 0;"></p>
            </div>
            
            <!-- Row 3: Navigation Buttons - Rectangular, evenly spaced -->
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px; padding: 0 4px;">
                <button type="button" onclick="openScorecardModal()" style="flex: 1; height: 40px; border-radius: 10px; border: 2px solid #3b82f6; background: white; color: #3b82f6; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 4px;" title="Scorecard">ð</button>
                <button type="button" id="finishRoundBtn" onclick="showPage('resultsPage')" style="flex: 1; height: 40px; border-radius: 10px; border: none; background: #3b82f6; color: white; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 4px;" title="Results">ð</button>
                <button type="button" onclick="confirmBackToHome()" style="flex: 1; height: 40px; border-radius: 10px; border: none; background: #64748b; color: white; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 4px;" title="Home">ð </button>
                <button type="button" id="managePlayersBtn" onclick="showPlayerManagement()" style="display: none; flex: 1; height: 40px; border-radius: 10px; border: none; background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #78350f; font-size: 16px; cursor: pointer; align-items: center; justify-content: center; gap: 4px;" title="Manage Tournament">âï¸</button>
                <button type="button" id="myPlayersBtnHeader" onclick="showMyPlayersPage()" style="display: none; flex: 1; height: 40px; border-radius: 10px; border: none; background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #78350f; font-size: 16px; cursor: pointer; align-items: center; justify-content: center; gap: 4px;" title="My Players">ð¤</button>
            </div>
            
            <!-- Row 4: Toggle Buttons - Paired -->
            <div style="display: flex; justify-content: center; gap: 12px;">
                <div class="btn-toggle-group" style="display: flex; background: #e2e8f0; border-radius: 10px; padding: 3px;">
                    <button type="button" id="toggleHoleView" class="toggle-btn active" onclick="switchToHoleView()" style="padding: 6px 14px; font-size: 12px; font-weight: 600; border-radius: 8px; border: none; background: #3b82f6; color: white; cursor: pointer;">â³ Holes</button>
                    <button type="button" id="togglePlayerView" class="toggle-btn" onclick="switchToPlayerView()" style="padding: 6px 14px; font-size: 12px; font-weight: 600; border-radius: 8px; border: none; background: transparent; color: #64748b; cursor: pointer;">ð¤ Players</button>
                </div>
                <div class="btn-toggle-group" style="display: flex; background: #e2e8f0; border-radius: 10px; padding: 3px;">
                    <button type="button" class="toggle-btn active" id="keyboardModeBtn" onclick="setInputMode('keyboard')" style="padding: 6px 14px; font-size: 12px; font-weight: 600; border-radius: 8px; border: none; background: #3b82f6; color: white; cursor: pointer;">ð Touch</button>
                    <button type="button" class="toggle-btn" id="voiceModeBtn" onclick="setInputMode('voice')" style="padding: 6px 14px; font-size: 12px; font-weight: 600; border-radius: 8px; border: none; background: transparent; color: #64748b; cursor: pointer;">ð¤ Voice</button>
                </div>
            </div>
        </div>

        <div class="scoring-content">

            <div id="playerCards"></div>
            
            <!-- By Hole View (hidden by default) -->
            <div id="holeView" style="display: none;">
                <div id="holeViewContent"></div>
            </div>
        </div>
    </div>

    <!-- Results Page -->
    <div id="resultsPage" class="page">
        <div class="results-sticky-header">
            <div class="results-page-header">
                <!-- Row 1: Title with Connection Dot -->
                <div style="text-align: center; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <h2 style="color: #1e40af; font-size: 18px; margin: 0;">ð Let's Golf <span style="font-size: 10px; font-weight: 400; color: #64748b;">by Otis Williams</span></h2>
                    <span id="resultsConnectionDot" title="Connection status" style="width: 12px; height: 12px; border-radius: 50%; background: #10b981; flex-shrink: 0;"></span>
                </div>
                
                <!-- Row 2: Smart Info Line -->
                <div style="text-align: center;">
                    <p id="resultsSmartInfo" style="font-size: 12px; color: #1e40af; font-weight: 600; margin: 0;"></p>
                </div>
                
                <!-- Row 3: Button Row - Rectangular, evenly spaced -->
                <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px; padding: 0 4px;">
                    <button type="button" id="resultsScorecardBtn" onclick="openScorecardModal()" style="flex: 1; height: 40px; border-radius: 10px; border: 2px solid #3b82f6; background: white; color: #3b82f6; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="View Scorecards">ð</button>
                    <button type="button" onclick="showPage('scoringPage')" style="flex: 1; height: 40px; border-radius: 10px; border: none; background: #3b82f6; color: white; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Scoring">â³</button>
                    <button type="button" onclick="confirmBackToHome()" style="flex: 1; height: 40px; border-radius: 10px; border: none; background: #64748b; color: white; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Home">ð </button>
                    <button type="button" id="resultsManageBtn" onclick="showPlayerManagement()" style="display: none; flex: 1; height: 40px; border-radius: 10px; border: none; background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #78350f; font-size: 16px; cursor: pointer; align-items: center; justify-content: center;" title="Manage Tournament">âï¸</button>
                    <button type="button" id="resultsMyPlayersBtn" onclick="showMyPlayersPage()" style="display: none; flex: 1; height: 40px; border-radius: 10px; border: none; background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #78350f; font-size: 16px; cursor: pointer; align-items: center; justify-content: center;" title="My Players">ð¤</button>
                    <button type="button" id="newRoundBtnTop" data-action="confirmNewRound" style="flex: 1; height: 40px; border-radius: 10px; border: none; background: #ef4444; color: white; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Finish Round">ð</button>
                </div>
            </div>
        </div>

        <div class="results-container">
            <!-- Settings Card -->
            <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 12px; padding: 12px; margin-bottom: 16px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-size: 13px; font-weight: 600; color: #374151; white-space: nowrap;">View Results As:</label>
                    <select id="resultsGameType" onchange="updateResultsGameType()" style="flex: 1; padding: 8px 10px; border: 1.5px solid #d1d5db; border-radius: 8px; font-size: 13px; background: white;">
                        <option value="Stroke Play Gross">Stroke Play Gross</option>
                        <option value="Stroke Play Net">Stroke Play Net</option>
                        <option value="Gross Skins">Gross Skins</option>
                        <option value="Net Skins (Full Hcp)">Net Skins (Full Hcp)</option>
                        <option value="Net Skins (18 Max)">Net Skins (18 Max)</option>
                        <option value="Net Skins (1/2 Pop)">Net Skins (1/2 Pop)</option>
                        <option value="Stableford">Stableford</option>
                        <option value="Stableford (Modified)">Stableford (Modified)</option>
                        <option value="2-Man Best Ball">2-Man Best Ball</option>
                        <option value="3-Man Best Ball">3-Man Best Ball</option>
                        <option value="4-Man Best Ball">4-Man Best Ball</option>
                    </select>
                    <div id="resultsFilterToggle" style="display: flex; flex-direction: column; background: #e2e8f0; border-radius: 12px; padding: 3px; gap: 2px;">
                        <button id="resultsToggleMine" onclick="setResultsFilter('mine')" 
                            style="padding: 5px 12px; border: none; border-radius: 9px; background: transparent; color: #64748b; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s;" title="My Players">
                            ð¤
                        </button>
                        <button id="resultsToggleAll" onclick="setResultsFilter('all')" 
                            style="padding: 5px 12px; border: none; border-radius: 9px; background: #3b82f6; color: white; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s;" title="All Players">
                            ð¥
                        </button>
                    </div>
                </div>
                <!-- Live Update Indicator -->
                <div id="liveUpdateIndicator" style="display: flex; align-items: center; justify-content: center; gap: 6px; margin-top: 8px; padding-top: 8px; border-top: 1px solid #e2e8f0;">
                    <span style="width: 6px; height: 6px; border-radius: 50%; background: #10b981; animation: pulse 2s infinite;"></span>
                    <span style="font-size: 11px; color: #64748b;">Live â¢ Updated just now</span>
                </div>
            </div>
            
            <!-- Leaderboard Card -->
            <div style="background: linear-gradient(135deg, #fefce8 0%, #fef9c3 100%); border: 2px solid #fbbf24; border-radius: 16px; padding: 0; overflow: hidden; box-shadow: 0 4px 12px rgba(251, 191, 36, 0.2);">
                <!-- Trophy Header -->
                <div style="background: linear-gradient(135deg, #fbbf24, #f59e0b); padding: 12px 16px; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <span style="font-size: 24px;">ð</span>
                    <span style="font-size: 16px; font-weight: 700; color: #78350f; text-transform: uppercase; letter-spacing: 1px;">Leaderboard</span>
                    <span style="font-size: 24px;">ð</span>
                </div>
                
                <!-- Results Content -->
                <div id="resultsContent" style="padding: 16px; background: white;">
                    <!-- Generated dynamically -->
                </div>
            </div>
            
        </div>
    </div>

    <!-- Scorecard Modal -->
    <div id="scorecardModal" class="scorecard-modal">
        <div class="scorecard-content">
            <div class="scorecard-header">
                <h2 style="color: #1e40af; margin: 0;">ð Scorecards</h2>
                <button onclick="closeScorecardModal()" style="background: #ef4444; color: white; border: none; border-radius: 8px; padding: 8px 16px; font-weight: 600; cursor: pointer;">â Close</button>
            </div>
            <div style="padding: 20px; border-bottom: 1px solid #e2e8f0;">
                <label style="font-weight: 600; color: #1e40af; margin-bottom: 8px; display: block;">Select View:</label>
                <select id="scorecardViewSelect" onchange="updateScorecardView()" style="width: 100%; padding: 12px; border: 2px solid #cbd5e1; border-radius: 8px; font-size: 16px;">
                    <option value="all-summary">All Players - Summary Table</option>
                    <option value="all-individual">All Players - Individual Cards</option>
                    <option disabled>âââââââââââââââââ</option>
                </select>
            </div>
            <div class="scorecard-body" id="scorecardBody">
                <!-- Scorecard content will be populated here -->
            </div>
            <div class="scorecard-footer">
                <button onclick="printScorecard()" class="btn btn-primary" style="background: #10b981; margin: 0;">ð¤ Share / Print</button>
            </div>
        </div>
    </div>

    <!-- Printable Scorecard (Hidden, only shows when printing) -->
    <div id="printableScorecard" class="print-scorecard"></div>

    <!-- Auto-save Toast -->
    <div id="autoSaveToast" class="auto-save-toast">â Saved</div>

    <!-- Join Tournament Page -->
    <div id="joinPage" class="page">
        <div class="card">
            <div class="tournament-info-centered">
                <p style="font-size: 32px;">â³</p>
                <h2>Join Tournament</h2>
                <p id="joinTournamentInfo" style="margin-top: 8px;">Loading...</p>
            </div>

            <!-- Quick Add Section - Players to Claim or Watch -->
            <div id="joinExistingPlayers" style="margin-top: 24px; display: none;">
                <h3 style="color: #1e40af; font-size: 18px; margin-bottom: 8px; text-align: center;">Select Players</h3>
                <p style="color: #64748b; font-size: 13px; margin-bottom: 16px; text-align: center;">Tap to claim (you'll score) or watch (view only)</p>
                <div id="existingPlayersList"></div>
                
                <!-- Selection Summary -->
                <div id="selectionSummary" style="display: none; margin-top: 16px; padding: 12px; background: #f0fdf4; border: 2px solid #10b981; border-radius: 10px;">
                    <div style="font-size: 13px; color: #065f46;">
                        <span id="claimCount">0</span> to score â¢ <span id="watchCount">0</span> watching
                    </div>
                </div>
            </div>

            <!-- Divider -->
            <div id="joinDivider" style="display: none; margin: 24px 0; text-align: center; position: relative;">
                <div style="position: absolute; top: 50%; left: 0; right: 0; height: 1px; background: linear-gradient(90deg, transparent, #cbd5e1, transparent);"></div>
                <span style="position: relative; background: white; padding: 0 16px; color: #94a3b8; font-size: 13px; font-weight: 600;">OR</span>
            </div>

            <!-- Bottom Options -->
            <div id="joinBottomOptions" style="display: none;">
                <!-- Viewer Option -->
                <button type="button" id="viewerJoinBtn" onclick="joinAsViewer()"
                    style="width: 100%; padding: 16px 20px; margin-bottom: 12px; background: #f1f5f9; border: 2px solid #94a3b8; border-radius: 12px; color: #475569; font-size: 16px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 12px;">
                    <span style="font-size: 24px;">ð</span>
                    <span>Join as Viewer Only</span>
                </button>
                
                <!-- Add New Player (for players not in list) -->
                <button type="button" onclick="showAddNewPlayerForm()"
                    style="width: 100%; padding: 16px 20px; background: #fef3c7; border: 2px solid #f59e0b; border-radius: 12px; color: #92400e; font-size: 16px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 12px;">
                    <span style="font-size: 24px;">â</span>
                    <span>I'm Not Listed - Add Me</span>
                </button>
            </div>

            <!-- Join Tournament Button (appears when selections made) -->
            <div id="joinTournamentBtnContainer" style="display: none; margin-top: 20px;">
                <button type="button" onclick="executeJoinTournament()" 
                    style="width: 100%; padding: 16px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 12px; font-size: 18px; font-weight: 700; cursor: pointer; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);">
                    ðï¸ Join Tournament
                </button>
            </div>

            <!-- Cancel Button -->
            <div style="margin-top: 16px;">
                <button type="button" onclick="showPage('setupPage')" style="width: 100%; padding: 12px; background: transparent; color: #64748b; border: none; font-size: 14px; cursor: pointer;">
                    Cancel
                </button>
            </div>
            
            <!-- Hidden form for adding new player -->
            <form id="joinTournamentForm" style="display: none; margin-top: 24px;">
                <h3 style="color: #1e40af; font-size: 18px; margin-bottom: 16px; text-align: center;">Add New Player</h3>
                
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 12px; margin-bottom: 16px;">
                    <div>
                        <label style="display: block; margin-bottom: 8px; color: #475569; font-weight: 600; font-size: 14px;">Your Name</label>
                        <input type="text" id="joinPlayerName" placeholder="Enter your name" required style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 8px; color: #475569; font-weight: 600; font-size: 14px;">Handicap</label>
                        <input type="number" id="joinPlayerHandicap" min="-10" max="54" step="1" placeholder="0" required style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; text-align: center;">
                    </div>
                </div>
                
                <input type="hidden" id="joinPlayerEmail" value="">
                <input type="hidden" id="joinPlayerPhone" value="">

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 16px;">
                    <button type="button" onclick="hideAddNewPlayerForm()" style="padding: 14px; background: #f1f5f9; color: #475569; border: 2px solid #cbd5e1; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer;">
                        Back
                    </button>
                    <button type="submit" style="padding: 14px; background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer;">
                        Add & Join
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Handicap Confirmation Dialog -->
    <div id="handicapConfirmDialog" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; border-radius: 16px; padding: 24px; margin: 20px; max-width: 400px; box-shadow: 0 8px 16px rgba(0,0,0,0.3);">
            <h3 style="color: #1e40af; margin-bottom: 12px; font-size: 20px;">Claim Player</h3>
            <p id="handicapConfirmPlayerName" style="color: #64748b; margin-bottom: 16px; font-size: 16px;"></p>
            
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; color: #475569; font-weight: 600; font-size: 14px;">Your Initials</label>
                <input type="text" id="initialsInput" maxlength="3" placeholder="ABC" style="width: 100%; padding: 12px; border: 2px solid #3b82f6; border-radius: 8px; font-size: 18px; text-align: center; font-weight: 600; text-transform: uppercase;">
                <p style="font-size: 12px; color: #64748b; margin-top: 4px;">So the host knows who's scoring</p>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: #475569; font-weight: 600; font-size: 14px;">Course Handicap for This Round</label>
                <input type="number" id="handicapConfirmInput" min="0" max="54" step="1" placeholder="0" style="width: 100%; padding: 12px; border: 2px solid #3b82f6; border-radius: 8px; font-size: 18px; text-align: center; font-weight: 600;">
            </div>
            
            <div style="display: flex; gap: 12px;">
                <button type="button" id="handicapConfirmCancel" style="flex: 1; padding: 12px; background: #e2e8f0; color: #475569; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">Cancel</button>
                <button type="button" id="handicapConfirmOk" style="flex: 1; padding: 12px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">Claim & Score</button>
            </div>
        </div>
    </div>

    <!-- Claim Players List Modal -->
    <div id="claimPlayersModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center; overflow-y: auto;">
        <div style="background: white; border-radius: 16px; padding: 24px; margin: 20px; max-width: 500px; max-height: 80vh; overflow-y: auto; box-shadow: 0 8px 16px rgba(0,0,0,0.3);">
            <h3 style="color: #1e40af; margin-bottom: 16px; font-size: 20px;">Claim Additional Player</h3>
            <p style="color: #64748b; margin-bottom: 20px; font-size: 14px;">Select an unclaimed player to score for them</p>
            
            <div id="claimPlayersListContent">
                <!-- Player list will be populated here -->
            </div>
            
            <button type="button" onclick="document.getElementById('claimPlayersModal').style.display='none'" style="width: 100%; padding: 12px; background: #e2e8f0; color: #475569; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 16px;">
                Cancel
            </button>
        </div>
    </div>

    <!-- Manage Tournament Page (for host) -->
    <div id="playerManagementPage" class="page">
        <div class="card" style="padding: 16px;">
            <!-- Header with Title and Connection Status -->
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px;">
                <h2 style="color: #1e40af; font-size: 18px; margin: 0;">âï¸ Manage Tournament</h2>
                <div id="managementConnectionStatus" style="display: flex; align-items: center; gap: 4px; padding: 4px 10px; background: #f0fdf4; border: 1px solid #10b981; border-radius: 12px;">
                    <span style="width: 8px; height: 8px; border-radius: 50%; background: #10b981;"></span>
                    <span style="color: #059669; font-size: 11px; font-weight: 500;">Connected</span>
                </div>
            </div>
            
            <!-- Navigation + Share Row - Enlarged, evenly spaced -->
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px; padding: 8px; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; margin-bottom: 12px;">
                <button type="button" onclick="confirmBackToHome()" style="flex: 1; height: 44px; border-radius: 8px; border: none; background: #64748b; color: white; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Home">ð </button>
                <button type="button" onclick="copyActiveTournamentLink()" style="flex: 1; height: 44px; border-radius: 8px; border: 2px solid #3b82f6; background: white; color: #3b82f6; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Copy Link">ð</button>
                <button type="button" onclick="showQRCodeForActiveTournament()" style="flex: 1; height: 44px; border-radius: 8px; border: 2px solid #8b5cf6; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 6px;" title="Show QR">
                    <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="#8b5cf6" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7" rx="1"/>
                        <rect x="14" y="3" width="7" height="7" rx="1"/>
                        <rect x="3" y="14" width="7" height="7" rx="1"/>
                        <rect x="14" y="14" width="3" height="3"/>
                        <rect x="18" y="14" width="3" height="3"/>
                        <rect x="14" y="18" width="3" height="3"/>
                        <rect x="18" y="18" width="3" height="3"/>
                        <path d="M1 4V1h3M20 1h3v3M1 20v3h3M20 24h3v-3" stroke="#8b5cf6" stroke-width="2.5" stroke-linecap="round"/>
                    </svg>
                </button>
                <button type="button" onclick="saveTournamentFile()" style="flex: 1; height: 44px; border-radius: 8px; border: 2px solid #f97316; background: white; color: #f97316; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Save File">ð¾</button>
                <button type="button" onclick="showPage('scoringPage')" style="flex: 1; height: 44px; border-radius: 8px; border: none; background: #3b82f6; color: white; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Scoring">â³</button>
                <button type="button" onclick="showPage('resultsPage')" style="flex: 1; height: 44px; border-radius: 8px; border: none; background: #3b82f6; color: white; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Results">ð</button>
            </div>
            
            <!-- SECTION 1: Co-hosts (Host only) -->
            <div id="coHostsSection" style="background: #faf5ff; border: 1px solid #c4b5fd; border-radius: 10px; padding: 10px; margin-bottom: 10px; display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <h3 style="color: #7c3aed; font-size: 12px; margin: 0;">ð Co-hosts</h3>
                    <span style="font-size: 10px; color: #8b5cf6;">Can manage tournament</span>
                </div>
                <div id="coHostsContent">
                    <!-- Co-hosts list generated dynamically -->
                </div>
            </div>
            
            <!-- SECTION 2: Players -->
            <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; padding: 10px; margin-bottom: 10px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <h3 style="color: #1e40af; font-size: 12px; margin: 0;">ð¥ Players</h3>
                    <button type="button" onclick="showAddPlayerForm()" style="padding: 4px 8px; background: #3b82f6; color: white; border: none; border-radius: 5px; font-size: 11px; font-weight: 600; cursor: pointer;">+ Add</button>
                </div>
                
                <!-- Add Player Form (hidden by default) -->
                <div id="addPlayerForm" style="display: none; background: #eff6ff; border: 1.5px solid #3b82f6; border-radius: 8px; padding: 10px; margin-bottom: 8px;">
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        <input type="text" id="newPlayerName" placeholder="Name" style="flex: 2; min-width: 80px; padding: 8px; border: 1.5px solid #cbd5e1; border-radius: 6px; font-size: 13px;">
                        <input type="number" id="newPlayerHandicap" placeholder="HCP" style="flex: 1; min-width: 45px; max-width: 60px; padding: 8px; border: 1.5px solid #cbd5e1; border-radius: 6px; font-size: 13px;" value="0">
                        <button type="button" onclick="addNewPlayerFromManagement()" style="padding: 8px 12px; background: #10b981; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">Add</button>
                        <button type="button" onclick="hideAddPlayerForm()" style="padding: 8px 10px; background: #e2e8f0; color: #64748b; border: none; border-radius: 6px; font-size: 13px; cursor: pointer;">â</button>
                    </div>
                </div>

                <div id="playerManagementContent">
                    <!-- Player list will be generated here -->
                </div>
            </div>
            
            <!-- SECTION 3: Clear Scores (RED theme) -->
            <div style="background: #fef2f2; border: 1.5px solid #fca5a5; border-radius: 10px; padding: 10px; margin-bottom: 10px;">
                <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 6px;">
                    <h3 style="color: #dc2626; font-size: 12px; margin: 0;">ð Clear Scores</h3>
                    <div style="display: flex; gap: 4px;">
                        <button type="button" onclick="clearAllScores()" style="padding: 5px 8px; background: #dc2626; color: white; border: none; border-radius: 5px; font-size: 10px; font-weight: 600; cursor: pointer;">All 18</button>
                        <button type="button" onclick="clearFront9Scores()" style="padding: 5px 8px; background: white; color: #dc2626; border: 1.5px solid #dc2626; border-radius: 5px; font-size: 10px; font-weight: 600; cursor: pointer;">Front 9</button>
                        <button type="button" onclick="clearBack9Scores()" style="padding: 5px 8px; background: white; color: #dc2626; border: 1.5px solid #dc2626; border-radius: 5px; font-size: 10px; font-weight: 600; cursor: pointer;">Back 9</button>
                    </div>
                </div>
            </div>
            
            <!-- SECTION 4: Tournament Details -->
            <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; padding: 10px;">
                <h3 style="color: #1e40af; font-size: 12px; margin: 0 0 8px 0;">ð Tournament Details</h3>
                
                <input type="text" id="manageTournamentName" placeholder="Tournament Name" style="width: 100%; padding: 8px; border: 1.5px solid #e2e8f0; border-radius: 6px; font-size: 13px; box-sizing: border-box; margin-bottom: 8px;">
                
                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <input type="date" id="manageTournamentDate" style="flex: 1; padding: 8px; border: 1.5px solid #e2e8f0; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
                    <select id="manageTournamentCourse" style="flex: 1; padding: 8px; border: 1.5px solid #e2e8f0; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
                        <!-- Options populated dynamically -->
                    </select>
                </div>
                
                <div style="display: flex; gap: 8px;">
                    <button type="button" onclick="saveTournamentDetails()" style="flex: 1; padding: 10px; background: #3b82f6; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">
                        ð¾ Save
                    </button>
                    <button type="button" onclick="confirmDeleteTournament()" style="flex: 1; padding: 10px; background: #dc2626; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">
                        ðï¸ Delete
                    </button>
                </div>
            </div>
        </div>
    </div>


    <!-- My Players Page (Non-Host) -->
    <div id="myPlayersPage" class="page">
        <div class="card" style="padding: 16px;">
            <!-- Header with Title and Connection Status -->
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px;">
                <h2 style="color: #1e40af; font-size: 18px; margin: 0;">ð¤ My Players</h2>
                <div id="myPlayersConnectionStatus" style="display: flex; align-items: center; gap: 4px; padding: 4px 10px; background: #f0fdf4; border: 1px solid #10b981; border-radius: 12px;">
                    <span style="width: 8px; height: 8px; border-radius: 50%; background: #10b981;"></span>
                    <span style="color: #059669; font-size: 11px; font-weight: 500;">Connected</span>
                </div>
            </div>
            
            <!-- Navigation Row -->
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px; padding: 8px; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; margin-bottom: 12px;">
                <button type="button" onclick="showGuestHomePage()" style="flex: 1; height: 44px; border-radius: 8px; border: none; background: #64748b; color: white; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Home">ð </button>
                <button type="button" onclick="copyActiveTournamentLink()" style="flex: 1; height: 44px; border-radius: 8px; border: 2px solid #3b82f6; background: white; color: #3b82f6; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Copy Link">ð</button>
                <button type="button" onclick="showQRCodeForActiveTournament()" style="flex: 1; height: 44px; border-radius: 8px; border: 2px solid #8b5cf6; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 6px;" title="Show QR">
                    <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="#8b5cf6" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7" rx="1"/>
                        <rect x="14" y="3" width="7" height="7" rx="1"/>
                        <rect x="3" y="14" width="7" height="7" rx="1"/>
                        <rect x="14" y="14" width="3" height="3"/>
                        <rect x="18" y="14" width="3" height="3"/>
                        <rect x="14" y="18" width="3" height="3"/>
                        <rect x="18" y="18" width="3" height="3"/>
                        <path d="M1 4V1h3M20 1h3v3M1 20v3h3M20 24h3v-3" stroke="#8b5cf6" stroke-width="2.5" stroke-linecap="round"/>
                    </svg>
                </button>
                <button type="button" onclick="showPage('scoringPage')" style="flex: 1; height: 44px; border-radius: 8px; border: none; background: #3b82f6; color: white; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Scoring">â³</button>
                <button type="button" onclick="showPage('resultsPage')" style="flex: 1; height: 44px; border-radius: 8px; border: none; background: #3b82f6; color: white; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Results">ð</button>
            </div>
            
            <!-- My Players Content -->
            <div id="myPlayersPageContent">
                <!-- Dynamic content here -->
            </div>
        </div>
    </div>

    <!-- Guest Home Page (Non-Host) -->
    <div id="guestHomePage" class="page">
        <div class="card" style="padding: 24px; text-align: center;">
            <!-- Logo -->
            <div style="margin-bottom: 20px;">
                <span style="font-size: 48px;">â³</span>
                <h1 style="color: #1e40af; font-size: 24px; margin: 8px 0 4px 0;">Let's Golf</h1>
                <p style="color: #64748b; font-size: 12px; margin: 0;">by Otis Williams</p>
            </div>
            
            <!-- Current Tournament Card -->
            <div id="guestCurrentTournament" style="background: #f0fdf4; border: 2px solid #10b981; border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 8px;">
                    <span style="font-size: 20px;">ð</span>
                    <span style="font-weight: 700; color: #059669; font-size: 14px;">Current Tournament</span>
                </div>
                <h3 id="guestTournamentName" style="color: #1e40af; font-size: 16px; margin: 0 0 4px 0;">Loading...</h3>
                <p id="guestTournamentInfo" style="color: #64748b; font-size: 12px; margin: 0 0 16px 0;"></p>
                
                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <button type="button" onclick="showPage('scoringPage')" style="width: 100%; padding: 14px; background: #10b981; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                        â¶ï¸ Resume Scoring
                    </button>
                    <button type="button" onclick="showPage('resultsPage')" style="width: 100%; padding: 14px; background: #3b82f6; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                        ð View Results
                    </button>
                    <button type="button" onclick="confirmLeaveTournament()" style="width: 100%; padding: 14px; background: white; color: #ef4444; border: 2px solid #ef4444; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                        ðª Leave Tournament
                    </button>
                </div>
            </div>
            
            <!-- Join Different Tournament Card -->
            <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 12px; padding: 16px;">
                <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 12px;">
                    <span style="font-size: 20px;">ð</span>
                    <span style="font-weight: 700; color: #64748b; font-size: 14px;">Join Different Tournament</span>
                </div>
                <p style="color: #94a3b8; font-size: 12px; margin: 0 0 12px 0;">Enter tournament code or scan QR</p>
                
                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <input type="text" id="guestJoinCode" placeholder="Enter code..." style="flex: 1; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px;" disabled>
                    <button type="button" style="padding: 12px 20px; background: #e2e8f0; color: #94a3b8; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: not-allowed;">
                        Join
                    </button>
                </div>
                <p style="color: #94a3b8; font-size: 11px; font-style: italic; margin: 0;">Coming Soon</p>
            </div>
        </div>
    </div>

    <!-- Live Leaderboard Page (for spectators) -->
    <div id="liveLeaderboardPage" class="page">
        <div class="card">
            <div class="tournament-info-centered">
                <p style="font-size: 32px;">ð</p>
                <h2>Live Leaderboard</h2>
                <p id="liveLeaderboardInfo"></p>
            </div>

            <!-- Game Toggle Tabs -->
            <div id="gameToggleTabs" style="display: flex; gap: 4px; margin: 20px 0; overflow-x: auto; -webkit-overflow-scrolling: touch; flex-wrap: nowrap;">
                <!-- Tabs will be generated dynamically -->
            </div>

            <div id="liveLeaderboardContent" style="margin-top: 16px;">
                <!-- Leaderboard will be generated here -->
            </div>

            <div style="margin-top: 20px; padding: 16px; background: rgba(255,255,255,0.1); border-radius: 12px; text-align: center;">
                <p style="color: #64748b; font-size: 14px; margin-bottom: 8px;">
                    <span id="lastUpdateTime">Just now</span> â¢ <span id="activePlayersCount">0</span> players
                </p>
                <label style="display: flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="autoRefreshToggle" checked style="width: 20px; height: 20px;">
                    <span style="color: white; font-size: 14px;">Auto-refresh</span>
                </label>
            </div>

            <button type="button" id="leaderboardActionBtn" class="btn-primary" onclick="handleLeaderboardAction()" style="width: 100%; margin-top: 16px; padding: 16px; font-size: 16px; font-weight: 700; background: linear-gradient(135deg, #10b981, #059669); border: none; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);">
                Start Scoring â³
            </button>
        </div>
    </div>

    <!-- Host Dashboard Page -->
    <div id="hostDashboardPage" class="page">
        <div class="card">
            <div class="tournament-info-centered">
                <p style="font-size: 32px;">ð®</p>
                <h2>Tournament Admin</h2>
                <p id="hostDashboardInfo"></p>
            </div>

            <div style="margin-top: 24px;">
                <h3 style="color: #1e40af; margin-bottom: 12px; font-size: 18px;">Players & Devices</h3>
                <div id="playerDeviceList">
                    <!-- Will be populated dynamically -->
                </div>
            </div>

            <div style="margin-top: 24px;">
                <h3 style="color: #1e40af; margin-bottom: 12px; font-size: 18px;">Tournament Controls</h3>
                <button type="button" class="btn-secondary" onclick="addPlayerManually()" style="width: 100%; margin-bottom: 8px;">
                    â Add Player Manually
                </button>
                <button type="button" class="btn-secondary" onclick="lockTournament(activeTournamentId)" style="width: 100%; margin-bottom: 8px;">
                    ð Lock Tournament (No More Joins)
                </button>
                <button type="button" class="btn-primary" onclick="endTournament(activeTournamentId)" style="width: 100%; margin-bottom: 8px; background: #ef4444;">
                    ð End Tournament
                </button>
            </div>

            <button type="button" class="btn-secondary" onclick="showPage('scoringPage')" style="width: 100%; margin-top: 16px;">
                Back to Scoring
            </button>
        </div>
    </div>

    <!-- Custom Confirmation Dialog (iOS-friendly) -->
    <div id="confirmDialog" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; border-radius: 16px; padding: 24px; margin: 20px; max-width: 400px; box-shadow: 0 8px 16px rgba(0,0,0,0.3);">
            <h3 id="confirmTitle" style="color: #1e40af; margin-bottom: 12px; font-size: 20px;">Confirm Action</h3>
            <p id="confirmMessage" style="color: #64748b; margin-bottom: 24px; font-size: 16px; line-height: 1.5;"></p>
            <div style="display: flex; gap: 12px;">
                <button type="button" id="confirmCancel" style="flex: 1; padding: 12px; background: #e2e8f0; color: #475569; border: none; border-radius: 8px; font-size: 16px; font-weight: 600;">Cancel</button>
                <button type="button" id="confirmOk" style="flex: 1; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600;">Confirm</button>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // FIREBASE CONFIGURATION & INITIALIZATION
        // ========================================
        
        // Wait for Firebase scripts to load
        function initializeFirebase() {
            if (typeof firebase === 'undefined') {
                console.error('â ï¸ Firebase scripts not loaded! Retrying...');
                setTimeout(initializeFirebase, 500);
                return;
            }
            
            console.log('â Firebase scripts loaded successfully!');
            
            const firebaseConfig = {
                apiKey: "AIzaSyDXgnAjWT0Csd0gu9D6JUbghz149hLhb90",
                authDomain: "u-lik-golf.firebaseapp.com",
                projectId: "u-lik-golf",
                storageBucket: "u-lik-golf.firebasestorage.app",
                messagingSenderId: "637984857306",
                appId: "1:637984857306:web:7d7ff315a360c3544b59e3"
            };

            // Initialize Firebase
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
            auth = firebase.auth();
            firebaseReady = true; // Mark Firebase as ready
            
            console.log('â Firebase initialized!');
            console.log('   firebaseReady:', firebaseReady);
            
            // Enable offline persistence
            db.enablePersistence({synchronizeTabs: true})
                .catch((err) => {
                    if (err.code == 'failed-precondition') {
                        console.warn('Multiple tabs open, persistence only in one tab');
                    } else if (err.code == 'unimplemented') {
                        console.warn('Browser doesn\'t support persistence');
                    }
                });

            // Skip Firebase Auth - use direct Firestore with local IDs instead
            // This avoids the auth/configuration-not-found error on iOS
            console.log('ð Setting up device authentication (no Firebase Auth required)...');
            
            // Generate persistent user ID (stored in localStorage)
            if (!localStorage.getItem('persistentUserId')) {
                localStorage.setItem('persistentUserId', 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
            }
            currentUserId = localStorage.getItem('persistentUserId');
            
            // Generate persistent device ID (stored in localStorage)
            if (!localStorage.getItem('deviceId')) {
                localStorage.setItem('deviceId', 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
            }
            currentDeviceId = localStorage.getItem('deviceId');
            
            authCompleted = true;
            console.log('â Device authenticated successfully (no Firebase Auth needed)!');
            console.log('   User ID:', currentUserId);
            console.log('   Device ID:', currentDeviceId);
        }
        
        // Start initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeFirebase);
        } else {
            initializeFirebase();
        }

        // Global Firebase state
        let db = null;
        let auth = null;
        let currentUserId = null;
        let currentDeviceId = null;
        
        // Player order storage (per device)
        let playerOrder = {
            claimed: [],   // Player names in custom order
            watching: []   // Watched player names in custom order
        };
        
        // Results filter
        let currentResultsFilter = 'all'; // 'all' or 'mine'
        let unsubscribeFunctions = [];
        let authCompleted = false;
        let firebaseReady = false; // Track if Firebase is loaded and initialized

        // CRITICAL FALLBACK: Set timer immediately on page load
        // This creates persistent IDs if Firebase init fails
        console.log('â° Starting 3-second fallback timer...');
        setTimeout(() => {
            if (!authCompleted && !currentUserId) {
                console.warn('â±ï¸ Firebase initialization timeout');
                
                // Check if Firebase loaded
                if (typeof firebase !== 'undefined' && firebaseReady) {
                    console.log('Firebase loaded but auth not complete - creating device IDs');
                    authCompleted = true;
                    
                    // Generate persistent user ID (stored in localStorage)
                    if (!localStorage.getItem('persistentUserId')) {
                        localStorage.setItem('persistentUserId', 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
                    }
                    currentUserId = localStorage.getItem('persistentUserId');
                    
                    // Generate persistent device ID (stored in localStorage)
                    if (!localStorage.getItem('deviceId')) {
                        localStorage.setItem('deviceId', 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
                    }
                    currentDeviceId = localStorage.getItem('deviceId');
                    
                    console.log('â Device IDs created via fallback');
                    console.log('   User ID:', currentUserId);
                    console.log('   Device ID:', currentDeviceId);
                } else {
                    console.error('â Firebase not loaded - Multi-Device mode unavailable');
                    console.log('   Please use Single-Device mode or refresh the page');
                }
            } else {
                console.log('â Device IDs already set, no fallback needed');
            }
        }, 3000);

        // ========================================
        // COURSE DATA
        // ========================================
        
        // Course data
        const courses = {
            hidden_valley: {
                name: "Hidden Valley Golf Club",
                totalPar: 72,
                holes: [
                    { number: 1, par: 5, handicap: 9 },
                    { number: 2, par: 4, handicap: 5 },
                    { number: 3, par: 4, handicap: 13 },
                    { number: 4, par: 4, handicap: 11 },
                    { number: 5, par: 3, handicap: 1 },
                    { number: 6, par: 5, handicap: 7 },
                    { number: 7, par: 4, handicap: 17 },
                    { number: 8, par: 3, handicap: 15 },
                    { number: 9, par: 4, handicap: 3 },
                    { number: 10, par: 4, handicap: 6 },
                    { number: 11, par: 5, handicap: 10 },
                    { number: 12, par: 4, handicap: 8 },
                    { number: 13, par: 3, handicap: 16 },
                    { number: 14, par: 4, handicap: 18 },
                    { number: 15, par: 5, handicap: 4 },
                    { number: 16, par: 3, handicap: 12 },
                    { number: 17, par: 4, handicap: 14 },
                    { number: 18, par: 4, handicap: 2 }
                ]
            },
            indian_hills: {
                name: "Indian Hills Golf Club",
                totalPar: 70,
                holes: [
                    { number: 1, par: 4, handicap: 5 },
                    { number: 2, par: 4, handicap: 15 },
                    { number: 3, par: 3, handicap: 7 },
                    { number: 4, par: 4, handicap: 3 },
                    { number: 5, par: 3, handicap: 11 },
                    { number: 6, par: 4, handicap: 9 },
                    { number: 7, par: 4, handicap: 17 },
                    { number: 8, par: 5, handicap: 13 },
                    { number: 9, par: 4, handicap: 1 },
                    { number: 10, par: 4, handicap: 8 },
                    { number: 11, par: 3, handicap: 16 },
                    { number: 12, par: 4, handicap: 18 },
                    { number: 13, par: 4, handicap: 12 },
                    { number: 14, par: 4, handicap: 6 },
                    { number: 15, par: 3, handicap: 14 },
                    { number: 16, par: 4, handicap: 4 },
                    { number: 17, par: 4, handicap: 2 },
                    { number: 18, par: 5, handicap: 10 }
                ]
            },
            jurupa_hills: {
                name: "Jurupa Hills Country Club",
                totalPar: 70,
                holes: [
                    { number: 1, par: 4, handicap: 7 },
                    { number: 2, par: 4, handicap: 3 },
                    { number: 3, par: 3, handicap: 15 },
                    { number: 4, par: 4, handicap: 11 },
                    { number: 5, par: 4, handicap: 13 },
                    { number: 6, par: 4, handicap: 5 },
                    { number: 7, par: 5, handicap: 1 },
                    { number: 8, par: 3, handicap: 17 },
                    { number: 9, par: 4, handicap: 9 },
                    { number: 10, par: 4, handicap: 8 },
                    { number: 11, par: 4, handicap: 2 },
                    { number: 12, par: 4, handicap: 14 },
                    { number: 13, par: 4, handicap: 4 },
                    { number: 14, par: 3, handicap: 18 },
                    { number: 15, par: 5, handicap: 6 },
                    { number: 16, par: 4, handicap: 12 },
                    { number: 17, par: 4, handicap: 10 },
                    { number: 18, par: 3, handicap: 16 }
                ]
            },
            green_river: {
                name: "Green River Golf Club",
                totalPar: 73,
                holes: [
                    { number: 1, par: 4, handicap: 9 },
                    { number: 2, par: 3, handicap: 15 },
                    { number: 3, par: 5, handicap: 7 },
                    { number: 4, par: 3, handicap: 13 },
                    { number: 5, par: 5, handicap: 3 },
                    { number: 6, par: 4, handicap: 5 },
                    { number: 7, par: 5, handicap: 1 },
                    { number: 8, par: 3, handicap: 17 },
                    { number: 9, par: 4, handicap: 11 },
                    { number: 10, par: 5, handicap: 4 },
                    { number: 11, par: 4, handicap: 18 },
                    { number: 12, par: 4, handicap: 8 },
                    { number: 13, par: 3, handicap: 16 },
                    { number: 14, par: 4, handicap: 12 },
                    { number: 15, par: 4, handicap: 10 },
                    { number: 16, par: 3, handicap: 14 },
                    { number: 17, par: 5, handicap: 2 },
                    { number: 18, par: 5, handicap: 6 }
                ]
            }
        };

        let courseData = null; // No default course - user must select

        let currentPlayerCount = 1;
        let nextPlayerId = 2;
        const maxPlayers = 40;

        // Swipe-to-delete functionality
        let touchStartX = 0;
        let touchStartY = 0;
        let touchCurrentX = 0;
        let swipingRow = null;
        let isScrolling = null;

        // Initialize autocomplete, quick add, and swipe after page loads
        window.addEventListener('load', function() {
            // Set today's date as default
            const dateInput = document.getElementById('tournamentDate');
            if (dateInput) {
                dateInput.valueAsDate = new Date();
            }
            
            initializeAutocomplete();
            renderQuickAddButtons();
            initializeSwipeGestures();
            
            // Check for shared tournament in URL
            loadTournamentFromURL();
        });

        function initializeSwipeGestures() {
            // Setup swipe-to-delete for player rows
            const playerList = document.getElementById('playerList');
            if (!playerList) return;

            let touchStartX = 0;
            let touchStartY = 0;
            let touchCurrentX = 0;
            let swipingRow = null;
            let isScrolling = null;

            playerList.addEventListener('touchstart', function(e) {
                const row = e.target.closest('.player-row');
                if (!row) return;

                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                swipingRow = row;
                isScrolling = null;
            }, { passive: true });

            playerList.addEventListener('touchmove', function(e) {
                if (!swipingRow) return;

                touchCurrentX = e.touches[0].clientX;
                const touchCurrentY = e.touches[0].clientY;
                const diffX = touchStartX - touchCurrentX;
                const diffY = touchStartY - touchCurrentY;

                // Determine if scrolling vertically or swiping horizontally
                if (isScrolling === null) {
                    isScrolling = Math.abs(diffY) > Math.abs(diffX);
                }

                // If scrolling vertically, don't swipe
                if (isScrolling) return;

                // Prevent vertical scroll while swiping
                e.preventDefault();

                // Only allow swipe left
                if (diffX > 0 && diffX <= 100) {
                    swipingRow.style.transform = `translateX(-${diffX}px)`;
                }
            }, { passive: false });

            playerList.addEventListener('touchend', function(e) {
                if (!swipingRow) return;

                const diffX = touchStartX - touchCurrentX;

                // If swiped more than 50px, snap to delete position
                if (diffX > 50) {
                    swipingRow.classList.add('swiped');
                    swipingRow.style.transform = 'translateX(-100px)';
                } else {
                    // Snap back
                    swipingRow.classList.remove('swiped');
                    swipingRow.style.transform = 'translateX(0)';
                }

                // Reset
                swipingRow = null;
                isScrolling = null;
                touchStartX = 0;
                touchCurrentX = 0;
            }, { passive: true });

            // Click on delete area to delete
            playerList.addEventListener('click', function(e) {
                const row = e.target.closest('.player-row.swiped');
                if (!row) return;

                const rect = row.getBoundingClientRect();
                const clickX = e.clientX;

                // If clicked on the revealed delete button area
                if (clickX > rect.right - 20) {
                    const playerId = row.getAttribute('data-player');
                    deletePlayerRow(playerId);
                } else {
                    // Clicked elsewhere, close the swipe
                    row.classList.remove('swiped');
                    row.style.transform = 'translateX(0)';
                }
            });
        }

        // Delete player row with animation
        function deletePlayerRow(playerId) {
            const row = document.querySelector(`[data-player="${playerId}"]`);
            if (!row) return;
            
            // Don't allow deleting if only 1 player remains
            if (currentPlayerCount <= 1) {
                alert('You must have at least one player');
                row.classList.remove('swiped');
                row.style.transform = 'translateX(0)';
                return;
            }
            
            // Add deleting animation
            row.classList.add('deleting');
            
            // Remove after animation
            setTimeout(() => {
                row.remove();
                currentPlayerCount--;
                
                // Re-enable Add button if was at max
                if (currentPlayerCount < maxPlayers) {
                    document.getElementById('addPlayerBtn').disabled = false;
                    document.getElementById('addPlayerBtn').innerHTML = '<span style="font-size: 20px; font-weight: 600;">+</span> Add Player';
                }
                
                // CRITICAL: Reset all swipe state variables
                swipingRow = null;
                isScrolling = null;
                touchStartX = 0;
                touchCurrentX = 0;
                touchStartY = 0;
                
                // Remove swiped class from any other rows that might have it
                const allRows = document.querySelectorAll('.player-row.swiped');
                allRows.forEach(r => {
                    r.classList.remove('swiped');
                    r.style.transform = 'translateX(0)';
                });
            }, 300);
        }

        // Render quick add buttons for frequent players
        function renderQuickAddButtons() {
            const quickAddSection = document.getElementById('quickAddSection');
            const quickAddButtons = document.getElementById('quickAddButtons');
            
            // Safety check - these elements only exist on setup page
            if (!quickAddSection || !quickAddButtons) {
                return;
            }
            
            // Get top 8 most used players
            const frequentPlayers = Object.values(playerHistory)
                .sort((a, b) => b.usageCount - a.usageCount)
                .slice(0, 8);
            
            if (frequentPlayers.length === 0) {
                quickAddSection.style.display = 'none';
                return;
            }
            
            quickAddSection.style.display = 'block';
            quickAddButtons.innerHTML = '';
            
            frequentPlayers.forEach(player => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'quick-add-btn';
                btn.textContent = `${player.name} (${player.handicap})`;
                
                // Create delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'quick-add-delete';
                deleteBtn.innerHTML = 'Ã';
                deleteBtn.onclick = function(e) {
                    e.stopPropagation();
                    deleteQuickAddPlayer(player.name);
                };
                
                // Long press detection
                let pressTimer = null;
                let touchMoved = false;
                
                btn.addEventListener('touchstart', function(e) {
                    touchMoved = false;
                    pressTimer = setTimeout(() => {
                        if (!touchMoved) {
                            btn.classList.add('show-delete');
                            // Vibrate if supported
                            if (navigator.vibrate) {
                                navigator.vibrate(50);
                            }
                        }
                    }, 500); // 500ms long press
                });
                
                btn.addEventListener('touchmove', function() {
                    touchMoved = true;
                    if (pressTimer) {
                        clearTimeout(pressTimer);
                    }
                });
                
                btn.addEventListener('touchend', function() {
                    if (pressTimer) {
                        clearTimeout(pressTimer);
                    }
                });
                
                btn.onclick = function(e) {
                    if (!btn.classList.contains('show-delete')) {
                        quickAddPlayer(player.name, player.handicap);
                    }
                };
                
                btn.appendChild(deleteBtn);
                quickAddButtons.appendChild(btn);
            });
            
            // Click outside to hide delete buttons
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.quick-add-btn')) {
                    document.querySelectorAll('.quick-add-btn.show-delete').forEach(btn => {
                        btn.classList.remove('show-delete');
                    });
                }
            });
        }
        
        // Delete a player from quick-add history
        function deleteQuickAddPlayer(playerName) {
            if (confirm(`Remove ${playerName} from quick add?`)) {
                delete playerHistory[playerName];
                localStorage.setItem('indianHillsPlayerHistory', JSON.stringify(playerHistory));
                renderQuickAddButtons();
            }
        }

        // Quick add a player to the first empty row or create new row
        function quickAddPlayer(name, handicap) {
            // Find first empty player row
            const playerRows = document.querySelectorAll('.player-row');
            let emptyRow = null;
            
            for (let row of playerRows) {
                const playerId = row.getAttribute('data-player');
                const nameInput = document.getElementById(`player${playerId}`);
                if (nameInput && nameInput.value.trim() === '') {
                    emptyRow = { row, playerId };
                    break;
                }
            }
            
            if (emptyRow) {
                // Fill empty row
                document.getElementById(`player${emptyRow.playerId}`).value = name;
                document.getElementById(`hcp${emptyRow.playerId}`).value = handicap;
            } else {
                // Add new row
                if (currentPlayerCount >= maxPlayers) {
                    alert(`Maximum of ${maxPlayers} players reached`);
                    return;
                }
                
                addPlayerRow();
                // Fill the newly added row
                document.getElementById(`player${nextPlayerId - 1}`).value = name;
                document.getElementById(`hcp${nextPlayerId - 1}`).value = handicap;
            }
            
            // Refresh team setup if team game is selected
            refreshTeamSetupIfNeeded();
        }

        // Warn before page refresh if there's active data
        // Initialize autocomplete on all player name inputs
        function initializeAutocomplete() {
            const playerList = document.getElementById('playerList');
            if (!playerList) return;

            playerList.addEventListener('input', function(e) {
                // Refresh team setup if player name or handicap changes
                if (e.target.classList.contains('player-name-input') || e.target.classList.contains('player-hcp-input')) {
                    refreshTeamSetupIfNeeded();
                }
                
                if (!e.target.classList.contains('player-name-input')) return;
                
                const input = e.target;
                const row = input.closest('.player-row');
                if (!row) return;
                
                const query = input.value;
                
                // Remove existing suggestions
                const existingSuggestions = row.querySelector('.autocomplete-suggestions');
                if (existingSuggestions) {
                    existingSuggestions.remove();
                }
                
                if (!query || query.length < 1) {
                    row.classList.remove('has-suggestions');
                    return;
                }
                
                const suggestions = getPlayerSuggestions(query);
                if (suggestions.length === 0) {
                    row.classList.remove('has-suggestions');
                    return;
                }
                
                // Create suggestions dropdown
                const suggestionsDiv = document.createElement('div');
                suggestionsDiv.className = 'autocomplete-suggestions show';
                
                suggestions.forEach(player => {
                    const item = document.createElement('div');
                    item.className = 'suggestion-item';
                    item.innerHTML = `
                        <span class="suggestion-name">${player.name}</span>
                        <span class="suggestion-hcp">HCP: ${player.handicap}</span>
                    `;
                    
                    item.addEventListener('click', function(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        input.value = player.name;
                        
                        // Auto-fill handicap
                        const playerId = row.getAttribute('data-player');
                        const hcpInput = document.getElementById(`hcp${playerId}`);
                        if (hcpInput) {
                            hcpInput.value = player.handicap;
                        }
                        
                        suggestionsDiv.remove();
                        row.classList.remove('has-suggestions');
                        
                        // Refresh team setup
                        refreshTeamSetupIfNeeded();
                    });
                    
                    suggestionsDiv.appendChild(item);
                });
                
                row.appendChild(suggestionsDiv);
                row.classList.add('has-suggestions');
            });
            
            // Close suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.classList.contains('player-name-input') && 
                    !e.target.closest('.autocomplete-suggestions')) {
                    document.querySelectorAll('.autocomplete-suggestions').forEach(s => s.remove());
                    document.querySelectorAll('.player-row').forEach(r => r.classList.remove('has-suggestions'));
                }
            });
        }


        // Add new player row
        function addPlayerRow() {
            if (currentPlayerCount >= maxPlayers) {
                alert(`Maximum of ${maxPlayers} players reached`);
                return;
            }

            currentPlayerCount++;
            const playerList = document.getElementById('playerList');
            
            const newRow = document.createElement('div');
            newRow.className = 'player-row';
            newRow.setAttribute('data-player', nextPlayerId);
            newRow.innerHTML = `
                <input type="text" class="player-name-input" placeholder="Player Name" id="player${nextPlayerId}">
                <input type="text" class="player-hcp-input" placeholder="HCP" id="hcp${nextPlayerId}" pattern="-?[0-9]*" inputmode="numeric">
            `;
            
            playerList.appendChild(newRow);
            nextPlayerId++;
            
            // Disable button if at max
            if (currentPlayerCount >= maxPlayers) {
                document.getElementById('addPlayerBtn').disabled = true;
                document.getElementById('addPlayerBtn').textContent = `Maximum ${maxPlayers} Players`;
            }
        }

        // Delete player row with animation

        let tournamentData = {
            id: '',
            date: '',
            gameType: '',
            course: '',
            players: [],
            teams: []
        };

        // Generate unique tournament ID
        function generateTournamentId() {
            return 'T' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }

        // ===== UI ENHANCEMENT FUNCTIONS =====
        
        // Generate player avatar color based on name
        function getPlayerColor(playerName) {
            const colors = [
                '#3b82f6', // Blue
                '#10b981', // Green
                '#f59e0b', // Orange
                '#8b5cf6', // Purple
                '#ef4444', // Red
                '#06b6d4', // Cyan
                '#ec4899', // Pink
                '#f97316', // Deep Orange
                '#14b8a6', // Teal
                '#a855f7'  // Violet
            ];
            
            // Hash the name to get consistent color
            let hash = 0;
            for (let i = 0; i < playerName.length; i++) {
                hash = playerName.charCodeAt(i) + ((hash << 5) - hash);
            }
            return colors[Math.abs(hash) % colors.length];
        }

        // Get player initials
        function getPlayerInitials(playerName) {
            const words = playerName.trim().split(' ');
            if (words.length === 1) {
                return words[0].substring(0, 2).toUpperCase();
            }
            return (words[0][0] + words[words.length - 1][0]).toUpperCase();
        }

        // Create player avatar HTML
        function createPlayerAvatar(playerName, large = false) {
            const initials = getPlayerInitials(playerName);
            const color = getPlayerColor(playerName);
            const sizeClass = large ? 'player-avatar-large' : 'player-avatar';
            return `<span class="player-avatar ${sizeClass}" style="background: ${color};">${initials}</span>`;
        }

        // Get score color class based on par
        function getScoreClass(score, par) {
            if (score === 0) return 'score-par';
            const diff = score - par;
            if (diff <= -2) return 'score-eagle';
            if (diff === -1) return 'score-birdie';
            if (diff === 0) return 'score-par';
            if (diff === 1) return 'score-bogey';
            return 'score-double';
        }

        // Trigger confetti animation
        function showConfetti() {
            const colors = ['#fbbf24', '#3b82f6', '#10b981', '#ef4444', '#8b5cf6'];
            const confettiCount = 50;
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
                confetti.style.animationDelay = (Math.random() * 0.5) + 's';
                confetti.style.animation = 'confetti-fall linear forwards';
                
                document.body.appendChild(confetti);
                
                setTimeout(() => confetti.remove(), 5000);
            }
        }

        // Add pulse animation to element
        function pulseElement(element) {
            element.classList.add('score-changed');
            setTimeout(() => element.classList.remove('score-changed'), 300);
        }

        // Calculate tournament progress
        function getTournamentProgress() {
            if (!tournamentData.players || tournamentData.players.length === 0) return 0;
            
            let totalHoles = 0;
            let completedHoles = 0;
            
            tournamentData.players.forEach(player => {
                player.scores.forEach(score => {
                    totalHoles++;
                    if (score > 0) completedHoles++;
                });
            });
            
            return totalHoles > 0 ? (completedHoles / totalHoles) * 100 : 0;
        }
        
        // Current hole for hole view
        let currentHole = 0; // 0-17 (holes 1-18)
        let currentView = 'player'; // 'player' or 'hole'

        // Format date from YYYY-MM-DD string without timezone issues
        function formatDateDisplay(dateString) {
            if (!dateString) return '';
            const [year, month, day] = dateString.split('-');
            const date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
        }

        // Player history for auto-complete and handicap memory
        let playerHistory = JSON.parse(localStorage.getItem('indianHillsPlayerHistory') || '{}');
        // Format: { "PlayerName": { name: "PlayerName", handicap: 10, lastUsed: timestamp, usageCount: 5 } }

        // Save player history
        function savePlayerHistory() {
            localStorage.setItem('indianHillsPlayerHistory', JSON.stringify(playerHistory));
        }

        // Update player in history
        function updatePlayerHistory(name, handicap) {
            if (!name || name.trim() === '') return;
            
            const normalizedName = name.trim();
            if (!playerHistory[normalizedName]) {
                playerHistory[normalizedName] = {
                    name: normalizedName,
                    handicap: handicap || 0,
                    lastUsed: Date.now(),
                    usageCount: 1
                };
            } else {
                playerHistory[normalizedName].handicap = handicap || playerHistory[normalizedName].handicap;
                playerHistory[normalizedName].lastUsed = Date.now();
                playerHistory[normalizedName].usageCount++;
            }
            savePlayerHistory();
        }

        // Get player suggestions sorted by usage and recency
        function getPlayerSuggestions(query) {
            query = query.toLowerCase().trim();
            if (!query) {
                // Return most recent players
                return Object.values(playerHistory)
                    .sort((a, b) => b.lastUsed - a.lastUsed)
                    .slice(0, 5);
            }
            
            // Filter and sort by match quality
            return Object.values(playerHistory)
                .filter(p => p.name.toLowerCase().includes(query))
                .sort((a, b) => {
                    // Exact match first
                    const aExact = a.name.toLowerCase() === query ? 1 : 0;
                    const bExact = b.name.toLowerCase() === query ? 1 : 0;
                    if (aExact !== bExact) return bExact - aExact;
                    
                    // Then by usage count
                    if (a.usageCount !== b.usageCount) return b.usageCount - a.usageCount;
                    
                    // Then by recency
                    return b.lastUsed - a.lastUsed;
                })
                .slice(0, 5);
        }

        // Update course when selection changes
        function updateCourse() {
            const selectedCourse = document.getElementById('courseSelect').value;
            if (selectedCourse) {
                courseData = courses[selectedCourse];
            } else {
                courseData = null;
            }
        }

        // Handle game type changes to show/hide team setup
        function handleGameTypeChange() {
            const gameType = document.getElementById('gameType').value;
            const teamSection = document.getElementById('teamSetupSection');
            
            if (gameType.includes('Best Ball')) {
                teamSection.style.display = 'block';
                renderTeamSetup(gameType);
            } else {
                teamSection.style.display = 'none';
            }
        }

        // Refresh team setup if a team game is currently selected
        function refreshTeamSetupIfNeeded() {
            const gameType = document.getElementById('gameType').value;
            if (gameType.includes('Best Ball')) {
                renderTeamSetup(gameType);
            }
        }

        // Render team setup based on game type
        function renderTeamSetup(gameType) {
            const content = document.getElementById('teamSetupContent');
            
            // Determine players per team from game type
            let playersPerTeam;
            if (gameType.includes('2-Man')) {
                playersPerTeam = 2;
            } else if (gameType.includes('3-Man')) {
                playersPerTeam = 3;
            } else if (gameType.includes('4-Man')) {
                playersPerTeam = 4;
            }
            
            // Get current player names from the player list
            const playerNames = [];
            const playerRows = document.querySelectorAll('.player-row');
            playerRows.forEach((row, index) => {
                const nameInput = row.querySelector('.player-name-input');
                const hcpInput = row.querySelector('.player-hcp-input');
                if (nameInput && nameInput.value.trim()) {
                    playerNames.push({
                        index: index,
                        name: nameInput.value.trim(),
                        handicap: hcpInput ? hcpInput.value : '0'
                    });
                }
            });
            
            // Calculate number of teams based on player count
            // Example: 8 players in 3-Man teams = 2 full teams (6 players) + 1 team with 2 players = 3 teams
            const totalPlayers = playerNames.length;
            const numTeams = totalPlayers > 0 ? Math.ceil(totalPlayers / playersPerTeam) : 2;
            
            content.innerHTML = '';
            
            if (totalPlayers === 0) {
                content.innerHTML = '<p style="color: #64748b; font-size: 14px; padding: 12px;">Add players first to create teams</p>';
                return;
            }
            
            // Create team selection dropdowns
            for (let t = 0; t < numTeams; t++) {
                const teamDiv = document.createElement('div');
                teamDiv.className = 'team-container';
                
                let teamHtml = `<div class="team-header">Team ${t + 1}</div>`;
                
                for (let p = 0; p < playersPerTeam; p++) {
                    teamHtml += `
                        <select class="team-member-select" id="team${t}_player${p}">
                            <option value="">Select Player ${p + 1}</option>
                    `;
                    
                    // Add options for each added player
                    playerNames.forEach(player => {
                        teamHtml += `<option value="${player.index}">${player.name} (${player.handicap})</option>`;
                    });
                    
                    teamHtml += `</select>`;
                }
                
                teamDiv.innerHTML = teamHtml;
                content.appendChild(teamDiv);
            }
        }

        // Auto-save functionality
        function saveToLocalStorage() {
            try {
                const data = {
                    ...tournamentData,
                    _activeTournamentId: activeTournamentId,
                    _tournamentMode: tournamentMode,
                    _isHost: isHost,
                    _hostForTournament: activeTournamentId ? activeTournamentId : null, // Tie host to specific tournament
                    _scoreTimestamps: scoreTimestamps, // NEWEST WINS: Save score timestamps
                    _deletedPlayers: deletedPlayers, // Tombstones for deleted players
                    _lastSaved: new Date().toISOString()
                };
                
                const jsonData = JSON.stringify(data);
                
                // Track save time for conflict resolution
                localStorage.setItem('_lastLocalSaveTime', Date.now().toString());
                
                // Save to localStorage
                localStorage.setItem('indianHillsScoring', jsonData);
                
                // VERIFY save worked by reading it back
                const verification = localStorage.getItem('indianHillsScoring');
                
                if (!verification) {
                    console.error('â SAVE VERIFICATION FAILED - localStorage returned null');
                    throw new Error('Save verification failed');
                }
                
                if (verification !== jsonData) {
                    console.error('â SAVE VERIFICATION FAILED - Data mismatch');
                    throw new Error('Save data mismatch');
                }
                
                console.log('â Data saved and verified successfully');
                showSaveIndicator();
                return true;
                
            } catch (error) {
                console.error('â SAVE ERROR:', error);
                
                // Retry once
                try {
                    console.log('ð Retrying save...');
                    const retryData = {
                        ...tournamentData,
                        _activeTournamentId: activeTournamentId,
                        _tournamentMode: tournamentMode,
                        _isHost: isHost,
                        _hostForTournament: activeTournamentId ? activeTournamentId : null,
                        _scoreTimestamps: scoreTimestamps,
                        _deletedPlayers: deletedPlayers,
                        _lastSaved: new Date().toISOString()
                    };
                    localStorage.setItem('indianHillsScoring', JSON.stringify(retryData));
                    console.log('â Retry successful');
                    showSaveIndicator();
                    return true;
                } catch (retryError) {
                    console.error('â RETRY FAILED:', retryError);
                    showSaveError();
                    return false;
                }
            }
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('indianHillsScoring');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    activeTournamentId = data._activeTournamentId || null;
                    tournamentMode = data._tournamentMode || 'single';
                    
                    // IMPROVED HOST RESTORATION: Only restore host if it matches the tournament
                    const savedHostForTournament = data._hostForTournament || null;
                    if (savedHostForTournament && savedHostForTournament === activeTournamentId) {
                        isHost = data._isHost || false;
                        console.log('ð Host status restored for tournament:', activeTournamentId);
                    } else if (data._isHost && activeTournamentId) {
                        // Fallback for old data format
                        isHost = data._isHost;
                        console.log('ð Host status restored (legacy format)');
                    } else {
                        isHost = false;
                    }
                    
                    // NEWEST WINS: Restore score timestamps and tombstones
                    scoreTimestamps = data._scoreTimestamps || {};
                    deletedPlayers = data._deletedPlayers || {};
                    
                    // AUTO-FIX: If there's a tournament ID, it MUST be multi-device mode
                    if (activeTournamentId && tournamentMode !== 'multi') {
                        console.log('ð§ AUTO-FIX: Detected Firebase tournament ID, forcing multi-device mode');
                        tournamentMode = 'multi';
                        isHost = true;
                    }
                    
                    delete data._activeTournamentId;
                    delete data._tournamentMode;
                    delete data._isHost;
                    delete data._hostForTournament;
                    delete data._scoreTimestamps;
                    delete data._deletedPlayers;
                    delete data._lastSaved;
                    tournamentData = data;
                    console.log('â Loaded tournament data from localStorage');
                    console.log('ð Mode:', tournamentMode, '| Host:', isHost, '| TournamentID:', activeTournamentId);
                    console.log('ð ScoreTimestamps:', Object.keys(scoreTimestamps).length, '| DeletedPlayers:', Object.keys(deletedPlayers).length);
                    return true;
                } catch (error) {
                    console.error('â Error parsing saved data:', error);
                    return false;
                }
            }
            return false;
        }
        
        // Visual save indicator
        function showSaveIndicator() {
            // Remove any existing indicator
            let indicator = document.getElementById('saveIndicator');
            if (indicator) {
                indicator.remove();
            }
            
            // Create new indicator
            indicator = document.createElement('div');
            indicator.id = 'saveIndicator';
            indicator.innerHTML = 'â Saved';
            indicator.style.cssText = `
                position: fixed;
                top: 70px;
                right: 20px;
                background: #10b981;
                color: white;
                padding: 8px 16px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 600;
                z-index: 10000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                animation: slideIn 0.3s ease-out;
            `;
            
            document.body.appendChild(indicator);
            
            // Remove after 1 second
            setTimeout(() => {
                if (indicator && indicator.parentNode) {
                    indicator.style.animation = 'slideOut 0.3s ease-out';
                    setTimeout(() => {
                        if (indicator && indicator.parentNode) {
                            indicator.remove();
                        }
                    }, 300);
                }
            }, 1000);
        }
        
        function showSaveError() {
            // Remove any existing indicator
            let indicator = document.getElementById('saveIndicator');
            if (indicator) {
                indicator.remove();
            }
            
            // Create error indicator
            indicator = document.createElement('div');
            indicator.id = 'saveIndicator';
            indicator.innerHTML = 'â ï¸ Save Failed!';
            indicator.style.cssText = `
                position: fixed;
                top: 70px;
                right: 20px;
                background: #ef4444;
                color: white;
                padding: 8px 16px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 600;
                z-index: 10000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            `;
            
            document.body.appendChild(indicator);
            
            // Keep it visible longer
            setTimeout(() => {
                if (indicator && indicator.parentNode) {
                    indicator.remove();
                }
            }, 3000);
        }
        
        // Verify that a specific score was saved correctly
        async function verifyScoreSaved(playerIndex, holeIndex, expectedScore) {
            try {
                // Longer delay for iOS to ensure localStorage write completes
                await new Promise(resolve => setTimeout(resolve, 150));
                
                const saved = localStorage.getItem('indianHillsScoring');
                if (!saved) {
                    console.error('â VERIFY: No saved data found in localStorage');
                    return false;
                }
                
                const data = JSON.parse(saved);
                const actualScore = data.players[playerIndex].scores[holeIndex];
                
                if (actualScore === expectedScore) {
                    console.log('â VERIFY: Score verified -', 
                        data.players[playerIndex].name, 
                        'Hole', holeIndex + 1, 
                        '=', actualScore);
                    return true;
                } else {
                    console.error('â VERIFY: Score mismatch!', 
                        'Expected:', expectedScore, 
                        'Got:', actualScore);
                    return false;
                }
            } catch (error) {
                console.error('â VERIFY: Error during verification:', error);
                return false;
            }
        }

        // ========================================
        // FIREBASE TOURNAMENT MANAGEMENT SYSTEM
        // ========================================
        
        // Current tournament state
        let activeTournamentId = null;
        let isHost = false;
        let isCoHost = false; // True if current device is a co-host
        let isGuestUser = false; // True if joined via invite link (no home access)
        let claimedPlayers = []; // Players this device can edit
        let tournamentUnsubscribe = null;
        let lastFirebaseWriteTime = 0; // Track when we last wrote to Firebase
        
        // Helper function to check if current device can manage tournament
        function canManageTournament() {
            return isHost || isCoHost;
        }
        
        // NEWEST-WINS SYNC: Track score timestamps and deletion tombstones
        let scoreTimestamps = {}; // { "playerName-holeIndex": timestamp }
        let deletedPlayers = {}; // { "playerName": deletedAtTimestamp } - tombstones to prevent zombies
        
        // Create a new cloud tournament
        async function createCloudTournament(tournamentConfig) {
            try {
                // Check if Firebase is loaded
                if (typeof firebase === 'undefined' || !db) {
                    console.error('Firebase not ready - firebase:', typeof firebase, 'db:', !!db);
                    throw new Error('Firebase is not loaded yet. Please wait a moment and try again.');
                }
                
                // Wait for authentication if not ready
                if (!currentUserId || !currentDeviceId) {
                    console.log('Waiting for Firebase authentication...');
                    console.log('currentUserId:', currentUserId, 'currentDeviceId:', currentDeviceId);
                    
                    await new Promise((resolve) => {
                        let attempts = 0;
                        const checkAuth = setInterval(() => {
                            attempts++;
                            console.log(`Auth check attempt ${attempts}:`, currentUserId, currentDeviceId);
                            if (currentUserId && currentDeviceId) {
                                console.log('Authentication successful!');
                                clearInterval(checkAuth);
                                resolve();
                            }
                        }, 100);
                        // Timeout after 10 seconds
                        setTimeout(() => {
                            console.log('Authentication timeout after 10 seconds');
                            clearInterval(checkAuth);
                            resolve();
                        }, 10000);
                    });
                }
                
                // If still not authenticated, throw error
                if (!currentUserId || !currentDeviceId) {
                    console.error('Auth failed - currentUserId:', currentUserId, 'currentDeviceId:', currentDeviceId);
                    throw new Error('Device authentication failed. Please refresh the page and try again.');
                }
                
                const tournamentId = 'T' + Date.now() + Math.random().toString(36).substr(2, 6);
                
                // Create tournament in Firestore (no Firebase Auth required)
                console.log('Creating cloud tournament:', tournamentId);
                const tournament = {
                    id: tournamentId,
                    ...tournamentConfig,
                    hostDeviceId: currentDeviceId,
                    hostUserId: currentUserId,
                    status: 'open', // open, active, locked, ended
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    // Keep players from tournamentConfig (don't overwrite with empty array)
                    devices: {
                        [currentDeviceId]: {
                            name: getDeviceName(),
                            userId: currentUserId,
                            connectedAt: firebase.firestore.FieldValue.serverTimestamp(),
                            lastActive: firebase.firestore.FieldValue.serverTimestamp(),
                            isHost: true
                        }
                    },
                    enabledGames: tournamentConfig.enabledGames || [tournamentConfig.gameType]
                };
                
                console.log('Creating tournament:', tournamentId);
                await db.collection('tournaments').doc(tournamentId).set(tournament);
                
                activeTournamentId = tournamentId;
                isHost = true;
                
                console.log('Tournament created successfully!');
                return tournamentId;
            } catch (error) {
                console.error('Error creating tournament:', error);
                // Don't show alert here - let the calling function handle it
                throw error; // Re-throw so the catch in startScoring can handle it
            }
        }
        
        // Join existing tournament
        async function joinTournament(tournamentId, playerInfo) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                
                if (!tournamentDoc.exists) {
                    alert('Tournament not found!');
                    return false;
                }
                
                const tournament = tournamentDoc.data();
                
                if (tournament.status === 'ended') {
                    alert('This tournament has ended!');
                    return false;
                }
                
                // Add player and register device
                await tournamentRef.update({
                    players: firebase.firestore.FieldValue.arrayUnion({
                        ...playerInfo,
                        joinedAt: new Date().toISOString(),
                        claimedBy: currentDeviceId,
                        scores: new Array(18).fill(null)
                    }),
                    [`devices.${currentDeviceId}`]: {
                        name: getDeviceName(),
                        userId: currentUserId,
                        connectedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastActive: firebase.firestore.FieldValue.serverTimestamp(),
                        isHost: false
                    }
                });
                
                activeTournamentId = tournamentId;
                claimedPlayers = [playerInfo.name];
                
                // Subscribe to tournament updates
                subscribToTournamentUpdates(tournamentId);
                
                return true;
            } catch (error) {
                console.error('Error joining tournament:', error);
                alert('Failed to join tournament. Please try again.');
                return false;
            }
        }
        
        // Claim additional players (for scoring a foursome)
        async function claimAdditionalPlayer(tournamentId, playerName) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Find the player
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) {
                    alert('Player not found!');
                    return false;
                }
                
                const player = tournament.players[playerIndex];
                
                // Check if already claimed
                if (player.claimedBy && player.claimedBy !== currentDeviceId) {
                    alert(`${playerName} is already being scored by another device!`);
                    return false;
                }
                
                // Claim the player
                tournament.players[playerIndex].claimedBy = currentDeviceId;
                
                await tournamentRef.update({
                    players: tournament.players
                });
                
                claimedPlayers.push(playerName);
                return true;
            } catch (error) {
                console.error('Error claiming player:', error);
                return false;
            }
        }
        
        // Update player score
        async function updatePlayerScore(tournamentId, playerName, holeIndex, score) {
            console.log('ð¥ updatePlayerScore called:');
            console.log('   tournamentId:', tournamentId);
            console.log('   playerName:', playerName);
            console.log('   holeIndex:', holeIndex);
            console.log('   score:', score);
            
            // NEWEST WINS: Record timestamp for this score change
            const now = Date.now();
            const timestampKey = `${playerName}-${holeIndex}`;
            scoreTimestamps[timestampKey] = now;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                
                if (!tournamentDoc.exists) {
                    console.error('â Tournament document does not exist!');
                    return false;
                }
                
                const tournament = tournamentDoc.data();
                console.log('   Fetched tournament from Firebase');
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) {
                    console.error('â Player not found:', playerName);
                    return false;
                }
                
                console.log('   Found player at index:', playerIndex);
                
                // Check permissions - hosts and co-hosts can edit any player
                if (!canManageTournament() && tournament.players[playerIndex].claimedBy !== currentDeviceId) {
                    console.error('â Permission denied - not your player!');
                    alert('You cannot edit this player\'s scores!');
                    return false;
                }
                
                console.log('   Permission check passed');
                
                // Initialize scores array if it doesn't exist
                if (!tournament.players[playerIndex].scores) {
                    tournament.players[playerIndex].scores = new Array(18).fill(null);
                    console.log('   Initialized scores array');
                }
                
                // Initialize scoreTimestamps array if it doesn't exist
                if (!tournament.players[playerIndex].scoreTimestamps) {
                    tournament.players[playerIndex].scoreTimestamps = new Array(18).fill(0);
                }
                
                tournament.players[playerIndex].scores[holeIndex] = score;
                tournament.players[playerIndex].scoreTimestamps[holeIndex] = now;
                console.log('   Updated score in tournament object with timestamp:', now);
                
                // Mark that WE are writing to Firebase
                lastFirebaseWriteTime = Date.now();
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                console.log('â Score successfully written to Firebase!');
                return true;
            } catch (error) {
                console.error('â Error updating score:', error);
                console.error('   Error details:', error.message);
                return false;
            }
        }
        
        // Subscribe to real-time tournament updates
        function subscribToTournamentUpdates(tournamentId) {
            console.log('ð¡ Subscribing to tournament updates:', tournamentId);
            
            if (tournamentUnsubscribe) {
                tournamentUnsubscribe();
            }
            
            tournamentUnsubscribe = db.collection('tournaments')
                .doc(tournamentId)
                .onSnapshot((doc) => {
                    if (doc.exists) {
                        const tournament = doc.data();
                        console.log('ð¥ Received tournament update from Firebase');
                        console.log('   Players:', tournament.players.length);
                        console.log('   Sample scores:', tournament.players[0]?.scores?.slice(0, 3));
                        
                        // Check if this update is from OUR recent write
                        const timeSinceOurWrite = Date.now() - lastFirebaseWriteTime;
                        if (lastFirebaseWriteTime > 0 && timeSinceOurWrite < 2000) {
                            console.log('ð Skipping update - we just wrote to Firebase', timeSinceOurWrite + 'ms ago');
                            console.log('   This is our own write echoing back - ignoring it');
                            return; // Skip this update, it's our own write echoing back
                        }
                        
                        updateLocalTournamentState(tournament);
                        updateLiveLeaderboard(tournament);
                        
                        // Refresh UI if on scoring page - BUT not if user is actively editing
                        if (document.getElementById('scoringPage').classList.contains('active')) {
                            const activeElement = document.activeElement;
                            const isEditingScore = activeElement && 
                                                 (activeElement.classList.contains('score-input') || 
                                                  activeElement.tagName === 'INPUT');
                            
                            if (!isEditingScore) {
                                // Clear any pending refresh
                                if (window.subscriptionRefreshTimeout) {
                                    clearTimeout(window.subscriptionRefreshTimeout);
                                }
                                
                                // Debounce: Wait 300ms after last update before re-rendering
                                console.log('ð Scheduling scoring page refresh...');
                                window.subscriptionRefreshTimeout = setTimeout(() => {
                                    console.log('ð Refreshing scoring page UI from subscription');
                                    renderScoringPage();
                                }, 300);
                            } else {
                                console.log('â¸ï¸ User is editing - skipping refresh');
                            }
                        }
                        
                        // Check for notifications
                        if (tournament.status === 'ended' && !sessionStorage.getItem('tournamentEndedNotified_' + tournamentId)) {
                            sessionStorage.setItem('tournamentEndedNotified_' + tournamentId, 'true');
                            showNotification('Tournament Complete!', 'Tap to view final results');
                        }
                    } else {
                        console.warn('â ï¸ Tournament document does not exist');
                    }
                }, (error) => {
                    console.error('â Error listening to tournament:', error);
                });
        }
        
        // Update local state from cloud data - NEWEST WINS approach
        function updateLocalTournamentState(tournament) {
            console.log('ð¥ NEWEST-WINS SYNC: Merging tournament data from cloud:', {
                players: tournament.players.length,
                hasScores: tournament.players.some(p => p.scores && p.scores.some(s => s > 0))
            });
            
            // Initialize tournamentData if it doesn't exist
            if (!tournamentData) {
                tournamentData = {
                    id: tournament.id,
                    name: tournament.name || '',
                    date: tournament.date,
                    course: tournament.course,
                    gameType: tournament.gameType,
                    enabledGames: tournament.enabledGames || [tournament.gameType],
                    players: [],
                    teams: tournament.teams || []
                };
            }
            
            // Always update non-score data from cloud
            tournamentData.date = tournament.date;
            tournamentData.course = tournament.course;
            tournamentData.gameType = tournament.gameType;
            tournamentData.enabledGames = tournament.enabledGames || [tournament.gameType];
            tournamentData.name = tournament.name || '';
            
            // NEWEST-WINS: Merge players intelligently
            const now = Date.now();
            const mergedPlayers = [];
            
            // Build a map of local players by name
            const localPlayerMap = {};
            if (tournamentData.players) {
                tournamentData.players.forEach(p => {
                    localPlayerMap[p.name] = p;
                });
            }
            
            // Process cloud players
            tournament.players.forEach(cloudPlayer => {
                const localPlayer = localPlayerMap[cloudPlayer.name];
                
                // Check if this player was deleted locally (tombstone check)
                const deletedAt = deletedPlayers[cloudPlayer.name];
                const cloudPlayerAddedAt = cloudPlayer.addedAt ? new Date(cloudPlayer.addedAt).getTime() : 0;
                
                if (deletedAt && cloudPlayerAddedAt < deletedAt) {
                    console.log(`ðª¦ TOMBSTONE: Blocking zombie player "${cloudPlayer.name}" (deleted at ${deletedAt}, added at ${cloudPlayerAddedAt})`);
                    return; // Skip this player - they were deleted after being added
                }
                
                if (!localPlayer) {
                    // New player from cloud - accept them
                    console.log(`â NEW PLAYER from cloud: ${cloudPlayer.name}`);
                    mergedPlayers.push({
                        name: cloudPlayer.name,
                        handicap: cloudPlayer.handicap,
                        scores: cloudPlayer.scores || new Array(18).fill(null),
                        claimedBy: cloudPlayer.claimedBy,
                        addedAt: cloudPlayer.addedAt || now
                    });
                } else {
                    // Existing player - MERGE scores using timestamps (newest wins)
                    const mergedScores = new Array(18).fill(null);
                    
                    for (let holeIdx = 0; holeIdx < 18; holeIdx++) {
                        const localScore = localPlayer.scores ? localPlayer.scores[holeIdx] : null;
                        const cloudScore = cloudPlayer.scores ? cloudPlayer.scores[holeIdx] : null;
                        const timestampKey = `${cloudPlayer.name}-${holeIdx}`;
                        const localTimestamp = scoreTimestamps[timestampKey] || 0;
                        const cloudTimestamp = cloudPlayer.scoreTimestamps ? (cloudPlayer.scoreTimestamps[holeIdx] || 0) : 0;
                        
                        // NEWEST WINS logic
                        if (localScore !== null && cloudScore !== null) {
                            // Both have scores - use newest
                            if (localTimestamp >= cloudTimestamp) {
                                mergedScores[holeIdx] = localScore;
                                console.log(`ð¡ï¸ KEPT LOCAL: ${cloudPlayer.name} H${holeIdx + 1} = ${localScore} (local: ${localTimestamp}, cloud: ${cloudTimestamp})`);
                            } else {
                                mergedScores[holeIdx] = cloudScore;
                                // Update our timestamp to cloud's
                                scoreTimestamps[timestampKey] = cloudTimestamp;
                                console.log(`âï¸ TOOK CLOUD: ${cloudPlayer.name} H${holeIdx + 1} = ${cloudScore} (local: ${localTimestamp}, cloud: ${cloudTimestamp})`);
                            }
                        } else if (localScore !== null) {
                            // Only local has score - keep it
                            mergedScores[holeIdx] = localScore;
                            console.log(`ð¡ï¸ LOCAL ONLY: ${cloudPlayer.name} H${holeIdx + 1} = ${localScore}`);
                        } else if (cloudScore !== null) {
                            // Only cloud has score - accept it
                            mergedScores[holeIdx] = cloudScore;
                            if (cloudTimestamp) {
                                scoreTimestamps[timestampKey] = cloudTimestamp;
                            }
                            console.log(`âï¸ CLOUD ONLY: ${cloudPlayer.name} H${holeIdx + 1} = ${cloudScore}`);
                        }
                        // else both null - keep null
                    }
                    
                    mergedPlayers.push({
                        name: cloudPlayer.name,
                        handicap: cloudPlayer.handicap,
                        scores: mergedScores,
                        claimedBy: cloudPlayer.claimedBy, // Always use cloud's claim status
                        addedAt: cloudPlayer.addedAt || localPlayer.addedAt || now
                    });
                    
                    // Remove from local map since we processed it
                    delete localPlayerMap[cloudPlayer.name];
                }
            });
            
            // Add any local players that weren't in cloud (unless deleted on cloud)
            Object.values(localPlayerMap).forEach(localPlayer => {
                // Check if this player was intentionally removed from cloud
                // If cloud doesn't have them but we do, keep them for now
                // (they might have been added offline)
                console.log(`ð  LOCAL ONLY PLAYER: ${localPlayer.name} (keeping for offline support)`);
                mergedPlayers.push(localPlayer);
            });
            
            tournamentData.players = mergedPlayers;
            
            // Update co-host status
            const coHosts = tournament.coHosts || [];
            isCoHost = coHosts.includes(currentDeviceId);
            console.log('ð Co-host status:', isCoHost, '| CoHosts:', coHosts);
            
            console.log('â NEWEST-WINS SYNC complete:', {
                finalPlayerCount: tournamentData.players.length,
                sampleScores: tournamentData.players[0]?.scores?.slice(0, 3)
            });
            
            // Save merged state
            saveToLocalStorage();
        }
        
        // Host/Co-host: Reassign player to different device
        async function reassignPlayer(tournamentId, playerName, newDeviceId) {
            if (!canManageTournament()) {
                alert('Only hosts and co-hosts can reassign players!');
                return false;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) return false;
                
                tournament.players[playerIndex].claimedBy = newDeviceId;
                
                await tournamentRef.update({
                    players: tournament.players
                });
                
                return true;
            } catch (error) {
                console.error('Error reassigning player:', error);
                return false;
            }
        }
        
        // Host/Co-host: Lock tournament (no more joins)
        async function lockTournament(tournamentId) {
            if (!canManageTournament()) return false;
            
            try {
                await db.collection('tournaments').doc(tournamentId).update({
                    status: 'locked',
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error locking tournament:', error);
                return false;
            }
        }
        
        // Host/Co-host: End tournament
        async function endTournament(tournamentId) {
            if (!canManageTournament()) return false;
            
            try {
                await db.collection('tournaments').doc(tournamentId).update({
                    status: 'ended',
                    endedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Send notifications to all players
                sendTournamentEndNotification(tournamentId);
                
                return true;
            } catch (error) {
                console.error('Error ending tournament:', error);
                return false;
            }
        }
        
        // Get device name for display
        function getDeviceName() {
            const deviceType = /iPhone/i.test(navigator.userAgent) ? 'iPhone' :
                              /iPad/i.test(navigator.userAgent) ? 'iPad' :
                              /Android/i.test(navigator.userAgent) ? 'Android' :
                              'Device';
            
            // Try to get a friendly name from localStorage
            const customName = localStorage.getItem('deviceName');
            return customName || deviceType;
        }
        
        // Send tournament end notification
        function sendTournamentEndNotification(tournamentId) {
            // This will use web push notifications if permitted
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification('ð Tournament Complete!', {
                    body: 'Tap to view final results',
                    icon: '/apple-touch-icon.png',
                    badge: '/apple-touch-icon.png',
                    tag: 'tournament-ended-' + tournamentId
                });
            }
        }
        
        // Request notification permission
        function requestNotificationPermission() {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        console.log('Notifications enabled');
                    }
                });
            }
        }
        
        // Show in-app notification
        function showNotification(title, message, requireDismiss = false) {
            // Create notification UI element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #1e40af;
                color: white;
                padding: 16px 24px;
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                max-width: 90%;
                text-align: center;
                animation: slideDown 0.3s ease;
            `;
            
            notification.innerHTML = `
                <div style="font-weight: 700; margin-bottom: 4px;">${title}</div>
                <div style="font-size: 14px;">${message}</div>
                ${requireDismiss ? '<button onclick="this.parentElement.remove()" style="margin-top: 12px; background: white; color: #1e40af; border: none; padding: 8px 16px; border-radius: 6px; font-weight: 600; cursor: pointer;">OK</button>' : ''}
            `;
            
            document.body.appendChild(notification);
            
            // Auto-dismiss after 4 seconds only if not requiring manual dismissal
            if (!requireDismiss) {
                setTimeout(() => {
                    notification.style.animation = 'slideUp 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }, 4000);
            }
        }
        
        // Generate shareable tournament link
        function getShareLink(tournamentId) {
            return window.location.origin + window.location.pathname + '?join=' + tournamentId;
        }
        
        // Check URL for join parameter on page load
        function checkForJoinLink() {
            const urlParams = new URLSearchParams(window.location.search);
            const joinId = urlParams.get('join');
            if (joinId) {
                // Mark as guest user - they can only participate in this tournament
                isGuestUser = true;
                // Show join tournament screen
                showJoinTournamentScreen(joinId);
            } else {
                // No join link - check if device has claimed players from a previous session
                checkForPreviousSession();
            }
        }
        
        // Check if this device has claimed players from a previous session
        async function checkForPreviousSession() {
            const savedData = localStorage.getItem('indianHillsScoring');
            if (!savedData) return;
            
            try {
                const data = JSON.parse(savedData);
                const savedTournamentId = data._activeTournamentId;
                const savedMode = data._tournamentMode;
                
                // Only check for multi-device tournaments
                if (savedMode !== 'multi' || !savedTournamentId) return;
                
                // Check if tournament still exists and this device has claimed players
                const tournamentDoc = await db.collection('tournaments').doc(savedTournamentId).get();
                if (!tournamentDoc.exists) {
                    console.log('Previous tournament no longer exists');
                    return;
                }
                
                const tournament = tournamentDoc.data();
                const myClaimedPlayers = tournament.players.filter(p => p.claimedBy === currentDeviceId);
                
                if (myClaimedPlayers.length > 0) {
                    // Device has claimed players - show Keep/Release dialog
                    showKeepReleaseDialog(savedTournamentId, tournament, myClaimedPlayers);
                }
            } catch (error) {
                console.error('Error checking for previous session:', error);
            }
        }
        
        // Show dialog asking user to Keep or Release their claimed players
        function showKeepReleaseDialog(tournamentId, tournament, claimedPlayers) {
            const playerNames = claimedPlayers.map(p => p.name).join(', ');
            const tournamentName = tournament.name || `${tournament.course} - ${tournament.gameType}`;
            
            const modal = document.createElement('div');
            modal.id = 'keepReleaseModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; max-width: 400px; width: 100%; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 16px;">â³</div>
                    <h2 style="color: #1e40af; margin-bottom: 12px; font-size: 20px;">Welcome Back!</h2>
                    <p style="color: #64748b; margin-bottom: 16px; font-size: 14px;">
                        You were scoring for <strong>${playerNames}</strong> in:
                    </p>
                    <p style="color: #1e293b; font-weight: 600; margin-bottom: 20px; padding: 12px; background: #f1f5f9; border-radius: 8px;">
                        ${tournamentName}
                    </p>
                    <p style="color: #64748b; margin-bottom: 24px; font-size: 14px;">
                        Would you like to continue scoring or select different players?
                    </p>
                    <div style="display: flex; gap: 12px;">
                        <button onclick="handleReleaseAndChoose('${tournamentId}')" style="flex: 1; padding: 14px; background: #ef4444; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Release & Choose
                        </button>
                        <button onclick="handleKeepPlayers('${tournamentId}')" style="flex: 1; padding: 14px; background: #10b981; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Keep & Continue
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Keep claimed players and continue scoring
        async function handleKeepPlayers(tournamentId) {
            document.getElementById('keepReleaseModal')?.remove();
            
            try {
                const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                if (!tournamentDoc.exists) {
                    showNotification('Error', 'Tournament no longer exists');
                    return;
                }
                
                const tournament = tournamentDoc.data();
                
                // Set up tournament state
                activeTournamentId = tournamentId;
                tournamentMode = 'multi';
                isHost = false;
                
                // Get claimed players
                claimedPlayers = tournament.players
                    .filter(p => p.claimedBy === currentDeviceId)
                    .map(p => p.name);
                
                // Load tournament data
                tournamentData = {
                    id: tournamentId,
                    name: tournament.name || '',
                    date: tournament.date,
                    gameType: tournament.gameType,
                    course: tournament.course,
                    players: tournament.players,
                    teams: tournament.teams || []
                };
                
                saveToLocalStorage();
                subscribToTournamentUpdates(tournamentId);
                
                // Go directly to scoring
                renderScoringPage();
                showPage('scoringPage');
                switchToHoleView();
                
                showNotification('Welcome Back!', `Continuing with ${claimedPlayers.join(', ')}`);
            } catch (error) {
                console.error('Error keeping players:', error);
                showNotification('Error', 'Failed to restore session');
            }
        }
        
        // Release all claimed players and show join screen
        async function handleReleaseAndChoose(tournamentId) {
            document.getElementById('keepReleaseModal')?.remove();
            
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                if (!tournamentDoc.exists) {
                    showNotification('Error', 'Tournament no longer exists');
                    return;
                }
                
                const tournament = tournamentDoc.data();
                
                // Release all players claimed by this device
                let released = [];
                tournament.players.forEach(p => {
                    if (p.claimedBy === currentDeviceId) {
                        released.push(p.name);
                        p.claimedBy = null;
                    }
                });
                
                // Update tournament
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Clear local claimed players
                claimedPlayers = [];
                playerOrder.claimed = [];
                savePlayerOrder();
                
                // Set up tournament state
                activeTournamentId = tournamentId;
                tournamentMode = 'multi';
                isHost = false;
                
                // Load tournament data
                tournamentData = {
                    id: tournamentId,
                    name: tournament.name || '',
                    date: tournament.date,
                    gameType: tournament.gameType,
                    course: tournament.course,
                    players: tournament.players,
                    teams: tournament.teams || []
                };
                
                saveToLocalStorage();
                subscribToTournamentUpdates(tournamentId);
                
                // Show join screen with available players
                showJoinTournamentScreen(tournamentId);
                
                showNotification('Players Released', `${released.join(', ')} are now available`);
            } catch (error) {
                console.error('Error releasing players:', error);
                showNotification('Error', 'Failed to release players');
            }
        }
        
        // Generate share link and display it
        function generateShareLink(tournamentId) {
            const shareLink = getShareLink(tournamentId);
            
            // Show notification with option to view
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: white;
                color: #1e40af;
                padding: 16px 24px;
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                max-width: 90%;
                text-align: center;
            `;
            notification.innerHTML = `
                <div style="font-weight: 700; margin-bottom: 8px;">ð Tournament Ready!</div>
                <div style="font-size: 14px; margin-bottom: 12px;">Share this link or QR code for others to join</div>
                <button onclick="copyShareLink('${shareLink}')" style="padding: 8px 16px; background: #1e40af; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; margin-right: 8px;">
                    ð Copy Link
                </button>
                <button onclick="showQRCode('${tournamentId}')" style="padding: 8px 16px; background: #10b981; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
                    ð± Show QR
                </button>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideDown 0.3s ease reverse';
                setTimeout(() => notification.remove(), 300);
            }, 8000);
        }
        
        // Copy share link to clipboard
        function copyShareLink(link) {
            navigator.clipboard.writeText(link).then(() => {
                showNotification('Copied!', 'Share link copied to clipboard');
            }).catch(() => {
                // Fallback for older browsers
                const input = document.createElement('input');
                input.value = link;
                document.body.appendChild(input);
                input.select();
                document.execCommand('copy');
                document.body.removeChild(input);
                showNotification('Copied!', 'Share link copied to clipboard');
            });
        }
        
        // Show QR code for tournament
        function showQRCode(tournamentId) {
            const link = getShareLink(tournamentId);
            
            // Create modal with QR code
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 10001;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; padding: 24px; border-radius: 16px; max-width: 400px; text-align: center;">
                    <h2 style="color: #1e40af; margin-bottom: 16px;">Scan to Join Tournament</h2>
                    <div id="tempQRCode" style="display: inline-block; padding: 16px; background: white;"></div>
                    <p style="color: #64748b; font-size: 14px; margin-top: 16px; word-break: break-all;">${link}</p>
                    <button onclick="this.closest('div[style*=fixed]').remove()" style="margin-top: 16px; padding: 12px 24px; background: #ef4444; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; width: 100%;">
                        Close
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Generate QR code
            new QRCode(document.getElementById('tempQRCode'), {
                text: link,
                width: 256,
                height: 256
            });
            
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
        }
        
        // Show share buttons on scoring page (for multi-device mode)
        
        // Show QR code for active tournament (legacy - kept for compatibility)
        function showQRCodeForActiveTournament() {
            if (activeTournamentId) {
                showQRCode(activeTournamentId);
            } else {
                alert('No active tournament!');
            }
        }
        
        // Copy active tournament link (legacy - kept for compatibility)
        function copyActiveTournamentLink() {
            if (activeTournamentId) {
                const link = getShareLink(activeTournamentId);
                copyShareLink(link);
            } else {
                alert('No active tournament!');
            }
        }
        
        // Show QR code from Resume section
        function showQRFromResume() {
            console.log('=== QR CODE DEBUG ===');
            console.log('showQRFromResume called');
            console.log('activeTournamentId:', activeTournamentId);
            console.log('tournamentMode:', tournamentMode);
            console.log('isHost:', isHost);
            
            if (activeTournamentId) {
                console.log('â Tournament ID found - showing QR code');
                showQRCode(activeTournamentId);
            } else {
                console.error('â No active tournament ID');
                showNotification('No Active Tournament', 'Please start a multi-device tournament first');
            }
        }
        
        // Copy link from Resume section
        function copyLinkFromResume() {
            if (activeTournamentId) {
                const link = getShareLink(activeTournamentId);
                navigator.clipboard.writeText(link).then(() => {
                    showNotification('Link Copied!', 'Share link copied to clipboard');
                }).catch(() => {
                    showNotification('Copy Failed', 'Please try again');
                });
            } else {
                showNotification('No Active Tournament', 'Please start a multi-device tournament first');
            }
        }
        
        // Save tournament to file
        function saveTournamentFile() {
            if (!activeTournamentId) {
                showNotification('No Active Tournament', 'Please start a multi-device tournament first');
                return;
            }
            
            try {
                // Create tournament export object
                const exportData = {
                    tournamentId: activeTournamentId,
                    tournamentData: tournamentData,
                    tournamentMode: tournamentMode,
                    savedAt: new Date().toISOString(),
                    version: '1.0'
                };
                
                // Convert to JSON
                const jsonStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                
                // Create download link
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                // Create filename with tournament info
                const date = tournamentData.date || new Date().toISOString().split('T')[0];
                const name = tournamentData.name ? tournamentData.name.replace(/[^a-z0-9]/gi, '_') : 'tournament';
                a.download = `${name}_${date}_${activeTournamentId}.json`;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification('Tournament Saved!', 'File downloaded successfully');
            } catch (error) {
                console.error('Error saving tournament:', error);
                showNotification('Save Failed', 'Could not save tournament file');
            }
        }

        // ========================================
        // END FIREBASE FUNCTIONS
        // ========================================

        // Page navigation
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId).classList.add('active');
            
            // Render scoring page when navigating to it
            if (pageId === 'scoringPage') {
                renderScoringPage();
            }
            
            // Render results page when navigating to it
            if (pageId === 'resultsPage') {
                renderResultsPage();
            }
            
            // Hide Home button for guest users (they can only access this tournament)
            if (isGuestUser) {
                const homeBtn = document.getElementById('backToSetupBtn');
                if (homeBtn) {
                    homeBtn.style.display = 'none';
                }
                
                // On results page, show manage button instead of finish for guest users
                const finishBtn = document.getElementById('newRoundBtnTop');
                const manageBtn = document.getElementById('resultsManageBtn');
                if (finishBtn) finishBtn.style.display = 'none';
                if (manageBtn) manageBtn.style.display = 'block';
            }
            
            // Refresh quick add buttons and check for saved round when returning to setup page
            if (pageId === 'setupPage') {
                renderQuickAddButtons();
                checkForSavedRound(); // Update resume section with share buttons if needed
                
                // Extra check: If multi-device tournament is active, ensure buttons are visible
                if (tournamentMode === 'multi' && activeTournamentId) {
                    // Multiple checks at different intervals for iOS
                    setTimeout(() => {
                        const shareButtons = document.getElementById('resumeShareButtons');
                        if (shareButtons) {
                            console.log('ð Setup page shown (50ms) - forcing share buttons visible');
                            shareButtons.classList.add('visible');
                            shareButtons.style.setProperty('display', 'grid', 'important');
                            shareButtons.style.setProperty('visibility', 'visible', 'important');
                        }
                    }, 50);
                    
                    setTimeout(() => {
                        const shareButtons = document.getElementById('resumeShareButtons');
                        if (shareButtons) {
                            console.log('ð Setup page shown (200ms) - forcing share buttons visible');
                            shareButtons.classList.add('visible');
                            shareButtons.style.setProperty('display', 'grid', 'important');
                            shareButtons.style.setProperty('visibility', 'visible', 'important');
                        }
                    }, 200);
                    
                    setTimeout(() => {
                        const shareButtons = document.getElementById('resumeShareButtons');
                        if (shareButtons) {
                            console.log('ð Setup page shown (500ms) - forcing share buttons visible');
                            shareButtons.classList.add('visible');
                            shareButtons.style.setProperty('display', 'grid', 'important');
                            shareButtons.style.setProperty('visibility', 'visible', 'important');
                        }
                    }, 500);
                }
            }
        }

        // Custom confirmation dialog (iOS-friendly)
        function showConfirm(title, message, onConfirm) {
            const dialog = document.getElementById('confirmDialog');
            const titleEl = document.getElementById('confirmTitle');
            const messageEl = document.getElementById('confirmMessage');
            const okBtn = document.getElementById('confirmOk');
            const cancelBtn = document.getElementById('confirmCancel');
            
            titleEl.textContent = title;
            messageEl.textContent = message;
            dialog.style.display = 'flex';
            
            // Remove old listeners
            const newOkBtn = okBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
            
            // Add new listeners
            newOkBtn.addEventListener('click', function() {
                dialog.style.display = 'none';
                onConfirm();
            });
            
            newCancelBtn.addEventListener('click', function() {
                dialog.style.display = 'none';
            });
        }
        
        function hideConfirmDialog() {
            const dialog = document.getElementById('confirmDialog');
            if (dialog) {
                dialog.style.display = 'none';
            }
        }

        // Back button - shows resume option if there's an active game
        function confirmBackToHome() {
            // Non-hosts/non-co-hosts go to guest home page
            if (tournamentMode === 'multi' && !canManageTournament()) {
                showGuestHomePage();
            } else {
                confirmBackToSetup();
            }
        }
        
        // Generate smart info line with progressive shortening
        function generateSmartInfoLine(containerId) {
            if (!tournamentData || !courseData) return;
            
            const container = document.getElementById(containerId);
            if (!container) return;
            
            const tournamentName = tournamentData.name || 'Tournament';
            const gameType = tournamentData.gameType || 'Stroke Play';
            const courseName = courseData.name || tournamentData.course;
            const dateStr = formatDateDisplay(tournamentData.date);
            
            // Get course initials (e.g., "Jurupa Hills Country Club" -> "JHCC")
            const courseInitials = courseName.split(' ')
                .map(word => word.charAt(0).toUpperCase())
                .join('');
            
            // Short date format (MM/DD/YY)
            const shortDate = formatShortDate(tournamentData.date);
            
            // Get container width
            const containerWidth = container.parentElement ? container.parentElement.clientWidth - 40 : 300;
            
            // Create a hidden span to measure text width
            const measureSpan = document.createElement('span');
            measureSpan.style.cssText = 'position: absolute; visibility: hidden; white-space: nowrap; font-size: 12px; font-weight: 600;';
            document.body.appendChild(measureSpan);
            
            // Level 1: Full version
            let infoText = `${tournamentName} | ${gameType} | ${courseName} | ${dateStr}`;
            measureSpan.textContent = infoText;
            
            if (measureSpan.offsetWidth > containerWidth) {
                // Level 2: Abbreviate course name
                infoText = `${tournamentName} | ${gameType} | ${courseInitials} | ${dateStr}`;
                measureSpan.textContent = infoText;
                
                if (measureSpan.offsetWidth > containerWidth) {
                    // Level 3: Also shorten date
                    infoText = `${tournamentName} | ${gameType} | ${courseInitials} | ${shortDate}`;
                }
            }
            
            // Clean up
            document.body.removeChild(measureSpan);
            
            container.textContent = infoText;
        }
        
        // Format date as MM/DD/YY
        function formatShortDate(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString + 'T12:00:00');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const year = String(date.getFullYear()).slice(-2);
            return `${month}/${day}/${year}`;
        }

        function confirmBackToSetup() {
            console.log('=== CONFIRM BACK TO SETUP ===');
            console.log('tournamentMode:', tournamentMode);
            console.log('activeTournamentId:', activeTournamentId);
            console.log('isHost:', isHost);
            
            showPage('setupPage');
            
            // Show Resume Scoring button if there are active scores
            if (tournamentData.players && tournamentData.players.length > 0) {
                const resumeBtn = document.getElementById('resumeScoringBtn');
                if (resumeBtn) {
                    resumeBtn.style.display = 'block';
                }
            }
            
            // FORCE share buttons check after a moment (for iOS)
            setTimeout(() => {
                console.log('ð Checking share buttons after back to setup...');
                const shareButtons = document.getElementById('resumeShareButtons');
                console.log('  shareButtons element:', shareButtons);
                console.log('  display:', shareButtons?.style.display);
                console.log('  visibility:', shareButtons?.style.visibility);
                console.log('  classList:', shareButtons?.classList);
                
                if (tournamentMode === 'multi' && activeTournamentId && shareButtons) {
                    console.log('  ð§ FORCING VISIBLE');
                    shareButtons.classList.add('visible');
                    shareButtons.style.setProperty('display', 'grid', 'important');
                    shareButtons.style.setProperty('visibility', 'visible', 'important');
                }
            }, 100);
        }

        // Resume scoring - go back to scoring page with existing data
        function resumeScoring() {
            renderScoringPage();
            showPage('scoringPage');
            
            // Start in Holes view by default
            switchToHoleView();
        }

        // Start scoring from setup page
        // ========================================
        // TOURNAMENT MODE SELECTION & UI HANDLERS
        // ========================================
        
        let tournamentMode = 'multi'; // Always multi-device mode now
        let isOnline = navigator.onLine; // Track connection status
        
        // Connection status monitoring
        function updateConnectionStatus() {
            isOnline = navigator.onLine;
            const dot = document.getElementById('connectionDot');
            const text = document.getElementById('connectionText');
            const statusContainer = document.getElementById('connectionStatus');
            const scoringDot = document.getElementById('scoringConnectionDot');
            
            if (dot && text) {
                if (isOnline) {
                    dot.style.background = '#10b981';
                    text.textContent = 'Online - Scores sync across devices';
                    if (statusContainer) statusContainer.style.background = 'rgba(16, 185, 129, 0.2)';
                } else {
                    dot.style.background = '#ef4444';
                    text.textContent = 'Offline - Scores saved locally';
                    if (statusContainer) statusContainer.style.background = 'rgba(239, 68, 68, 0.2)';
                }
            }
            
            // Update scoring page dot
            if (scoringDot) {
                scoringDot.style.background = isOnline ? '#10b981' : '#ef4444';
                scoringDot.title = isOnline ? 'Online - Syncing' : 'Offline - Local only';
            }
            
            // Also update management page status if visible
            updateManagementConnectionStatus();
        }
        
        function updateManagementConnectionStatus() {
            const manageDot = document.getElementById('manageConnectionDot');
            const manageText = document.getElementById('manageConnectionText');
            
            if (manageDot && manageText) {
                if (isOnline) {
                    manageDot.style.background = '#10b981';
                    manageText.textContent = 'Connected - Real-time sync active';
                    manageText.style.color = '#065f46';
                } else {
                    manageDot.style.background = '#ef4444';
                    manageText.textContent = 'Offline - Changes saved locally';
                    manageText.style.color = '#991b1b';
                }
            }
        }
        
        // Listen for online/offline events
        window.addEventListener('online', () => {
            updateConnectionStatus();
            showNotification('Back Online', 'Syncing scores...');
            // Try to sync any pending changes
            if (activeTournamentId && tournamentData) {
                saveToLocalStorage();
            }
        });
        
        window.addEventListener('offline', () => {
            updateConnectionStatus();
            showNotification('Offline', 'Scores will be saved locally');
        });
        
        // Initialize connection status on page load
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(updateConnectionStatus, 500);
        });
        
        function selectScoringMode(mode) {
            // Always use multi-device mode now
            tournamentMode = 'multi';
            requestNotificationPermission();
        }
        
        // Show join tournament screen
        // Track selected players for joining
        let joinSelections = {
            claim: [],  // Players to score for
            watch: [],  // Players to watch
            tournamentId: null
        };
        
        function showJoinTournamentScreen(tournamentId) {
            // Reset selections
            joinSelections = { claim: [], watch: [], tournamentId: tournamentId };
            
            // Load tournament info
            db.collection('tournaments').doc(tournamentId).get()
                .then(doc => {
                    if (doc.exists) {
                        const tournament = doc.data();
                        const infoEl = document.getElementById('joinTournamentInfo');
                        infoEl.textContent = `${tournament.course} â¢ ${tournament.date} â¢ ${tournament.gameType}`;
                        
                        // Show existing players if any
                        if (tournament.players && tournament.players.length > 0) {
                            document.getElementById('joinExistingPlayers').style.display = 'block';
                            document.getElementById('joinDivider').style.display = 'block';
                            document.getElementById('joinBottomOptions').style.display = 'block';
                            const listEl = document.getElementById('existingPlayersList');
                            
                            listEl.innerHTML = tournament.players.map((p, index) => {
                                const colors = [
                                    { bg: '#dbeafe', border: '#3b82f6', text: '#1e40af' },
                                    { bg: '#fef3c7', border: '#f59e0b', text: '#92400e' },
                                    { bg: '#d1fae5', border: '#10b981', text: '#065f46' },
                                    { bg: '#fce7f3', border: '#ec4899', text: '#9f1239' },
                                    { bg: '#e0e7ff', border: '#6366f1', text: '#3730a3' },
                                ];
                                const color = colors[index % colors.length];
                                const isClaimed = p.claimedBy;
                                
                                return `
                                    <div id="playerRow_${index}" class="join-player-row" data-player="${p.name}" data-handicap="${p.handicap}" data-index="${index}"
                                        style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                                        
                                        <!-- Player Info Button -->
                                        <div style="flex: 1; padding: 14px 16px; background: ${isClaimed ? '#f1f5f9' : color.bg}; border: 2px solid ${isClaimed ? '#94a3b8' : color.border}; border-radius: 10px; opacity: ${isClaimed ? '0.6' : '1'};">
                                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                                <span style="display: flex; align-items: center; gap: 10px; color: ${isClaimed ? '#64748b' : color.text}; font-weight: 600;">
                                                    <span style="font-size: 20px;">${isClaimed ? 'ð' : 'â³'}</span>
                                                    <span>${p.name}</span>
                                                </span>
                                                <span style="background: white; padding: 3px 10px; border-radius: 16px; font-size: 13px; font-weight: 700; color: ${isClaimed ? '#64748b' : color.text};">
                                                    ${p.handicap}
                                                </span>
                                            </div>
                                        </div>
                                        
                                        ${!isClaimed ? `
                                        <!-- Claim Button -->
                                        <button type="button" onclick="toggleJoinSelection(${index}, 'claim', '${p.name}')" id="claimBtn_${index}"
                                            style="width: 48px; height: 48px; border-radius: 10px; border: 2px solid #10b981; background: white; color: #10b981; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;"
                                            title="Score for this player">
                                            â
                                        </button>
                                        
                                        <!-- Watch Button -->
                                        <button type="button" onclick="toggleJoinSelection(${index}, 'watch', '${p.name}')" id="watchBtn_${index}"
                                            style="width: 48px; height: 48px; border-radius: 10px; border: 2px solid #64748b; background: white; color: #64748b; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;"
                                            title="Watch this player">
                                            ð
                                        </button>
                                        ` : `
                                        <div style="width: 104px; text-align: center; font-size: 11px; color: #64748b;">Claimed</div>
                                        `}
                                    </div>
                                `;
                            }).join('');
                        } else {
                            document.getElementById('joinExistingPlayers').style.display = 'none';
                            document.getElementById('joinDivider').style.display = 'block';
                            document.getElementById('joinBottomOptions').style.display = 'block';
                        }
                        
                        // Hide join button initially
                        document.getElementById('joinTournamentBtnContainer').style.display = 'none';
                        document.getElementById('selectionSummary').style.display = 'none';
                        
                        showPage('joinPage');
                        
                        // Store tournament ID for form submission
                        document.getElementById('joinTournamentForm').dataset.tournamentId = tournamentId;
                    } else {
                        alert('Tournament not found!');
                    }
                })
                .catch(error => {
                    console.error('Error loading tournament:', error);
                    alert('Failed to load tournament');
                });
        }
        
        function toggleJoinSelection(index, type, playerName) {
            const claimBtn = document.getElementById(`claimBtn_${index}`);
            const watchBtn = document.getElementById(`watchBtn_${index}`);
            
            if (type === 'claim') {
                const idx = joinSelections.claim.indexOf(playerName);
                if (idx > -1) {
                    // Deselect claim
                    joinSelections.claim.splice(idx, 1);
                    claimBtn.style.background = 'white';
                    claimBtn.style.color = '#10b981';
                } else {
                    // Select claim, remove from watch if there
                    joinSelections.claim.push(playerName);
                    claimBtn.style.background = '#10b981';
                    claimBtn.style.color = 'white';
                    
                    // Remove from watch
                    const watchIdx = joinSelections.watch.indexOf(playerName);
                    if (watchIdx > -1) {
                        joinSelections.watch.splice(watchIdx, 1);
                        watchBtn.style.background = 'white';
                        watchBtn.style.color = '#64748b';
                    }
                }
            } else if (type === 'watch') {
                const idx = joinSelections.watch.indexOf(playerName);
                if (idx > -1) {
                    // Deselect watch
                    joinSelections.watch.splice(idx, 1);
                    watchBtn.style.background = 'white';
                    watchBtn.style.color = '#64748b';
                } else {
                    // Select watch, remove from claim if there
                    joinSelections.watch.push(playerName);
                    watchBtn.style.background = '#64748b';
                    watchBtn.style.color = 'white';
                    
                    // Remove from claim
                    const claimIdx = joinSelections.claim.indexOf(playerName);
                    if (claimIdx > -1) {
                        joinSelections.claim.splice(claimIdx, 1);
                        claimBtn.style.background = 'white';
                        claimBtn.style.color = '#10b981';
                    }
                }
            }
            
            updateJoinSelectionUI();
        }
        
        function updateJoinSelectionUI() {
            const hasSelections = joinSelections.claim.length > 0 || joinSelections.watch.length > 0;
            
            document.getElementById('joinTournamentBtnContainer').style.display = hasSelections ? 'block' : 'none';
            document.getElementById('selectionSummary').style.display = hasSelections ? 'block' : 'none';
            document.getElementById('claimCount').textContent = joinSelections.claim.length;
            document.getElementById('watchCount').textContent = joinSelections.watch.length;
        }
        
        async function executeJoinTournament() {
            if (joinSelections.claim.length === 0 && joinSelections.watch.length === 0) {
                showNotification('Select Players', 'Please select at least one player to claim or watch');
                return;
            }
            
            // If claiming players, need initials
            if (joinSelections.claim.length > 0) {
                const initials = prompt('Enter your initials (so host knows who\'s scoring):');
                if (!initials) return;
                localStorage.setItem('userInitials', initials.toUpperCase());
            }
            
            try {
                const tournamentId = joinSelections.tournamentId;
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Claim selected players
                for (const playerName of joinSelections.claim) {
                    const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                    if (playerIndex > -1 && !tournament.players[playerIndex].claimedBy) {
                        tournament.players[playerIndex].claimedBy = currentDeviceId;
                    }
                }
                
                // Initialize devices if needed
                if (!tournament.devices) tournament.devices = {};
                const userInitials = localStorage.getItem('userInitials') || 'Guest';
                tournament.devices[currentDeviceId] = {
                    name: userInitials,
                    initials: userInitials,
                    joinedAt: new Date().toISOString()
                };
                
                // Save to Firebase
                await tournamentRef.update({
                    players: tournament.players,
                    devices: tournament.devices,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Set local state
                activeTournamentId = tournamentId;
                tournamentMode = 'multi';
                isHost = false;
                isGuestUser = true;
                claimedPlayers = joinSelections.claim;
                playerOrder.watching = joinSelections.watch;
                savePlayerOrder();
                
                // Load tournament data
                tournamentData = {
                    id: tournamentId,
                    name: tournament.name || '',
                    date: tournament.date,
                    gameType: tournament.gameType,
                    course: tournament.course,
                    players: tournament.players,
                    teams: tournament.teams || []
                };
                
                saveToLocalStorage();
                subscribToTournamentUpdates(tournamentId);
                
                // Navigate based on what was selected
                if (joinSelections.claim.length > 0) {
                    renderScoringPage();
                    showPage('scoringPage');
                    switchToHoleView();
                    showNotification('Ready!', `Scoring for ${joinSelections.claim.join(', ')}`);
                } else {
                    renderScoringPage();
                    showPage('scoringPage');
                    showNotification('Watching', `Following ${joinSelections.watch.join(', ')}`);
                }
            } catch (error) {
                console.error('Error joining tournament:', error);
                showNotification('Error', 'Failed to join tournament');
            }
        }
        
        async function joinAsViewer() {
            try {
                const tournamentId = joinSelections.tournamentId;
                const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                const tournament = tournamentDoc.data();
                
                // Set local state as viewer only
                activeTournamentId = tournamentId;
                tournamentMode = 'multi';
                isHost = false;
                isGuestUser = true;
                claimedPlayers = [];
                
                tournamentData = {
                    id: tournamentId,
                    name: tournament.name || '',
                    date: tournament.date,
                    gameType: tournament.gameType,
                    course: tournament.course,
                    players: tournament.players,
                    teams: tournament.teams || []
                };
                
                saveToLocalStorage();
                subscribToTournamentUpdates(tournamentId);
                renderScoringPage();
                showPage('scoringPage');
                showNotification('Viewing', 'Watching the tournament');
            } catch (error) {
                console.error('Error joining as viewer:', error);
                showNotification('Error', 'Failed to join');
            }
        }
        
        function showAddNewPlayerForm() {
            document.getElementById('joinExistingPlayers').style.display = 'none';
            document.getElementById('joinDivider').style.display = 'none';
            document.getElementById('joinBottomOptions').style.display = 'none';
            document.getElementById('joinTournamentBtnContainer').style.display = 'none';
            document.getElementById('joinTournamentForm').style.display = 'block';
        }
        
        function hideAddNewPlayerForm() {
            document.getElementById('joinExistingPlayers').style.display = 'block';
            document.getElementById('joinDivider').style.display = 'block';
            document.getElementById('joinBottomOptions').style.display = 'block';
            document.getElementById('joinTournamentForm').style.display = 'none';
            updateJoinSelectionUI();
        }
        
        // Handle join tournament form submission
        document.addEventListener('DOMContentLoaded', () => {
            // Set default date to today
            const today = new Date();
            const dateStr = today.toISOString().split('T')[0];
            const dateInput = document.getElementById('tournamentDate');
            if (dateInput && !dateInput.value) {
                dateInput.value = dateStr;
            }
            
            // Check if URL has join parameter
            checkForJoinLink();
            
            const joinForm = document.getElementById('joinTournamentForm');
            if (joinForm) {
                joinForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const tournamentId = joinForm.dataset.tournamentId;
                    const playerInfo = {
                        name: document.getElementById('joinPlayerName').value.trim(),
                        handicap: parseFloat(document.getElementById('joinPlayerHandicap').value) || 0,
                        email: document.getElementById('joinPlayerEmail').value.trim(),
                        phone: document.getElementById('joinPlayerPhone').value.trim()
                    };
                    
                    const success = await joinTournament(tournamentId, playerInfo);
                    
                    if (success) {
                        isGuestUser = true; // Mark as guest - no home access
                        showNotification('Joined!', 'You\'ve joined the tournament');
                        // Navigate to scoring
                        renderScoringPage();
                        showPage('scoringPage');
                    }
                });
            }
        });
        
        // Show handicap confirmation dialog
        function showHandicapConfirmDialog(tournamentId, playerName, currentHandicap) {
            const dialog = document.getElementById('handicapConfirmDialog');
            const nameEl = document.getElementById('handicapConfirmPlayerName');
            const handicapInput = document.getElementById('handicapConfirmInput');
            const initialsInput = document.getElementById('initialsInput');
            const cancelBtn = document.getElementById('handicapConfirmCancel');
            const okBtn = document.getElementById('handicapConfirmOk');
            
            nameEl.textContent = `Claiming: ${playerName}`;
            handicapInput.value = currentHandicap;
            
            // Pre-fill initials if saved
            const savedInitials = localStorage.getItem('userInitials') || '';
            initialsInput.value = savedInitials;
            
            dialog.style.display = 'flex';
            
            // Focus on initials input if empty, otherwise handicap
            setTimeout(() => {
                if (!savedInitials) {
                    initialsInput.focus();
                } else {
                    handicapInput.focus();
                }
            }, 100);
            
            // Auto-uppercase initials
            initialsInput.addEventListener('input', (e) => {
                e.target.value = e.target.value.toUpperCase();
            });
            
            // Cancel handler
            const handleCancel = () => {
                dialog.style.display = 'none';
                cancelBtn.removeEventListener('click', handleCancel);
                okBtn.removeEventListener('click', handleOk);
            };
            
            // OK handler
            const handleOk = () => {
                const initials = initialsInput.value.trim().toUpperCase();
                if (!initials) {
                    alert('Please enter your initials');
                    initialsInput.focus();
                    return;
                }
                
                const confirmedHandicap = parseInt(handicapInput.value) || 0;
                
                // Save initials for next time
                localStorage.setItem('userInitials', initials);
                
                dialog.style.display = 'none';
                cancelBtn.removeEventListener('click', handleCancel);
                okBtn.removeEventListener('click', handleOk);
                
                selectExistingPlayer(tournamentId, playerName, confirmedHandicap, initials);
            };
            
            cancelBtn.addEventListener('click', handleCancel);
            okBtn.addEventListener('click', handleOk);
            
            // Enter key to confirm on both inputs
            const handleEnterKey = (e) => {
                if (e.key === 'Enter') {
                    handleOk();
                }
            };
            
            handicapInput.addEventListener('keyup', handleEnterKey);
            initialsInput.addEventListener('keyup', handleEnterKey);
        }
        
        // Select existing player when joining
        async function selectExistingPlayer(tournamentId, playerName, confirmedHandicap, userInitials) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) {
                    alert('Player not found!');
                    return;
                }
                
                const player = tournament.players[playerIndex];
                
                // Check if already claimed
                if (player.claimedBy) {
                    alert(`${playerName} is already being scored by another device!`);
                    return;
                }
                
                // Initialize devices object if it doesn't exist
                if (!tournament.devices) {
                    tournament.devices = {};
                }
                
                // Create or update device entry with initials
                if (userInitials) {
                    tournament.devices[currentDeviceId] = {
                        name: userInitials,
                        initials: userInitials,
                        joinedAt: new Date().toISOString()
                    };
                }
                
                // Update handicap if provided
                if (confirmedHandicap !== undefined && confirmedHandicap !== player.handicap) {
                    tournament.players[playerIndex].handicap = confirmedHandicap;
                }
                
                // Save changes before claiming
                await tournamentRef.update({
                    players: tournament.players,
                    devices: tournament.devices,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Claim this player
                const claimed = await claimAdditionalPlayer(tournamentId, playerName);
                if (claimed) {
                    activeTournamentId = tournamentId;
                    tournamentMode = 'multi';
                    isHost = false; // Not the host, just a participant
                    
                    // Add to claimed players list if not already there
                    if (!claimedPlayers.includes(playerName)) {
                        claimedPlayers.push(playerName);
                    }
                    
                    // Load tournament data into local tournamentData
                    tournamentData = {
                        id: tournamentId,
                        name: tournament.name || '',
                        date: tournament.date,
                        gameType: tournament.gameType,
                        course: tournament.course,
                        players: tournament.players,
                        teams: tournament.teams || []
                    };
                    
                    // Save to localStorage
                    saveToLocalStorage();
                    
                    // Subscribe to updates
                    subscribToTournamentUpdates(tournamentId);
                    
                    // Check if we should return to My Players page
                    if (claimingFromMyPlayersModal || window.returnToMyPlayersPage) {
                        claimingFromMyPlayersModal = false;
                        window.returnToMyPlayersPage = false;
                        showNotification('Claimed!', `Now scoring for ${playerName}`);
                        showMyPlayersPage(); // Return to My Players page
                    } else {
                        // FIXED: Ensure scoring page shows content by defaulting to Hole View
                        currentView = 'hole'; // Force hole view
                        renderScoringPage();
                        showPage('scoringPage');
                        
                        // Delay hole view render to ensure tournamentData is fully loaded
                        setTimeout(() => {
                            switchToHoleView();
                        }, 100);
                        
                        showNotification('Ready to Score!', `You're scoring for ${playerName}`);
                    }
                }
            } catch (error) {
                console.error('Error selecting player:', error);
                alert('Failed to select player');
            }
        }
        
        // Handle leaderboard action button click
        function handleLeaderboardAction() {
            // If user has claimed players and tournament data loaded, go to scoring
            if (activeTournamentId && tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                renderScoringPage();
                showPage('scoringPage');
                switchToHoleView();
            } else {
                // Otherwise go to setup page
                showPage('setupPage');
            }
        }
        
        // Show list of unclaimed players for additional claims
        async function showClaimPlayersList() {
            if (!activeTournamentId) {
                showNotification('Error', 'No active tournament');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const modal = document.getElementById('claimPlayersModal');
                const content = document.getElementById('claimPlayersListContent');
                
                // Filter unclaimed players
                const unclaimedPlayers = tournament.players.filter(p => !p.claimedBy);
                
                if (unclaimedPlayers.length === 0) {
                    content.innerHTML = `
                        <div style="text-align: center; padding: 40px 20px;">
                            <p style="font-size: 40px; margin-bottom: 12px;">â</p>
                            <p style="color: #64748b; font-size: 16px;">All players have been claimed!</p>
                        </div>
                    `;
                } else {
                    content.innerHTML = unclaimedPlayers.map((p, index) => {
                        const colors = [
                            { bg: '#dbeafe', border: '#3b82f6', text: '#1e40af' },
                            { bg: '#fef3c7', border: '#f59e0b', text: '#92400e' },
                            { bg: '#d1fae5', border: '#10b981', text: '#065f46' },
                            { bg: '#fce7f3', border: '#ec4899', text: '#9f1239' },
                            { bg: '#e0e7ff', border: '#6366f1', text: '#3730a3' },
                        ];
                        const color = colors[index % colors.length];
                        
                        return `
                            <button type="button"
                                onclick="claimAdditionalPlayerFromList('${p.name}', ${p.handicap})"
                                style="
                                    width: 100%;
                                    padding: 16px;
                                    margin-bottom: 12px;
                                    background: ${color.bg};
                                    border: 2px solid ${color.border};
                                    border-radius: 12px;
                                    color: ${color.text};
                                    font-size: 16px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    display: flex;
                                    align-items: center;
                                    justify-content: space-between;
                                    transition: all 0.2s;
                                ">
                                <span style="display: flex; align-items: center; gap: 12px;">
                                    <span style="font-size: 24px;">â³</span>
                                    <span>${p.name}</span>
                                </span>
                                <span style="background: white; padding: 4px 12px; border-radius: 20px; font-size: 14px;">
                                    HCP ${p.handicap}
                                </span>
                            </button>
                        `;
                    }).join('');
                }
                
                modal.style.display = 'flex';
            } catch (error) {
                console.error('Error loading players:', error);
                showNotification('Error', 'Failed to load players');
            }
        }
        
        // Claim additional player from the list
        function claimAdditionalPlayerFromList(playerName, currentHandicap) {
            // Close the modal
            document.getElementById('claimPlayersModal').style.display = 'none';
            // Show handicap confirmation dialog
            showHandicapConfirmDialog(activeTournamentId, playerName, currentHandicap);
        }
        
        // Update Live leaderboard display
        function updateLiveLeaderboard(tournament) {
            if (!tournament || !tournament.players) return;
            
            // Update tournament info header
            const infoEl = document.getElementById('liveLeaderboardInfo');
            if (infoEl) {
                let infoText = tournament.date || '';
                if (tournament.name) {
                    infoText = tournament.name + (tournament.date ? ' â¢ ' + tournament.date : '');
                }
                infoEl.textContent = infoText;
            }
            
            const content = document.getElementById('liveLeaderboardContent');
            if (!content) return;
            
            // Get current game type from tabs or use first enabled game
            const enabledGames = tournament.enabledGames || [tournament.gameType];
            const currentGame = document.querySelector('.game-tab.active')?.dataset.gameType || enabledGames[0];
            
            // Calculate results for current game
            const results = calculateGameResults(tournament.players, currentGame, tournament.course);
            
            // Render leaderboard
            content.innerHTML = results.map((player, index) => {
                const medal = index === 0 ? 'ð¥' : index === 1 ? 'ð¥' : index === 2 ? 'ð¥' : '';
                const rankClass = index === 0 ? 'first' : index === 1 ? 'second' : index === 2 ? 'third' : '';
                
                return `
                    <div class="leaderboard-entry ${rankClass}">
                        <div class="leaderboard-rank">${medal || (index + 1) + '.'}</div>
                        <div class="leaderboard-name">${player.name}</div>
                        <div class="leaderboard-score">${player.displayScore}</div>
                    </div>
                `;
            }).join('');
            
            // Update info
            document.getElementById('activePlayersCount').textContent = tournament.players.length;
            document.getElementById('lastUpdateTime').textContent = 'Just now';
            
            // Update action button based on whether user can score
            const actionBtn = document.getElementById('leaderboardActionBtn');
            if (actionBtn) {
                if (activeTournamentId && tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                    actionBtn.textContent = 'Start Scoring â³';
                    actionBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                    actionBtn.style.boxShadow = '0 4px 12px rgba(16, 185, 129, 0.4)';
                } else {
                    actionBtn.textContent = 'Back to Home';
                    actionBtn.style.background = '#94a3b8';
                    actionBtn.style.boxShadow = 'none';
                }
            }
        }
        
        // Calculate game results (simplified version)
        function calculateGameResults(players, gameType, course) {
            // This is a simplified calculation - full logic would match your existing results calculation
            return players.map(player => {
                const totalScore = player.scores.reduce((sum, score) => sum + (score || 0), 0);
                const par = courses[course]?.totalPar || 72;
                const toPar = totalScore - par;
                const displayScore = toPar >= 0 ? `+${toPar}` : toPar;
                
                return {
                    name: player.name,
                    totalScore,
                    toPar,
                    displayScore: `${totalScore} (${displayScore})`
                };
            }).sort((a, b) => a.totalScore - b.totalScore);
        }
        
        // Render game toggle tabs
        function renderGameTabs(enabledGames) {
            const tabsContainer = document.getElementById('gameToggleTabs');
            if (!tabsContainer) return;
            
            const gameLabels = {
                'Stroke Play Gross': 'Gross',
                'Stroke Play Net': 'Net',
                'Gross Skins': 'Skins',
                'Net Skins (Full Hcp)': 'Net Skins',
                'Stableford': 'Stableford'
            };
            
            tabsContainer.innerHTML = enabledGames.map((game, index) => `
                <button class="game-tab ${index === 0 ? 'active' : ''}" data-game-type="${game}" onclick="switchGameTab('${game}')">
                    ${gameLabels[game] || game}
                </button>
            `).join('');
        }
        
        // Switch active game tab
        function switchGameTab(gameType) {
            document.querySelectorAll('.game-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.gameType === gameType);
            });
            
            // Reload leaderboard for new game type
            if (activeTournamentId) {
                db.collection('tournaments').doc(activeTournamentId).get()
                    .then(doc => {
                        if (doc.exists) {
                            updateLiveLeaderboard(doc.data());
                        }
                    });
            }
        }

        // ========================================
        // MAIN SCORING FUNCTION (MODIFIED FOR CLOUD)
        // ========================================
        
        function startScoring() {
            const date = document.getElementById('tournamentDate').value;
            const tournamentName = document.getElementById('tournamentName').value.trim();
            const gameType = document.getElementById('gameType').value;
            const selectedCourse = document.getElementById('courseSelect').value;
            
            // Validate date selection
            if (!date) {
                alert('Please select a date');
                return;
            }
            
            // Validate game type selection
            if (!gameType) {
                alert('Please select a game type');
                return;
            }
            
            // Validate course selection
            if (!selectedCourse) {
                alert('Please select a course');
                return;
            }
            
            // Update course data
            courseData = courses[selectedCourse];
            
            const players = [];
            // Loop through all player rows (they may not be sequential)
            const playerRows = document.querySelectorAll('.player-row');
            playerRows.forEach(row => {
                const playerId = row.getAttribute('data-player');
                const nameInput = document.getElementById(`player${playerId}`);
                const hcpInput = document.getElementById(`hcp${playerId}`);
                
                if (nameInput && hcpInput) {
                    const name = nameInput.value.trim();
                    const hcp = parseInt(hcpInput.value) || 0;
                    if (name) {
                        players.push({
                            name: name,
                            handicap: hcp,
                            scores: new Array(18).fill(0)
                        });
                    }
                }
            });

            if (players.length === 0) {
                alert('Please enter at least one player name');
                return;
            }

            // Save players to history
            players.forEach(player => {
                updatePlayerHistory(player.name, player.handicap);
            });

            // Capture team assignments for Best Ball games
            let teams = [];
            if (gameType.includes('Best Ball')) {
                const numTeams = 2;
                const playersPerTeam = gameType === '2-Man Best Ball' ? 2 : gameType === '3-Man Best Ball' ? 3 : 4;
                
                for (let t = 0; t < numTeams; t++) {
                    const teamPlayers = [];
                    for (let p = 0; p < playersPerTeam; p++) {
                        const playerIndex = document.getElementById(`team${t}_player${p}`).value;
                        if (playerIndex !== '') {
                            teamPlayers.push(parseInt(playerIndex));
                        }
                    }
                    if (teamPlayers.length > 0) {
                        teams.push(teamPlayers);
                    }
                }
                
                if (teams.length < 2) {
                    alert('Please assign players to both teams');
                    return;
                }
            }

            tournamentData = {
                id: generateTournamentId(),
                name: tournamentName || '', // Optional tournament name
                date: date,
                gameType: gameType,
                course: selectedCourse,
                players: players,
                teams: teams
            };

            // Hide Resume button when starting fresh
            const resumeBtn = document.getElementById('resumeScoringBtn');
            if (resumeBtn) {
                resumeBtn.style.display = 'none';
            }

            // Handle based on scoring mode
            if (tournamentMode === 'multi') {
                // Create cloud tournament
                createCloudTournament({
                    name: tournamentName || '', // Optional tournament name
                    date: date,
                    gameType: gameType,
                    course: selectedCourse,
                    players: players.map(p => ({
                        ...p,
                        scores: new Array(18).fill(null),
                        claimedBy: null // No one claimed yet
                    })),
                    teams: teams,
                    enabledGames: [gameType] // Can add more games later
                }).then(tournamentId => {
                    if (tournamentId) {
                        activeTournamentId = tournamentId;
                        isHost = true;
                        
                        // Subscribe to real-time updates
                        subscribToTournamentUpdates(tournamentId);
                        
                        // Continue to scoring
                        saveToLocalStorage();
                        renderScoringPage();
                        showPage('scoringPage');
                        switchToHoleView();
                        
                        // Show notification
                        showNotification('Tournament Created!', 'Go back to Setup page to share QR/Link');
                    } else {
                        // If tournament creation returned null (shouldn't happen with throw, but just in case)
                        console.error('Tournament creation returned null');
                        throw new Error('Tournament creation failed');
                    }
                }).catch(error => {
                    console.error('Tournament creation error:', error);
                    
                    // Show single consolidated error message
                    const errorMsg = error.message || 'Unknown error';
                    showNotification('Multi-Device Mode Failed', `Switching to Single-Device mode. Error: ${errorMsg}`, true);
                    
                    // Fall back to single-device mode
                    tournamentMode = 'single';
                    document.getElementById('singleDeviceBtn').classList.add('active');
                    document.getElementById('multiDeviceBtn').classList.remove('active');
                    
                    saveToLocalStorage();
                    renderScoringPage();
                    showPage('scoringPage');
                    switchToHoleView();
                });
            } else {
                // Single-device mode - existing behavior
                saveToLocalStorage();
                renderScoringPage();
                showPage('scoringPage');
                switchToHoleView();
            }
        }

        // Show player management page (host only)
        async function showPlayerManagement() {
            if (!activeTournamentId || !canManageTournament()) {
                showNotification('Not Available', 'Only hosts and co-hosts can manage the tournament');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Populate tournament details form
                document.getElementById('manageTournamentName').value = tournament.name || '';
                document.getElementById('manageTournamentDate').value = tournament.date || '';
                
                // Populate course dropdown
                const courseSelect = document.getElementById('manageTournamentCourse');
                courseSelect.innerHTML = '';
                Object.keys(courses).forEach(courseKey => {
                    const option = document.createElement('option');
                    option.value = courseKey;
                    option.textContent = courses[courseKey].name;
                    if (courseKey === tournament.course) {
                        option.selected = true;
                    }
                    courseSelect.appendChild(option);
                });
                
                // Update connection status
                const statusDiv = document.getElementById('managementConnectionStatus');
                if (statusDiv) {
                    if (isOnline) {
                        statusDiv.innerHTML = `
                            <span style="width: 8px; height: 8px; border-radius: 50%; background: #10b981;"></span>
                            <span style="color: #059669; font-size: 12px; font-weight: 500;">Connected</span>
                        `;
                        statusDiv.parentElement.style.background = '#f0fdf4';
                        statusDiv.parentElement.style.borderColor = '#10b981';
                    } else {
                        statusDiv.innerHTML = `
                            <span style="width: 8px; height: 8px; border-radius: 50%; background: #ef4444;"></span>
                            <span style="color: #991b1b; font-size: 12px; font-weight: 500;">Offline</span>
                        `;
                        statusDiv.parentElement.style.background = '#fef2f2';
                        statusDiv.parentElement.style.borderColor = '#fca5a5';
                    }
                }
                
                // Generate player cards with reorder buttons
                const content = document.getElementById('playerManagementContent');
                const playerCount = tournament.players.length;
                
                content.innerHTML = tournament.players.map((p, index) => {
                    const claimedDevice = p.claimedBy ? tournament.devices[p.claimedBy] : null;
                    const isHostPlayer = p.claimedBy === currentDeviceId;
                    const deviceDisplay = claimedDevice ? (claimedDevice.initials || claimedDevice.name) : null;
                    const holesPlayed = p.scores ? p.scores.filter(s => s !== null && s !== undefined).length : 0;
                    const totalScore = p.scores ? p.scores.reduce((sum, s) => sum + (s || 0), 0) : 0;
                    
                    return `
                        <div style="
                            background: ${p.claimedBy ? '#f0fdf4' : 'white'};
                            border: 1.5px solid ${p.claimedBy ? '#10b981' : '#e2e8f0'};
                            border-radius: 8px;
                            padding: 10px;
                            margin-bottom: 8px;
                            display: flex;
                            align-items: center;
                            gap: 8px;
                        ">
                            <!-- Reorder Buttons -->
                            <div style="display: flex; flex-direction: column; gap: 2px;">
                                <button onclick="movePlayerUp(${index})" ${index === 0 ? 'disabled' : ''} style="width: 24px; height: 20px; border: none; background: ${index === 0 ? '#e2e8f0' : '#dbeafe'}; color: ${index === 0 ? '#94a3b8' : '#3b82f6'}; border-radius: 4px; font-size: 10px; cursor: ${index === 0 ? 'default' : 'pointer'}; display: flex; align-items: center; justify-content: center;">â</button>
                                <button onclick="movePlayerDown(${index})" ${index === playerCount - 1 ? 'disabled' : ''} style="width: 24px; height: 20px; border: none; background: ${index === playerCount - 1 ? '#e2e8f0' : '#dbeafe'}; color: ${index === playerCount - 1 ? '#94a3b8' : '#3b82f6'}; border-radius: 4px; font-size: 10px; cursor: ${index === playerCount - 1 ? 'default' : 'pointer'}; display: flex; align-items: center; justify-content: center;">â</button>
                            </div>
                            
                            <!-- Player Info -->
                            <div style="flex: 1; min-width: 0;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <span style="font-weight: 600; color: #1e293b; font-size: 14px;">${p.name}</span>
                                        <span style="color: #64748b; font-size: 12px;">(${p.handicap})</span>
                                    </div>
                                    <div style="text-align: right;">
                                        ${p.claimedBy ? `
                                            <span style="color: #10b981; font-size: 11px; font-weight: 600;">â ${deviceDisplay}</span>
                                        ` : `
                                            <span style="color: #94a3b8; font-size: 11px;">Unclaimed</span>
                                        `}
                                    </div>
                                </div>
                                <div style="font-size: 11px; color: #64748b; margin-top: 2px;">
                                    ${holesPlayed > 0 ? `${holesPlayed} holes â¢ Score: ${totalScore}` : 'No scores yet'}
                                </div>
                            </div>
                            
                            <!-- Action Buttons -->
                            <div style="display: flex; gap: 4px; flex-shrink: 0;">
                                ${p.claimedBy && !isHostPlayer ? `
                                    <button onclick="unclaimPlayer('${p.name}')" style="padding: 4px 6px; background: white; color: #64748b; border: 1px solid #d1d5db; border-radius: 4px; font-size: 10px; cursor: pointer;">Release</button>
                                ` : ''}
                                <button onclick="editPlayerFromManagement('${p.name}', ${p.handicap})" style="padding: 4px 6px; background: #dbeafe; color: #1e40af; border: none; border-radius: 4px; font-size: 10px; cursor: pointer;">Edit</button>
                                <button onclick="deletePlayerFromTournament('${p.name}')" style="padding: 4px 6px; background: #fee2e2; color: #dc2626; border: none; border-radius: 4px; font-size: 10px; cursor: pointer;">ðï¸</button>
                            </div>
                        </div>
                    `;
                }).join('');
                
                if (tournament.players.length === 0) {
                    content.innerHTML = '<p style="text-align: center; color: #64748b; padding: 20px;">No players added yet</p>';
                }
                
                showPage('playerManagementPage');
                
                // Render co-hosts section (host only)
                renderCoHostsSection();
            } catch (error) {
                console.error('Error loading tournament management:', error);
                showNotification('Error', 'Failed to load tournament management');
            }
        }
        
        // Move player up in the list
        async function movePlayerUp(index) {
            if (index <= 0) return;
            await swapPlayers(index, index - 1);
        }
        
        // Move player down in the list
        async function movePlayerDown(index) {
            if (!tournamentData || index >= tournamentData.players.length - 1) return;
            await swapPlayers(index, index + 1);
        }
        
        // Swap two players in the list
        async function swapPlayers(indexA, indexB) {
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Swap players
                const temp = tournament.players[indexA];
                tournament.players[indexA] = tournament.players[indexB];
                tournament.players[indexB] = temp;
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update local data
                tournamentData.players = tournament.players;
                saveToLocalStorage();
                
                // Refresh the page
                showPlayerManagement();
            } catch (error) {
                console.error('Error reordering players:', error);
                showNotification('Error', 'Failed to reorder players');
            }
        }
        
        // ========================================
        // CO-HOST MANAGEMENT FUNCTIONS
        // ========================================
        
        // Render co-hosts section in management page
        async function renderCoHostsSection() {
            const section = document.getElementById('coHostsSection');
            const content = document.getElementById('coHostsContent');
            
            if (!section || !content) return;
            
            // Only show for the original host (not co-hosts)
            if (!isHost) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const coHosts = tournament.coHosts || [];
                const devices = tournament.devices || {};
                
                // Get list of devices that could be promoted (connected, not host, not already co-host)
                const availableDevices = Object.entries(devices).filter(([deviceId, device]) => {
                    return deviceId !== currentDeviceId && !coHosts.includes(deviceId);
                });
                
                let html = '';
                
                // Current co-hosts
                if (coHosts.length > 0) {
                    html += '<div style="margin-bottom: 10px;">';
                    coHosts.forEach(coHostId => {
                        const device = devices[coHostId];
                        const displayName = device ? (device.initials || device.name || 'Unknown') : 'Unknown Device';
                        html += `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: white; border: 1px solid #c4b5fd; border-radius: 6px; margin-bottom: 6px;">
                                <span style="font-size: 13px; color: #5b21b6; font-weight: 500;">ð ${displayName}</span>
                                <button onclick="removeCoHost('${coHostId}')" style="padding: 4px 8px; background: #fee2e2; color: #dc2626; border: none; border-radius: 4px; font-size: 11px; cursor: pointer;">Remove</button>
                            </div>
                        `;
                    });
                    html += '</div>';
                }
                
                // Available devices to promote
                if (availableDevices.length > 0) {
                    html += `
                        <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                            ${availableDevices.map(([deviceId, device]) => {
                                const displayName = device.initials || device.name || 'Device';
                                return `
                                    <button onclick="addCoHost('${deviceId}')" style="padding: 6px 10px; background: white; color: #7c3aed; border: 1.5px solid #c4b5fd; border-radius: 6px; font-size: 11px; font-weight: 500; cursor: pointer;">
                                        + ${displayName}
                                    </button>
                                `;
                            }).join('')}
                        </div>
                    `;
                } else if (coHosts.length === 0) {
                    html += '<p style="font-size: 12px; color: #8b5cf6; margin: 0;">No other devices connected yet. Share the link to add co-hosts.</p>';
                }
                
                content.innerHTML = html;
            } catch (error) {
                console.error('Error rendering co-hosts:', error);
                content.innerHTML = '<p style="font-size: 12px; color: #dc2626; margin: 0;">Error loading co-hosts</p>';
            }
        }
        
        // Add a device as co-host
        async function addCoHost(deviceId) {
            if (!isHost) {
                showNotification('Not Authorized', 'Only the host can add co-hosts');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const coHosts = tournament.coHosts || [];
                
                if (!coHosts.includes(deviceId)) {
                    coHosts.push(deviceId);
                    
                    await tournamentRef.update({
                        coHosts: coHosts,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    const device = tournament.devices[deviceId];
                    const displayName = device ? (device.initials || device.name) : 'Device';
                    showNotification('Co-host Added', `${displayName} can now manage the tournament`);
                    renderCoHostsSection();
                }
            } catch (error) {
                console.error('Error adding co-host:', error);
                showNotification('Error', 'Failed to add co-host');
            }
        }
        
        // Remove a co-host
        async function removeCoHost(deviceId) {
            if (!isHost) {
                showNotification('Not Authorized', 'Only the host can remove co-hosts');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                let coHosts = tournament.coHosts || [];
                coHosts = coHosts.filter(id => id !== deviceId);
                
                await tournamentRef.update({
                    coHosts: coHosts,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                const device = tournament.devices[deviceId];
                const displayName = device ? (device.initials || device.name) : 'Device';
                showNotification('Co-host Removed', `${displayName} is no longer a co-host`);
                renderCoHostsSection();
            } catch (error) {
                console.error('Error removing co-host:', error);
                showNotification('Error', 'Failed to remove co-host');
            }
        }
        
        // Clear scores for a single player
        async function clearPlayerScores(playerName) {
            if (!confirm(`Clear all scores for ${playerName}?`)) return;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) return;
                
                tournament.players[playerIndex].scores = Array(18).fill(null);
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update local data
                tournamentData.players = tournament.players;
                saveToLocalStorage();
                
                showNotification('Cleared', `Scores cleared for ${playerName}`);
                showPlayerManagement();
            } catch (error) {
                console.error('Error clearing player scores:', error);
                showNotification('Error', 'Failed to clear scores');
            }
        }
        
        // Save tournament details
        async function saveTournamentDetails() {
            const name = document.getElementById('manageTournamentName').value.trim();
            const date = document.getElementById('manageTournamentDate').value;
            const course = document.getElementById('manageTournamentCourse').value;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const oldCourse = tournamentData.course;
                
                await tournamentRef.update({
                    name: name,
                    date: date,
                    course: course,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update local data
                tournamentData.name = name;
                tournamentData.date = date;
                tournamentData.course = course;
                courseData = courses[course];
                saveToLocalStorage();
                
                // Update smart info lines
                generateSmartInfoLine('scoringSmartInfo');
                generateSmartInfoLine('resultsSmartInfo');
                
                if (oldCourse !== course) {
                    showNotification('Saved', 'Tournament details updated. Handicap allocations will be recalculated based on new course.');
                } else {
                    showNotification('Saved', 'Tournament details updated');
                }
            } catch (error) {
                console.error('Error saving tournament details:', error);
                showNotification('Error', 'Failed to save tournament details');
            }
        }
        
        // Confirm delete tournament
        function confirmDeleteTournament() {
            if (!confirm('Are you sure you want to delete this tournament? This cannot be undone.')) return;
            if (!confirm('FINAL WARNING: All scores and data will be permanently deleted. Continue?')) return;
            deleteTournament();
        }
        
        // Delete tournament
        async function deleteTournament() {
            try {
                await db.collection('tournaments').doc(activeTournamentId).delete();
                
                // Clear local data
                localStorage.removeItem('letsgolf_data');
                activeTournamentId = null;
                tournamentData = null;
                isHost = false;
                
                showNotification('Deleted', 'Tournament has been deleted');
                showPage('setupPage');
            } catch (error) {
                console.error('Error deleting tournament:', error);
                showNotification('Error', 'Failed to delete tournament');
            }
        }
        
        // Clear all scores (all 18 holes)
        async function clearAllScores() {
            if (!confirm('Clear ALL scores for ALL players? This cannot be undone.')) return;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                tournament.players.forEach(p => {
                    p.scores = Array(18).fill(null);
                });
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                tournamentData.players = tournament.players;
                saveToLocalStorage();
                
                showNotification('Cleared', 'All scores have been cleared');
                showPlayerManagement();
            } catch (error) {
                console.error('Error clearing scores:', error);
                showNotification('Error', 'Failed to clear scores');
            }
        }
        
        // Clear front 9 scores
        async function clearFront9Scores() {
            if (!confirm('Clear Front 9 scores (holes 1-9) for ALL players?')) return;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                tournament.players.forEach(p => {
                    if (!p.scores) p.scores = Array(18).fill(null);
                    for (let i = 0; i < 9; i++) {
                        p.scores[i] = null;
                    }
                });
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                tournamentData.players = tournament.players;
                saveToLocalStorage();
                
                showNotification('Cleared', 'Front 9 scores have been cleared');
                showPlayerManagement();
            } catch (error) {
                console.error('Error clearing front 9:', error);
                showNotification('Error', 'Failed to clear scores');
            }
        }
        
        // Clear back 9 scores
        async function clearBack9Scores() {
            if (!confirm('Clear Back 9 scores (holes 10-18) for ALL players?')) return;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                tournament.players.forEach(p => {
                    if (!p.scores) p.scores = Array(18).fill(null);
                    for (let i = 9; i < 18; i++) {
                        p.scores[i] = null;
                    }
                });
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                tournamentData.players = tournament.players;
                saveToLocalStorage();
                
                showNotification('Cleared', 'Back 9 scores have been cleared');
                showPlayerManagement();
            } catch (error) {
                console.error('Error clearing back 9:', error);
                showNotification('Error', 'Failed to clear scores');
            }
        }
        
        // Unclaim a player (host and co-hosts)
        async function unclaimPlayer(playerName) {
            if (!activeTournamentId || !canManageTournament()) {
                showNotification('Not Authorized', 'Only hosts and co-hosts can release claims');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) return;
                
                tournament.players[playerIndex].claimedBy = null;
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                showNotification('Released', `${playerName} is now unclaimed`);
                showPlayerManagement(); // Refresh the page
            } catch (error) {
                console.error('Error unclaiming player:', error);
                showNotification('Error', 'Failed to release claim');
            }
        }
        
        // Show add player form
        function showAddPlayerForm() {
            document.getElementById('addPlayerForm').style.display = 'block';
            document.getElementById('newPlayerName').focus();
        }
        
        // Hide add player form
        function hideAddPlayerForm() {
            document.getElementById('addPlayerForm').style.display = 'none';
            document.getElementById('newPlayerName').value = '';
            document.getElementById('newPlayerHandicap').value = '0';
        }
        
        // Refresh player management
        function refreshPlayerManagement() {
            showPlayerManagement();
            showNotification('Refreshed', 'Player list updated');
        }
        
        // Add new player from management page
        async function addNewPlayerFromManagement() {
            const name = document.getElementById('newPlayerName').value.trim();
            const handicap = parseFloat(document.getElementById('newPlayerHandicap').value) || 0;
            
            if (!name) {
                showNotification('Error', 'Please enter a player name');
                return;
            }
            
            if (!activeTournamentId) {
                showNotification('Error', 'No active tournament');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Check if name already exists
                if (tournament.players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                    showNotification('Error', 'Player with this name already exists');
                    return;
                }
                
                // Add new player
                const newPlayer = {
                    name: name,
                    handicap: handicap,
                    scores: new Array(18).fill(0),
                    claimedBy: null
                };
                
                tournament.players.push(newPlayer);
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Also update local data
                tournamentData.players.push(newPlayer);
                saveToLocalStorage();
                
                hideAddPlayerForm();
                showNotification('Added', `${name} added to tournament`);
                showPlayerManagement(); // Refresh
            } catch (error) {
                console.error('Error adding player:', error);
                showNotification('Error', 'Failed to add player');
            }
        }

        // ========================================
        // MY PLAYERS MANAGEMENT FUNCTIONS
        // ========================================
        
        // Load player order from localStorage
        function loadPlayerOrder() {
            const saved = localStorage.getItem(`playerOrder_${currentDeviceId}`);
            if (saved) {
                try {
                    playerOrder = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading player order:', e);
                    playerOrder = { claimed: [], watching: [] };
                }
            }
        }
        
        // Save player order to localStorage
        function savePlayerOrder() {
            localStorage.setItem(`playerOrder_${currentDeviceId}`, JSON.stringify(playerOrder));
        }
        
        // Get device name for display
        function getDeviceName(tournament, deviceId) {
            if (!deviceId) return 'UNK';
            if (!tournament || !tournament.devices) return deviceId.substring(0, 3).toUpperCase();
            if (tournament.devices[deviceId]) {
                return tournament.devices[deviceId].initials || tournament.devices[deviceId].name || deviceId.substring(0, 3).toUpperCase();
            }
            return deviceId.substring(0, 3).toUpperCase();
        }
        
        // Sort players by saved order
        function sortPlayersByOrder(players, orderArray) {
            const ordered = [];
            const unordered = [...players];
            
            orderArray.forEach(name => {
                const player = unordered.find(p => p.name === name);
                if (player) {
                    ordered.push(player);
                    unordered.splice(unordered.indexOf(player), 1);
                }
            });
            
            return [...ordered, ...unordered];
        }
        
        // Render individual player row
        function renderPlayerRow(player, index, type, totalCount) {
            const canEdit = type === 'claimed';
            const isFirst = index === 0;
            const isLast = index === totalCount - 1;
            
            const bgColor = type === 'claimed' ? '#fef3c7' : '#dbeafe';
            const borderColor = type === 'claimed' ? '#f59e0b' : '#3b82f6';
            
            return `
                <div style="background: ${bgColor}; border: 2px solid ${borderColor}; border-radius: 8px; padding: 12px; margin-bottom: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <div style="flex: 1;">
                            <div style="font-weight: 700; font-size: 15px;">${player.name}</div>
                            <div style="font-size: 13px; color: #64748b;">Handicap: ${player.handicap}</div>
                            ${type === 'watching' && player.claimedBy ? 
                                `<div style="font-size: 12px; color: #3b82f6;">Scored by: ${player.claimedBy.substring(0, 3).toUpperCase()}</div>` : 
                                ''}
                        </div>
                        <div style="display: flex; gap: 4px; align-items: center;">
                            <button 
                                onclick="movePlayer('${player.name}', ${index}, -1, '${type}')"
                                ${isFirst ? 'disabled' : ''}
                                style="width: 32px; height: 32px; background: ${isFirst ? '#e2e8f0' : '#ffffff'}; border: 2px solid ${borderColor}; border-radius: 6px; cursor: ${isFirst ? 'not-allowed' : 'pointer'}; font-size: 16px;">
                                â¬ï¸
                            </button>
                            <button 
                                onclick="movePlayer('${player.name}', ${index}, 1, '${type}')"
                                ${isLast ? 'disabled' : ''}
                                style="width: 32px; height: 32px; background: ${isLast ? '#e2e8f0' : '#ffffff'}; border: 2px solid ${borderColor}; border-radius: 6px; cursor: ${isLast ? 'not-allowed' : 'pointer'}; font-size: 16px;">
                                â¬ï¸
                            </button>
                            ${canEdit ? `
                                <button 
                                    onclick="editPlayerModal('${player.name}', ${player.handicap})"
                                    style="width: 32px; height: 32px; background: #ffffff; border: 2px solid ${borderColor}; border-radius: 6px; cursor: pointer; font-size: 16px;">
                                    âï¸
                                </button>
                            ` : ''}
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        ${canEdit ? `
                            <button onclick="releasePlayer('${player.name}')" style="flex: 1; padding: 8px; background: #ef4444; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                                Release Player
                            </button>
                        ` : `
                            <button onclick="removeFromWatchList('${player.name}')" style="flex: 1; padding: 8px; background: #64748b; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                                Stop Watching
                            </button>
                        `}
                    </div>
                </div>
            `;
        }
        
        // Show My Players Page (Full Page for Non-Hosts)
        async function showMyPlayersPage() {
            if (!activeTournamentId) {
                showNotification('Error', 'No active tournament');
                return;
            }
            
            loadPlayerOrder();
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const claimedPlayers = tournament.players.filter(p => p.claimedBy === currentDeviceId);
                const watchedPlayerNames = playerOrder.watching || [];
                const watchedPlayers = tournament.players.filter(p => 
                    watchedPlayerNames.includes(p.name) && p.claimedBy !== currentDeviceId
                );
                const availablePlayers = tournament.players.filter(p => 
                    !claimedPlayers.includes(p) && !watchedPlayers.includes(p)
                );
                
                // IMPORTANT: Ensure claimed players are in the order array
                claimedPlayers.forEach(p => {
                    if (!playerOrder.claimed.includes(p.name)) {
                        playerOrder.claimed.push(p.name);
                    }
                });
                // Remove any players from order that are no longer claimed
                playerOrder.claimed = playerOrder.claimed.filter(name => 
                    claimedPlayers.some(p => p.name === name)
                );
                savePlayerOrder();
                
                const sortedClaimed = sortPlayersByOrder(claimedPlayers, playerOrder.claimed);
                const sortedWatched = sortPlayersByOrder(watchedPlayers, playerOrder.watching);
                
                const content = document.getElementById('myPlayersPageContent');
                
                content.innerHTML = `
                    <!-- SECTION 1: My Claimed Players -->
                    <div style="background: #fef3c7; border: 1.5px solid #fbbf24; border-radius: 10px; padding: 10px; margin-bottom: 10px;">
                        <h3 style="color: #92400e; font-size: 12px; margin: 0 0 8px 0;">â My Claimed Players</h3>
                        ${sortedClaimed.length === 0 ? 
                            '<p style="color: #92400e; font-size: 12px; opacity: 0.7;">No claimed players</p>' :
                            sortedClaimed.map((p, index) => renderMyPlayerRow(p, index, 'claimed', sortedClaimed.length)).join('')
                        }
                    </div>
                    
                    <!-- SECTION 2: Watching -->
                    <div style="background: #dbeafe; border: 1.5px solid #3b82f6; border-radius: 10px; padding: 10px; margin-bottom: 10px;">
                        <h3 style="color: #1e40af; font-size: 12px; margin: 0 0 8px 0;">ðï¸ Watching</h3>
                        ${sortedWatched.length === 0 ? 
                            '<p style="color: #1e40af; font-size: 12px; opacity: 0.7;">Not watching any players</p>' :
                            sortedWatched.map((p, index) => renderMyPlayerRow(p, index, 'watching', sortedWatched.length)).join('')
                        }
                    </div>
                    
                    <!-- SECTION 3: Available Players -->
                    <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; padding: 10px;">
                        <h3 style="color: #64748b; font-size: 12px; margin: 0 0 8px 0;">ð Available Players</h3>
                        ${availablePlayers.length === 0 ? 
                            '<p style="color: #64748b; font-size: 12px; opacity: 0.7;">All players claimed or watched</p>' :
                            availablePlayers.map(p => `
                                <div style="background: white; border: 1.5px solid #e2e8f0; border-radius: 8px; padding: 10px; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="font-weight: 600; font-size: 14px; color: #1e293b;">${p.name}</div>
                                        <div style="font-size: 11px; color: #64748b;">HCP ${p.handicap}${p.claimedBy ? ' â¢ Claimed by ' + getDeviceName(tournament, p.claimedBy) : ''}</div>
                                    </div>
                                    <div style="display: flex; gap: 6px;">
                                        ${!p.claimedBy ? `
                                            <button onclick="claimPlayerFromMyPage('${p.name}')" style="padding: 6px 10px; background: #10b981; color: white; border: none; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer;">
                                                Claim
                                            </button>
                                        ` : ''}
                                        <button onclick="addToWatchListFromPage('${p.name}')" style="padding: 6px 10px; background: #3b82f6; color: white; border: none; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer;">
                                            ðï¸ Watch
                                        </button>
                                    </div>
                                </div>
                            `).join('')
                        }
                    </div>
                `;
                
                showPage('myPlayersPage');
            } catch (error) {
                console.error('Error loading my players:', error);
                showNotification('Error', 'Failed to load players');
            }
        }
        
        // Render player row for My Players page
        function renderMyPlayerRow(player, index, type, totalCount) {
            const canMoveUp = index > 0;
            const canMoveDown = index < totalCount - 1;
            const bgColor = type === 'claimed' ? '#fffbeb' : '#eff6ff';
            const borderColor = type === 'claimed' ? '#fbbf24' : '#3b82f6';
            
            return `
                <div style="background: ${bgColor}; border: 1.5px solid ${borderColor}; border-radius: 8px; padding: 10px; margin-bottom: 6px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <div>
                            <div style="font-weight: 600; font-size: 14px; color: #1e293b;">${player.name}</div>
                            <div style="font-size: 11px; color: #64748b;">Handicap: ${player.handicap}</div>
                        </div>
                        <div style="display: flex; gap: 4px;">
                            <button onclick="movePlayerInPage('${player.name}', ${index}, -1, '${type}')" 
                                style="width: 32px; height: 32px; border-radius: 6px; border: 1px solid #d1d5db; background: white; font-size: 14px; cursor: pointer; opacity: ${canMoveUp ? '1' : '0.3'};"
                                ${!canMoveUp ? 'disabled' : ''}>â¬ï¸</button>
                            <button onclick="movePlayerInPage('${player.name}', ${index}, 1, '${type}')" 
                                style="width: 32px; height: 32px; border-radius: 6px; border: 1px solid #d1d5db; background: white; font-size: 14px; cursor: pointer; opacity: ${canMoveDown ? '1' : '0.3'};"
                                ${!canMoveDown ? 'disabled' : ''}>â¬ï¸</button>
                            <button onclick="editPlayerHandicapFromPage('${player.name}', ${player.handicap})" 
                                style="width: 32px; height: 32px; border-radius: 6px; border: 1px solid #d1d5db; background: white; font-size: 14px; cursor: pointer;">âï¸</button>
                        </div>
                    </div>
                    <button onclick="${type === 'claimed' ? `releasePlayerFromPage('${player.name}')` : `removeFromWatchListFromPage('${player.name}')`}" 
                        style="width: 100%; padding: 8px; background: #ef4444; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">
                        ${type === 'claimed' ? 'Release Player' : 'Stop Watching'}
                    </button>
                </div>
            `;
        }
        
        // My Players Page helper functions
        function movePlayerInPage(playerName, currentIndex, direction, type) {
            const orderArray = type === 'claimed' ? playerOrder.claimed : playerOrder.watching;
            const newIndex = currentIndex + direction;
            
            if (newIndex < 0 || newIndex >= orderArray.length) return;
            
            // Swap
            [orderArray[currentIndex], orderArray[newIndex]] = [orderArray[newIndex], orderArray[currentIndex]];
            savePlayerOrder();
            showMyPlayersPage();
        }
        
        async function claimPlayerFromMyPage(playerName) {
            // Get current handicap
            const player = tournamentData.players.find(p => p.name === playerName);
            if (player) {
                showHandicapConfirmDialog(activeTournamentId, playerName, player.handicap);
                // Set flag to return to My Players page after claiming
                window.returnToMyPlayersPage = true;
            }
        }
        
        function addToWatchListFromPage(playerName) {
            if (!playerOrder.watching.includes(playerName)) {
                playerOrder.watching.push(playerName);
                savePlayerOrder();
                showMyPlayersPage();
            }
        }
        
        function removeFromWatchListFromPage(playerName) {
            playerOrder.watching = playerOrder.watching.filter(n => n !== playerName);
            savePlayerOrder();
            showMyPlayersPage();
        }
        
        async function releasePlayerFromPage(playerName) {
            if (!activeTournamentId) return;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex !== -1 && tournament.players[playerIndex].claimedBy === currentDeviceId) {
                    tournament.players[playerIndex].claimedBy = null;
                    tournament.players[playerIndex].deviceInitials = null;
                    
                    await tournamentRef.update({ players: tournament.players });
                    
                    // Remove from local order
                    playerOrder.claimed = playerOrder.claimed.filter(n => n !== playerName);
                    savePlayerOrder();
                    
                    showNotification('Released', `${playerName} is now available`);
                    showMyPlayersPage();
                }
            } catch (error) {
                console.error('Error releasing player:', error);
                showNotification('Error', 'Failed to release player');
            }
        }
        
        function editPlayerHandicapFromPage(playerName, currentHandicap) {
            // Use existing edit dialog but return to My Players page
            const dialog = document.getElementById('confirmDialog');
            const titleEl = document.getElementById('confirmTitle');
            const messageEl = document.getElementById('confirmMessage');
            const cancelBtn = document.getElementById('confirmCancel');
            const okBtn = document.getElementById('confirmOk');
            
            titleEl.textContent = `Edit ${playerName}`;
            messageEl.innerHTML = `
                <div style="margin: 16px 0;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">Handicap:</label>
                    <input type="number" id="editHandicapInput" value="${currentHandicap}" 
                        style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; text-align: center;"
                        min="-10" max="54">
                </div>
            `;
            
            cancelBtn.textContent = 'Cancel';
            okBtn.textContent = 'Save';
            
            const newCancelHandler = () => {
                dialog.style.display = 'none';
            };
            const newOkHandler = async () => {
                const newHandicap = parseInt(document.getElementById('editHandicapInput').value) || 0;
                await updatePlayerHandicap(playerName, newHandicap);
                dialog.style.display = 'none';
                showMyPlayersPage();
            };
            
            cancelBtn.replaceWith(cancelBtn.cloneNode(true));
            okBtn.replaceWith(okBtn.cloneNode(true));
            document.getElementById('confirmCancel').addEventListener('click', newCancelHandler);
            document.getElementById('confirmOk').addEventListener('click', newOkHandler);
            
            dialog.style.display = 'flex';
        }
        
        // Show Guest Home Page (Non-Host)
        function showGuestHomePage() {
            // Populate tournament info
            if (tournamentData) {
                document.getElementById('guestTournamentName').textContent = tournamentData.name || 'Tournament';
                document.getElementById('guestTournamentInfo').textContent = 
                    `${tournamentData.course || ''} â¢ ${formatDateDisplay(tournamentData.date) || ''}`;
            }
            showPage('guestHomePage');
        }
        
        // Leave tournament (non-host)
        function confirmLeaveTournament() {
            const dialog = document.getElementById('confirmDialog');
            const titleEl = document.getElementById('confirmTitle');
            const messageEl = document.getElementById('confirmMessage');
            const cancelBtn = document.getElementById('confirmCancel');
            const okBtn = document.getElementById('confirmOk');
            
            titleEl.textContent = 'ðª Leave Tournament?';
            messageEl.innerHTML = `
                <p>You will release all your claimed players and leave this tournament.</p>
                <p style="color: #ef4444; font-weight: 600;">This cannot be undone.</p>
            `;
            
            cancelBtn.textContent = 'Cancel';
            okBtn.textContent = 'Leave';
            okBtn.style.background = '#ef4444';
            
            const newCancelHandler = () => {
                dialog.style.display = 'none';
                okBtn.style.background = '#3b82f6';
            };
            const newOkHandler = async () => {
                dialog.style.display = 'none';
                okBtn.style.background = '#3b82f6';
                await leaveTournament();
            };
            
            cancelBtn.replaceWith(cancelBtn.cloneNode(true));
            okBtn.replaceWith(okBtn.cloneNode(true));
            document.getElementById('confirmCancel').addEventListener('click', newCancelHandler);
            document.getElementById('confirmOk').addEventListener('click', newOkHandler);
            
            dialog.style.display = 'flex';
        }
        
        async function leaveTournament() {
            try {
                // Release all claimed players
                if (activeTournamentId) {
                    const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                    const tournamentDoc = await tournamentRef.get();
                    const tournament = tournamentDoc.data();
                    
                    // Release all players claimed by this device
                    tournament.players.forEach(p => {
                        if (p.claimedBy === currentDeviceId) {
                            p.claimedBy = null;
                            p.deviceInitials = null;
                        }
                    });
                    
                    await tournamentRef.update({ players: tournament.players });
                }
                
                // Clear local storage
                activeTournamentId = null;
                tournamentData = null;
                isHost = false;
                isCoHost = false;
                playerOrder = { claimed: [], watching: [] };
                claimedPlayers = [];
                
                localStorage.removeItem('activeTournamentId');
                localStorage.removeItem('tournamentData');
                localStorage.removeItem('playerOrder');
                
                showNotification('Left', 'You have left the tournament');
                showPage('landingPage');
            } catch (error) {
                console.error('Error leaving tournament:', error);
                showNotification('Error', 'Failed to leave tournament');
            }
        }
        
        // Legacy function for compatibility
        function showMyPlayersModal() {
            showMyPlayersPage();
        }
        
        function closeMyPlayersModal() {
            showPage('scoringPage');
            renderScoringPage();
        }
        
        function movePlayer(playerName, currentIndex, direction, type) {
            const orderArray = type === 'claimed' ? playerOrder.claimed : playerOrder.watching;
            const newIndex = currentIndex + direction;
            
            if (newIndex < 0 || newIndex >= orderArray.length) return;
            
            [orderArray[currentIndex], orderArray[newIndex]] = [orderArray[newIndex], orderArray[currentIndex]];
            
            savePlayerOrder();
            showMyPlayersModal();
        }
        
        function addToWatchList(playerName) {
            if (!playerOrder.watching.includes(playerName)) {
                playerOrder.watching.push(playerName);
                savePlayerOrder();
                showMyPlayersModal();
                showNotification('Added', `Now watching ${playerName}`);
                
                // Refresh current view to show the new watched player
                if (currentView === 'hole') {
                    renderHoleView();
                } else {
                    renderCompactPlayerView(getPlayersToShow());
                }
            }
        }
        
        function removeFromWatchList(playerName) {
            const index = playerOrder.watching.indexOf(playerName);
            if (index > -1) {
                playerOrder.watching.splice(index, 1);
                savePlayerOrder();
                showMyPlayersModal();
                showNotification('Removed', `Stopped watching ${playerName}`);
                
                // Refresh current view to remove the unwatched player
                if (currentView === 'hole') {
                    renderHoleView();
                } else {
                    renderCompactPlayerView(getPlayersToShow());
                }
            }
        }
        
        // Helper function to get filtered players list
        function getPlayersToShow() {
            let playersToShow = tournamentData.players;
            if (tournamentMode === 'multi' && !canManageTournament()) {
                // Separate claimed and watched players
                const claimedPlayers = tournamentData.players.filter(p => p.claimedBy === currentDeviceId);
                const watchedPlayers = tournamentData.players.filter(p => 
                    playerOrder.watching && playerOrder.watching.includes(p.name) && p.claimedBy !== currentDeviceId
                );
                // Claimed first, then watched
                playersToShow = [...claimedPlayers, ...watchedPlayers];
                
                if (playersToShow.length === 0) {
                    playersToShow = tournamentData.players;
                }
            }
            return playersToShow;
        }
        
        // Track if claiming from My Players modal
        let claimingFromMyPlayersModal = false;
        
        async function claimPlayerFromModal(playerName) {
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                const player = tournament.players.find(p => p.name === playerName);
                
                if (!player) {
                    showNotification('Error', 'Player not found');
                    return;
                }
                
                // Set flag to return to My Players page after claiming
                claimingFromMyPlayersModal = true;
                showHandicapConfirmDialog(activeTournamentId, playerName, player.handicap);
            } catch (error) {
                console.error('Error claiming player:', error);
                showNotification('Error', 'Failed to claim player');
            }
        }
        
        async function releasePlayer(playerName) {
            showConfirm(
                'Release Player?',
                `Are you sure you want to release ${playerName}? You'll stop scoring for them, but their scores will be preserved.`,
                async function() {
                    try {
                        const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                        const tournamentDoc = await tournamentRef.get();
                        const tournament = tournamentDoc.data();
                        
                        const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                        if (playerIndex > -1) {
                            tournament.players[playerIndex].claimedBy = null;
                            
                            await tournamentRef.update({
                                players: tournament.players,
                                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                            });
                            
                            const index = playerOrder.claimed.indexOf(playerName);
                            if (index > -1) {
                                playerOrder.claimed.splice(index, 1);
                            }
                            
                            const cpIndex = claimedPlayers.indexOf(playerName);
                            if (cpIndex > -1) {
                                claimedPlayers.splice(cpIndex, 1);
                            }
                            
                            savePlayerOrder();
                            hideConfirmDialog();
                            showMyPlayersModal();
                            showNotification('Released', `${playerName} is now unclaimed`);
                        }
                    } catch (error) {
                        console.error('Error releasing player:', error);
                        showNotification('Error', 'Failed to release player');
                    }
                }
            );
        }
        
        function editPlayerModal(playerName, currentHandicap) {
            const dialog = document.getElementById('confirmDialog');
            const titleEl = document.getElementById('confirmTitle');
            const messageEl = document.getElementById('confirmMessage');
            const cancelBtn = document.getElementById('confirmCancel');
            const okBtn = document.getElementById('confirmOk');
            
            titleEl.textContent = `Edit ${playerName}`;
            messageEl.innerHTML = `
                <div style="margin: 16px 0;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">Name:</label>
                    <input type="text" id="editPlayerName" value="${playerName}" 
                        style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px;">
                    
                    <label style="display: block; margin: 16px 0 8px; font-weight: 600;">Handicap:</label>
                    <input type="number" id="editPlayerHandicap" value="${currentHandicap}" 
                        style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px;">
                </div>
            `;
            
            dialog.style.display = 'flex';
            
            const handleOk = async () => {
                const newName = document.getElementById('editPlayerName').value.trim();
                const newHandicap = parseInt(document.getElementById('editPlayerHandicap').value) || 0;
                
                if (!newName) {
                    alert('Name cannot be empty');
                    return;
                }
                
                try {
                    const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                    const tournamentDoc = await tournamentRef.get();
                    const tournament = tournamentDoc.data();
                    
                    const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                    if (playerIndex > -1) {
                        tournament.players[playerIndex].name = newName;
                        tournament.players[playerIndex].handicap = newHandicap;
                        
                        await tournamentRef.update({
                            players: tournament.players,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        
                        tournamentData.players = tournament.players;
                        saveToLocalStorage();
                        
                        if (newName !== playerName) {
                            const claimedIndex = playerOrder.claimed.indexOf(playerName);
                            if (claimedIndex > -1) {
                                playerOrder.claimed[claimedIndex] = newName;
                            }
                            const watchingIndex = playerOrder.watching.indexOf(playerName);
                            if (watchingIndex > -1) {
                                playerOrder.watching[watchingIndex] = newName;
                            }
                            savePlayerOrder();
                        }
                        
                        hideConfirmDialog();
                        showMyPlayersModal();
                        showNotification('Updated', `Player updated successfully`);
                    }
                } catch (error) {
                    console.error('Error updating player:', error);
                    showNotification('Error', 'Failed to update player');
                }
            };
            
            okBtn.onclick = handleOk;
            cancelBtn.onclick = hideConfirmDialog;
        }
        
        function getOrderedPlayers() {
            loadPlayerOrder();
            
            let playersToShow = tournamentData.players;
            
            if (tournamentMode === 'multi' && !canManageTournament()) {
                const claimed = playersToShow.filter(p => p.claimedBy === currentDeviceId);
                const watched = playersToShow.filter(p => playerOrder.watching.includes(p.name) && p.claimedBy !== currentDeviceId);
                
                const sortedClaimed = sortPlayersByOrder(claimed, playerOrder.claimed);
                const sortedWatched = sortPlayersByOrder(watched, playerOrder.watching);
                
                playersToShow = [...sortedClaimed, ...sortedWatched];
            }
            
            return playersToShow;
        }
        
        function setResultsFilter(filter) {
            currentResultsFilter = filter;
            
            const allBtn = document.getElementById('resultsToggleAll');
            const mineBtn = document.getElementById('resultsToggleMine');
            
            if (allBtn && mineBtn) {
                if (filter === 'all') {
                    allBtn.style.background = '#3b82f6';
                    allBtn.style.color = 'white';
                    mineBtn.style.background = 'transparent';
                    mineBtn.style.color = '#64748b';
                } else {
                    mineBtn.style.background = '#3b82f6';
                    mineBtn.style.color = 'white';
                    allBtn.style.background = 'transparent';
                    allBtn.style.color = '#64748b';
                }
            }
            
            updateResultsDisplay();
        }
        
        // Edit player from management page (host function)
        async function editPlayerFromManagement(playerName, currentHandicap) {
            const dialog = document.getElementById('confirmDialog');
            const titleEl = document.getElementById('confirmTitle');
            const messageEl = document.getElementById('confirmMessage');
            const cancelBtn = document.getElementById('confirmCancel');
            const okBtn = document.getElementById('confirmOk');
            
            titleEl.textContent = `Edit ${playerName}`;
            messageEl.innerHTML = `
                <div style="margin: 16px 0;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">Name:</label>
                    <input type="text" id="editPlayerName" value="${playerName}" 
                        style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px;">
                    
                    <label style="display: block; margin: 16px 0 8px; font-weight: 600;">Handicap:</label>
                    <input type="number" id="editPlayerHandicap" value="${currentHandicap}" 
                        style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px;">
                </div>
            `;
            
            dialog.style.display = 'flex';
            
            const handleOk = async () => {
                const newName = document.getElementById('editPlayerName').value.trim();
                const newHandicap = parseInt(document.getElementById('editPlayerHandicap').value) || 0;
                
                if (!newName) {
                    alert('Name cannot be empty');
                    return;
                }
                
                try {
                    const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                    const tournamentDoc = await tournamentRef.get();
                    const tournament = tournamentDoc.data();
                    
                    const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                    if (playerIndex > -1) {
                        tournament.players[playerIndex].name = newName;
                        tournament.players[playerIndex].handicap = newHandicap;
                        
                        await tournamentRef.update({
                            players: tournament.players,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        
                        // Update local tournamentData
                        tournamentData.players = tournament.players;
                        saveToLocalStorage();
                        
                        hideConfirmDialog();
                        showPlayerManagement(); // Refresh the page
                        showNotification('Updated', `Player updated successfully`);
                    }
                } catch (error) {
                    console.error('Error updating player:', error);
                    showNotification('Error', 'Failed to update player');
                }
            };
            
            okBtn.onclick = handleOk;
            cancelBtn.onclick = hideConfirmDialog;
        }
        
        // Add player to tournament (host and co-hosts)
        async function addPlayerToTournament() {
            if (!activeTournamentId || !canManageTournament()) {
                showNotification('Not Authorized', 'Only hosts and co-hosts can add players');
                return;
            }
            
            const nameInput = document.getElementById('newPlayerName');
            const handicapInput = document.getElementById('newPlayerHandicap');
            const name = nameInput.value.trim();
            const handicap = parseInt(handicapInput.value) || 0;
            
            if (!name) {
                showNotification('Error', 'Please enter a player name');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Check if player already exists
                if (tournament.players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                    showNotification('Error', 'Player already exists');
                    return;
                }
                
                // Add new player with empty scores
                const newPlayer = {
                    name: name,
                    handicap: handicap,
                    scores: new Array(18).fill(0),
                    claimedBy: null
                };
                
                tournament.players.push(newPlayer);
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update local data
                tournamentData.players = tournament.players;
                saveToLocalStorage();
                
                // Clear inputs
                nameInput.value = '';
                handicapInput.value = '0';
                
                showNotification('Added', `${name} added to tournament`);
                showPlayerManagement(); // Refresh
            } catch (error) {
                console.error('Error adding player:', error);
                showNotification('Error', 'Failed to add player');
            }
        }
        
        // Delete player from tournament (host and co-hosts)
        async function deletePlayerFromTournament(playerName) {
            if (!activeTournamentId || !canManageTournament()) {
                showNotification('Not Authorized', 'Only hosts and co-hosts can delete players');
                return;
            }
            
            showConfirm(
                'Delete Player?',
                `Are you sure you want to remove ${playerName} from the tournament? All their scores will be lost.`,
                async function() {
                    try {
                        const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                        const tournamentDoc = await tournamentRef.get();
                        const tournament = tournamentDoc.data();
                        
                        // TOMBSTONE: Record deletion time to prevent zombie reappearance
                        deletedPlayers[playerName] = Date.now();
                        console.log(`ðª¦ TOMBSTONE created for "${playerName}" at ${deletedPlayers[playerName]}`);
                        
                        // Remove player
                        tournament.players = tournament.players.filter(p => p.name !== playerName);
                        
                        await tournamentRef.update({
                            players: tournament.players,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        
                        // Update local data
                        tournamentData.players = tournament.players;
                        saveToLocalStorage();
                        
                        hideConfirmDialog();
                        showNotification('Deleted', `${playerName} removed from tournament`);
                        showPlayerManagement(); // Refresh
                    } catch (error) {
                        console.error('Error deleting player:', error);
                        showNotification('Error', 'Failed to delete player');
                    }
                }
            );
        }

        // Render the scoring page
        function renderScoringPage() {
            // Load the correct course data
            courseData = courses[tournamentData.course];
            
            // Update smart info line
            setTimeout(() => {
                generateSmartInfoLine('scoringSmartInfo');
            }, 10);

            // Clear the player cards container - content will be rendered by view-specific functions
            const container = document.getElementById('playerCards');
            container.innerHTML = '';
            
            // Show/hide Manage Players button (for host and co-hosts)
            const manageBtn = document.getElementById('managePlayersBtn');
            if (manageBtn) {
                if (canManageTournament()) {
                    manageBtn.style.display = 'flex';
                } else {
                    manageBtn.style.display = 'none';
                }
            }
            
            // Show My Players button for non-hosts/non-co-hosts (now in header)
            const myPlayersBtnHeader = document.getElementById('myPlayersBtnHeader');
            if (myPlayersBtnHeader) {
                if (tournamentMode === 'multi' && !canManageTournament()) {
                    myPlayersBtnHeader.style.display = 'flex';
                } else {
                    myPlayersBtnHeader.style.display = 'none';
                }
            }
            
            // Show/hide Claim Another Player button (only for non-hosts/non-co-hosts in multi-device mode)
            const claimBtn = document.getElementById('claimAnotherBtn');
            if (claimBtn) {
                if (tournamentMode === 'multi' && !canManageTournament()) {
                    claimBtn.style.display = 'block';
                } else {
                    claimBtn.style.display = 'none';
                }
            }
            
            // Update connection status
            updateConnectionStatus();
            
            // FIXED: Default to hole view if not set, and always render content
            if (!currentView) {
                currentView = 'hole';
            }
            
            // Render the current active view (hole or player)
            // Use setTimeout to ensure DOM is ready
            setTimeout(() => {
                if (currentView === 'hole') {
                    renderHoleView();
                } else if (currentView === 'player') {
                    renderCompactPlayerView();
                } else {
                    // Fallback to hole view
                    currentView = 'hole';
                    renderHoleView();
                }
            }, 10);
        }

        // Score modification functions
        async function updateScore(playerIndex, holeIndex, value) {
            const score = parseInt(value) || 0;
            tournamentData.players[playerIndex].scores[holeIndex] = score;
            
            // NEWEST WINS: Record timestamp for this score change
            const playerName = tournamentData.players[playerIndex].name;
            const timestampKey = `${playerName}-${holeIndex}`;
            scoreTimestamps[timestampKey] = Date.now();
            
            // IMMEDIATE SAVE with verification - this happens FIRST before any async
            const saveSuccess = saveToLocalStorage();
            
            // VERIFY the score was actually saved
            if (saveSuccess) {
                const verified = await verifyScoreSaved(playerIndex, holeIndex, score);
                if (!verified) {
                    console.error('â MANUAL INPUT: Score verification failed! Retrying save...');
                    tournamentData.players[playerIndex].scores[holeIndex] = score;
                    saveToLocalStorage();
                }
            }
            
            // Sync to Firebase if in cloud mode - AWAIT to ensure completion
            if (activeTournamentId && tournamentMode === 'multi') {
                const playerName = tournamentData.players[playerIndex].name;
                try {
                    await updatePlayerScore(activeTournamentId, playerName, holeIndex, score);
                } catch (error) {
                    console.error('â Firebase sync failed, but localStorage has the score:', error);
                }
            }
            
            updateProgressBar();
            renderScoringPage();
        }

        async function incrementScore(playerIndex, holeIndex) {
            console.log('=== INCREMENT SCORE CALLED ===');
            console.log('playerIndex:', playerIndex, 'holeIndex:', holeIndex);
            
            if (playerIndex === undefined || holeIndex === undefined) {
                console.error('â Invalid parameters:', { playerIndex, holeIndex });
                return;
            }
            
            if (!tournamentData || !tournamentData.players || !tournamentData.players[playerIndex]) {
                console.error('â Invalid player data:', { 
                    hasTournamentData: !!tournamentData, 
                    playersLength: tournamentData?.players?.length,
                    playerIndex 
                });
                return;
            }
            
            const currentScore = tournamentData.players[playerIndex].scores[holeIndex];
            const par = courseData.holes[holeIndex].par;
            
            console.log('Player:', tournamentData.players[playerIndex].name);
            console.log('Hole:', holeIndex + 1);
            console.log('Current score:', currentScore);
            
            // If score is 0 or null, set to par first
            if (!currentScore || currentScore === 0) {
                tournamentData.players[playerIndex].scores[holeIndex] = par;
            } else {
                tournamentData.players[playerIndex].scores[holeIndex] = Math.min(currentScore + 1, 15);
            }
            
            const newScore = tournamentData.players[playerIndex].scores[holeIndex];
            console.log('New score:', newScore);
            console.log('Full scores array:', tournamentData.players[playerIndex].scores);
            
            // NEWEST WINS: Record timestamp for this score change
            const playerName = tournamentData.players[playerIndex].name;
            const timestampKey = `${playerName}-${holeIndex}`;
            scoreTimestamps[timestampKey] = Date.now();
            
            // IMMEDIATE SAVE with verification
            console.log('ð¾ Attempting localStorage save...');
            const saveSuccess = saveToLocalStorage();
            console.log('ð¾ Save result:', saveSuccess);
            
            // VERIFY the score was actually saved
            if (saveSuccess) {
                const verified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                if (!verified) {
                    console.error('â INCREMENT: Score verification failed! Retrying save...');
                    tournamentData.players[playerIndex].scores[holeIndex] = newScore;
                    const retrySuccess = saveToLocalStorage();
                    console.log('ð¾ Retry save result:', retrySuccess);
                    
                    // Verify again
                    const reVerified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                    if (!reVerified) {
                        console.error('ð¨ CRITICAL: Score still not saved after retry!');
                        // Don't alert - Firebase has it
                    }
                }
            } else {
                console.error('ð¨ CRITICAL: Initial save failed!');
                // Don't alert - Firebase has it
            }
            
            // Sync to Firebase if in cloud mode
            console.log('Checking Firebase sync:');
            console.log('  activeTournamentId:', activeTournamentId);
            console.log('  tournamentMode:', tournamentMode);
            
            if (activeTournamentId && tournamentMode === 'multi') {
                console.log('â SYNCING to Firebase:', playerName, 'Hole', holeIndex + 1, '=', newScore);
                updatePlayerScore(activeTournamentId, playerName, holeIndex, newScore);
            } else {
                console.log('â NOT syncing - missing activeTournamentId or not in multi mode');
            }
            
            updateProgressBar();
            
            // Update only the specific score input without full re-render
            updateScoreDisplay(playerIndex, holeIndex, newScore, par);
        }

        async function decrementScore(playerIndex, holeIndex) {
            console.log('=== DECREMENT SCORE CALLED ===');
            console.log('playerIndex:', playerIndex, 'holeIndex:', holeIndex);
            
            if (playerIndex === undefined || holeIndex === undefined) {
                console.error('â Invalid parameters:', { playerIndex, holeIndex });
                return;
            }
            
            if (!tournamentData || !tournamentData.players || !tournamentData.players[playerIndex]) {
                console.error('â Invalid player data:', { 
                    hasTournamentData: !!tournamentData, 
                    playersLength: tournamentData?.players?.length,
                    playerIndex 
                });
                return;
            }
            
            const currentScore = tournamentData.players[playerIndex].scores[holeIndex];
            const par = courseData.holes[holeIndex].par;
            
            console.log('Player:', tournamentData.players[playerIndex].name);
            console.log('Hole:', holeIndex + 1);
            console.log('Current score:', currentScore);
            
            // If score is 0 or null, set to par first
            if (!currentScore || currentScore === 0) {
                tournamentData.players[playerIndex].scores[holeIndex] = par;
            } else {
                tournamentData.players[playerIndex].scores[holeIndex] = Math.max(currentScore - 1, 0);
            }
            
            const newScore = tournamentData.players[playerIndex].scores[holeIndex];
            console.log('New score:', newScore);
            console.log('Full scores array:', tournamentData.players[playerIndex].scores);
            
            // NEWEST WINS: Record timestamp for this score change
            const playerName = tournamentData.players[playerIndex].name;
            const timestampKey = `${playerName}-${holeIndex}`;
            scoreTimestamps[timestampKey] = Date.now();
            
            // IMMEDIATE SAVE with verification
            console.log('ð¾ Attempting localStorage save...');
            const saveSuccess = saveToLocalStorage();
            console.log('ð¾ Save result:', saveSuccess);
            
            // VERIFY the score was actually saved
            if (saveSuccess) {
                const verified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                if (!verified) {
                    console.error('â DECREMENT: Score verification failed! Retrying save...');
                    tournamentData.players[playerIndex].scores[holeIndex] = newScore;
                    const retrySuccess = saveToLocalStorage();
                    console.log('ð¾ Retry save result:', retrySuccess);
                    
                    // Verify again
                    const reVerified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                    if (!reVerified) {
                        console.error('ð¨ CRITICAL: Score still not saved after retry!');
                        // Don't alert - Firebase has it
                    }
                }
            } else {
                console.error('ð¨ CRITICAL: Initial save failed!');
                // Don't alert - Firebase has it
            }
            
            // Sync to Firebase if in cloud mode
            console.log('Checking Firebase sync:');
            console.log('  activeTournamentId:', activeTournamentId);
            console.log('  tournamentMode:', tournamentMode);
            
            if (activeTournamentId && tournamentMode === 'multi') {
                console.log('â SYNCING to Firebase:', playerName, 'Hole', holeIndex + 1, '=', newScore);
                updatePlayerScore(activeTournamentId, playerName, holeIndex, newScore);
            } else {
                console.log('â NOT syncing - missing activeTournamentId or not in multi mode');
            }
            
            updateProgressBar();
            
            // Update only the specific score input without full re-render
            updateScoreDisplay(playerIndex, holeIndex, newScore, par);
        }
        
        // Update just the score display without re-rendering entire page
        function updateScoreDisplay(playerIndex, holeIndex, score, par) {
            // Find the score input for this player/hole
            const grid = document.getElementById(`player${playerIndex}Grid`);
            if (!grid) return; // Player not visible (filtered out)
            
            const holeInputs = grid.querySelectorAll('.hole-input-group');
            if (!holeInputs[holeIndex]) return;
            
            const scoreInput = holeInputs[holeIndex].querySelector('.score-input');
            if (!scoreInput) return;
            
            // Update value
            scoreInput.value = score || '';
            
            // Update color class
            scoreInput.className = 'score-input';
            if (score > 0) {
                const diff = score - par;
                if (diff >= 2) {
                    scoreInput.classList.add('double-bogey-plus');
                } else if (diff === 1) {
                    scoreInput.classList.add('bogey');
                } else if (diff === 0) {
                    scoreInput.classList.add('par');
                } else if (diff <= -1) {
                    scoreInput.classList.add('birdie-better');
                }
            }
            
            // Update player total
            const playerCard = scoreInput.closest('.player-card');
            if (playerCard) {
                const player = tournamentData.players[playerIndex];
                const total = player.scores.reduce((sum, s) => sum + (s || 0), 0);
                const toPar = total - courseData.totalPar;
                const toParText = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar);
                
                const totalDisplay = playerCard.querySelector('.player-total');
                if (totalDisplay) {
                    totalDisplay.innerHTML = `${total > 0 ? total : '-'} <span style="font-size: 16px; color: #64748b;">(${toParText})</span>`;
                }
            }
        }

        // Update progress bar
        function updateProgressBar() {
            const progressBar = document.getElementById('tournamentProgress');
            if (progressBar) {
                const progress = getTournamentProgress();
                progressBar.style.width = progress + '%';
            }
        }

        // Show finish confirmation dialog with 3 options
        function showFinishConfirmation() {
            const modal = document.createElement('div');
            modal.id = 'finishConfirmModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; max-width: 340px; width: 100%; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 12px;">ð</div>
                    <h2 style="color: #1e40af; margin-bottom: 8px; font-size: 20px;">View Results?</h2>
                    <p style="color: #64748b; margin-bottom: 20px; font-size: 14px;">
                        What would you like to do?
                    </p>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="confirmFinishAndView()" style="padding: 14px; background: #10b981; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            â View Results
                        </button>
                        <button onclick="saveAndStay()" style="padding: 14px; background: #3b82f6; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            ð¾ Save Backup & Stay
                        </button>
                        <button onclick="document.getElementById('finishConfirmModal').remove()" style="padding: 14px; background: #e2e8f0; color: #64748b; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Confirm and go to results
        function confirmFinishAndView() {
            document.getElementById('finishConfirmModal')?.remove();
            finishRound();
        }
        
        // Save backup and stay on scoring page
        function saveAndStay() {
            document.getElementById('finishConfirmModal')?.remove();
            saveTournamentFile();
            showNotification('Saved!', 'Backup file downloaded');
        }

        // Finish round and show results
        async function finishRound() {
            // Force sync from Firestore in multi-device mode before showing results
            if (tournamentMode === 'multi' && activeTournamentId) {
                try {
                    const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                    const tournamentDoc = await tournamentRef.get();
                    if (tournamentDoc.exists) {
                        const tournament = tournamentDoc.data();
                        updateLocalTournamentState(tournament);
                    }
                } catch (error) {
                    console.error('Error syncing tournament data:', error);
                }
            }
            
            renderResultsPage();
            showPage('resultsPage');
            // Celebrate with confetti!
            setTimeout(() => showConfetti(), 300);
        }

        function backToScoring() {
            showPage('scoringPage');
        }

        // Helper functions for net score calculations
        function getNetScore(grossScore, playerHcp, holeHcp, method = 'full') {
            if (grossScore === 0) return 0;
            
            let strokes = 0;
            
            // Handle plus handicaps (negative values)
            if (playerHcp < 0) {
                const absHcp = Math.abs(playerHcp);
                
                if (method === 'full') {
                    // Plus handicap: add strokes on EASIEST holes (18, 17, 16...)
                    strokes = -Math.floor(absHcp / 18); // Negative = add to score
                    if (holeHcp > (18 - (absHcp % 18))) {
                        strokes -= 1; // Add another stroke on easier holes
                    }
                } else if (method === '18max') {
                    // 18 Max: max 1 stroke added per hole on easiest holes
                    if (holeHcp > (18 - Math.min(absHcp, 18))) {
                        strokes = -1;
                    }
                } else if (method === 'half') {
                    // Half Pop: 0.5 stroke added per allocated stroke
                    const fullStrokes = Math.floor(absHcp / 18);
                    const extraStroke = holeHcp > (18 - (absHcp % 18)) ? 1 : 0;
                    strokes = -(fullStrokes + extraStroke) * 0.5;
                }
            } 
            // Handle regular (positive) handicaps
            else if (playerHcp > 0) {
                if (method === 'full') {
                    // Regular handicap: subtract strokes on HARDEST holes (1, 2, 3...)
                    strokes = Math.floor(playerHcp / 18);
                    if (holeHcp <= (playerHcp % 18)) {
                        strokes += 1;
                    }
                } else if (method === '18max') {
                    // 18 Max: max 1 stroke per hole
                    if (holeHcp <= Math.min(playerHcp, 18)) {
                        strokes = 1;
                    }
                } else if (method === 'half') {
                    // Half Pop: 0.5 stroke per allocated stroke
                    const fullStrokes = Math.floor(playerHcp / 18);
                    const extraStroke = holeHcp <= (playerHcp % 18) ? 1 : 0;
                    strokes = (fullStrokes + extraStroke) * 0.5;
                }
            }
            
            return grossScore - strokes;
        }
        
        // Get the number of handicap strokes for a specific hole
        // Returns: positive = strokes subtracted (getting pops), negative = strokes added (plus handicap)
        function getHandicapStrokesForHole(playerHcp, holeHcp, method = 'full') {
            if (playerHcp === 0) return 0;
            
            let strokes = 0;
            
            // Handle plus handicaps (negative values) - add strokes on easiest holes
            if (playerHcp < 0) {
                const absHcp = Math.abs(playerHcp);
                
                if (method === 'full') {
                    strokes = -Math.floor(absHcp / 18);
                    if (holeHcp > (18 - (absHcp % 18))) {
                        strokes -= 1;
                    }
                } else if (method === '18max') {
                    if (holeHcp > (18 - Math.min(absHcp, 18))) {
                        strokes = -1;
                    }
                } else if (method === 'half') {
                    const fullStrokes = Math.floor(absHcp / 18);
                    const extraStroke = holeHcp > (18 - (absHcp % 18)) ? 1 : 0;
                    strokes = -(fullStrokes + extraStroke) * 0.5;
                }
            } 
            // Handle regular (positive) handicaps - subtract strokes on hardest holes
            else if (playerHcp > 0) {
                if (method === 'full') {
                    strokes = Math.floor(playerHcp / 18);
                    if (holeHcp <= (playerHcp % 18)) {
                        strokes += 1;
                    }
                } else if (method === '18max') {
                    if (holeHcp <= Math.min(playerHcp, 18)) {
                        strokes = 1;
                    }
                } else if (method === 'half') {
                    const fullStrokes = Math.floor(playerHcp / 18);
                    const extraStroke = holeHcp <= (playerHcp % 18) ? 1 : 0;
                    strokes = (fullStrokes + extraStroke) * 0.5;
                }
            }
            
            return strokes;
        }

        function getStablefordPoints(netScore, par, modified = false) {
            const diff = netScore - par;
            
            if (modified) {
                // Modified Stableford
                if (diff <= -4) return 11;  // Condor
                if (diff === -3) return 8;   // Albatross
                if (diff === -2) return 5;   // Eagle
                if (diff === -1) return 2;   // Birdie
                if (diff === 0) return 0;    // Par
                if (diff === 1) return -1;   // Bogey
                return -3;                    // Double bogey or worse
            } else {
                // Standard Stableford
                if (diff <= -4) return 6;    // Condor
                if (diff === -3) return 5;   // Albatross
                if (diff === -2) return 4;   // Eagle
                if (diff === -1) return 3;   // Birdie
                if (diff === 0) return 2;    // Par
                if (diff === 1) return 1;    // Bogey
                return 0;                     // Double bogey or worse
            }
        }

        function renderResultsPage() {
            // Load the correct course data
            courseData = courses[tournamentData.course];
            
            // Update smart info line
            setTimeout(() => {
                generateSmartInfoLine('resultsSmartInfo');
            }, 10);
            
            // Show/hide manage button for hosts and co-hosts
            const manageBtn = document.getElementById('resultsManageBtn');
            if (manageBtn) {
                manageBtn.style.display = canManageTournament() ? 'flex' : 'none';
            }
            
            // Show/hide finish button (only for hosts/co-hosts)
            const finishBtn = document.getElementById('newRoundBtnTop');
            if (finishBtn) {
                finishBtn.style.display = canManageTournament() ? 'flex' : 'none';
            }
            
            // Show My Players button for non-hosts/non-co-hosts only
            const myPlayersBtn = document.getElementById('resultsMyPlayersBtn');
            if (myPlayersBtn) {
                myPlayersBtn.style.display = (!canManageTournament() && tournamentMode === 'multi') ? 'flex' : 'none';
            }
            
            // Show/hide filter toggle (only for non-hosts/non-co-hosts in multi mode)
            const filterToggle = document.getElementById('resultsFilterToggle');
            if (filterToggle) {
                filterToggle.style.display = (!canManageTournament() && tournamentMode === 'multi') ? 'flex' : 'none';
            }
            
            // Set the dropdown to match current game type
            document.getElementById('resultsGameType').value = tournamentData.gameType;
            
            updateResultsDisplay();
        }

        function updateResultsGameType() {
            const newGameType = document.getElementById('resultsGameType').value;
            
            // Update the tournament data
            tournamentData.gameType = newGameType;
            
            // Update the smart info lines on both pages
            generateSmartInfoLine('scoringSmartInfo');
            generateSmartInfoLine('resultsSmartInfo');
            
            // Save to local storage
            saveToLocalStorage();
            
            // Update results display
            updateResultsDisplay(newGameType);
        }
        
        // Refresh results data from Firebase
        async function refreshResultsData() {
            if (!activeTournamentId) {
                // Single device mode - just re-render
                updateResultsDisplay();
                showNotification('Refreshed', 'Results updated');
                return;
            }
            
            try {
                // Fetch latest from Firebase
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                
                if (tournamentDoc.exists) {
                    const tournament = tournamentDoc.data();
                    updateLocalTournamentState(tournament);
                    updateResultsDisplay();
                    showNotification('Refreshed', 'Latest scores loaded');
                } else {
                    showNotification('Error', 'Tournament not found');
                }
            } catch (error) {
                console.error('Error refreshing results:', error);
                showNotification('Error', 'Failed to refresh');
            }
        }

        function updateResultsDisplay(displayGameType) {
            const gameType = displayGameType || tournamentData.gameType;
            const container = document.getElementById('resultsContent');
            container.innerHTML = `<div style="text-align: center; margin-bottom: 12px;">
                <span style="background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: white; padding: 4px 12px; border-radius: 12px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">${gameType}</span>
            </div>`;
            
            // Filter players based on currentResultsFilter
            let playersToDisplay = tournamentData.players;
            if (currentResultsFilter === 'mine' && tournamentMode === 'multi' && !canManageTournament()) {
                loadPlayerOrder();
                playersToDisplay = playersToDisplay.filter(p => 
                    p.claimedBy === currentDeviceId || playerOrder.watching.includes(p.name)
                );
            }

            // Stroke Play Gross
            if (gameType === 'Stroke Play Gross') {
                const results = playersToDisplay.map((player, idx) => {
                    const total = player.scores.reduce((sum, s) => sum + (s || 0), 0); // â Handle null scores
                    const toPar = total - courseData.totalPar;
                    return { player, total, toPar, index: idx };
                }).filter(r => r.total > 0);

                // Sort by total, then by back-nine tiebreaker using handicap holes
                results.sort((a, b) => {
                    if (a.total !== b.total) return a.total - b.total;
                    
                    // Tiebreaker: lowest score on hardest holes (hcp 1, 2, 3...)
                    for (let hcp = 1; hcp <= 18; hcp++) {
                        const holeIdx = courseData.holes.findIndex(h => h.handicap === hcp);
                        const scoreA = a.player.scores[holeIdx] || 0;
                        const scoreB = b.player.scores[holeIdx] || 0;
                        if (scoreA !== scoreB) return scoreA - scoreB;
                    }
                    return 0;
                });

                results.forEach((r, position) => {
                    const medal = position === 0 ? 'ð¥' : position === 1 ? 'ð¥' : position === 2 ? 'ð¥' : `${position + 1}.`;
                    const toParText = r.toPar === 0 ? 'E' : (r.toPar > 0 ? `+${r.toPar}` : `${r.toPar}`);
                    
                    container.appendChild(createPlayerResultCard(medal, r.player.name, r.total, toParText, r.player.handicap));
                });
            }

            // Stroke Play Net
            else if (gameType === 'Stroke Play Net') {
                const results = playersToDisplay.map((player, idx) => {
                    let netTotal = 0;
                    player.scores.forEach((score, holeIdx) => {
                        if (score > 0) {
                            const netScore = getNetScore(score, player.handicap, courseData.holes[holeIdx].handicap, 'full');
                            netTotal += netScore;
                        }
                    });
                    const toPar = netTotal - courseData.totalPar;
                    return { player, netTotal, toPar, index: idx };
                }).filter(r => r.netTotal > 0);

                results.sort((a, b) => {
                    if (a.netTotal !== b.netTotal) return a.netTotal - b.netTotal;
                    
                    // Tiebreaker: lowest net score on hardest holes
                    for (let hcp = 1; hcp <= 18; hcp++) {
                        const holeIdx = courseData.holes.findIndex(h => h.handicap === hcp);
                        const netA = getNetScore(a.player.scores[holeIdx], a.player.handicap, hcp, 'full');
                        const netB = getNetScore(b.player.scores[holeIdx], b.player.handicap, hcp, 'full');
                        if (netA !== netB) return netA - netB;
                    }
                    return 0;
                });

                results.forEach((r, position) => {
                    const medal = position === 0 ? 'ð¥' : position === 1 ? 'ð¥' : position === 2 ? 'ð¥' : `${position + 1}.`;
                    const toParText = r.toPar === 0 ? 'E' : (r.toPar > 0 ? `+${r.toPar}` : `${r.toPar}`);
                    
                    container.appendChild(createPlayerResultCard(medal, r.player.name, r.netTotal, toParText, r.player.handicap, 'Net'));
                });
            }

            // Skins Games
            else if (gameType.includes('Skins')) {
                const method = gameType === 'Gross Skins' ? 'gross' : 
                              gameType === 'Net Skins (Full Hcp)' ? 'full' :
                              gameType === 'Net Skins (18 Max)' ? '18max' : 'half';
                
                const skinWinners = {};
                const skinDetails = {}; // Track which holes each player won
                
                playersToDisplay.forEach((p, idx) => {
                    skinWinners[idx] = 0;
                    skinDetails[idx] = [];
                });
                
                for (let holeIdx = 0; holeIdx < 18; holeIdx++) {
                    const holeScores = playersToDisplay.map((player, pIdx) => {
                        const gross = player.scores[holeIdx];
                        
                        // â FIX: Exclude null, undefined, AND zero scores
                        if (!gross || gross === 0) return { pIdx, score: 999, gross: 0 };
                        
                        const score = method === 'gross' ? gross : 
                                     getNetScore(gross, player.handicap, courseData.holes[holeIdx].handicap, 
                                               method === 'full' ? 'full' : method === '18max' ? '18max' : 'half');
                        return { pIdx, score, gross };
                    }).filter(s => s.score < 999);
                    
                    if (holeScores.length === 0) continue;
                    
                    const minScore = Math.min(...holeScores.map(s => s.score));
                    const winners = holeScores.filter(s => s.score === minScore);
                    
                    // Only award skin if there's a sole winner
                    if (winners.length === 1) {
                        const winnerIdx = winners[0].pIdx;
                        skinWinners[winnerIdx]++;
                        skinDetails[winnerIdx].push({
                            hole: holeIdx + 1,
                            score: winners[0].score
                        });
                    }
                }
                
                const results = playersToDisplay.map((player, idx) => ({
                    player,
                    skins: skinWinners[idx] || 0,
                    details: skinDetails[idx] || []
                })).sort((a, b) => b.skins - a.skins);
                
                results.forEach((r, position) => {
                    const medal = position === 0 ? 'ð¥' : position === 1 ? 'ð¥' : position === 2 ? 'ð¥' : `${position + 1}.`;
                    const hcpDisplay = r.player.handicap !== 0 ? `<span style="color: #6b7280; font-size: 13px; font-weight: 500; margin-left: 6px;">(${r.player.handicap > 0 ? r.player.handicap : '+' + Math.abs(r.player.handicap)})</span>` : '';
                    
                    // Medal/rank display
                    let rankHtml = '';
                    if (medal === 'ð¥') {
                        rankHtml = '<span style="font-size: 28px; margin-right: 10px;">ð</span>';
                    } else if (medal === 'ð¥') {
                        rankHtml = '<span style="font-size: 24px; margin-right: 10px;">ð¥</span>';
                    } else if (medal === 'ð¥') {
                        rankHtml = '<span style="font-size: 22px; margin-right: 10px;">ð¥</span>';
                    } else {
                        rankHtml = `<span style="font-weight: 700; font-size: 16px; color: #64748b; margin-right: 10px; min-width: 24px;">${medal}</span>`;
                    }
                    
                    // Format hole details for second row - only if player has skins
                    const holeDetailsHtml = r.skins > 0 && r.details.length > 0 
                        ? `<div style="padding: 4px 14px 12px 52px; display: flex; flex-wrap: wrap; gap: 4px;">
                            ${r.details.map(d => `<span style="color: #059669; font-weight: 600; font-size: 14px; margin-right: 16px;">#${d.hole}<span style="color: #475569;">(${d.score})</span></span>`).join('')}
                           </div>`
                        : '';
                    
                    const div = document.createElement('div');
                    div.className = 'results-player';
                    div.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px 14px ${r.skins > 0 ? '4px' : '12px'} 14px;">
                            <div style="display: flex; align-items: center; flex: 1; min-width: 0;">
                                ${rankHtml}
                                <span style="color: #1e293b; font-weight: 600; font-size: 15px;">${r.player.name}</span>${hcpDisplay}
                            </div>
                            <div style="font-size: 18px; font-weight: 700; color: #1e293b; white-space: nowrap; margin-left: 12px;">${r.skins} skin${r.skins !== 1 ? 's' : ''}</div>
                        </div>
                        ${holeDetailsHtml}
                    `;
                    container.appendChild(div);
                });
            }

            // Stableford
            else if (gameType.includes('Stableford')) {
                const modified = gameType.includes('Modified');
                
                const results = playersToDisplay.map((player, idx) => {
                    let points = 0;
                    player.scores.forEach((score, holeIdx) => {
                        if (score > 0) {
                            const netScore = getNetScore(score, player.handicap, courseData.holes[holeIdx].handicap, 'full');
                            const par = courseData.holes[holeIdx].par;
                            points += getStablefordPoints(netScore, par, modified);
                        }
                    });
                    return { player, points };
                }).sort((a, b) => b.points - a.points);

                results.forEach((r, position) => {
                    const medal = position === 0 ? 'ð¥' : position === 1 ? 'ð¥' : position === 2 ? 'ð¥' : `${position + 1}.`;
                    const hcpDisplay = r.player.handicap !== 0 ? `<span style="color: #6b7280; font-size: 13px; font-weight: 500; margin-left: 6px;">(${r.player.handicap > 0 ? r.player.handicap : '+' + Math.abs(r.player.handicap)})</span>` : '';
                    
                    // Medal/rank display
                    let rankHtml = '';
                    if (medal === 'ð¥') {
                        rankHtml = '<span style="font-size: 28px; margin-right: 10px;">ð</span>';
                    } else if (medal === 'ð¥') {
                        rankHtml = '<span style="font-size: 24px; margin-right: 10px;">ð¥</span>';
                    } else if (medal === 'ð¥') {
                        rankHtml = '<span style="font-size: 22px; margin-right: 10px;">ð¥</span>';
                    } else {
                        rankHtml = `<span style="font-weight: 700; font-size: 16px; color: #64748b; margin-right: 10px; min-width: 24px;">${medal}</span>`;
                    }
                    
                    const div = document.createElement('div');
                    div.className = 'results-player';
                    div.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px 14px;">
                            <div style="display: flex; align-items: center; flex: 1; min-width: 0;">
                                ${rankHtml}
                                <span style="color: #1e293b; font-weight: 600; font-size: 15px;">${r.player.name}</span>${hcpDisplay}
                            </div>
                            <div style="font-size: 18px; font-weight: 700; color: #1e293b; white-space: nowrap; margin-left: 12px;">${r.points} pts</div>
                        </div>
                    `;
                    container.appendChild(div);
                });
            }

            // Best Ball Games
            else if (gameType.includes('Best Ball')) {
                const teamsPerRound = gameType === '2-Man Best Ball' ? 2 : gameType === '3-Man Best Ball' ? 2 : 2;
                const scoreCount = gameType === '2-Man Best Ball' ? 1 : 2;
                
                const teamResults = tournamentData.teams.map((team, teamIdx) => {
                    let teamTotal = 0;
                    
                    for (let holeIdx = 0; holeIdx < 18; holeIdx++) {
                        const holeScores = team.map(playerIdx => {
                            const player = playersToDisplay[playerIdx];
                            const gross = player.scores[holeIdx];
                            if (gross === 0) return 999;
                            return getNetScore(gross, player.handicap, courseData.holes[holeIdx].handicap, 'full');
                        }).filter(s => s < 999).sort((a, b) => a - b);
                        
                        // Take best 1 score (2-man) or best 2 scores (3-man, 4-man)
                        const scoresToCount = holeScores.slice(0, scoreCount);
                        teamTotal += scoresToCount.reduce((sum, s) => sum + s, 0);
                    }
                    
                    const teamNames = team.map(pIdx => playersToDisplay[pIdx].name).join(' & ');
                    return { teamNames, teamTotal, teamIdx };
                }).sort((a, b) => a.teamTotal - b.teamTotal);

                teamResults.forEach((r, position) => {
                    const medal = position === 0 ? 'ð¥' : position === 1 ? 'ð¥' : `${position + 1}.`;
                    const toPar = r.teamTotal - courseData.totalPar;
                    const toParText = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : `${toPar}`);
                    
                    // Medal/rank display
                    let rankHtml = '';
                    if (medal === 'ð¥') {
                        rankHtml = '<span style="font-size: 28px; margin-right: 10px;">ð</span>';
                    } else if (medal === 'ð¥') {
                        rankHtml = '<span style="font-size: 24px; margin-right: 10px;">ð¥</span>';
                    } else {
                        rankHtml = `<span style="font-weight: 700; font-size: 16px; color: #64748b; margin-right: 10px; min-width: 24px;">${medal}</span>`;
                    }
                    
                    const div = document.createElement('div');
                    div.className = 'results-player';
                    div.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px 14px;">
                            <div style="display: flex; align-items: center; flex: 1; min-width: 0;">
                                ${rankHtml}
                                <span style="color: #1e293b; font-weight: 600; font-size: 15px;">${r.teamNames}</span>
                            </div>
                            <div style="font-size: 18px; font-weight: 700; color: #1e293b; white-space: nowrap; margin-left: 12px;">${r.teamTotal} <span style="color: #6b7280; font-size: 14px;">(${toParText})</span></div>
                        </div>
                    `;
                    container.appendChild(div);
                });
            }
        }

        function createPlayerResultCard(medal, name, score, toPar, handicap, scoreType = 'Gross') {
            const div = document.createElement('div');
            div.className = 'results-player card-shadow';
            div.style.animation = 'fadeIn 0.3s ease-out';
            
            // Handicap display in smaller gray font
            const hcpDisplay = handicap !== 0 ? `<span style="color: #6b7280; font-size: 13px; font-weight: 500; margin-left: 6px;">(${handicap > 0 ? handicap : '+' + Math.abs(handicap)})</span>` : '';
            
            // Medal/rank display
            let rankHtml = '';
            if (medal === 'ð¥') {
                rankHtml = '<span style="font-size: 28px; margin-right: 10px;">ð</span>';
            } else if (medal === 'ð¥') {
                rankHtml = '<span style="font-size: 24px; margin-right: 10px;">ð¥</span>';
            } else if (medal === 'ð¥') {
                rankHtml = '<span style="font-size: 22px; margin-right: 10px;">ð¥</span>';
            } else {
                rankHtml = `<span style="font-weight: 700; font-size: 16px; color: #64748b; margin-right: 10px; min-width: 24px;">${medal}</span>`;
            }
            
            div.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px 14px;">
                    <div style="display: flex; align-items: center; flex: 1; min-width: 0;">
                        ${rankHtml}
                        <span style="color: #1e293b; font-weight: 600; font-size: 15px;">${name}</span>${hcpDisplay}
                    </div>
                    <div style="font-size: 18px; font-weight: 700; color: #1e293b; white-space: nowrap; margin-left: 12px;">${score}</div>
                </div>
            `;
            return div;
        }

        // New round - with custom confirmation dialog
        function confirmNewRound() {
            const modal = document.createElement('div');
            modal.id = 'newRoundConfirmModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; max-width: 340px; width: 100%; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 12px;">â ï¸</div>
                    <h2 style="color: #ef4444; margin-bottom: 8px; font-size: 20px;">Start New Round?</h2>
                    <p style="color: #64748b; margin-bottom: 20px; font-size: 14px;">
                        All current scores will be cleared. This cannot be undone.
                    </p>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="executeNewRound()" style="padding: 14px; background: #ef4444; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            â Confirm New Round
                        </button>
                        <button onclick="saveAndDismissNewRound()" style="padding: 14px; background: #3b82f6; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            ð¾ Save Backup First
                        </button>
                        <button onclick="document.getElementById('newRoundConfirmModal').remove()" style="padding: 14px; background: #e2e8f0; color: #64748b; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function executeNewRound() {
            document.getElementById('newRoundConfirmModal')?.remove();
            newRound();
        }
        
        function saveAndDismissNewRound() {
            document.getElementById('newRoundConfirmModal')?.remove();
            saveTournamentFile();
            showNotification('Saved!', 'Backup downloaded. Tap Finish again to start new round.');
        }

        function newRound() {
            localStorage.removeItem('indianHillsScoring');
            tournamentData = { id: '', date: '', gameType: '', course: '', players: [], teams: [] };
            document.getElementById('tournamentDate').value = ''; // Clear date
            
            // Reset player list to default 1
            const playerList = document.getElementById('playerList');
            playerList.innerHTML = `
                <div class="player-row" data-player="1">
                    <input type="text" class="player-name-input" placeholder="Player Name" id="player1">
                    <input type="text" class="player-hcp-input" placeholder="HCP" id="hcp1" pattern="-?[0-9]*" inputmode="numeric">
                </div>
            `;
            
            currentPlayerCount = 1;
            nextPlayerId = 2;
            document.getElementById('addPlayerBtn').disabled = false;
            document.getElementById('addPlayerBtn').textContent = '+ Add Player';
            
            // Reset course and game type selection to directives
            document.getElementById('courseSelect').value = '';
            document.getElementById('gameType').value = '';
            courseData = null;
            
            showPage('setupPage');
        }

        // Load saved data on startup
        window.addEventListener('load', () => {
            checkForSavedRound();
        });

        // Prevent accidental page refresh
        // Prevent accidental page refresh/close when there's data
        window.addEventListener('beforeunload', (e) => {
            // Force save to localStorage before leaving
            if (tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                saveToLocalStorage();
            }
            
            const hasData = localStorage.getItem('indianHillsScoring');
            const hasPlayers = tournamentData && tournamentData.players && tournamentData.players.length > 0;
            
            if (hasData || hasPlayers) {
                const message = 'You have an active round in progress. Leaving will lose unsaved data.';
                e.preventDefault();
                e.returnValue = message; // For Chrome
                return message; // For other browsers
            }
        });
        
        // iOS Safari specific - save when app goes to background or tab loses focus
        // These events are more reliable on iOS than beforeunload
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                console.log('ð± Page hidden - emergency save triggered');
                if (tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                    saveToLocalStorage();
                }
            }
        });
        
        // Additional iOS Safari handler - pagehide is more reliable than beforeunload
        window.addEventListener('pagehide', () => {
            console.log('ð± Page hide - emergency save triggered');
            if (tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                saveToLocalStorage();
            }
        });

        // Universal button handler for iOS compatibility
        // This uses event delegation on the document level
        function handleButtonClick(e) {
            let target = e.target;
            
            // Find button if clicked on emoji or text inside button
            while (target && target !== document.body) {
                if (target.tagName === 'BUTTON' && target.hasAttribute('data-action')) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const action = target.getAttribute('data-action');
                    
                    // Execute the corresponding function
                    try {
                        switch(action) {
                            case 'confirmBackToSetup':
                                confirmBackToSetup();
                                break;
                            case 'finishRound':
                                finishRound();
                                break;
                            case 'shareResults':
                                shareResults();
                                break;
                            case 'exportToCsv':
                                exportToCsv();
                                break;
                            case 'printScorecard':
                                printScorecard();
                                break;
                            case 'backToScoring':
                                backToScoring();
                                break;
                            case 'confirmNewRound':
                                confirmNewRound();
                                break;
                            default:
                        }
                    } catch (err) {
                        console.error('Error executing button action:', err);
                        alert('Button error: ' + err.message);
                    }
                    
                    return false;
                }
                target = target.parentElement;
            }
        }

        // Attach to both click and touchend for maximum compatibility
        document.addEventListener('click', handleButtonClick, true);
        document.addEventListener('touchend', handleButtonClick, true);

        // Print Scorecard Function
        // Share results as text
        function shareResults() {
            let shareText = `â³ ${courseData.name} - ${formatDateDisplay(tournamentData.date)}\n`;
            shareText += `Game: ${tournamentData.gameType}\n\n`;
            shareText += `ð FINAL RESULTS\n`;
            shareText += `${'='.repeat(40)}\n\n`;
            
            // Calculate scores for all players
            const playerResults = tournamentData.players.map(player => {
                const grossScore = player.scores.reduce((sum, s) => sum + s, 0);
                const netScore = grossScore - player.handicap;
                const toPar = grossScore - courseData.totalPar;
                return { player, grossScore, netScore, toPar };
            });
            
            // Sort by appropriate score
            const isNet = tournamentData.gameType.includes('Net');
            playerResults.sort((a, b) => {
                const aScore = isNet ? a.netScore : a.grossScore;
                const bScore = isNet ? b.netScore : b.grossScore;
                return aScore - bScore;
            });
            
            // Format results
            playerResults.forEach((r, idx) => {
                const medal = idx === 0 ? 'ð¥ ' : idx === 1 ? 'ð¥ ' : idx === 2 ? 'ð¥ ' : '';
                const score = isNet ? r.netScore : r.grossScore;
                const toParText = r.toPar === 0 ? 'E' : (r.toPar > 0 ? `+${r.toPar}` : r.toPar);
                shareText += `${medal}${r.player.name}: ${score} (${toParText})\n`;
            });
            
            shareText += `\n---\nCreated with Let's Golf by Otis Williams`;
            
            // Use Web Share API if available
            if (navigator.share) {
                navigator.share({
                    title: `${courseData.name} Results`,
                    text: shareText
                }).catch(err => {
                    copyToClipboard(shareText);
                });
            } else {
                // Fallback to copy to clipboard
                copyToClipboard(shareText);
            }
        }
        
        // Copy to clipboard helper
        function copyToClipboard(text) {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text).then(() => {
                    alert('Results copied to clipboard!');
                }).catch(() => {
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }
        
        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                alert('Results copied to clipboard!');
            } catch (err) {
                alert('Could not copy results. Please try again.');
            }
            document.body.removeChild(textarea);
        }
        
        // ===== PHASE 1: SHARING FEATURES =====
        
        // Get current page URL
        function getCurrentPageURL() {
            return window.location.origin + window.location.pathname;
        }
        
        // Copy shareable tournament link
        
        // Download tournament data as JSON backup
        function downloadTournamentData() {
            if (!tournamentData.id) {
                alert('No active tournament to download');
                return;
            }
            
            const backup = {
                ...tournamentData,
                courseData: courseData,
                timestamp: new Date().toISOString(),
                version: '1.0'
            };
            
            const dataStr = JSON.stringify(backup, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const dateStr = formatDateDisplay(tournamentData.date).replace(/\//g, '-');
            const filename = `LetsGolf_${tournamentData.id}_${dateStr}.json`;
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            
            URL.revokeObjectURL(url);
            
            alert('â Tournament backup downloaded!\n\nYou can import this file later to restore the tournament.');
        }
        
        // Load tournament from URL parameter
        function loadTournamentFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const tournamentId = urlParams.get('tournament');
            
            if (tournamentId) {
                // Try to load from localStorage
                const savedData = localStorage.getItem('indianHillsScoring');
                if (savedData) {
                    const data = JSON.parse(savedData);
                    if (data.id === tournamentId) {
                        // Found matching tournament
                        alert(`ð Tournament "${tournamentId}" loaded!\n\nViewing shared tournament.`);
                        // Auto-resume if tournament exists
                        const resumeBtn = document.getElementById('resumeScoringBtn');
                        if (resumeBtn && resumeBtn.style.display !== 'none') {
                            resumeScoring();
                        }
                        return true;
                    }
                }
                
                // Tournament not found locally
                alert(`â ï¸ Tournament "${tournamentId}" not found on this device.\n\nMake sure you're on the same device where the tournament was created, or import the tournament backup file.`);
                return false;
            }
            return false;
        }
        
        // Import tournament from backup file
        function importTournamentBackup(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const backup = JSON.parse(e.target.result);
                    
                    // Validate backup structure
                    if (!backup.id || !backup.players || !backup.courseData) {
                        alert('â Invalid backup file format');
                        return;
                    }
                    
                    // Restore tournament data
                    tournamentData = {
                        id: backup.id,
                        date: backup.date,
                        gameType: backup.gameType,
                        course: backup.course,
                        players: backup.players,
                        teams: backup.teams || []
                    };
                    
                    courseData = backup.courseData;
                    
                    // Save to localStorage
                    saveToLocalStorage();
                    
                    // Show success and offer to resume
                    alert(`â Tournament imported successfully!\n\nID: ${backup.id}\nDate: ${formatDateDisplay(backup.date)}\nCourse: ${backup.courseData.name}\nPlayers: ${backup.players.length}`);
                    
                    // Reload page to show resume option
                    location.reload();
                    
                } catch (error) {
                    alert('â Error reading backup file. Please make sure it\'s a valid Let\'s Golf backup.');
                    console.error('Import error:', error);
                }
            };
            
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }
        
        // Export to CSV
        function exportToCsv() {
            const dateStr = formatDateDisplay(tournamentData.date).replace(/\//g, '-');
            const filename = `${courseData.name.replace(/\s+/g, '_')}_${dateStr}.csv`;
            
            let csv = `"Course","Game Type","Date"\n`;
            csv += `"${courseData.name}","${tournamentData.gameType}","${formatDateDisplay(tournamentData.date)}"\n\n`;
            
            // Player scores by hole
            csv += `"Player","Handicap"`;
            for (let i = 1; i <= 18; i++) {
                csv += `,"Hole ${i}"`;
            }
            csv += `,"Total","Net","To Par"\n`;
            
            tournamentData.players.forEach(player => {
                const total = player.scores.reduce((sum, s) => sum + s, 0);
                const net = total - player.handicap;
                const toPar = total - courseData.totalPar;
                const toParText = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar);
                
                csv += `"${player.name}","${player.handicap}"`;
                player.scores.forEach(score => {
                    csv += `,"${score || ''}"`;
                });
                csv += `,"${total}","${net}","${toParText}"\n`;
            });
            
            // Download CSV
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        function printScorecard() {
            // Print the current scorecard view
            window.print();
        }

        // Open scorecard modal
        function openScorecardModal() {
            const modal = document.getElementById('scorecardModal');
            const select = document.getElementById('scorecardViewSelect');
            
            // Populate individual player options
            const playerOptions = tournamentData.players
                .map((player, idx) => `<option value="player-${idx}">${player.name}</option>`)
                .join('');
            
            // Check if we're in multi-device mode (show My Players options)
            const showMyPlayersOptions = tournamentMode === 'multi';
            
            // Rebuild select to include players
            select.innerHTML = `
                <option value="all-summary">All Players - Summary Table</option>
                <option value="all-individual">All Players - Individual Cards</option>
                ${showMyPlayersOptions ? `
                    <option disabled>âââââââââââââââââ</option>
                    <option value="mine-summary">My Players - Summary Table</option>
                    <option value="mine-individual">My Players - Individual Cards</option>
                ` : ''}
                <option disabled>âââââââââââââââââ</option>
                ${playerOptions}
            `;
            
            modal.classList.add('active');
            updateScorecardView();
        }

        // Close scorecard modal
        function closeScorecardModal() {
            const modal = document.getElementById('scorecardModal');
            modal.classList.remove('active');
        }

        // Update scorecard view based on selection
        function updateScorecardView() {
            const select = document.getElementById('scorecardViewSelect');
            const body = document.getElementById('scorecardBody');
            const viewType = select.value;
            
            if (viewType === 'all-summary') {
                body.innerHTML = generateSummaryTable(false);
            } else if (viewType === 'mine-summary') {
                body.innerHTML = generateSummaryTable(true);
            } else if (viewType === 'all-individual') {
                body.innerHTML = generateAllIndividualCards(false);
            } else if (viewType === 'mine-individual') {
                body.innerHTML = generateAllIndividualCards(true);
            } else if (viewType.startsWith('player-')) {
                const playerIndex = parseInt(viewType.split('-')[1]);
                body.innerHTML = generateIndividualCard(playerIndex);
            }
        }

        // Generate summary table for all players
        function generateSummaryTable(myPlayersOnly = false) {
            const currentGameType = document.getElementById('resultsGameType').value;
            
            // Determine handicap method based on game type
            let hcpMethod = 'full';
            if (currentGameType.includes('18 Max')) {
                hcpMethod = '18max';
            } else if (currentGameType.includes('1/2 Pop')) {
                hcpMethod = 'half';
            }
            
            // Check if this is a net or team game (team games use net scores)
            const isNetOrTeam = currentGameType.includes('Net') || 
                                currentGameType.includes('Best Ball') || 
                                currentGameType.includes('Select Shot');
            
            // Check if this is a skins game
            const isSkinsGame = currentGameType.includes('Skins');
            
            // Get skins winners if applicable
            let skinWinners = {};
            if (isSkinsGame) {
                skinWinners = calculateSkinsForScorecard(currentGameType, hcpMethod);
            }
            
            // Load player order for highlighting
            loadPlayerOrder();
            
            // Determine which players to show
            let playersToShow = tournamentData.players;
            let allPlayers = tournamentData.players; // Keep reference to all for ranking
            
            if (myPlayersOnly) {
                playersToShow = tournamentData.players.filter(p => 
                    p.claimedBy === currentDeviceId || playerOrder.watching.includes(p.name)
                );
            }
            
            let html = `
                <div style="margin-bottom: 8px; text-align: center;">
                    ${tournamentData.name ? `<h2 style="color: #1e40af; margin-bottom: 4px; font-size: 18px; font-weight: 700;">${tournamentData.name}</h2>` : ''}
                    <h3 style="color: #1e40af; margin-bottom: 2px; font-size: 16px;">${courseData.name}</h3>
                    <p style="color: #64748b; font-size: 12px; margin: 0;">${currentGameType} - ${formatDateDisplay(tournamentData.date)}${myPlayersOnly ? ' (My Players)' : ''}</p>
                </div>
                <div class="table-wrapper">
                <table class="scorecard-table">
                    <thead>
                        <tr>
                            <th style="width: 70px;">Hole</th>
            `;
            
            // Add player name columns with highlighting
            playersToShow.forEach(player => {
                let bgStyle = '';
                let fontStyle = '';
                if (player.claimedBy === currentDeviceId) {
                    bgStyle = 'background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);'; // Yellow for claimed
                    fontStyle = 'color: #1e293b;'; // Black text for readability
                } else if (playerOrder.watching && playerOrder.watching.includes(player.name)) {
                    bgStyle = 'background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);'; // Blue for watching
                    fontStyle = 'color: #1e293b;'; // Black text for readability
                }
                html += `<th style="${bgStyle}${fontStyle}">${player.name}<br><span style="font-size: 11px; ${fontStyle}">(${player.handicap > 0 ? player.handicap : player.handicap < 0 ? '+' + Math.abs(player.handicap) : 'Scratch'})</span></th>`;
            });
            
            html += `</tr></thead><tbody>`;
            
            // Add hole rows
            for (let i = 0; i < 18; i++) {
                const hole = courseData.holes[i];
                html += `<tr>`;
                html += `<td style="font-size: 10px; line-height: 1.1;"><strong style="font-size: 11px;">${hole.number}</strong><br>Par ${hole.par}<br>Hcp ${hole.handicap}</td>`;
                
                playersToShow.forEach(player => {
                    const playerIdx = allPlayers.findIndex(p => p.name === player.name);
                    const score = player.scores[i] || '';
                    let netScore = '';
                    
                    if (score && isNetOrTeam) {
                        netScore = getNetScore(score, player.handicap, hole.handicap, hcpMethod);
                    }
                    
                    // Check for highlighting
                    let cellStyle = '';
                    if (player.claimedBy === currentDeviceId) {
                        cellStyle = 'background: #fef9c3;'; // Light yellow
                    } else if (playerOrder.watching && playerOrder.watching.includes(player.name)) {
                        cellStyle = 'background: #e0f2fe;'; // Light blue
                    }
                    
                    // Check if this player won a skin on this hole
                    let isSkinWinner = false;
                    if (isSkinsGame && skinWinners[i] && skinWinners[i].includes(playerIdx)) {
                        isSkinWinner = true;
                        cellStyle = 'background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%); font-weight: 700;';
                    }
                    
                    html += `<td style="${cellStyle}">`;
                    if (score) {
                        html += `<strong>${score}</strong>`;
                        if (netScore !== '' && netScore !== score) {
                            html += `<br><span style="font-size: 9px; color: #10b981;">(${netScore})</span>`;
                        }
                        if (isSkinWinner) {
                            html += `<br><span style="font-size: 9px;">ð</span>`;
                        }
                    }
                    html += `</td>`;
                });
                
                html += `</tr>`;
                
                // Add subtotal after hole 9
                if (i === 8) {
                    html += `<tr class="total-row">`;
                    html += `<td><strong>OUT</strong></td>`;
                    
                    playersToShow.forEach(player => {
                        let cellStyle = '';
                        if (player.claimedBy === currentDeviceId) {
                            cellStyle = 'background: #fef9c3;';
                        } else if (playerOrder.watching && playerOrder.watching.includes(player.name)) {
                            cellStyle = 'background: #e0f2fe;';
                        }
                        const outGross = player.scores.slice(0, 9).reduce((sum, s) => sum + (s || 0), 0);
                        html += `<td style="${cellStyle}"><strong>${outGross || ''}</strong></td>`;
                    });
                    
                    html += `</tr>`;
                }
            }
            
            // Add total row
            html += `<tr class="total-row">`;
            html += `<td><strong>IN</strong></td>`;
            
            playersToShow.forEach(player => {
                let cellStyle = '';
                if (player.claimedBy === currentDeviceId) {
                    cellStyle = 'background: #fef9c3;';
                } else if (playerOrder.watching && playerOrder.watching.includes(player.name)) {
                    cellStyle = 'background: #e0f2fe;';
                }
                const inGross = player.scores.slice(9).reduce((sum, s) => sum + (s || 0), 0);
                html += `<td style="${cellStyle}"><strong>${inGross || ''}</strong></td>`;
            });
            
            html += `</tr>`;
            
            // Add grand total
            html += `<tr class="total-row" style="background: #dbeafe;">`;
            html += `<td><strong>TOTAL</strong></td>`;
            
            playersToShow.forEach(player => {
                let cellStyle = '';
                if (player.claimedBy === currentDeviceId) {
                    cellStyle = 'background: #fde68a;';
                } else if (playerOrder.watching && playerOrder.watching.includes(player.name)) {
                    cellStyle = 'background: #bfdbfe;';
                }
                const totalGross = player.scores.reduce((sum, s) => sum + (s || 0), 0);
                const totalNet = totalGross - player.handicap;
                const toPar = totalGross - courseData.totalPar;
                const toParText = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar);
                
                html += `<td style="${cellStyle}"><strong>${totalGross}</strong>`;
                if (currentGameType.includes('Net')) {
                    html += `<br><span style="font-size: 9px; color: #10b981;">(Net: ${totalNet})</span>`;
                }
                html += `<br><span style="font-size: 9px;">${toParText}</span>`;
                html += `</td>`;
            });
            
            html += `</tr>`;
            html += `</tbody></table>`;
            html += `</div>`; // Close table-wrapper
            
            return html;
        }
        
        // Calculate skins winners for scorecard display
        function calculateSkinsForScorecard(gameType, hcpMethod) {
            const skinWinners = {}; // hole index => array of player indices who won
            
            for (let holeIdx = 0; holeIdx < 18; holeIdx++) {
                const hole = courseData.holes[holeIdx];
                let scores = [];
                
                tournamentData.players.forEach((player, pIdx) => {
                    let score = player.scores[holeIdx];
                    if (score > 0) {
                        if (gameType.includes('Net')) {
                            score = getNetScore(score, player.handicap, hole.handicap, hcpMethod);
                        }
                        scores.push({ playerIdx: pIdx, score });
                    }
                });
                
                if (scores.length > 0) {
                    const minScore = Math.min(...scores.map(s => s.score));
                    const winners = scores.filter(s => s.score === minScore);
                    
                    // Only award skin if there's a single winner (no tie)
                    if (winners.length === 1) {
                        skinWinners[holeIdx] = [winners[0].playerIdx];
                    }
                }
            }
            
            return skinWinners;
        }

        // Generate all individual cards
        function generateAllIndividualCards(myPlayersOnly = false) {
            let html = '';
            let playersToShow = tournamentData.players;
            
            if (myPlayersOnly) {
                loadPlayerOrder();
                playersToShow = tournamentData.players.filter(p => 
                    p.claimedBy === currentDeviceId || playerOrder.watching.includes(p.name)
                );
            }
            
            playersToShow.forEach((player) => {
                const playerIdx = tournamentData.players.findIndex(p => p.name === player.name);
                html += generateIndividualCard(playerIdx);
            });
            return html;
        }

        // Generate individual scorecard for one player
        function generateIndividualCard(playerIndex) {
            const player = tournamentData.players[playerIndex];
            const currentGameType = document.getElementById('resultsGameType').value;
            
            // Determine handicap method based on game type
            let hcpMethod = 'full';
            if (currentGameType.includes('18 Max')) {
                hcpMethod = '18max';
            } else if (currentGameType.includes('1/2 Pop')) {
                hcpMethod = 'half';
            }
            
            let html = `
                <div class="scorecard-individual">
                    <div class="scorecard-player-header">
                        <div class="scorecard-player-name">${player.name}</div>
                        <div class="scorecard-player-info">
                            ${tournamentData.name ? `<strong>${tournamentData.name}</strong><br>` : ''}
                            ${courseData.name} â¢ ${currentGameType}<br>
                            ${formatDateDisplay(tournamentData.date)} â¢ Handicap: ${player.handicap > 0 ? player.handicap : player.handicap < 0 ? '+' + Math.abs(player.handicap) : 'Scratch'}
                        </div>
                    </div>
                    
                    <div class="table-wrapper">
                    <table class="scorecard-table">
                        <thead>
                            <tr>
                                <th>Hole</th>
            `;
            
            // Front 9
            for (let i = 1; i <= 9; i++) {
                html += `<th>${i}</th>`;
            }
            html += `<th>OUT</th>`;
            
            // Back 9
            for (let i = 10; i <= 18; i++) {
                html += `<th>${i}</th>`;
            }
            html += `<th>IN</th><th>TOT</th>`;
            
            html += `</tr></thead><tbody>`;
            
            // Par row
            html += `<tr><td><strong>Par</strong></td>`;
            let frontPar = 0, backPar = 0;
            for (let i = 0; i < 9; i++) {
                frontPar += courseData.holes[i].par;
                html += `<td>${courseData.holes[i].par}</td>`;
            }
            html += `<td><strong>${frontPar}</strong></td>`;
            for (let i = 9; i < 18; i++) {
                backPar += courseData.holes[i].par;
                html += `<td>${courseData.holes[i].par}</td>`;
            }
            html += `<td><strong>${backPar}</strong></td><td><strong>${courseData.totalPar}</strong></td></tr>`;
            
            // Handicap row
            html += `<tr><td><strong>HCP</strong></td>`;
            for (let i = 0; i < 9; i++) {
                html += `<td style="font-size: 11px;">${courseData.holes[i].handicap}</td>`;
            }
            html += `<td></td>`;
            for (let i = 9; i < 18; i++) {
                html += `<td style="font-size: 11px;">${courseData.holes[i].handicap}</td>`;
            }
            html += `<td></td><td></td></tr>`;
            
            // Gross score row
            html += `<tr style="background: #f0f9ff;"><td><strong>Gross</strong></td>`;
            let frontGross = 0, backGross = 0;
            for (let i = 0; i < 9; i++) {
                const score = player.scores[i] || '';
                if (score) frontGross += score;
                html += `<td><strong>${score}</strong></td>`;
            }
            html += `<td><strong>${frontGross || ''}</strong></td>`;
            for (let i = 9; i < 18; i++) {
                const score = player.scores[i] || '';
                if (score) backGross += score;
                html += `<td><strong>${score}</strong></td>`;
            }
            const totalGross = frontGross + backGross;
            html += `<td><strong>${backGross || ''}</strong></td><td><strong>${totalGross || ''}</strong></td></tr>`;
            
            // Net score row (if applicable - for net games OR team games)
            const isNetOrTeam = currentGameType.includes('Net') || 
                                currentGameType.includes('Best Ball') || 
                                currentGameType.includes('Select Shot');
            
            if (isNetOrTeam && player.handicap !== 0) {
                html += `<tr style="background: #dcfce7;"><td><strong>Net</strong></td>`;
                let frontNet = 0, backNet = 0;
                for (let i = 0; i < 9; i++) {
                    const gross = player.scores[i];
                    if (gross) {
                        const net = getNetScore(gross, player.handicap, courseData.holes[i].handicap, hcpMethod);
                        frontNet += net;
                        html += `<td><strong>${net}</strong></td>`;
                    } else {
                        html += `<td></td>`;
                    }
                }
                html += `<td><strong>${frontNet || ''}</strong></td>`;
                for (let i = 9; i < 18; i++) {
                    const gross = player.scores[i];
                    if (gross) {
                        const net = getNetScore(gross, player.handicap, courseData.holes[i].handicap, hcpMethod);
                        backNet += net;
                        html += `<td><strong>${net}</strong></td>`;
                    } else {
                        html += `<td></td>`;
                    }
                }
                const totalNet = frontNet + backNet;
                html += `<td><strong>${backNet || ''}</strong></td><td><strong>${totalNet || ''}</strong></td></tr>`;
            }
            
            // To Par row
            const toPar = totalGross - courseData.totalPar;
            const toParText = toPar === 0 ? 'Even' : (toPar > 0 ? `+${toPar}` : toPar);
            html += `<tr class="total-row"><td colspan="11"><strong>To Par:</strong></td><td colspan="10"><strong>${toParText}</strong></td></tr>`;
            
            html += `</tbody></table>`;
            html += `</div>`; // Close table-wrapper
            html += `</div>`; // Close scorecard-individual
            
            return html;
        }
        // Check for saved round on page load
        function checkForSavedRound() {
            const savedData = localStorage.getItem('indianHillsScoring');
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    
                    // CRITICAL: Restore activeTournamentId, tournamentMode, and isHost
                    activeTournamentId = data._activeTournamentId || null;
                    tournamentMode = data._tournamentMode || 'single';
                    isHost = data._isHost || false;
                    
                    const resumeSection = document.getElementById('resumeRoundSection');
                    const resumeInfo = document.getElementById('resumeRoundInfo');
                    const shareButtons = document.getElementById('resumeShareButtons');
                    
                    if (data.players && data.players.length > 0) {
                        // Show resume section
                        resumeSection.classList.add('active');
                        
                        // Format info
                        const playerCount = data.players.length;
                        const date = data.date ? new Date(data.date).toLocaleDateString() : 'Today';
                        const gametype = data.gameType || 'Round';
                        const tournamentName = data.name || '';
                        
                        let infoText = `${playerCount} player${playerCount > 1 ? 's' : ''} â¢ ${gametype}`;
                        if (tournamentName) {
                            infoText = `${tournamentName} â¢ ${infoText}`;
                        }
                        resumeInfo.textContent = infoText;
                        
                        // Debug logging
                        console.log('checkForSavedRound - tournamentMode:', tournamentMode);
                        console.log('checkForSavedRound - activeTournamentId:', activeTournamentId);
                        console.log('checkForSavedRound - isHost:', isHost);
                        
                        // Show share buttons in multi-device mode (even if tournament creation failed)
                        if (shareButtons && tournamentMode === 'multi' && activeTournamentId) {
                            console.log('â Showing share buttons - activeTournamentId:', activeTournamentId);
                            
                            // Add class for CSS-based visibility (better for iOS)
                            shareButtons.classList.add('visible');
                            
                            // Also set inline styles with !important
                            shareButtons.style.setProperty('display', 'grid', 'important');
                            shareButtons.style.setProperty('visibility', 'visible', 'important');
                            shareButtons.style.setProperty('opacity', '1', 'important');
                            
                            // Triple-check with multiple delays (for iOS)
                            setTimeout(() => {
                                if (shareButtons) {
                                    shareButtons.classList.add('visible');
                                    shareButtons.style.setProperty('display', 'grid', 'important');
                                    console.log('â Re-confirmed share buttons visible (100ms)');
                                }
                            }, 100);
                            
                            setTimeout(() => {
                                if (shareButtons) {
                                    shareButtons.classList.add('visible');
                                    shareButtons.style.setProperty('display', 'grid', 'important');
                                    console.log('â Re-confirmed share buttons visible (500ms)');
                                }
                            }, 500);
                        } else if (shareButtons) {
                            console.log('â Hiding share buttons - mode:', tournamentMode, 'tournamentId:', activeTournamentId);
                            shareButtons.classList.remove('visible');
                            shareButtons.style.display = 'none';
                        }
                    }
                } catch (e) {
                    console.error('Error loading saved round:', e);
                }
            }
        }

        // Resume saved round
        function resumeSavedRound() {
            if (loadFromLocalStorage()) {
                // Restore the course data
                courseData = courses[tournamentData.course];
                
                // Re-save to persist any auto-fixes
                saveToLocalStorage();
                
                renderScoringPage();
                showPage('scoringPage');
                showRoundIndicator();
            }
        }

        // Discard saved round and start fresh
        function discardSavedRound() {
            showConfirm(
                'Discard Saved Round?',
                'This will permanently delete your saved round. Are you sure?',
                function() {
                    localStorage.removeItem('indianHillsScoring');
                    document.getElementById('resumeRoundSection').classList.remove('active');
                    
                    // Hide Resume Scoring button
                    const resumeBtn = document.getElementById('resumeScoringBtn');
                    if (resumeBtn) {
                        resumeBtn.style.display = 'none';
                    }
                    
                    hideConfirmDialog();
                }
            );
        }

        // Show round in progress indicator
        function showRoundIndicator() {
            const indicator = document.getElementById('roundIndicator');
            if (indicator) {
                indicator.classList.add('active');
            }
        }

        // Hide round in progress indicator
        function hideRoundIndicator() {
            const indicator = document.getElementById('roundIndicator');
            if (indicator) {
                indicator.classList.remove('active');
            }
        }

        // Show auto-save toast
        function showAutoSaveToast() {
            const toast = document.getElementById('autoSaveToast');
            if (toast) {
                toast.classList.add('show');
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 800);
            }
        }

        // Override saveToLocalStorage to add visual feedback
        const originalSave = saveToLocalStorage;
        saveToLocalStorage = function() {
            originalSave();
            showAutoSaveToast();
        };

        // Disable pull-to-refresh on iOS during active round
        function disablePullToRefresh() {
            document.body.style.overscrollBehavior = 'none';
            document.documentElement.style.overscrollBehavior = 'none';
        }

        // Enable pull-to-refresh
        function enablePullToRefresh() {
            document.body.style.overscrollBehavior = 'auto';
            document.documentElement.style.overscrollBehavior = 'auto';
        }

        // Switch to player view
        function switchToPlayerView() {
            currentView = 'player';
            document.getElementById('playerCards').style.display = 'block';
            document.getElementById('holeView').style.display = 'none';
            document.getElementById('togglePlayerView').classList.add('active');
            document.getElementById('toggleHoleView').classList.remove('active');
            
            // Use compact view rendering with sorted players (claimed first, then watched)
            renderCompactPlayerView(getPlayersToShow());
        }
        
        // Player carousel state
        let currentCarouselIndex = 0;
        let carouselTouchStartX = 0;
        let carouselTouchEndX = 0;
        
        // Input mode state
        let inputMode = 'keyboard'; // 'keyboard' or 'voice'
        let currentVoiceTarget = null; // { playerIndex, holeIndex }
        let recognition = null;
        
        // Set input mode
        function setInputMode(mode) {
            inputMode = mode;
            const keyboardBtn = document.getElementById('keyboardModeBtn');
            const voiceBtn = document.getElementById('voiceModeBtn');
            
            keyboardBtn.classList.toggle('active', mode === 'keyboard');
            voiceBtn.classList.toggle('active', mode === 'voice');
            voiceBtn.classList.toggle('voice-active', mode === 'voice');
            
            // Check if voice is supported
            if (mode === 'voice' && !('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                alert('Voice input is not supported in this browser. Please use Chrome or Safari.');
                setInputMode('keyboard');
            }
        }
        
        // Initialize speech recognition
        function initSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) return null;
            
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';
            recognition.maxAlternatives = 3;
            
            recognition.onresult = (event) => {
                const result = event.results[0][0].transcript.toLowerCase().trim();
                console.log('Voice result:', result);
                processVoiceResult(result);
            };
            
            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                hideVoiceListening();
                if (event.error === 'not-allowed') {
                    alert('Microphone access denied. Please enable microphone permissions.');
                    setInputMode('keyboard');
                }
            };
            
            recognition.onend = () => {
                // Auto-hide after timeout if no result
                setTimeout(() => {
                    hideVoiceListening();
                }, 500);
            };
            
            return recognition;
        }
        
        // Process voice input result
        function processVoiceResult(result) {
            if (!currentVoiceTarget) {
                console.log('No voice target, ignoring result:', result);
                return;
            }
            
            // Capture target immediately in case it gets cleared
            const targetPlayerIndex = currentVoiceTarget.playerIndex;
            const targetHoleIndex = currentVoiceTarget.holeIndex;
            
            let score = null;
            
            // Direct number parsing
            const numMatch = result.match(/\d+/);
            if (numMatch) {
                score = parseInt(numMatch[0]);
            }
            
            // Word to number mapping
            const wordNumbers = {
                'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,
                'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9,
                'ten': 10, 'eleven': 11, 'twelve': 12
            };
            
            for (const [word, num] of Object.entries(wordNumbers)) {
                if (result.includes(word)) {
                    score = num;
                    break;
                }
            }
            
            // Golf terms (relative to par)
            if (courseData && courseData.holes[targetHoleIndex]) {
                const hole = courseData.holes[targetHoleIndex];
                const par = hole.par;
                
                if (result.includes('ace') || result.includes('hole in one')) {
                    score = 1;
                } else if (result.includes('double eagle') || result.includes('albatross')) {
                    score = par - 3;
                } else if (result.includes('eagle')) {
                    score = par - 2;
                } else if (result.includes('birdie')) {
                    score = par - 1;
                } else if (result.includes('par')) {
                    score = par;
                } else if (result.includes('bogey') && !result.includes('double') && !result.includes('triple')) {
                    score = par + 1;
                } else if (result.includes('double bogey') || result.includes('double')) {
                    score = par + 2;
                } else if (result.includes('triple bogey') || result.includes('triple')) {
                    score = par + 3;
                }
            }
            
            // Show result and save
            if (score !== null && score >= 1 && score <= 15) {
                document.getElementById('voiceResult').textContent = score;
                
                setTimeout(() => {
                    updateScore(targetPlayerIndex, targetHoleIndex, score);
                    hideVoiceListening();
                    // Refresh appropriate view
                    if (currentView === 'hole') {
                        renderHoleView();
                    } else {
                        switchToPlayerView();
                    }
                }, 800);
            } else {
                document.getElementById('voiceResult').textContent = '?';
                setTimeout(hideVoiceListening, 1000);
            }
        }
        
        // Show voice listening overlay
        function showVoiceListening(playerIndex, holeIndex) {
            currentVoiceTarget = { playerIndex, holeIndex };
            document.getElementById('voiceResult').textContent = '';
            document.getElementById('voiceListening').classList.add('active');
            
            if (!recognition) {
                recognition = initSpeechRecognition();
            }
            
            if (recognition) {
                try {
                    recognition.start();
                } catch (e) {
                    console.error('Could not start recognition:', e);
                }
            }
            
            // Auto-timeout after 4 seconds
            setTimeout(() => {
                if (document.getElementById('voiceListening').classList.contains('active')) {
                    hideVoiceListening();
                }
            }, 4000);
        }
        
        // Hide voice listening overlay
        function hideVoiceListening() {
            document.getElementById('voiceListening').classList.remove('active');
            currentVoiceTarget = null;
            if (recognition) {
                try {
                    recognition.stop();
                } catch (e) {}
            }
        }
        
        // Handle score cell click (keyboard or voice based on mode)
        function handleScoreCellClick(playerIndex, holeIndex, currentScore) {
            if (inputMode === 'voice') {
                showVoiceListening(playerIndex, holeIndex);
            } else {
                // Keyboard mode - show prompt
                const hole = courseData.holes[holeIndex];
                const newScore = prompt(`Hole ${hole.number} (Par ${hole.par}) - Enter score:`, currentScore || hole.par);
                if (newScore !== null) {
                    const score = parseInt(newScore);
                    if (!isNaN(score) && score >= 0 && score <= 15) {
                        updateScore(playerIndex, holeIndex, score);
                        renderScoringPage();
                    }
                }
            }
        }
        
        // Render compact player view (9-column grid)
        function renderCompactPlayerView(playersToShow) {
            const container = document.getElementById('playerCards');
            
            // Build carousel with compact cards (6 columns x 3 rows)
            let slidesHTML = playersToShow.map((player, idx) => {
                const actualPlayerIndex = tournamentData.players.indexOf(player);
                const total = player.scores.reduce((sum, score) => sum + (score || 0), 0);
                const toPar = total - courseData.totalPar;
                const toParText = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar);
                const hcpDisplay = player.handicap !== 0 ? ` (${player.handicap})` : '';
                
                // Check if this is a watched player (not claimed by this device)
                const isWatchedPlayer = tournamentMode === 'multi' && !canManageTournament() && player.claimedBy !== currentDeviceId;
                const watchIndicator = isWatchedPlayer ? ' ð' : '';
                
                // Calculate front/back 9 totals
                const front9 = player.scores.slice(0, 9).reduce((sum, s) => sum + (s || 0), 0);
                const back9 = player.scores.slice(9, 18).reduce((sum, s) => sum + (s || 0), 0);
                
                // Generate hole cells in 3 rows of 6
                let row1Cells = ''; // Holes 1-6
                let row2Cells = ''; // Holes 7-12
                let row3Cells = ''; // Holes 13-18
                
                // Determine net method for dots
                let netMethod = 'full';
                const gameTypeLower = tournamentData.gameType.toLowerCase();
                if (gameTypeLower.includes('18 max')) {
                    netMethod = '18max';
                } else if (gameTypeLower.includes('1/2 pop') || gameTypeLower.includes('half pop')) {
                    netMethod = 'half';
                }
                
                for (let i = 0; i < 18; i++) {
                    const hole = courseData.holes[i];
                    const score = player.scores[i];
                    const diff = score ? score - hole.par : 0;
                    let scoreClass = 'empty';
                    if (score > 0) {
                        if (diff <= -1) scoreClass = 'birdie-better';
                        else if (diff === 0) scoreClass = 'par';
                        else if (diff === 1) scoreClass = 'bogey';
                        else scoreClass = 'double-plus';
                    }
                    
                    // Calculate handicap dots
                    let hcpDotsHtml = '';
                    if (player.handicap !== 0) {
                        const strokes = getHandicapStrokesForHole(player.handicap, hole.handicap, netMethod);
                        if (strokes !== 0) {
                            const isHalfPop = netMethod === 'half';
                            const dotCount = isHalfPop ? Math.abs(strokes * 2) : Math.abs(strokes);
                            const dotColor = strokes > 0 ? 'green' : 'red';
                            
                            hcpDotsHtml = '<div class="hcp-dots-compact">';
                            for (let d = 0; d < Math.min(dotCount, 3); d++) {
                                hcpDotsHtml += `<span class="hcp-dot-compact ${dotColor}"></span>`;
                            }
                            hcpDotsHtml += '</div>';
                        }
                    }
                    
                    // Calculate net score for display
                    let netScoreHTML = '';
                    if (score > 0 && player.handicap !== 0) {
                        const netScore = getNetScore(score, player.handicap, hole.handicap, netMethod);
                        netScoreHTML = `<div class="net-score">(${netScore})</div>`;
                    }
                    
                    const cellHTML = `
                        <div class="hole-cell" onclick="handleCompactCellClick(${actualPlayerIndex}, ${i}, ${score || 0}, '${player.name}')">
                            <div class="hole-num">${hole.number}</div>
                            <div class="hole-par">Par ${hole.par}</div>
                            <div class="hole-hcp">H${hole.handicap}</div>
                            ${hcpDotsHtml}
                            <div class="score-cell ${scoreClass}">
                                ${score || '-'}
                            </div>
                            ${netScoreHTML}
                        </div>
                    `;
                    
                    if (i < 6) row1Cells += cellHTML;
                    else if (i < 12) row2Cells += cellHTML;
                    else row3Cells += cellHTML;
                }
                
                return `
                    <div class="player-carousel-slide" data-index="${idx}">
                        <div class="player-card-compact ${isWatchedPlayer ? 'watched' : ''}">
                            <div class="player-header-compact">
                                <div class="player-name-compact">
                                    ${createPlayerAvatar(player.name)}
                                    <span>${player.name}${hcpDisplay}${watchIndicator}</span>
                                </div>
                                <div class="player-total-compact">${total > 0 ? total : '-'} (${toParText})</div>
                            </div>
                            
                            <div class="nine-section">
                                <div class="nine-section-label">
                                    <span>HOLES 1-6</span>
                                </div>
                                <div class="holes-grid-6">
                                    ${row1Cells}
                                </div>
                            </div>
                            
                            <div class="nine-section">
                                <div class="nine-section-label">
                                    <span>HOLES 7-12</span>
                                </div>
                                <div class="holes-grid-6">
                                    ${row2Cells}
                                </div>
                            </div>
                            
                            <div class="nine-section">
                                <div class="nine-section-label">
                                    <span>HOLES 13-18</span>
                                </div>
                                <div class="holes-grid-6">
                                    ${row3Cells}
                                </div>
                            </div>
                            
                            <div class="totals-row">
                                <div class="total-item">
                                    <div class="total-label">OUT</div>
                                    <div class="total-value">${front9 > 0 ? front9 : '-'}</div>
                                </div>
                                <div class="total-item">
                                    <div class="total-label">IN</div>
                                    <div class="total-value">${back9 > 0 ? back9 : '-'}</div>
                                </div>
                                <div class="total-item">
                                    <div class="total-label">TOTAL</div>
                                    <div class="total-value">${total > 0 ? total : '-'}</div>
                                </div>
                                <div class="total-item">
                                    <div class="total-label">TO PAR</div>
                                    <div class="total-value">${toParText}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Single player - no carousel needed
            if (playersToShow.length === 1) {
                container.innerHTML = `
                    <div style="padding: 0 8px;">
                        <div style="display: flex; justify-content: center; gap: 8px; padding: 6px 8px; background: rgba(255,255,255,0.95); border-radius: 10px; margin-bottom: 8px;">
                            <button id="fullscreenToggleBtn" onclick="toggleFullscreenPlayerView()" title="Toggle fullscreen" style="padding: 8px 14px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">â¶</button>
                        </div>
                        ${slidesHTML.replace('class="player-carousel-slide"', '')}
                    </div>
                `;
                return;
            }
            
            // Store players globally for nav access
            window.carouselPlayers = playersToShow;
            
            // Get prev/next player names for initial state (infinite wrap)
            const getFirstName = (name) => name ? name.split(' ')[0] : '';
            // At first player: prev wraps to last, next goes to second
            const prevPlayerName = playersToShow.length > 1 ? getFirstName(playersToShow[playersToShow.length - 1].name) : '';
            const nextPlayerName = playersToShow.length > 1 ? getFirstName(playersToShow[1].name) : '';
            
            // Multiple players - use carousel with player names in nav (infinite - always enabled)
            const carouselHTML = `
                <div class="carousel-nav" style="display: flex; align-items: center; justify-content: space-between; padding: 6px 8px; background: rgba(255,255,255,0.95); border-radius: 10px; margin: 0 8px 8px 8px; gap: 4px;">
                    <button class="carousel-nav-btn" id="carouselPrev" onclick="carouselPrev()" style="display: flex; align-items: center; gap: 3px; padding: 8px 10px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; flex: 1; justify-content: center; max-width: 110px;">
                        <span>â</span> <span id="prevPlayerName" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${prevPlayerName}</span>
                    </button>
                    <button onclick="resetCarousel()" title="Reset to first player" style="padding: 8px 10px; background: #64748b; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">âº</button>
                    <button onclick="showPlayerSearchModal()" title="Search players" style="padding: 8px 10px; background: #f1f5f9; border: 2px solid #e2e8f0; border-radius: 8px; cursor: pointer; font-size: 14px;">ð</button>
                    <button id="fullscreenToggleBtn" onclick="toggleFullscreenPlayerView()" title="Toggle fullscreen" style="padding: 8px 10px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">â¶</button>
                    <button class="carousel-nav-btn" id="carouselNext" onclick="carouselNext()" style="display: flex; align-items: center; gap: 3px; padding: 8px 10px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; flex: 1; justify-content: center; max-width: 110px;">
                        <span id="nextPlayerName" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${nextPlayerName}</span> <span>â</span>
                    </button>
                </div>
                <div class="player-carousel" id="playerCarousel">
                    <div class="player-carousel-track" id="carouselTrack">
                        ${slidesHTML}
                    </div>
                </div>
                <div class="carousel-dots" id="carouselDots">
                    ${playersToShow.map((_, idx) => `
                        <div class="carousel-dot ${idx === 0 ? 'active' : ''}" onclick="goToCarouselSlide(${idx})"></div>
                    `).join('')}
                </div>
            `;
            
            container.innerHTML = carouselHTML;
            
            // Setup swipe listeners
            const carousel = document.getElementById('playerCarousel');
            
            carousel.addEventListener('touchstart', (e) => {
                carouselTouchStartX = e.changedTouches[0].screenX;
            }, { passive: true });
            
            carousel.addEventListener('touchend', (e) => {
                carouselTouchEndX = e.changedTouches[0].screenX;
                handleCarouselSwipe();
            }, { passive: true });
            
            // Reset carousel index
            currentCarouselIndex = 0;
            updateCarouselNav();
        }
        
        // Player search modal
        function showPlayerSearchModal() {
            const players = window.carouselPlayers || [];
            if (players.length === 0) return;
            
            let listHTML = players.map((p, idx) => `
                <button onclick="goToCarouselSlide(${idx}); closePlayerSearchModal();" style="
                    display: block;
                    width: 100%;
                    padding: 14px 16px;
                    margin-bottom: 8px;
                    background: ${idx === currentCarouselIndex ? '#3b82f6' : '#f1f5f9'};
                    color: ${idx === currentCarouselIndex ? 'white' : '#1e293b'};
                    border: none;
                    border-radius: 8px;
                    font-size: 16px;
                    font-weight: 600;
                    text-align: left;
                    cursor: pointer;
                ">${p.name}</button>
            `).join('');
            
            const modal = document.createElement('div');
            modal.id = 'playerSearchModal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;';
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 20px; width: 100%; max-width: 320px; max-height: 70vh; overflow-y: auto;">
                    <h3 style="margin: 0 0 16px 0; color: #1e40af; font-size: 18px;">Jump to Player</h3>
                    ${listHTML}
                    <button onclick="closePlayerSearchModal()" style="width: 100%; padding: 14px; background: #e2e8f0; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 8px;">Cancel</button>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function closePlayerSearchModal() {
            const modal = document.getElementById('playerSearchModal');
            if (modal) modal.remove();
        }
        
        // Fullscreen state
        let isFullscreenPlayerView = false;
        
        function toggleFullscreenPlayerView() {
            const container = document.getElementById('playerCards');
            const scoringHeader = document.querySelector('.scoring-header');
            const btn = document.getElementById('fullscreenToggleBtn');
            
            if (isFullscreenPlayerView) {
                // Exit fullscreen
                container.style.position = '';
                container.style.top = '';
                container.style.left = '';
                container.style.right = '';
                container.style.bottom = '';
                container.style.zIndex = '';
                container.style.background = '';
                container.style.paddingTop = '';
                container.style.overflow = '';
                container.style.overflowY = '';
                container.style.overflowX = '';
                container.style.touchAction = '';
                container.classList.remove('fullscreen-mode');
                document.body.style.overflow = '';
                if (scoringHeader) scoringHeader.style.display = '';
                if (btn) btn.textContent = 'â¶';
                isFullscreenPlayerView = false;
            } else {
                // Enter fullscreen
                container.style.position = 'fixed';
                container.style.top = '0';
                container.style.left = '0';
                container.style.right = '0';
                container.style.bottom = '0';
                container.style.zIndex = '9999';
                container.style.background = 'linear-gradient(135deg, #059669 0%, #10b981 20%, #3b82f6 60%, #1e40af 100%)';
                container.style.paddingTop = '20px';
                container.style.overflow = 'hidden'; // Lock all scroll
                container.style.overflowY = 'hidden'; // Lock vertical scroll
                container.style.overflowX = 'hidden'; // Lock horizontal scroll (swipe handled by JS)
                container.style.touchAction = 'pan-x'; // Only allow horizontal touch
                container.classList.add('fullscreen-mode');
                document.body.style.overflow = 'hidden'; // Prevent body scroll
                if (scoringHeader) scoringHeader.style.display = 'none';
                if (btn) btn.textContent = 'â';
                isFullscreenPlayerView = true;
            }
        }
        
        // Handle compact cell click - voice or expanded view
        function handleCompactCellClick(playerIndex, holeIndex, currentScore, playerName) {
            // Check if this is a watched player (view only, no scoring) - doesn't apply to hosts/co-hosts
            if (tournamentMode === 'multi' && !canManageTournament()) {
                const player = tournamentData.players[playerIndex];
                // If player is not claimed by this device, they're being watched - no interaction
                if (player && player.claimedBy !== currentDeviceId) {
                    // Just viewing - no popup
                    return;
                }
            }
            
            if (inputMode === 'voice') {
                showVoiceListening(playerIndex, holeIndex);
            } else {
                showExpandedScoreInput(playerIndex, holeIndex, currentScore, playerName);
            }
        }
        
        // Expanded score input state
        let expandedTarget = null;
        let expandedCurrentScore = 0;
        
        // Show expanded score input modal
        function showExpandedScoreInput(playerIndex, holeIndex, currentScore, playerName) {
            expandedTarget = { playerIndex, holeIndex };
            expandedCurrentScore = currentScore || 0;
            
            const hole = courseData.holes[holeIndex];
            const par = hole.par;
            
            document.getElementById('expandedHoleNumber').textContent = `HOLE ${hole.number}`;
            document.getElementById('expandedHoleInfo').textContent = `Par ${par} â¢ HCP ${hole.handicap}`;
            document.getElementById('expandedPlayerName').textContent = playerName;
            document.getElementById('expandedScoreValue').textContent = expandedCurrentScore || '-';
            
            // Generate quick score buttons based on par
            const quickScores = document.getElementById('expandedQuickScores');
            let quickHTML = '';
            for (let s = Math.max(1, par - 2); s <= par + 4; s++) {
                const label = s === par - 2 ? `${s} (Eagle)` : 
                              s === par - 1 ? `${s} (Birdie)` : 
                              s === par ? `${s} (Par)` : 
                              s === par + 1 ? `${s} (Bogey)` : 
                              s === par + 2 ? `${s} (Dbl)` : s;
                quickHTML += `<button class="quick-score-btn" onclick="setExpandedScore(${s})">${label}</button>`;
            }
            quickScores.innerHTML = quickHTML;
            
            document.getElementById('expandedScoreModal').classList.add('active');
        }
        
        function closeExpandedScore() {
            document.getElementById('expandedScoreModal').classList.remove('active');
            expandedTarget = null;
        }
        
        // Quick score tap - auto save and close immediately
        async function setExpandedScore(score) {
            expandedCurrentScore = score;
            document.getElementById('expandedScoreValue').textContent = score;
            
            // Auto-save and close for quick score taps
            if (expandedTarget && score > 0) {
                // Capture values BEFORE closing (in case async operations are slow)
                const playerIndex = expandedTarget.playerIndex;
                const holeIndex = expandedTarget.holeIndex;
                const savedCarouselIndex = currentCarouselIndex;
                
                // Close modal first for responsive feel
                closeExpandedScore();
                
                // AWAIT the save to ensure it completes before re-rendering
                await updateScore(playerIndex, holeIndex, score);
                
                // Refresh the current view but stay on current player
                if (currentView === 'hole') {
                    renderHoleView();
                } else {
                    renderCompactPlayerView(getPlayersToShow());
                    // Restore carousel position
                    currentCarouselIndex = savedCarouselIndex;
                    updateCarouselPosition();
                }
            }
        }
        
        function expandedIncrement() {
            if (expandedCurrentScore < 15) {
                expandedCurrentScore++;
                document.getElementById('expandedScoreValue').textContent = expandedCurrentScore;
            }
        }
        
        function expandedDecrement() {
            if (expandedCurrentScore > 0) {
                expandedCurrentScore--;
                document.getElementById('expandedScoreValue').textContent = expandedCurrentScore || '-';
            }
        }
        
        // Manual save - for when user adjusts with +/- buttons or wants to clear
        async function saveExpandedScore() {
            if (expandedTarget) {
                const savedCarouselIndex = currentCarouselIndex;
                const playerIndex = expandedTarget.playerIndex;
                const holeIndex = expandedTarget.holeIndex;
                const scoreToSave = expandedCurrentScore;
                
                // Close modal first for responsive feel
                closeExpandedScore();
                
                if (scoreToSave > 0) {
                    // AWAIT the save to ensure it completes
                    await updateScore(playerIndex, holeIndex, scoreToSave);
                } else {
                    // Clear the score (set to 0/null)
                    tournamentData.players[playerIndex].scores[holeIndex] = 0;
                    saveToLocalStorage();
                    
                    // Also sync to Firebase if in multi-device mode
                    if (activeTournamentId && tournamentMode === 'multi') {
                        const playerName = tournamentData.players[playerIndex].name;
                        await updatePlayerScore(activeTournamentId, playerName, holeIndex, 0);
                    }
                }
                
                // Refresh the current view but stay on current player
                if (currentView === 'hole') {
                    renderHoleView();
                } else {
                    renderCompactPlayerView(getPlayersToShow());
                    // Restore carousel position
                    currentCarouselIndex = savedCarouselIndex;
                    updateCarouselPosition();
                }
            } else {
                closeExpandedScore();
            }
        }
        
        // Initialize player carousel for swipe navigation
        
        function handleCarouselSwipe() {
            const swipeThreshold = 50;
            const diff = carouselTouchStartX - carouselTouchEndX;
            
            if (Math.abs(diff) > swipeThreshold) {
                if (diff > 0) {
                    // Swiped left - go next
                    carouselNext();
                } else {
                    // Swiped right - go prev
                    carouselPrev();
                }
            }
        }
        
        function carouselNext() {
            const track = document.getElementById('carouselTrack');
            const slides = track?.querySelectorAll('.player-carousel-slide');
            if (!slides || slides.length === 0) return;
            
            // Infinite wrap - go to first if at end
            if (currentCarouselIndex >= slides.length - 1) {
                currentCarouselIndex = 0;
            } else {
                currentCarouselIndex++;
            }
            updateCarouselPosition();
        }
        
        function carouselPrev() {
            const track = document.getElementById('carouselTrack');
            const slides = track?.querySelectorAll('.player-carousel-slide');
            if (!slides || slides.length === 0) return;
            
            // Infinite wrap - go to last if at beginning
            if (currentCarouselIndex <= 0) {
                currentCarouselIndex = slides.length - 1;
            } else {
                currentCarouselIndex--;
            }
            updateCarouselPosition();
        }
        
        function goToCarouselSlide(index) {
            const track = document.getElementById('carouselTrack');
            const slides = track?.querySelectorAll('.player-carousel-slide');
            if (!slides || index < 0 || index >= slides.length) return;
            
            currentCarouselIndex = index;
            updateCarouselPosition();
        }
        
        function resetCarousel() {
            currentCarouselIndex = 0;
            updateCarouselPosition();
        }
        
        function updateCarouselPosition() {
            const track = document.getElementById('carouselTrack');
            const slides = track?.querySelectorAll('.player-carousel-slide');
            if (!track || !slides) return;
            
            // Move track
            track.style.transform = `translateX(-${currentCarouselIndex * 100}%)`;
            
            // Update dots
            const dots = document.querySelectorAll('.carousel-dot');
            dots.forEach((dot, idx) => {
                dot.classList.toggle('active', idx === currentCarouselIndex);
            });
            
            // Update nav buttons with player names
            updateCarouselNav();
        }
        
        function updateCarouselNav() {
            const players = window.carouselPlayers || [];
            if (players.length === 0) return;
            
            const prevBtn = document.getElementById('carouselPrev');
            const nextBtn = document.getElementById('carouselNext');
            const prevName = document.getElementById('prevPlayerName');
            const nextName = document.getElementById('nextPlayerName');
            
            // Infinite carousel - buttons always enabled
            if (prevBtn) {
                prevBtn.disabled = false;
                prevBtn.style.opacity = '1';
            }
            if (nextBtn) {
                nextBtn.disabled = false;
                nextBtn.style.opacity = '1';
            }
            
            // Update player names in nav buttons (wrap around)
            if (prevName && players.length > 0) {
                // Previous player wraps to last if at beginning
                const prevIndex = currentCarouselIndex === 0 ? players.length - 1 : currentCarouselIndex - 1;
                const prevPlayer = players[prevIndex];
                prevName.textContent = prevPlayer ? prevPlayer.name.split(' ')[0] : '';
            }
            if (nextName && players.length > 0) {
                // Next player wraps to first if at end
                const nextIndex = currentCarouselIndex >= players.length - 1 ? 0 : currentCarouselIndex + 1;
                const nextPlayer = players[nextIndex];
                nextName.textContent = nextPlayer ? nextPlayer.name.split(' ')[0] : '';
            }
        }

        // Switch to hole view
        function switchToHoleView() {
            currentView = 'hole';
            document.getElementById('playerCards').style.display = 'none';
            document.getElementById('holeView').style.display = 'block';
            document.getElementById('togglePlayerView').classList.remove('active');
            document.getElementById('toggleHoleView').classList.add('active');
            renderHoleView();
        }

        // Render hole view
        function renderHoleView() {
            console.log('=== RENDER HOLE VIEW CALLED ===');
            console.log('tournamentData:', tournamentData);
            console.log('tournamentData.players:', tournamentData?.players);
            console.log('currentHole:', currentHole);
            
            // Safety check
            if (!tournamentData || !tournamentData.players || tournamentData.players.length === 0) {
                console.error('â No tournament data or players available');
                document.getElementById('holeViewContent').innerHTML = '<p>No players found</p>';
                return;
            }
            
            const hole = courseData.holes[currentHole];
            const holeNumber = currentHole + 1;
            
            // Calculate prev/next for infinite carousel
            const prevHole = currentHole === 0 ? 18 : currentHole;
            const nextHole = currentHole === 17 ? 1 : currentHole + 2;
            
            let html = `
                <div class="hole-view-container" id="holeViewContainer">
                    <div class="hole-header">
                        <div class="hole-nav-top">
                            <button type="button" class="hole-nav-btn-compact" onclick="goToPrevHole()">
                                â ${prevHole}
                            </button>
                            <div class="hole-title-section" onclick="showHoleJumpModal()">
                                <div class="hole-number">HOLE ${holeNumber}</div>
                                <div class="hole-info">Par ${hole.par} â¢ HCP ${hole.handicap}</div>
                            </div>
                            <button type="button" class="hole-nav-btn-compact" onclick="goToNextHole()">
                                ${nextHole} â
                            </button>
                        </div>
                    </div>
            `;
            
            // Determine net scoring method from game type
            // ALWAYS show net scores, using full handicap by default
            let netMethod = 'full'; // Default to full handicap
            const gameTypeLower = tournamentData.gameType.toLowerCase();
            
            // Override with specific methods if applicable
            if (gameTypeLower.includes('18 max')) {
                netMethod = '18max';
            } else if (gameTypeLower.includes('1/2 pop') || gameTypeLower.includes('half pop')) {
                netMethod = 'half';
            }
            // Otherwise stays as 'full' for all other games
            
            console.log('renderHoleView - gameType:', tournamentData.gameType);
            console.log('renderHoleView - netMethod:', netMethod);
            
            // Filter players based on multi-device mode and claims (same as scoring page)
            let playersToShow = tournamentData.players;
            
            if (tournamentMode === 'multi' && !canManageTournament()) {
                // Non-hosts/non-co-hosts only see their claimed players AND watched players
                const claimedPlayers = tournamentData.players.filter(p => p.claimedBy === currentDeviceId);
                const watchedPlayers = tournamentData.players.filter(p => 
                    playerOrder.watching && playerOrder.watching.includes(p.name) && p.claimedBy !== currentDeviceId
                );
                
                // Claimed players first, then watched players
                playersToShow = [...claimedPlayers, ...watchedPlayers];
                console.log('ð Hole View - Claimed players:', claimedPlayers.map(p => p.name));
                console.log('ð Hole View - Watched players:', watchedPlayers.map(p => p.name));
                
                // If no players to show, show all (fallback for single-device or when no claims)
                if (playersToShow.length === 0) {
                    playersToShow = tournamentData.players;
                    console.log('â¹ï¸ No claimed/watched players - showing all players');
                }
            }
            
            // Add player rows with inline ticker
            playersToShow.forEach((player, index) => {
                // Get actual index in full players array for score updates
                const playerIndex = tournamentData.players.indexOf(player);
                
                const score = player.scores[currentHole]; // Don't default to par - allow blank
                const hasScore = score !== undefined && score !== null && score !== 0;
                const displayScore = hasScore ? score : '';
                
                let scoreClass = '';
                let netScoreDisplay = '';
                
                if (hasScore) {
                    const diff = score - hole.par;
                    
                    if (diff >= 2) {
                        scoreClass = 'double-bogey-plus';
                    } else if (diff === 1) {
                        scoreClass = 'bogey';
                    } else if (diff === 0) {
                        scoreClass = 'par'; // Add par class
                    } else if (diff <= -1) {
                        scoreClass = 'birdie-better';
                    }
                    
                    // Calculate net score if this is a net game
                    if (netMethod) {
                        const netScore = getNetScore(score, player.handicap, hole.handicap, netMethod);
                        netScoreDisplay = `<div class="hole-net-score">${netScore}</div>`;
                    }
                }
                
                // Calculate handicap dots
                let hcpDotsHtml = '';
                if (player.handicap !== 0) {
                    const strokes = getHandicapStrokesForHole(player.handicap, hole.handicap, netMethod);
                    if (strokes !== 0) {
                        const isHalfPop = netMethod === 'half';
                        const dotCount = isHalfPop ? Math.abs(strokes * 2) : Math.abs(strokes); // For half pop, show dots for half strokes
                        const dotColor = strokes > 0 ? 'green' : 'red'; // Green = subtract (getting strokes), Red = add (plus handicap)
                        
                        hcpDotsHtml = '<div class="hole-hcp-dots">';
                        for (let d = 0; d < Math.min(dotCount, 4); d++) {
                            hcpDotsHtml += `<div class="hcp-dot ${dotColor}"></div>`;
                        }
                        hcpDotsHtml += '</div>';
                    }
                }
                
                // Check if this is a watched player (view only) - doesn't apply to hosts/co-hosts
                const isWatchedPlayer = tournamentMode === 'multi' && !canManageTournament() && player.claimedBy !== currentDeviceId;
                
                html += `
                    <div class="hole-player-row-ticker ${isWatchedPlayer ? 'watch-only' : ''}">
                        <div class="hole-player-info">
                            <div class="hole-player-name">${player.name}${isWatchedPlayer ? ' ð' : ''}</div>
                            <div class="hole-player-hcp">Handicap: ${player.handicap > 0 ? player.handicap : player.handicap < 0 ? '+' + Math.abs(player.handicap) : 'Scratch'}</div>
                        </div>
                        <div class="hole-score-section">
                            ${isWatchedPlayer ? `
                                <div class="hole-score-display">
                                    ${hcpDotsHtml}
                                    <div class="score-input ${scoreClass}" style="pointer-events: none; width: 50px; height: 50px; font-size: 24px; display: flex; align-items: center; justify-content: center; border-radius: 50%; background: ${hasScore ? '' : '#e2e8f0'};">
                                        ${displayScore || 'â'}
                                    </div>
                                </div>
                            ` : `
                                <div class="hole-score-ticker">
                                    ${hcpDotsHtml}
                                    <input type="number" 
                                           class="score-input ${scoreClass}" 
                                           id="holeScore_${playerIndex}_${currentHole}"
                                           value="${displayScore}" 
                                           placeholder="â"
                                           readonly
                                           onclick="handleHoleInputFocus(${playerIndex}, ${currentHole}, this)"
                                           style="width: 60px; height: 60px; font-size: 28px; text-align: center; cursor: pointer;">
                                </div>
                            `}
                            ${netScoreDisplay}
                        </div>
                    </div>
                `;
            });
            
            // Close container
            html += `
                </div>
            `;
            
            document.getElementById('holeViewContent').innerHTML = html;
            setupHoleViewSwipe();
        }

        // Handle input focus in hole view - voice or touch based on mode
        function handleHoleInputFocus(playerIndex, holeIndex, inputElement) {
            // Always blur to prevent keyboard
            inputElement.blur();
            
            // If voice mode, use voice input
            if (inputMode === 'voice') {
                showVoiceListening(playerIndex, holeIndex);
                return;
            }
            
            // Touch mode - use expanded input modal
            const currentScore = tournamentData.players[playerIndex].scores[holeIndex] || 0;
            const playerName = tournamentData.players[playerIndex].name;
            showExpandedScoreInput(playerIndex, holeIndex, currentScore, playerName);
        }

        // Adjust score directly in hole view (inline ticker)
        async function adjustHoleScoreDirect(playerIndex, holeIndex, delta) {
            console.log('=== ADJUST HOLE SCORE CALLED ===');
            console.log('playerIndex:', playerIndex, 'holeIndex:', holeIndex, 'delta:', delta);
            
            const currentScore = tournamentData.players[playerIndex].scores[holeIndex];
            const hole = courseData.holes[holeIndex];
            let newScore;
            
            console.log('Current score:', currentScore);
            console.log('Player:', tournamentData.players[playerIndex].name);
            
            // If no score yet (blank), first press sets to par
            if (currentScore === undefined || currentScore === null || currentScore === 0) {
                newScore = hole.par;
            } else {
                // Score exists, adjust by delta
                if (delta > 0) {
                    newScore = currentScore + 1;
                } else {
                    newScore = Math.max(currentScore - 1, 1); // Min score is 1
                }
            }
            
            console.log('New score:', newScore);
            
            tournamentData.players[playerIndex].scores[holeIndex] = newScore;
            
            // IMMEDIATE SAVE with verification
            console.log('ð¾ Attempting localStorage save...');
            const saveSuccess = saveToLocalStorage();
            console.log('ð¾ Save result:', saveSuccess);
            
            // VERIFY the score was actually saved
            if (saveSuccess) {
                const verified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                if (!verified) {
                    console.error('â HOLE VIEW: Score verification failed! Retrying save...');
                    tournamentData.players[playerIndex].scores[holeIndex] = newScore;
                    const retrySuccess = saveToLocalStorage();
                    console.log('ð¾ Retry save result:', retrySuccess);
                    
                    // Verify again
                    const reVerified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                    if (!reVerified) {
                        console.error('ð¨ CRITICAL: Score still not saved after retry!');
                        // Don't alert - just log. Score is in Firebase anyway.
                    }
                }
            } else {
                console.error('ð¨ CRITICAL: Initial save failed!');
                // Don't alert - just log. Score is in Firebase anyway.
            }
            
            // Sync to Firebase if in multi-device mode
            if (activeTournamentId && tournamentMode === 'multi') {
                const playerName = tournamentData.players[playerIndex].name;
                console.log('ð¥ FIREBASE SYNC STARTING');
                console.log('   Player:', playerName);
                console.log('   Hole:', holeIndex + 1);
                console.log('   Score:', newScore);
                
                updatePlayerScore(activeTournamentId, playerName, holeIndex, newScore);
            } else {
                console.log('â¹ï¸ Skipping Firebase sync (single-device mode)');
            }
            
            // Update hole view
            updateHoleViewScore(playerIndex, holeIndex, newScore);
            
            // Update player view if visible
            renderScoringPage();
        }

        // Helper function to update hole view score display
        function updateHoleViewScore(playerIndex, holeIndex, newScore) {
            const input = document.getElementById(`holeScore_${playerIndex}_${holeIndex}`);
            if (!input) return;
            
            input.value = newScore;
            
            // Update color class
            const hole = courseData.holes[holeIndex];
            const diff = newScore - hole.par;
            
            input.classList.remove('birdie-better', 'par', 'bogey', 'double-bogey-plus');
            
            if (diff >= 2) {
                input.classList.add('double-bogey-plus');
            } else if (diff === 1) {
                input.classList.add('bogey');
            } else if (diff === 0) {
                input.classList.add('par');
            } else if (diff <= -1) {
                input.classList.add('birdie-better');
            }
            
            // Update net score if applicable
            const player = tournamentData.players[playerIndex];
            let netMethod = null;
            const gameTypeLower = tournamentData.gameType.toLowerCase();
            
            // Check for any net game
            if (gameTypeLower.includes('net')) {
                if (gameTypeLower.includes('full') || gameTypeLower.includes('full hcp')) {
                    netMethod = 'full';
                } else if (gameTypeLower.includes('18 max')) {
                    netMethod = '18max';
                } else if (gameTypeLower.includes('1/2 pop') || gameTypeLower.includes('half pop')) {
                    netMethod = 'half';
                } else {
                    // Default to full handicap for any other net game
                    netMethod = 'full';
                }
            }
            
            if (netMethod) {
                const netScore = getNetScore(newScore, player.handicap, hole.handicap, netMethod);
                const netDisplay = input.parentElement.parentElement.querySelector('.hole-net-score');
                
                if (netDisplay) {
                    netDisplay.textContent = `${netScore}`;
                } else {
                    // Add net score display if it doesn't exist
                    const netDiv = document.createElement('div');
                    netDiv.className = 'hole-net-score';
                    netDiv.textContent = `${netScore}`;
                    input.parentElement.parentElement.appendChild(netDiv);
                }
            }
        }

        // Update score from manual input in hole view
        function updateHoleScore(playerIndex, holeIndex, value) {
            const numValue = parseInt(value);
            
            // If empty or invalid, delete the score
            if (!value || isNaN(numValue) || numValue === 0) {
                tournamentData.players[playerIndex].scores[holeIndex] = 0;
                
                // Clear display
                const input = document.getElementById(`holeScore_${playerIndex}_${holeIndex}`);
                if (input) {
                    input.value = '';
                    input.classList.remove('birdie-better', 'par', 'bogey', 'double-bogey-plus');
                }
                
                // Remove net score
                const netDisplay = input?.parentElement?.parentElement?.querySelector('.hole-net-score');
                if (netDisplay) {
                    netDisplay.remove();
                }
                
                // Update player view
                renderScoringPage();
                saveToLocalStorage();
                return;
            }
            
            tournamentData.players[playerIndex].scores[holeIndex] = numValue;
            
            // Update hole view
            updateHoleViewScore(playerIndex, holeIndex, numValue);
            
            // Update player view
            renderScoringPage();
            
            saveToLocalStorage();
        }

        // Navigate to previous hole
        function goToPrevHole() {
            // Infinite carousel - wrap from hole 1 to hole 18
            if (currentHole === 0) {
                currentHole = 17;
            } else {
                currentHole--;
            }
            renderHoleView();
        }

        // Navigate to next hole
        function goToNextHole() {
            // Infinite carousel - wrap from hole 18 to hole 1
            if (currentHole === 17) {
                currentHole = 0;
            } else {
                currentHole++;
            }
            renderHoleView();
        }
        
        // Jump to specific hole
        function jumpToHole(holeIndex) {
            currentHole = holeIndex;
            renderHoleView();
            closeHoleJumpModal();
        }
        
        // Show hole jump modal
        function showHoleJumpModal() {
            const modal = document.createElement('div');
            modal.id = 'holeJumpModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                padding: 20px;
            `;
            
            let holesGrid = '';
            for (let i = 0; i < 18; i++) {
                const isCurrentHole = i === currentHole;
                holesGrid += `
                    <button onclick="jumpToHole(${i})" style="
                        width: 42px;
                        height: 42px;
                        border-radius: 8px;
                        border: 2px solid ${isCurrentHole ? '#3b82f6' : '#e2e8f0'};
                        background: ${isCurrentHole ? '#3b82f6' : 'white'};
                        color: ${isCurrentHole ? 'white' : '#1e40af'};
                        font-size: 16px;
                        font-weight: 700;
                        cursor: pointer;
                    ">${i + 1}</button>
                `;
            }
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 20px; max-width: 300px; width: 90%; text-align: center;">
                    <h2 style="color: #1e40af; margin-bottom: 16px; font-size: 20px;">Jump to Hole</h2>
                    <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 6px; margin-bottom: 20px;">
                        ${holesGrid}
                    </div>
                    <button onclick="closeHoleJumpModal()" style="padding: 12px 24px; background: #e2e8f0; color: #64748b; border: none; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function closeHoleJumpModal() {
            const modal = document.getElementById('holeJumpModal');
            if (modal) modal.remove();
        }

        // Setup swipe gestures for hole view
        function setupHoleViewSwipe() {
            const container = document.getElementById('holeViewContainer');
            if (!container) return;
            
            let touchStartX = 0;
            let touchEndX = 0;
            
            container.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
            }, { passive: true });
            
            container.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].screenX;
                handleSwipe();
            }, { passive: true });
            
            function handleSwipe() {
                const swipeThreshold = 50;
                const diff = touchStartX - touchEndX;
                
                if (Math.abs(diff) > swipeThreshold) {
                    if (diff > 0) {
                        // Swipe left - next hole
                        goToNextHole();
                    } else {
                        // Swipe right - previous hole
                        goToPrevHole();
                    }
                }
            }
        }

        // Update startScoring to show indicator and disable pull-to-refresh
        const originalStartScoring = startScoring;
        startScoring = function() {
            originalStartScoring();
            showRoundIndicator();
            disablePullToRefresh();
        };

        // Update confirmNewRound to hide indicator and enable pull-to-refresh
        const originalConfirmNewRound = confirmNewRound;
        confirmNewRound = function() {
            showConfirm(
                'Start New Round?',
                'This will end the current round and clear all data. Make sure you\'ve saved your results!',
                function() {
                    localStorage.removeItem('indianHillsScoring');
                    tournamentData = {
                        date: '',
                        gameType: '',
                        course: 'indian_hills',
                        players: [],
                        teams: []
                    };
                    hideRoundIndicator();
                    enablePullToRefresh();
                    showPage('setupPage');
                    hideConfirmDialog();
                    location.reload(); // Reload to reset everything
                }
            );
        };

        // iOS Install Prompt - Show if not running as standalone app
        function showInstallPrompt() {
            // Check if running as standalone (home screen app)
            const isStandalone = window.matchMedia('(display-mode: standalone)').matches || 
                               window.navigator.standalone === true;
            
            // Check if on iOS
            const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
            
            // Check if already dismissed
            const dismissed = localStorage.getItem('installPromptDismissed');
            
            if (!isStandalone && isIOS && !dismissed) {
                // Show after 3 seconds
                setTimeout(() => {
                    const banner = document.createElement('div');
                    banner.style.cssText = `
                        position: fixed;
                        bottom: 0;
                        left: 0;
                        right: 0;
                        background: rgba(30, 64, 175, 0.95);
                        color: white;
                        padding: 16px;
                        text-align: center;
                        z-index: 10000;
                        font-size: 14px;
                        line-height: 1.4;
                        box-shadow: 0 -4px 12px rgba(0,0,0,0.3);
                    `;
                    banner.innerHTML = `
                        <div style="margin-bottom: 8px;">ð± <strong>Install for Full Screen</strong></div>
                        <div style="font-size: 12px; opacity: 0.9; margin-bottom: 12px;">
                            Tap <strong>Share</strong> â <strong>Add to Home Screen</strong> to hide browser controls
                        </div>
                        <button onclick="this.closest('div').remove(); localStorage.setItem('installPromptDismissed', 'true');" 
                                style="background: white; color: #1e40af; border: none; padding: 8px 20px; border-radius: 6px; font-weight: 600; font-size: 13px;">
                            Got it
                        </button>
                    `;
                    document.body.appendChild(banner);
                    
                    // Auto-dismiss after 10 seconds
                    setTimeout(() => {
                        if (banner.parentNode) {
                            banner.remove();
                        }
                    }, 10000);
                }, 3000);
            }
        }
        
        // DISABLED: Homescreen install notification - will bring back later
        // showInstallPrompt();
    </script>
</body>
</html>
