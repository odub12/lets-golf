<!--
================================================================================
    Let's Golf - Golf Tournament Scoring Application
    
    Â© 2026 Otis Williams. All Rights Reserved.
    
    This software and its source code are the intellectual property of 
    Otis Williams. Unauthorized copying, modification, distribution, or use 
    of this code, in whole or in part, is strictly prohibited without prior 
    written permission from the copyright holder.
    
    For licensing inquiries, contact the author.
================================================================================
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=3.0, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Let's Golf">
    <meta name="theme-color" content="#3b82f6">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="manifest" href="data:application/json,{%22name%22:%22Let's%20Golf%22,%22short_name%22:%22Golf%22,%22start_url%22:%22.%22,%22display%22:%22standalone%22,%22background_color%22:%22%233b82f6%22,%22theme_color%22:%22%233b82f6%22,%22icons%22:[{%22src%22:%22apple-touch-icon.png%22,%22sizes%22:%22180x180%22,%22type%22:%22image/png%22}]}">
    <title>Let's Golf</title>
    <!-- QR Code Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging-compat.js"></script>
    
    <!-- VERSION: 2026-01-16-CANCELFIX-v11.49 -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #1e40af; /* Fallback solid color */
            min-height: 100vh;
            min-height: -webkit-fill-available; /* iOS Safari fix */
            padding: 0;
            overflow-x: hidden;
            touch-action: pan-y; /* Allow vertical scrolling */
            position: relative;
        }
        
        /* Fixed background that works on iOS */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 40%, #1e40af 80%, #1e3a8a 100%);
            z-index: -1;
        }

        html {
            height: -webkit-fill-available; /* iOS Safari fix */
        }

        /* Page Container */
        .page {
            display: none;
            min-height: 100vh;
            padding: 20px;
        }

        .page.active {
            display: block;
            animation: slideIn 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        /* Lock scroll on home pages only - fit to screen */
        #guestHomePage.active,
        #hostHomePage.active {
            display: flex !important;
            flex-direction: column;
            overflow: hidden;
            height: 100vh;
            max-height: 100vh;
            touch-action: none;
            overscroll-behavior: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 100;
            /* iOS safe area support for notch/Dynamic Island */
            padding: env(safe-area-inset-top) 20px env(safe-area-inset-bottom) 20px;
        }
        
        /* Small screen fallback - allow scroll if content doesn't fit */
        @media (max-height: 650px) {
            #guestHomePage.active,
            #hostHomePage.active {
                overflow-y: auto;
                touch-action: pan-y;
            }
        }

        @keyframes slideIn {
            from { 
                opacity: 0; 
                transform: translateX(20px);
            }
            to { 
                opacity: 1; 
                transform: translateX(0);
            }
        }
        
        @keyframes slideOut {
            from { 
                opacity: 1; 
                transform: translateX(0);
            }
            to { 
                opacity: 0; 
                transform: translateX(20px);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Header */
        .header {
            background: white;
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
        }

        .header h1 {
            color: #1e40af;
            font-size: 24px;
            margin-bottom: 5px;
        }

        .header p {
            color: #64748b;
            font-size: 14px;
        }

        /* Setup Page */
        .setup-container {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 
                        0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            color: #1e40af;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            max-width: 100%;
            padding: 14px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.2s;
            -webkit-appearance: none;
            appearance: none;
        }

        .form-group input[type="date"] {
            padding: 12px 14px;
            font-size: 15px;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #3b82f6;
            background: #f8fafc;
        }

        /* Player Input Grid */
        .player-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: hidden;
        }

        .player-row {
            display: grid;
            grid-template-columns: 1fr 65px 50px;
            gap: 8px;
            align-items: center;
            position: relative;
            background: white;
            border-radius: 12px;
            overflow: visible;
            z-index: 1;
            transition: transform 0.3s ease;
        }

        .player-row.has-suggestions {
            z-index: 100;
        }

        .player-row::after {
            content: 'Delete';
            position: absolute;
            right: -100px;
            top: 0;
            bottom: 0;
            width: 100px;
            background: #ef4444;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 15px;
            border-radius: 12px;
            z-index: -1;
        }

        .player-row.swiped {
            transform: translateX(-100px);
        }

        .player-row.deleting {
            opacity: 0;
            transform: translateX(-300px);
            transition: all 0.3s ease;
        }

        .player-row::before {
            content: 'Delete';
            position: absolute;
            right: -100px;
            top: 0;
            bottom: 0;
            width: 100px;
            background: #ef4444;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 15px;
            border-radius: 12px;
            z-index: -1;
        }

        .player-row.swiped {
            transform: translateX(-100px);
        }

        .player-row.deleting {
            opacity: 0;
            transform: translateX(-300px);
            transition: all 0.3s ease;
        }

        .player-name-input {
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 15px;
            width: 100%;
            background: white;
            position: relative;
            z-index: 1;
        }

        .player-name-input::placeholder {
            color: #94a3b8;
        }

        .player-hcp-input {
            width: 65px;
            padding: 12px 4px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 14px;
            text-align: center;
            background: white;
        }

        .player-hcp-input::placeholder {
            color: #64748b;
            font-size: 11px;
        }
        
        .course-hcp-display {
            width: 50px;
            padding: 12px 4px;
            background: #dbeafe;
            border: 2px solid #3b82f6;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 700;
            text-align: center;
            color: #1e40af;
        }
        
        .player-course-hcp {
            width: 45px;
            padding: 12px 4px;
            background: #dbeafe;
            border: 2px solid #3b82f6;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 700;
            text-align: center;
            color: #1e40af;
        }

        /* Autocomplete Suggestions */
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 90px;
            background: white;
            border: 2px solid #3b82f6;
            border-top: none;
            border-radius: 0 0 12px 12px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: none;
        }

        .autocomplete-suggestions.show {
            display: block;
        }

        .suggestion-item {
            padding: 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e2e8f0;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover,
        .suggestion-item:active {
            background: #eff6ff;
        }

        .suggestion-name {
            font-weight: 600;
            color: #1e40af;
        }

        .suggestion-hcp {
            color: #64748b;
            font-size: 14px;
        }

        .btn-add-player {
            width: auto;
            min-width: 140px;
            padding: 10px 20px;
            background: white;
            color: #3b82f6;
            border: 2px solid #3b82f6;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            margin: 10px auto 0;
            transition: all 0.2s;
            display: block;
        }

        .btn-add-player:active {
            background: #eff6ff;
        }

        .btn-add-player:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Quick Add Player Buttons */
        .quick-add-btn {
            padding: 8px 12px;
            background: #eff6ff;
            color: #3b82f6;
            border: 2px solid #3b82f6;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            position: relative;
        }

        .quick-add-btn:active {
            background: #dbeafe;
            transform: scale(0.95);
        }

        .quick-add-btn.show-delete {
            padding-right: 36px;
        }

        .quick-add-delete {
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .quick-add-btn.show-delete .quick-add-delete {
            display: flex;
        }

        /* Team Setup */
        .team-container {
            background: #f8fafc;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .team-header {
            color: #1e40af;
            font-weight: 700;
            margin-bottom: 12px;
            font-size: 16px;
        }

        .team-member-select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 8px;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 10px;
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto;
            position: relative;
            z-index: 10;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.3), 
                        0 2px 4px -1px rgba(59, 130, 246, 0.2);
        }

        .btn-primary:active {
            background: #2563eb;
            transform: scale(0.98);
            box-shadow: 0 2px 4px -1px rgba(59, 130, 246, 0.3);
        }

        .btn-primary::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn-primary:active::after {
            width: 300px;
            height: 300px;
        }

        .btn-secondary {
            background: #64748b;
            color: white;
            -webkit-user-select: none;
            user-select: none;
            z-index: 1000 !important;
        }

        .btn-secondary:active {
            background: #475569;
            transform: scale(0.98);
        }

        /* Game Toggle Tabs */
        .game-tab {
            flex: 1;
            min-width: 80px;
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            text-align: center;
        }

        .game-tab.active {
            background: white;
            color: #1e40af;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .game-tab:active {
            transform: scale(0.95);
        }

        /* Player Device Item */
        .player-device-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .player-device-item h4 {
            color: white;
            font-size: 16px;
            margin-bottom: 4px;
        }

        .player-device-item p {
            color: #cbd5e1;
            font-size: 13px;
            margin-bottom: 8px;
        }

        .player-device-item button {
            padding: 6px 12px;
            font-size: 13px;
            margin-right: 8px;
        }

        /* Leaderboard Styles */
        .leaderboard-entry {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .leaderboard-entry.first {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
        }

        .leaderboard-entry.second {
            background: linear-gradient(135deg, #94a3b8, #64748b);
        }

        .leaderboard-entry.third {
            background: linear-gradient(135deg, #fb923c, #ea580c);
        }

        .leaderboard-rank {
            font-size: 20px;
            font-weight: 700;
            min-width: 40px;
        }

        .leaderboard-name {
            flex: 1;
            font-weight: 600;
            color: white;
        }

        .leaderboard-score {
            font-size: 18px;
            font-weight: 700;
            color: white;
        }

        /* Scoring Page */
        .scoring-header {
            background: white;
            padding: 12px 16px;
            border-radius: 12px;
            margin-bottom: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: sticky;
            top: 20px;
            z-index: 50;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: top 0.3s;
        }

        .header-top-row {
            display: none; /* Deprecated - using new layout */
        }

        .header-bottom-row {
            display: flex; /* Changed from none - needed for setup page toggle */
        }
        
        /* Hide old row only in scoring header */
        .scoring-header .header-bottom-row {
            display: none; /* Old row - replaced by button grid */
        }
        
        .scoring-button-grid {
            display: flex;
            justify-content: center;
            gap: 8px;
            padding: 0 8px;
        }
        
        /* Grouped toggle button pairs */
        .btn-toggle-group {
            display: flex;
            background: #e2e8f0;
            border-radius: 8px;
            padding: 2px;
            gap: 0;
        }
        
        .btn-toggle-group .toggle-btn {
            flex: 1;
            padding: 6px 10px;
            background: transparent;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 4px;
            color: #64748b;
            white-space: nowrap;
        }
        
        .btn-toggle-group .toggle-btn.active {
            background: white;
            color: #1e40af;
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }
        
        .btn-toggle-group .toggle-btn.voice-active {
            background: #10b981;
            color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }
        
        .scoring-grid-btn {
            padding: 10px 8px;
            background: #f1f5f9;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            color: #64748b;
        }
        
        .scoring-grid-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }
        
        .scoring-grid-btn.voice-btn.active {
            background: #10b981;
            border-color: #10b981;
            color: white;
        }
        
        .scoring-grid-btn.card-btn {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }
        
        .scoring-grid-btn.myplayers-btn {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            border-color: #f59e0b;
            color: #78350f;
        }
        
        .scoring-grid-btn.manage-btn {
            background: #f59e0b;
            border-color: #f59e0b;
            color: white;
        }

        .tournament-info-centered {
            text-align: center;
        }

        .tournament-info-centered h2 {
            font-size: 16px;
            font-weight: 700;
            color: #1e293b;
            margin: 0;
            line-height: 1.2;
        }

        .tournament-info-centered p {
            font-size: 12px;
            color: #64748b;
            margin: 2px 0 0 0;
        }

        /* Results page header - simple single row */
        .results-sticky-header {
            position: sticky;
            top: 0;
            z-index: 50;
            background: linear-gradient(135deg, #1e3a5f 0%, #3b82f6 100%);
            margin: -20px -20px 16px -20px;
            padding: 12px;
            border-radius: 0 0 12px 12px;
        }
        
        .results-page-header {
            background: white;
            padding: 12px 16px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: stretch;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .tournament-info-simple {
            flex: 1;
            min-width: 0;
        }

        .tournament-info-simple h2 {
            color: #1e40af;
            font-size: 16px;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .tournament-info-simple p {
            color: #64748b;
            font-size: 12px;
            margin: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .scoring-content {
            padding-top: 76px;
            padding-left: 0;
            padding-right: 0;
        }

        .round-indicator.active ~ .scoring-header,
        #scoringPage .round-indicator.active ~ .scoring-header {
            top: 52px;
        }

        .round-indicator.active ~ .scoring-content,
        #scoringPage .round-indicator.active ~ .scoring-content {
            padding-top: 108px;
        }


        .finish-btn {
            padding: 8px 16px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 13px;
            white-space: nowrap;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            pointer-events: auto;
            position: relative;
            z-index: 10;
        }

        .finish-btn:active {
            background: #059669;
        }

        .back-btn {
            padding: 8px 12px;
            background: #64748b;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            white-space: nowrap;
            -webkit-tap-highlight-color: rgba(100, 116, 139, 0.3);
            touch-action: manipulation;
            pointer-events: auto;
            position: relative;
            z-index: 1000;
            -webkit-user-select: none;
            user-select: none;
        }

        .back-btn:active {
            background: #475569;
        }

        /* Player Card */
        .player-card {
            background: white;
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        /* Swipe Carousel for Player View */
        .player-carousel {
            position: relative;
            overflow: hidden;
            width: 100%;
        }
        
        .player-carousel-track {
            display: flex;
            transition: transform 0.3s ease-out;
            touch-action: pan-y pinch-zoom;
        }
        
        .player-carousel-slide {
            flex: 0 0 100%;
            width: 100%;
            padding: 0 8px;
            box-sizing: border-box;
        }
        
        .player-card-fit {
            background: white;
            border-radius: 16px;
            padding: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 220px);
        }
        
        .player-card-fit .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            border-bottom: 2px solid #e2e8f0;
            margin-bottom: 8px;
            flex-shrink: 0;
        }
        
        .player-card-fit .player-name {
            font-size: 18px;
            font-weight: 700;
            color: #1e40af;
        }
        
        .player-card-fit .player-total {
            font-size: 20px;
            font-weight: 700;
            color: #3b82f6;
        }
        
        /* Compact holes grid for auto-fit */
        .holes-grid-fit {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
            width: 100%;
            box-sizing: border-box;
            flex: 1;
            overflow-y: auto;
        }
        
        .hole-input-fit {
            background: #f8fafc;
            border-radius: 8px;
            padding: 4px;
            min-width: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .hole-input-fit .hole-num {
            font-size: 10px;
            font-weight: 700;
            color: #1e40af;
        }
        
        .hole-input-fit .hole-par {
            font-size: 8px;
            color: #64748b;
        }
        
        .hole-input-fit .score-display {
            font-size: 18px;
            font-weight: 700;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            margin: 2px 0;
        }
        
        .hole-input-fit .score-btns {
            display: flex;
            gap: 2px;
        }
        
        .hole-input-fit .score-btn-sm {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .hole-input-fit .score-btn-sm.minus {
            background: #fee2e2;
            color: #dc2626;
        }
        
        .hole-input-fit .score-btn-sm.plus {
            background: #dbeafe;
            color: #2563eb;
        }
        
        /* Carousel navigation dots */
        .carousel-dots {
            display: flex;
            justify-content: center;
            gap: 8px;
            padding: 12px 0;
        }
        
        .carousel-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #cbd5e1;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .carousel-dot.active {
            background: #3b82f6;
            transform: scale(1.2);
        }
        
        /* Carousel nav arrows */
        .carousel-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }
        
        .carousel-nav-btn {
            padding: 8px 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .carousel-nav-btn:disabled {
            background: #e2e8f0;
            color: #94a3b8;
            cursor: not-allowed;
        }
        
        .carousel-player-name {
            font-size: 16px;
            font-weight: 700;
            color: #1e40af;
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        }

        .player-name {
            font-size: 20px;
            font-weight: 700;
            color: #1e40af;
        }

        .player-total {
            font-size: 24px;
            font-weight: 700;
            color: #3b82f6;
        }

        /* Hole Grid */
        .holes-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
            box-sizing: border-box;
        }

        .hole-input-group {
            background: #f8fafc;
            border-radius: 10px;
            padding: 8px 5px;
            min-width: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hole-label {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
            font-size: 11px;
            color: #64748b;
            font-weight: 600;
            min-height: 32px;
        }

        .par-badge {
            background: #dbeafe;
            color: #1e40af;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 9px;
            white-space: nowrap;
        }

        .score-input-wrapper {
            display: flex;
            align-items: center;
            gap: 3px;
            min-width: 0;
        }

        .score-btn {
            width: 28px;
            height: 28px;
            min-width: 28px;
            border: none;
            background: #3b82f6;
            color: white;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        .score-btn:active {
            background: #2563eb;
            transform: scale(0.95);
        }

        .score-input {
            width: 100%;
            max-width: 100%;
            min-width: 0;
            text-align: center;
            padding: 6px 2px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 700;
            color: #1e40af;
            box-sizing: border-box;
        }

        .score-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        /* Score coloring */
        .score-input.birdie-better {
            background: #dcfce7;
            border-color: #10b981;
            color: #059669;
            font-weight: 600;
        }

        .score-input.par {
            background: #dbeafe;
            border-color: #3b82f6;
            color: #1e40af;
            font-weight: 600;
        }

        .score-input.bogey {
            background: #fef3c7;
            border-color: #f59e0b;
            color: #d97706;
            font-weight: 600;
        }

        .score-input.double-bogey-plus {
            background: #fef2f2;
            border-color: #ef4444;
            color: #dc2626;
            font-weight: 600;
        }

        /* Results Page */
        .results-container {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .results-title {
            color: #1e293b;
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
            text-align: center;
        }

        .results-player {
            background: #f8fafc;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .results-player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .results-player-name {
            font-size: 18px;
            font-weight: 700;
            color: #1e40af;
        }

        .results-score {
            font-size: 24px;
            font-weight: 700;
            color: #3b82f6;
        }

        .results-details {
            display: flex;
            gap: 16px;
            font-size: 13px;
            color: #64748b;
        }

        .results-stat {
            display: flex;
            flex-direction: column;
        }

        .results-stat-label {
            font-weight: 600;
            margin-bottom: 2px;
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: 40px;
            color: #64748b;
        }

        /* Share Tournament Section */
        .share-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .share-section h3 {
            color: #1e40af;
            margin-bottom: 16px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .share-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .share-btn {
            background: white;
            color: #3b82f6;
            border: 2px solid #3b82f6;
            padding: 12px 8px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .share-btn:active {
            transform: scale(0.98);
            background: #f8fafc;
        }

        .share-btn.copy {
            color: #10b981;
            border-color: #10b981;
        }

        .share-btn.qr {
            color: #a855f7;
            border-color: #a855f7;
        }

        .share-btn.download {
            color: #f59e0b;
            border-color: #f59e0b;
        }

        #qrCodeContainer {
            text-align: center;
            padding: 20px;
            background: #f8fafc;
            border-radius: 8px;
            margin-top: 16px;
        }

        #qrCodeContainer canvas {
            margin: 0 auto;
            display: block;
        }

        .tournament-id {
            font-family: monospace;
            background: #f1f5f9;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            color: #475569;
            margin-top: 10px;
            word-break: break-all;
        }

        /* ===== UI ENHANCEMENTS ===== */
        
        /* Player Avatar Circles */
        .player-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 12px;
            color: white;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .player-avatar-large {
            width: 48px;
            height: 48px;
            font-size: 18px;
        }

        /* Score Color Coding */
        .score-eagle {
            background: linear-gradient(135deg, #059669, #10b981);
            color: white;
            font-weight: 700;
        }

        .score-birdie {
            background: linear-gradient(135deg, #10b981, #34d399);
            color: white;
            font-weight: 700;
        }

        .score-par {
            background: #f1f5f9;
            color: #475569;
        }

        .score-bogey {
            background: linear-gradient(135deg, #f59e0b, #fbbf24);
            color: white;
            font-weight: 700;
        }

        .score-double {
            background: linear-gradient(135deg, #ef4444, #f87171);
            color: white;
            font-weight: 700;
        }

        /* Enhanced Shadows */
        .card-shadow {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 
                        0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .card-shadow-lg {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 
                        0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .card-shadow-xl {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 
                        0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        /* Pulse Animation for Score Changes */
        @keyframes scorePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .score-changed {
            animation: scorePulse 0.3s ease-out;
        }

        /* Trophy Icons */
        .trophy-gold {
            color: #fbbf24;
            font-size: 24px;
            margin-right: 8px;
        }

        .trophy-silver {
            color: #d1d5db;
            font-size: 22px;
            margin-right: 8px;
        }

        .trophy-bronze {
            color: #c27803;
            font-size: 20px;
            margin-right: 8px;
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 0;
        }
        
        /* Progress bar in scoring header uses gradient background */
        .scoring-header .progress-bar {
            background: #e2e8f0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #3b82f6);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        /* Confetti Animation */
        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            z-index: 9999;
            pointer-events: none;
        }

        /* Ripple Effect */
        .ripple {
            position: relative;
            overflow: hidden;
        }

        .ripple::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .ripple:active::after {
            width: 300px;
            height: 300px;
        }

        /* Number Count Animation */
        @keyframes numberCount {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .number-animate {
            animation: numberCount 0.3s ease-out;
        }

        /* Scorecard Modal */
        .scorecard-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .scorecard-modal.active {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 20px;
        }

        .scorecard-content {
            background: white;
            border-radius: 16px;
            max-width: 900px;
            width: 100%;
            margin: 20px auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .scorecard-header {
            padding: 20px;
            border-bottom: 2px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .scorecard-body {
            padding: 12px;
            max-height: 75vh;
            overflow-y: auto;
        }

        .scorecard-footer {
            padding: 16px;
            border-top: 2px solid #e2e8f0;
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .scorecard-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 11px;
            table-layout: auto;
        }

        .scorecard-table th,
        .scorecard-table td {
            border: 1px solid #cbd5e1;
            padding: 4px 2px;
            text-align: center;
            min-width: 35px;
            line-height: 1.2;
        }

        .scorecard-table th {
            background: #3b82f6;
            color: white;
            font-weight: 600;
            font-size: 10px;
            padding: 3px 2px;
        }

        .scorecard-table .player-name-cell {
            background: #dbeafe;
            font-weight: 600;
            color: #1e40af;
        }

        .scorecard-table .total-row {
            background: #f1f5f9;
            font-weight: 600;
        }

        .scorecard-individual {
            background: white;
            border: 2px solid #cbd5e1;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            page-break-inside: avoid;
            break-inside: avoid;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .scorecard-player-header {
            text-align: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        }

        .scorecard-player-name {
            font-size: 20px;
            font-weight: 700;
            color: #1e40af;
            margin-bottom: 4px;
        }

        .scorecard-player-info {
            font-size: 14px;
            color: #64748b;
        }

        /* Round in Progress Indicator */
        .round-indicator {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); /* Bright orange/amber */
            color: white;
            padding: 12px 16px; /* Slightly taller */
            text-align: center;
            font-size: 14px; /* Larger text */
            font-weight: 700; /* Bolder */
            z-index: 9998;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4); /* Stronger shadow with orange tint */
            display: none;
            border-bottom: 2px solid #fff; /* White bottom border */
        }

        .round-indicator.active {
            display: block;
        }

        .round-indicator-icon {
            display: inline-block;
            width: 10px; /* Slightly larger dot */
            height: 10px;
            background: #fff;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1.5s infinite; /* Faster pulse */
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .auto-save-toast {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 9999;
            pointer-events: none;
        }

        .auto-save-toast.show {
            opacity: 1;
        }

        .resume-round-section {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            color: white;
            display: none;
        }

        .resume-round-section.active {
            display: block;
        }

        .resume-round-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .resume-round-info {
            font-size: 14px;
            margin-bottom: 16px;
            opacity: 0.9;
        }

        .resume-round-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        /* Force share buttons to be visible on all devices including iPhone */
        #resumeShareButtons {
            min-height: 44px !important; /* iOS minimum tap target */
            overflow: visible !important;
        }
        
        #resumeShareButtons.visible {
            display: grid !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .resume-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
        }

        .discard-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* View Toggle Buttons in Header */
        .view-toggle-btn-header {
            padding: 8px 16px;
            background: #f1f5f9;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            color: #64748b;
            flex: 1;
            justify-content: center;
        }

        .view-toggle-btn-header.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }

        /* Old toggle buttons - can remove */
        .view-toggle-btn {
            flex: 1;
            padding: 8px 16px;
            background: white;
            border: 2px solid #cbd5e1;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #64748b;
            cursor: pointer;
            transition: all 0.2s;
        }

        .view-toggle-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }

        /* Hole View Styles */
        .hole-view-container {
            background: white;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .hole-header {
            text-align: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        }
        
        .hole-nav-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        
        .hole-nav-btn-compact {
            padding: 8px 14px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            min-width: 60px;
        }
        
        .hole-nav-btn-compact:active {
            transform: scale(0.95);
        }
        
        .hole-title-section {
            flex: 1;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 8px;
            transition: background 0.2s;
        }
        
        .hole-title-section:active {
            background: #f1f5f9;
        }

        .hole-number {
            font-size: 32px;
            font-weight: 700;
            color: #1e40af;
            margin-bottom: 2px;
        }

        .hole-info {
            font-size: 15px;
            color: #64748b;
            font-weight: 600;
        }

        .hole-player-row-ticker {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            padding: 16px;
            margin-bottom: 12px;
            background: #f8fafc;
            border-radius: 12px;
            gap: 16px;
        }

        .hole-player-info {
            flex: 1;
        }

        .hole-player-name {
            font-size: 34px;
            font-weight: 700;
            color: #1e40af;
        }

        .hole-player-hcp {
            font-size: 17px;
            color: #64748b;
            margin-top: 4px;
            font-weight: 500;
        }

        .hole-score-section {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 12px;
        }

        .hole-score-ticker {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .hole-hcp-dots {
            display: flex;
            gap: 3px;
            justify-content: center;
            margin-bottom: 4px;
            min-height: 10px;
            width: 100%;
        }
        
        .hcp-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .hcp-dot.green {
            background: #10b981;
        }
        
        .hcp-dot.red {
            background: #ef4444;
        }

        .hole-net-score {
            font-size: 18px;
            color: #475569;
            font-weight: 700;
            background: #e2e8f0;
            padding: 6px 12px;
            border-radius: 8px;
            min-width: 45px;
            text-align: center;
        }

        .hole-score-ticker .score-btn {
            display: none; /* Hide +/- buttons - using quick tap popup instead */
        }

        .hole-score-ticker .score-input {
            width: 70px;
            height: 70px;
            font-size: 32px;
            font-weight: 700;
            text-align: center;
            border: 3px solid #cbd5e1;
            border-radius: 50%;
            background: white;
            color: #1e40af;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            -webkit-appearance: none;
            -moz-appearance: textfield;
        }

        .hole-score-ticker .score-input:focus {
            outline: none;
            border-color: #3b82f6;
        }
        
        /* Watch-only row styling */
        .hole-player-row-ticker.watch-only {
            opacity: 0.85;
            background: #f8fafc;
        }
        
        .hole-score-display {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* Score coloring for hole view */
        .hole-score-ticker .score-input.birdie-better {
            background: #dcfce7;
            border-color: #86efac;
            color: #166534;
        }

        .hole-score-ticker .score-input.par {
            background: #dbeafe;
            border-color: #60a5fa;
            color: #1e40af;
        }

        .hole-score-ticker .score-input.bogey {
            background: #fef9c3;
            border-color: #fde047;
            color: #854d0e;
        }

        .hole-score-ticker .score-input.double-bogey-plus {
            background: #fee2e2;
            border-color: #fca5a5;
            color: #991b1b;
        }

        .hole-player-row {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            padding: 12px;
            margin-bottom: 12px;
            background: #f8fafc;
            border-radius: 12px;
            gap: 12px;
        }

        .hole-player-name {
            font-size: 16px;
            font-weight: 600;
            color: #1e40af;
        }

        .hole-player-hcp {
            font-size: 13px;
            color: #64748b;
            margin-top: 2px;
        }

        .hole-score-input {
            width: 60px;
            height: 60px;
            font-size: 24px;
            font-weight: 700;
            text-align: center;
            border: 2px solid #cbd5e1;
            border-radius: 12px;
            background: white;
            color: #1e40af;
        }

        .hole-score-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .hole-navigation {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 12px;
            align-items: center;
            margin-top: 24px;
        }

        .hole-nav-btn {
            padding: 12px 20px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .hole-nav-btn:disabled {
            background: #e2e8f0;
            color: #94a3b8;
            cursor: not-allowed;
        }

        .hole-counter {
            text-align: center;
            font-size: 16px;
            font-weight: 600;
            color: #64748b;
        }

        /* Swipe gesture support */
        .hole-view-container {
            touch-action: pan-y;
            position: relative;
        }

        /* Score Picker Overlay */
        .score-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 20px;
        }

        .score-picker {
            background: white;
            border-radius: 20px;
            padding: 24px;
            width: 100%;
            max-width: 320px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .score-picker-header {
            text-align: center;
            font-size: 16px;
            color: #1e40af;
            margin-bottom: 16px;
        }

        .score-display {
            text-align: center;
            font-size: 48px;
            font-weight: 700;
            color: #3b82f6;
            margin: 20px 0;
        }

        .score-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }

        .score-btn {
            padding: 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            transition: background 0.2s;
        }

        .score-btn:active {
            background: #2563eb;
        }

        .score-close {
            width: 100%;
            padding: 14px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        /* Wrapper for table to enable horizontal scroll */
        .table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin-bottom: 20px;
        }

        @media print {
            .scorecard-modal {
                display: block !important;
                position: static;
                background: white;
            }

            .scorecard-content {
                box-shadow: none;
                max-width: 100%;
            }

            .scorecard-header,
            .scorecard-footer {
                display: none !important;
            }

            .scorecard-body {
                max-height: none;
                overflow: visible;
            }
            
            .scorecard-individual {
                page-break-inside: avoid;
                break-inside: avoid;
            }
            
            .table-wrapper {
                overflow: visible;
            }
            
            .scorecard-table {
                font-size: 10px;
            }
            
            .scorecard-table th,
            .scorecard-table td {
                padding: 4px 2px;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
                padding: 0;
            }

            .page {
                display: none;
            }

            #printableScorecard {
                display: block !important;
            }

            .btn, .form-group, #resultsGameType {
                display: none !important;
            }

            .print-scorecard {
                display: block;
                padding: 20px;
                font-family: Arial, sans-serif;
                color: black;
            }

            .print-header {
                text-align: center;
                margin-bottom: 20px;
                border-bottom: 2px solid black;
                padding-bottom: 10px;
            }

            .print-table {
                width: 100%;
                border-collapse: collapse;
                margin-bottom: 20px;
                page-break-inside: avoid;
            }

            .print-table th,
            .print-table td {
                border: 1px solid black;
                padding: 6px;
                text-align: center;
                font-size: 11px;
            }

            .print-table th {
                background: #e0e0e0;
                font-weight: bold;
            }

            .print-results {
                margin-top: 20px;
                page-break-before: avoid;
            }

            .print-results h3 {
                border-bottom: 2px solid black;
                padding-bottom: 5px;
                margin-bottom: 10px;
            }
            
            /* Make scorecard table fit on one page */
            .scorecard-table {
                font-size: 9px !important;
                width: 100%;
                page-break-inside: avoid;
            }
            
            .scorecard-table th,
            .scorecard-table td {
                padding: 4px 2px !important;
                font-size: 9px !important;
            }
            
            .scorecard-table th {
                font-size: 8px !important;
                font-weight: 700;
            }
            
            /* Hide modal chrome in print */
            .scorecard-header,
            .scorecard-footer {
                display: none !important;
            }
            
            .scorecard-modal {
                position: static !important;
                background: white !important;
            }
            
            .scorecard-content {
                max-width: 100% !important;
                margin: 0 !important;
                box-shadow: none !important;
            }
            
            .scorecard-body {
                padding: 10px !important;
            }
        }

        .print-scorecard {
            display: none;
        }
        
        /* Voice/Keyboard Input Toggle */
        .input-mode-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f1f5f9;
            border-radius: 8px;
            margin: 8px 0;
        }
        
        .input-mode-toggle label {
            font-size: 12px;
            color: #64748b;
            font-weight: 600;
        }
        
        .input-mode-btn {
            padding: 6px 12px;
            border: 2px solid #e2e8f0;
            background: white;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .input-mode-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }
        
        .input-mode-btn:hover:not(.active) {
            border-color: #3b82f6;
        }
        
        /* Voice listening indicator */
        .voice-listening {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 32px 48px;
            border-radius: 16px;
            z-index: 10001;
            text-align: center;
            display: none;
        }
        
        .voice-listening.active {
            display: block;
        }
        
        .voice-listening .mic-icon {
            font-size: 48px;
            animation: pulse 1s infinite;
        }
        
        .voice-listening .voice-text {
            font-size: 18px;
            margin-top: 12px;
            font-weight: 600;
        }
        
        .voice-listening .voice-result {
            font-size: 48px;
            margin-top: 16px;
            font-weight: 700;
            color: #10b981;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        /* Compact Player Card (9-column grid for auto-fit) */
        .player-card-compact {
            background: white;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .player-card-compact.watched {
            background: #f8fafc;
            border: 2px dashed #94a3b8;
        }
        
        .player-card-compact .player-header-compact {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            border-bottom: 2px solid #e2e8f0;
            margin-bottom: 8px;
        }
        
        .player-card-compact .player-name-compact {
            font-size: 16px;
            font-weight: 700;
            color: #1e40af;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .player-card-compact .player-total-compact {
            font-size: 18px;
            font-weight: 700;
            color: #3b82f6;
        }
        
        .nine-section {
            margin-bottom: 16px;
        }
        
        .nine-section-label {
            font-size: 11px;
            font-weight: 700;
            color: #64748b;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .nine-section-total {
            font-size: 12px;
            font-weight: 700;
            color: #1e40af;
        }
        
        .holes-grid-6 {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
        }
        
        /* Expanded score input modal */
        .expanded-score-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 10002;
            align-items: center;
            justify-content: center;
        }
        
        .expanded-score-modal.active {
            display: flex;
        }
        
        .expanded-score-content {
            background: white;
            border-radius: 16px;
            padding: 20px;
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .expanded-hole-header {
            text-align: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        }
        
        .expanded-hole-number {
            font-size: 24px;
            font-weight: 700;
            color: #1e40af;
        }
        
        .expanded-hole-info {
            font-size: 14px;
            color: #64748b;
        }
        
        .expanded-player-name {
            font-size: 18px;
            font-weight: 600;
            color: #1e40af;
            margin-bottom: 16px;
            text-align: center;
        }
        
        .expanded-score-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            margin-bottom: 20px;
        }
        
        .expanded-score-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            font-size: 28px;
            font-weight: 700;
            cursor: pointer;
        }
        
        .expanded-score-btn.minus {
            background: #fee2e2;
            color: #dc2626;
        }
        
        .expanded-score-btn.plus {
            background: #dbeafe;
            color: #2563eb;
        }
        
        .expanded-score-value {
            font-size: 48px;
            font-weight: 700;
            width: 80px;
            text-align: center;
            color: #1e40af;
        }
        
        .expanded-quick-scores {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .quick-score-btn {
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .quick-score-btn:active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
        
        .expanded-actions {
            display: flex;
            gap: 12px;
        }
        
        .expanded-actions button {
            flex: 1;
            padding: 14px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }
        
        /* Putt Tracking Styles */
        .putt-btn {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 2px solid #8b5cf6;
            background: #f5f3ff;
            color: #7c3aed;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
            flex-shrink: 0;
            transition: all 0.2s;
        }
        
        .putt-btn:active {
            background: #8b5cf6;
            color: white;
        }
        
        .putt-btn.has-putt {
            background: #8b5cf6;
            color: white;
            border-color: #7c3aed;
        }
        
        .putt-popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 10003;
            align-items: center;
            justify-content: center;
        }
        
        .putt-popup.active {
            display: flex;
        }
        
        .putt-popup-content {
            background: white;
            border-radius: 16px;
            padding: 20px;
            max-width: 320px;
            width: 90%;
            text-align: center;
        }
        
        .putt-popup-title {
            font-size: 22px;
            font-weight: 700;
            color: #7c3aed;
            margin-bottom: 4px;
        }
        
        .putt-popup-info {
            font-size: 14px;
            color: #64748b;
            margin-bottom: 16px;
        }
        
        .putt-options {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 16px;
        }
        
        .putt-option-btn {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 10px;
            border: 2px solid #e2e8f0;
            background: white;
            font-size: 24px;
            font-weight: 700;
            color: #1e40af;
            cursor: pointer;
            transition: all 0.15s;
            min-height: 52px;
        }
        
        .putt-option-btn:active {
            background: #8b5cf6;
            color: white;
            border-color: #8b5cf6;
            transform: scale(0.95);
        }
        
        .putt-option-btn.selected {
            background: #8b5cf6;
            color: white;
            border-color: #7c3aed;
        }
        
        .putt-clear-btn {
            width: 100%;
            padding: 12px;
            background: #fee2e2;
            color: #dc2626;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .putt-clear-btn:active {
            background: #dc2626;
            color: white;
        }
        
        .hole-cell {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 3px 2px;
            background: #f8fafc;
            border-radius: 6px;
            min-width: 0;
            height: 110px;
            overflow: visible;
        }
        
        .hole-cell .hole-num {
            font-size: 12px;
            font-weight: 700;
            color: #1e40af;
            margin-bottom: 1px;
        }
        
        .hole-cell .hole-par {
            font-size: 9px;
            color: #64748b;
            font-weight: 600;
        }
        
        .hole-cell .hole-hcp {
            font-size: 8px;
            color: #94a3b8;
            font-weight: 500;
            margin-bottom: 2px;
        }
        
        .hole-cell .par-hcp-stack {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0px;
            margin-bottom: 2px;
        }
        
        .hole-cell .par-hcp-line {
            display: flex;
            align-items: center;
            gap: 3px;
            font-size: 9px;
        }
        
        .hole-cell .par-hcp-line .label {
            color: #94a3b8;
            font-weight: 500;
            min-width: 20px;
            text-align: right;
        }
        
        .hole-cell .par-hcp-line .value {
            color: #475569;
            font-weight: 700;
            min-width: 14px;
        }
        
        /* Legacy classes - keep for backward compatibility */
        .hole-cell .par-hcp-row {
            display: none;
        }
        
        .hole-cell .par-hcp-col {
            display: none;
        }
        
        .hole-cell .par-hcp-label {
            display: none;
        }
        
        .hole-cell .par-hcp-value {
            display: none;
        }
        
        .hole-cell .par-hcp-divider {
            display: none;
        }
        
        .hole-cell .score-cell {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 700;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s;
        }
        
        .hole-cell .score-cell:active {
            transform: scale(0.95);
        }
        
        .hole-cell .score-cell.empty {
            background: #e2e8f0;
            color: #94a3b8;
        }
        
        .hole-cell .score-cell.birdie-better {
            background: #d1fae5;
            color: #059669;
            border-color: #10b981;
        }
        
        .hole-cell .score-cell.par {
            background: #dbeafe;
            color: #2563eb;
            border-color: #3b82f6;
        }
        
        .hole-cell .score-cell.bogey {
            background: #fef3c7;
            color: #d97706;
            border-color: #f59e0b;
        }
        
        .hole-cell .score-cell.double-plus {
            background: #fee2e2;
            color: #dc2626;
            border-color: #ef4444;
        }
        
        .hole-cell .net-score {
            font-size: 9px;
            color: #64748b;
            font-weight: 600;
            margin-top: 1px;
        }
        
        .hcp-dots-compact {
            display: flex;
            gap: 2px;
            justify-content: center;
            height: 8px;
            margin-bottom: 2px;
        }
        
        .hcp-dot-compact {
            width: 5px;
            height: 5px;
            border-radius: 50%;
        }
        
        .hcp-dot-compact.green {
            background: #10b981;
        }
        
        .hcp-dot-compact.red {
            background: #ef4444;
        }
        
        .hole-cell .score-btns-mini {
            display: flex;
            gap: 2px;
        }
        
        .hole-cell .btn-mini {
            width: 20px;
            height: 18px;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        
        .hole-cell .btn-mini.minus {
            background: #fee2e2;
            color: #dc2626;
        }
        
        .hole-cell .btn-mini.plus {
            background: #dbeafe;
            color: #2563eb;
        }
        
        /* Fullscreen mode - expanded scorecard - fill screen */
        .fullscreen-mode .player-card-compact {
            max-width: 100%;
            margin: 0 8px;
            padding: 16px 16px 12px 16px;
            min-height: calc(100vh - 120px);
            display: flex;
            flex-direction: column;
        }
        
        .fullscreen-mode .holes-grid-6 {
            gap: 8px;
        }
        
        .fullscreen-mode .hole-cell {
            padding: 10px 6px 8px 6px;
            border-radius: 10px;
            height: auto;
            min-height: 140px;
            justify-content: space-between;
        }
        
        .fullscreen-mode .hole-cell .hole-num {
            font-size: 18px;
            margin-bottom: 4px;
        }
        
        .fullscreen-mode .hole-cell .hole-par {
            font-size: 12px;
        }
        
        .fullscreen-mode .hole-cell .hole-hcp {
            font-size: 10px;
            color: #64748b;
            font-weight: 500;
        }
        
        .fullscreen-mode .hole-cell .par-hcp-stack {
            gap: 2px;
            margin-bottom: 6px;
        }
        
        .fullscreen-mode .hole-cell .par-hcp-line {
            font-size: 12px;
            gap: 4px;
        }
        
        .fullscreen-mode .hole-cell .par-hcp-line .label {
            min-width: 26px;
        }
        
        .fullscreen-mode .hole-cell .par-hcp-line .value {
            min-width: 18px;
            font-size: 13px;
        }
        
        .fullscreen-mode .hole-cell .score-cell {
            width: 48px;
            height: 48px;
            font-size: 24px;
        }
        
        .fullscreen-mode .hole-cell .net-score {
            font-size: 14px;
            color: #475569;
            margin-top: 6px;
            font-weight: 700;
        }
        
        .fullscreen-mode .nine-section {
            margin-bottom: 12px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .fullscreen-mode .nine-section-label {
            font-size: 13px;
            margin-bottom: 6px;
            flex-shrink: 0;
        }
        
        .fullscreen-mode .holes-grid-6 {
            flex: 1;
        }
        
        .fullscreen-mode .totals-row {
            padding: 16px 20px;
            margin-top: auto;
            flex-shrink: 0;
        }
        
        .fullscreen-mode .totals-row .total-label {
            font-size: 11px;
        }
        
        .fullscreen-mode .total-value {
            font-size: 22px;
        }
        
        .fullscreen-mode .carousel-nav {
            margin: 8px 12px 12px 12px !important;
        }
        
        .totals-row {
            display: flex;
            justify-content: space-around;
            padding: 8px;
            background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
            border-radius: 8px;
            margin-top: 8px;
        }
        
        .totals-row .total-item {
            text-align: center;
            color: white;
        }
        
        .totals-row .total-label {
            font-size: 10px;
            opacity: 0.8;
        }
        
        .totals-row .total-value {
            font-size: 16px;
            font-weight: 700;
        }
        
        /* Scorecard Color Coding */
        .scorecard-col-claimed {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%) !important;
        }
        
        .scorecard-col-watching {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%) !important;
        }
        
        .scorecard-cell-skin {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%) !important;
            font-weight: 700 !important;
            position: relative;
        }
        
        .scorecard-cell-skin::after {
            content: "ð";
            position: absolute;
            right: 4px;
            top: 2px;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <!-- Setup Page -->
    <div id="setupPage" class="page active">
        <div class="header">
            <h1>â³ Let's Golf <span style="font-size: 12px; font-weight: 400; color: #64748b;">by Otis Williams</span> <span id="setupConnectionDot" style="display: inline-block; width: 10px; height: 10px; border-radius: 50%; background: #10b981; margin-left: 6px;"></span></h1>
            <p>Golf Games and Tournaments</p>
        </div>

        <div class="setup-container">
            <div class="form-group">
                <label>Tournament Name <span style="color: #94a3b8; font-weight: 400; font-size: 13px;">(Optional)</span></label>
                <input type="text" id="tournamentName" placeholder="e.g., Saturday Morning Scramble" style="color: #1e293b;">
            </div>

            <div class="form-group">
                <label>Tournament Date</label>
                <input type="date" id="tournamentDate" placeholder="Select a Date" required>
            </div>

            <div class="form-group">
                <label>Course</label>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <select id="courseSelect" onchange="updateCourse()" style="flex: 1;">
                        <option value="" selected>Select a Course</option>
                        <optgroup label="â­ Favorites" id="favoritesOptgroup" style="display: none;"></optgroup>
                        <optgroup label="ð Local Courses" id="localCoursesOptgroup">
                            <option value="indian_hills">Indian Hills Golf Club</option>
                            <option value="jurupa_hills">Jurupa Hills Country Club</option>
                            <option value="hidden_valley">Hidden Valley Golf Club</option>
                            <option value="green_river">Green River Golf Club</option>
                            <option value="shandin_hills">Shandin Hills Golf Club</option>
                        </optgroup>
                        <optgroup label="â Other">
                            <option value="search_course">ð Search for a Course...</option>
                            <option value="custom_course">âï¸ Add Custom Course...</option>
                        </optgroup>
                    </select>
                    <button type="button" id="favoriteBtn" onclick="toggleCurrentCourseFavorite()" 
                        style="width: 44px; height: 44px; border: 2px solid #e2e8f0; border-radius: 12px; background: white; font-size: 20px; cursor: pointer; display: none;"
                        title="Add to favorites">â</button>
                </div>
            </div>
            
            <!-- Tee Selection (shown after course is selected) -->
            <div id="teeSelectionSection" class="form-group" style="display: none;">
                <label>Playing Tees</label>
                <div id="teeButtons" style="display: flex; gap: 8px; flex-wrap: wrap;"></div>
                <div id="teeInfo" style="margin-top: 8px; font-size: 12px; color: #64748b; text-align: center;"></div>
            </div>

            <div class="form-group">
                <label>Game Type</label>
                <select id="gameType" onchange="handleGameTypeChange()">
                    <option value="Stroke Play" selected>Stroke Play</option>
                    <option value="Skins">Skins</option>
                    <option value="Stableford">Stableford</option>
                    <option value="Stableford (Modified)">Stableford (Modified)</option>
                    <option value="Footlong">Footlong</option>
                    <option value="Nassau">Nassau</option>
                    <option value="Best Ball">Best Ball</option>
                </select>
            </div>

            <!-- Best Ball Setup Section (shown when Best Ball selected) -->
            <div id="bestBallSetupSection" class="form-group" style="display: none;">
                <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border: 2px solid #10b981; border-radius: 12px; padding: 16px;">
                    <div style="font-weight: 700; color: #065f46; font-size: 14px; margin-bottom: 12px; text-align: center;">Best Ball Setup</div>
                    
                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 12px; color: #475569; margin-bottom: 6px;">Players per team:</div>
                        <div style="display: flex; gap: 8px;">
                            <button type="button" class="bestball-option-btn" data-field="playersPerTeam" data-value="2" onclick="setBestBallOption('playersPerTeam', 2)" style="flex: 1; padding: 10px; border: 2px solid #10b981; background: #10b981; color: white; border-radius: 8px; font-weight: 700; font-size: 14px; cursor: pointer;">2</button>
                            <button type="button" class="bestball-option-btn" data-field="playersPerTeam" data-value="3" onclick="setBestBallOption('playersPerTeam', 3)" style="flex: 1; padding: 10px; border: 2px solid #d1d5db; background: white; color: #475569; border-radius: 8px; font-weight: 700; font-size: 14px; cursor: pointer;">3</button>
                            <button type="button" class="bestball-option-btn" data-field="playersPerTeam" data-value="4" onclick="setBestBallOption('playersPerTeam', 4)" style="flex: 1; padding: 10px; border: 2px solid #d1d5db; background: white; color: #475569; border-radius: 8px; font-weight: 700; font-size: 14px; cursor: pointer;">4</button>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 12px; color: #475569; margin-bottom: 6px;">Scores to count per hole:</div>
                        <div style="display: flex; gap: 8px;">
                            <button type="button" class="bestball-option-btn" data-field="scoresPerHole" data-value="1" onclick="setBestBallOption('scoresPerHole', 1)" style="flex: 1; padding: 10px; border: 2px solid #10b981; background: #10b981; color: white; border-radius: 8px; font-weight: 700; font-size: 14px; cursor: pointer;">1</button>
                            <button type="button" class="bestball-option-btn" data-field="scoresPerHole" data-value="2" onclick="setBestBallOption('scoresPerHole', 2)" style="flex: 1; padding: 10px; border: 2px solid #d1d5db; background: white; color: #475569; border-radius: 8px; font-weight: 700; font-size: 14px; cursor: pointer;">2</button>
                            <button type="button" class="bestball-option-btn" data-field="scoresPerHole" data-value="3" onclick="setBestBallOption('scoresPerHole', 3)" style="flex: 1; padding: 10px; border: 2px solid #d1d5db; background: white; color: #475569; border-radius: 8px; font-weight: 700; font-size: 14px; cursor: pointer;">3</button>
                        </div>
                    </div>
                    
                    <div>
                        <div style="font-size: 12px; color: #475569; margin-bottom: 6px;">Format:</div>
                        <div style="display: flex; gap: 8px;">
                            <button type="button" class="bestball-option-btn" data-field="format" data-value="stroke" onclick="setBestBallOption('format', 'stroke')" style="flex: 1; padding: 10px; border: 2px solid #10b981; background: #10b981; color: white; border-radius: 8px; font-weight: 700; font-size: 14px; cursor: pointer;">Stroke Play</button>
                            <button type="button" class="bestball-option-btn" data-field="format" data-value="match" onclick="setBestBallOption('format', 'match')" style="flex: 1; padding: 10px; border: 2px solid #d1d5db; background: white; color: #475569; border-radius: 8px; font-weight: 700; font-size: 14px; cursor: pointer;">Match Play</button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="teamSetupSection" class="form-group" style="display: none;">
                <label>Team Setup</label>
                <div id="teamSetupContent"></div>
            </div>

            <div class="form-group">
                <label>Players & Handicaps</label>
                
                <!-- Quick Add Button (opens popup) -->
                <div id="quickAddSection" style="margin-bottom: 12px; display: none;">
                    <button type="button" onclick="showQuickAddModal()" 
                        style="width: 100%; padding: 12px; background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border: 2px solid #3b82f6; border-radius: 10px; color: #1e40af; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <span style="font-size: 18px;">ð¥</span> Quick Add Players
                    </button>
                </div>
                
                <!-- Column Headers -->
                <div style="display: flex; gap: 8px; margin-bottom: 6px; padding: 0 4px;">
                    <div style="flex: 1; font-size: 11px; color: #64748b; font-weight: 600; text-transform: uppercase;">Name</div>
                    <div style="width: 65px; font-size: 11px; color: #64748b; font-weight: 600; text-transform: uppercase; text-align: center;">HCP</div>
                    <div style="width: 50px;"></div>
                </div>
                
                <div class="player-list" id="playerList">
                    <div class="player-row" data-player="1">
                        <input type="text" class="player-name-input" placeholder="Player Name" id="player1">
                        <input type="text" class="player-hcp-input" placeholder="HCP" id="hcp1" pattern="-?[0-9.]*" inputmode="decimal" oninput="updateCourseHandicap(1)">
                        <div class="course-hcp-display" id="courseHcp1" title="Course handicap for this round">-</div>
                    </div>
                </div>
                
                <!-- Add Player and Load Game Side by Side -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                    <button type="button" class="btn-add-player" onclick="addPlayerRow()" id="addPlayerBtn"><span style="font-size: 20px; font-weight: 600;">+</span> Add Player</button>
                    <button type="button" class="btn-add-player" onclick="document.getElementById('importFile').click()" style="background: white; color: #3b82f6; border-color: #3b82f6;">
                        <span style="font-weight: 900; font-size: 18px;">â</span> Load Game
                    </button>
                </div>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importTournamentBackup(event)">
            </div>

            <button type="button" class="btn btn-primary" id="resumeScoringBtn" style="background: #10b981; display: none;" onclick="resumeScoring()">Resume Scoring</button>
            <div style="display: flex; gap: 10px; margin-top: 8px;">
                <button type="button" class="btn btn-primary" onclick="startScoring()" style="flex: 3;">Start Tournament</button>
                <button type="button" id="setupCancelBtn" class="btn" onclick="cancelSetup()" style="flex: 1; background: #ef4444; color: white;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Scoring Page -->
    <div id="scoringPage" class="page">
        <!-- Round in Progress Indicator -->
        <div id="roundIndicator" class="round-indicator">
            <span class="round-indicator-icon"></span>
            <span>Round in Progress â¢ Auto-saved</span>
        </div>
        
        <!-- Voice Listening Overlay -->
        <div id="voiceListening" class="voice-listening">
            <div class="mic-icon">ð¤</div>
            <div class="voice-text">Listening...</div>
            <div class="voice-result" id="voiceResult"></div>
        </div>
        
        <!-- Expanded Score Input Modal -->
        <div id="expandedScoreModal" class="expanded-score-modal">
            <div class="expanded-score-content">
                <div class="expanded-hole-header">
                    <div class="expanded-hole-number" id="expandedHoleNumber">HOLE 1</div>
                    <div class="expanded-hole-info" id="expandedHoleInfo">Par 4 â¢ HCP 5</div>
                </div>
                <div class="expanded-player-name" id="expandedPlayerName">Player Name</div>
                <div class="expanded-score-display">
                    <button class="expanded-score-btn minus" onclick="expandedDecrement()">â</button>
                    <div class="expanded-score-value" id="expandedScoreValue">-</div>
                    <button class="expanded-score-btn plus" onclick="expandedIncrement()">+</button>
                </div>
                <div class="expanded-quick-scores" id="expandedQuickScores">
                    <!-- Quick score buttons populated dynamically -->
                </div>
                <div class="expanded-actions">
                    <button onclick="closeExpandedScore()" style="background: #e2e8f0; color: #475569; border: none;">Cancel</button>
                    <button onclick="saveExpandedScore()" style="background: #10b981; color: white; border: none;">Save</button>
                </div>
            </div>
        </div>
        
        <!-- Putt Input Popup -->
        <div id="puttPopup" class="putt-popup">
            <div class="putt-popup-content">
                <div class="putt-popup-title">Putts</div>
                <div class="putt-popup-info" id="puttPopupInfo">Hole 1 â¢ Par 4</div>
                <div class="putt-options" id="puttOptions">
                    <!-- Putt buttons populated dynamically -->
                </div>
                <button class="putt-clear-btn" onclick="clearPutt()">Clear</button>
            </div>
        </div>
        
        <div class="scoring-header">
            <!-- Row 1: Title with Connection Dot and Crown Badge -->
            <div style="text-align: center; display: flex; align-items: center; justify-content: center; gap: 8px;">
                <h2 style="color: #1e40af; font-size: 18px; margin: 0;">â³ Let's Golf <span style="font-size: 10px; font-weight: 400; color: #64748b;">by Otis Williams</span></h2>
                <span id="scoringHostBadge" style="display: none; background: white; color: #f97316; font-size: 10px; font-weight: 700; padding: 2px 8px; border-radius: 10px; border: 1.5px solid #f97316;">ð</span>
                <span id="scoringConnectionDot" title="Connection status" style="width: 12px; height: 12px; border-radius: 50%; background: #10b981; flex-shrink: 0;"></span>
            </div>
            
            <!-- Row 2: Smart Info Line -->
            <div style="text-align: center;">
                <p id="scoringSmartInfo" style="font-size: 12px; color: #1e40af; font-weight: 600; margin: 0;"></p>
            </div>
            
            <!-- Row 3: Navigation Buttons - Rectangular, evenly spaced -->
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px; padding: 0 4px;">
                <button type="button" onclick="confirmBackToHome()" style="flex: 1; height: 40px; border-radius: 10px; border: 2px solid #3b82f6; background: #94a3b8; color: white; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 4px;" title="Home">ð </button>
                <button type="button" id="managePlayersBtn" onclick="showPlayerManagement()" style="display: none; flex: 1; height: 40px; border-radius: 10px; border: 2px solid #78350f; background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #78350f; font-size: 16px; cursor: pointer; align-items: center; justify-content: center; gap: 4px;" title="Manage Tournament">âï¸</button>
                <button type="button" id="myPlayersBtnHeader" onclick="showMyPlayersPage()" style="display: none; flex: 1; height: 40px; border-radius: 10px; border: 2px solid #78350f; background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #78350f; font-size: 16px; cursor: pointer; align-items: center; justify-content: center; gap: 4px;" title="My Players">ð¤</button>
                <button type="button" onclick="openScorecardModal()" style="flex: 1; height: 40px; border-radius: 10px; border: 2px solid #3b82f6; background: #dbeafe; color: #3b82f6; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 4px;" title="Scorecard">ð</button>
                <button type="button" id="finishRoundBtn" onclick="showPage('resultsPage')" style="flex: 1; height: 40px; border-radius: 10px; border: 2px solid #d97706; background: #3b82f6; color: white; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 4px;" title="Results">ð</button>
            </div>
            
            <!-- Row 4: Toggle Buttons - Paired -->
            <div style="display: flex; justify-content: center; gap: 12px;">
                <div class="btn-toggle-group" style="display: flex; background: #e2e8f0; border-radius: 10px; padding: 3px;">
                    <button type="button" id="toggleHoleView" class="toggle-btn active" onclick="switchToHoleView()" style="padding: 6px 14px; font-size: 12px; font-weight: 600; border-radius: 8px; border: none; background: #3b82f6; color: white; cursor: pointer;">â³ Holes</button>
                    <button type="button" id="togglePlayerView" class="toggle-btn" onclick="switchToPlayerView()" style="padding: 6px 14px; font-size: 12px; font-weight: 600; border-radius: 8px; border: none; background: transparent; color: #64748b; cursor: pointer;">ð¤ Players</button>
                </div>
                <div class="btn-toggle-group" style="display: flex; background: #e2e8f0; border-radius: 10px; padding: 3px;">
                    <button type="button" class="toggle-btn active" id="keyboardModeBtn" onclick="setInputMode('keyboard')" style="padding: 6px 14px; font-size: 12px; font-weight: 600; border-radius: 8px; border: none; background: #3b82f6; color: white; cursor: pointer;">ð Touch</button>
                    <button type="button" class="toggle-btn" id="voiceModeBtn" onclick="setInputMode('voice')" style="padding: 6px 14px; font-size: 12px; font-weight: 600; border-radius: 8px; border: none; background: transparent; color: #64748b; cursor: pointer;">ð¤ Voice</button>
                </div>
            </div>
        </div>

        <div class="scoring-content">

            <div id="playerCards"></div>
            
            <!-- By Hole View (hidden by default) -->
            <div id="holeView" style="display: none;">
                <div id="holeViewContent"></div>
            </div>
        </div>
    </div>

    <!-- Results Page -->
    <div id="resultsPage" class="page">
        <div class="results-sticky-header">
            <div class="results-page-header">
                <!-- Row 1: Title with Connection Dot and Crown Badge -->
                <div style="text-align: center; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <h2 style="color: #1e40af; font-size: 18px; margin: 0;">ð Let's Golf <span style="font-size: 10px; font-weight: 400; color: #64748b;">by Otis Williams</span></h2>
                    <span id="resultsHostBadge" style="display: none; background: white; color: #f97316; font-size: 10px; font-weight: 700; padding: 2px 8px; border-radius: 10px; border: 1.5px solid #f97316;">ð</span>
                    <span id="resultsConnectionDot" title="Connection status" style="width: 12px; height: 12px; border-radius: 50%; background: #10b981; flex-shrink: 0;"></span>
                </div>
                
                <!-- Row 2: Smart Info Line -->
                <div style="text-align: center;">
                    <p id="resultsSmartInfo" style="font-size: 12px; color: #1e40af; font-weight: 600; margin: 0;"></p>
                </div>
                
                <!-- Row 3: Button Row - Rectangular, evenly spaced -->
                <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px; padding: 0 4px;">
                    <button type="button" onclick="confirmBackToHome()" style="flex: 1; height: 40px; border-radius: 10px; border: 2px solid #3b82f6; background: #94a3b8; color: white; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Home">ð </button>
                    <button type="button" id="resultsManageBtn" onclick="showPlayerManagement()" style="display: none; flex: 1; height: 40px; border-radius: 10px; border: 2px solid #78350f; background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #78350f; font-size: 16px; cursor: pointer; align-items: center; justify-content: center;" title="Manage Tournament">âï¸</button>
                    <button type="button" id="resultsMyPlayersBtn" onclick="showMyPlayersPage()" style="display: none; flex: 1; height: 40px; border-radius: 10px; border: 2px solid #78350f; background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #78350f; font-size: 16px; cursor: pointer; align-items: center; justify-content: center;" title="My Players">ð¤</button>
                    <button type="button" id="resultsScorecardBtn" onclick="openScorecardModal()" style="flex: 1; height: 40px; border-radius: 10px; border: 2px solid #3b82f6; background: #dbeafe; color: #3b82f6; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="View Scorecards">ð</button>
                    <button type="button" onclick="showPage('scoringPage')" style="flex: 1; height: 40px; border-radius: 10px; border: 2px solid #10b981; background: #3b82f6; color: white; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Scoring">â³</button>
                    <button type="button" id="newRoundBtnTop" data-action="confirmNewRound" style="flex: 1; height: 40px; border-radius: 10px; border: none; background: #ef4444; color: white; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Finish Round">ð</button>
                </div>
            </div>
        </div>

        <div class="results-container">
            <!-- Settings Card -->
            <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 12px; padding: 12px; margin-bottom: 10px;">
                <!-- Row 1: Game Type and Tourney/Side Game Toggle -->
                <div id="resultsRow1" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                    <select id="resultsGameType" onchange="updateResultsGameType()" style="flex: 1; padding: 10px 12px; border: 1.5px solid #d1d5db; border-radius: 8px; font-size: 13px; background: white; max-width: 200px;">
                        <option value="Stroke Play">Stroke Play</option>
                        <option value="Skins">Skins</option>
                        <option value="Stableford">Stableford</option>
                        <option value="Stableford (Modified)">Stableford (Modified)</option>
                        <option value="Footlong">Footlong</option>
                        <option value="Nassau">Nassau</option>
                    </select>
                    <!-- Tourney/Side Game Toggle Switch -->
                    <div id="tourneyToggleContainer" style="display: flex; background: #e2e8f0; border-radius: 8px; padding: 3px;">
                        <button type="button" id="tourneyModeBtn" onclick="setResultsMode('tourney')" 
                            style="padding: 8px 12px; border: none; border-radius: 6px; background: #3b82f6; color: white; font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                            Tourney
                        </button>
                        <button type="button" id="sideGameModeBtn" onclick="setResultsMode('sideGame')" 
                            style="padding: 8px 12px; border: none; border-radius: 6px; background: transparent; color: #64748b; font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                            Side Game
                        </button>
                    </div>
                </div>
                
                <!-- Row 2: Scoring Method Buttons -->
                <div style="display: flex; gap: 6px; margin-bottom: 10px;">
                    <button type="button" id="scoringMethodGross" onclick="setScoringMethod('gross')" 
                        style="flex: 1; padding: 10px 8px; border: 2px solid #3b82f6; background: #3b82f6; color: white; border-radius: 8px; font-size: 13px; font-weight: 700; cursor: pointer;">
                        Gross
                    </button>
                    <button type="button" id="scoringMethodNet" onclick="setScoringMethod('net')" 
                        style="flex: 1; padding: 10px 8px; border: 2px solid #d1d5db; background: white; color: #475569; border-radius: 8px; font-size: 13px; font-weight: 700; cursor: pointer;">
                        Net
                    </button>
                    <button type="button" id="scoringMethodNet18" onclick="setScoringMethod('net18')" 
                        style="flex: 1; padding: 10px 8px; border: 2px solid #d1d5db; background: white; color: #475569; border-radius: 8px; font-size: 13px; font-weight: 700; cursor: pointer;">
                        Net 18
                    </button>
                    <button type="button" id="scoringMethodNetHalf" onclick="setScoringMethod('netHalf')" 
                        style="flex: 1; padding: 10px 8px; border: 2px solid #d1d5db; background: white; color: #9ca3af; border-radius: 8px; font-size: 13px; font-weight: 700; cursor: pointer; opacity: 0.5;" disabled>
                        Net Â½
                    </button>
                </div>
                
                <!-- Row 3: Filter Toggle (Centered) -->
                <div id="resultsFilterRow" style="display: flex; align-items: center; justify-content: center;">
                    <div id="resultsFilterToggle" style="display: flex; background: #e2e8f0; border-radius: 10px; padding: 3px;">
                        <button id="resultsToggleMine" onclick="setResultsFilter('mine')" 
                            style="padding: 8px 16px; border: none; border-radius: 8px; background: transparent; color: #64748b; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 6px;" title="My Players">
                            <span style="font-size: 14px;">ð¤</span> My Players
                        </button>
                        <button id="resultsToggleAll" onclick="setResultsFilter('all')" 
                            style="padding: 8px 16px; border: none; border-radius: 8px; background: #3b82f6; color: white; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 6px;" title="All Players">
                            <span style="font-size: 18px; line-height: 1;">ð¥</span> All Players
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Live Status Row -->
            <div id="liveUpdateIndicator" style="display: flex; align-items: center; justify-content: center; gap: 6px; margin-bottom: 10px; padding: 6px 0;">
                <span style="width: 8px; height: 8px; border-radius: 50%; background: #10b981; animation: pulse 2s infinite;"></span>
                <span style="font-size: 12px; color: #64748b; font-weight: 500;">Live Updates</span>
            </div>
            
            <!-- Leaderboard Card -->
            <div style="background: linear-gradient(135deg, #fefce8 0%, #fef9c3 100%); border: 2px solid #fbbf24; border-radius: 16px; padding: 0; overflow: hidden; box-shadow: 0 4px 12px rgba(251, 191, 36, 0.2);">
                <!-- Trophy Header -->
                <div style="background: linear-gradient(135deg, #fbbf24, #f59e0b); padding: 12px 16px; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <span style="font-size: 24px;">ð</span>
                    <span style="font-size: 16px; font-weight: 700; color: #78350f; text-transform: uppercase; letter-spacing: 1px;">Leaderboard</span>
                    <span style="font-size: 24px;">ð</span>
                </div>
                
                <!-- Results Content -->
                <div id="resultsContent" style="padding: 16px; background: white;">
                    <!-- Generated dynamically -->
                </div>
            </div>
            
        </div>
    </div>

    <!-- Scorecard Modal -->
    <div id="scorecardModal" class="scorecard-modal">
        <div class="scorecard-content">
            <div class="scorecard-header">
                <h2 style="color: #1e40af; margin: 0;">ð Scorecards</h2>
                <button onclick="closeScorecardModal()" style="background: #ef4444; color: white; border: none; border-radius: 8px; padding: 8px 16px; font-weight: 600; cursor: pointer;">â Close</button>
            </div>
            <div style="padding: 20px; border-bottom: 1px solid #e2e8f0;">
                <label style="font-weight: 600; color: #1e40af; margin-bottom: 8px; display: block;">Select View:</label>
                <select id="scorecardViewSelect" onchange="updateScorecardView()" style="width: 100%; padding: 12px; border: 2px solid #cbd5e1; border-radius: 8px; font-size: 16px;">
                    <option value="all-summary">All Players - Summary Table</option>
                    <option value="all-individual">All Players - Individual Cards</option>
                    <option disabled>âââââââââââââââââ</option>
                </select>
            </div>
            <div class="scorecard-body" id="scorecardBody">
                <!-- Scorecard content will be populated here -->
            </div>
            <div class="scorecard-footer">
                <button onclick="printScorecard()" class="btn btn-primary" style="background: #10b981; margin: 0;">ð¤ Share / Print</button>
            </div>
        </div>
    </div>

    <!-- Printable Scorecard (Hidden, only shows when printing) -->
    <div id="printableScorecard" class="print-scorecard"></div>

    <!-- Auto-save Toast -->
    <div id="autoSaveToast" class="auto-save-toast">â Saved</div>

    <!-- Join Tournament Page -->
    <div id="joinPage" class="page">
        <div class="card">
            <div class="tournament-info-centered">
                <p style="font-size: 32px;">â³</p>
                <h2>Join Tournament</h2>
                <p id="joinTournamentInfo" style="margin-top: 8px;">Loading...</p>
            </div>

            <!-- Quick Add Section - Players to Claim or Watch -->
            <div id="joinExistingPlayers" style="margin-top: 24px; display: none;">
                <h3 style="color: #1e40af; font-size: 18px; margin-bottom: 8px; text-align: center;">Select Players</h3>
                <p style="color: #64748b; font-size: 13px; margin-bottom: 16px; text-align: center;">Tap to claim (you'll score) or watch (view only)</p>
                <div id="existingPlayersList"></div>
                
                <!-- Selection Summary -->
                <div id="selectionSummary" style="display: none; margin-top: 16px; padding: 12px; background: #f0fdf4; border: 2px solid #10b981; border-radius: 10px;">
                    <div style="font-size: 13px; color: #065f46;">
                        <span id="claimCount">0</span> to score â¢ <span id="watchCount">0</span> watching
                    </div>
                </div>
            </div>

            <!-- Join Tournament Button (NOW ABOVE DIVIDER) -->
            <div id="joinTournamentBtnContainer" style="display: none; margin-top: 20px;">
                <button type="button" onclick="executeJoinTournament()" 
                    style="width: 100%; padding: 16px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 12px; font-size: 18px; font-weight: 700; cursor: pointer; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);">
                    ðï¸ Join Tournament
                </button>
            </div>

            <!-- Divider -->
            <div id="joinDivider" style="display: none; margin: 24px 0; text-align: center; position: relative;">
                <div style="position: absolute; top: 50%; left: 0; right: 0; height: 1px; background: linear-gradient(90deg, transparent, #cbd5e1, transparent);"></div>
                <span style="position: relative; background: white; padding: 0 16px; color: #94a3b8; font-size: 13px; font-weight: 600;">OR</span>
            </div>

            <!-- Bottom Options -->
            <div id="joinBottomOptions" style="display: none;">
                <!-- Viewer Option -->
                <button type="button" id="viewerJoinBtn" onclick="joinAsViewer()"
                    style="width: 100%; padding: 16px 20px; margin-bottom: 12px; background: #f1f5f9; border: 2px solid #94a3b8; border-radius: 12px; color: #475569; font-size: 16px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 12px;">
                    <span style="font-size: 24px;">ð</span>
                    <span>Join as Viewer</span>
                </button>
                
                <!-- Add New Player (for players not in list) -->
                <button type="button" onclick="showAddNewPlayerForm()"
                    style="width: 100%; padding: 16px 20px; background: #fef3c7; border: 2px solid #f59e0b; border-radius: 12px; color: #92400e; font-size: 16px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 12px;">
                    <span style="font-size: 24px;">â</span>
                    <span>I'm Not Listed - Add Me</span>
                </button>
            </div>

            <!-- Cancel Button -->
            <div style="margin-top: 16px;">
                <button type="button" onclick="showGuestHomePage()" style="width: 100%; padding: 12px; background: transparent; color: white; border: none; font-size: 14px; cursor: pointer;">
                    Cancel
                </button>
            </div>
            
            <!-- Hidden form for adding new player -->
            <form id="joinTournamentForm" style="display: none; margin-top: 24px;">
                <h3 style="color: #1e40af; font-size: 18px; margin-bottom: 16px; text-align: center;">Add New Player</h3>
                
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 12px; margin-bottom: 16px;">
                    <div>
                        <label style="display: block; margin-bottom: 8px; color: #475569; font-weight: 600; font-size: 14px;">Your Name</label>
                        <input type="text" id="joinPlayerName" placeholder="Enter your name" required style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 8px; color: #475569; font-weight: 600; font-size: 14px;">Handicap</label>
                        <input type="number" id="joinPlayerHandicap" min="-10" max="54" step="1" placeholder="0" required style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; text-align: center;">
                    </div>
                </div>
                
                <input type="hidden" id="joinPlayerEmail" value="">
                <input type="hidden" id="joinPlayerPhone" value="">

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 16px;">
                    <button type="button" onclick="hideAddNewPlayerForm()" style="padding: 14px; background: #f1f5f9; color: #475569; border: 2px solid #cbd5e1; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer;">
                        Back
                    </button>
                    <button type="submit" style="padding: 14px; background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer;">
                        Add & Join
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Account Modal -->
    <div id="accountModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; border-radius: 16px; padding: 24px; margin: 20px; max-width: 400px; width: 90%; box-shadow: 0 8px 16px rgba(0,0,0,0.3);">
            <div id="accountLoggedOut">
                <h3 style="color: #1e40af; margin-bottom: 8px; font-size: 20px; text-align: center;">ð¤ Account</h3>
                <p style="color: #64748b; font-size: 13px; text-align: center; margin-bottom: 20px;">Sign in to unlock multi-device scoring and unlimited players</p>
                
                <div id="authForm">
                    <div style="margin-bottom: 12px;">
                        <input type="email" id="authEmail" placeholder="Email" style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; box-sizing: border-box;">
                    </div>
                    <div style="margin-bottom: 16px;">
                        <input type="password" id="authPassword" placeholder="Password" style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; box-sizing: border-box;">
                    </div>
                    <div id="authError" style="display: none; color: #ef4444; font-size: 13px; margin-bottom: 12px; text-align: center;"></div>
                    
                    <button type="button" onclick="signInUser()" style="width: 100%; padding: 14px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 8px;">Sign In</button>
                    <button type="button" onclick="registerUser()" style="width: 100%; padding: 14px; background: #10b981; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 12px;">Create Account</button>
                    
                    <p style="text-align: center; color: #64748b; font-size: 12px;">
                        <a href="#" onclick="sendPasswordReset()" style="color: #3b82f6; text-decoration: none;">Forgot password?</a>
                    </p>
                </div>
            </div>
            
            <div id="accountLoggedIn" style="display: none;">
                <h3 style="color: #1e40af; margin-bottom: 16px; font-size: 20px; text-align: center;">ð¤ My Account</h3>
                
                <div style="background: #f8fafc; border-radius: 10px; padding: 16px; margin-bottom: 16px;">
                    <!-- Username -->
                    <p style="font-size: 14px; color: #64748b; margin-bottom: 4px;">Username</p>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                        <p id="accountUsername" style="font-size: 18px; font-weight: 700; color: #1e293b; margin: 0;"></p>
                        <button type="button" onclick="showChangeUsernameForm()" style="padding: 4px 8px; background: transparent; color: #3b82f6; border: none; font-size: 12px; cursor: pointer;">âï¸</button>
                    </div>
                    
                    <!-- Email -->
                    <p style="font-size: 14px; color: #64748b; margin-bottom: 4px;">Email</p>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <p id="accountEmail" style="font-size: 14px; font-weight: 600; color: #1e293b; margin: 0;"></p>
                        <span id="emailVerifiedBadge" style="display: none; font-size: 10px; padding: 2px 6px; border-radius: 8px; font-weight: 600;"></span>
                    </div>
                    <div id="verifyEmailPrompt" style="display: none; margin-bottom: 12px;">
                        <button type="button" onclick="sendVerificationEmail()" style="padding: 6px 12px; background: #fef3c7; color: #92400e; border: 1px solid #f59e0b; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">ð§ Verify Email</button>
                    </div>
                    
                    <div id="subscriptionInfo">
                        <p style="font-size: 14px; color: #64748b; margin-bottom: 4px;">Subscription</p>
                        <p id="subscriptionStatus" style="font-size: 16px; font-weight: 600; color: #10b981;"></p>
                        <p id="subscriptionExpiry" style="font-size: 12px; color: #64748b;"></p>
                    </div>
                </div>
                
                <!-- Account Settings -->
                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                    <button type="button" onclick="showChangeEmailForm()" style="flex: 1; padding: 10px; background: #f8fafc; color: #475569; border: 1.5px solid #e2e8f0; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer;">âï¸ Email</button>
                    <button type="button" onclick="showChangePasswordForm()" style="flex: 1; padding: 10px; background: #f8fafc; color: #475569; border: 1.5px solid #e2e8f0; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer;">ð Password</button>
                </div>
                
                <!-- Stats History Button -->
                <button type="button" onclick="hideAccountModal(); showStatsHistoryModal();" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #8b5cf6, #6d28d9); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; margin-bottom: 12px; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    ð View Stats History
                </button>
                
                <!-- Change Username Form (hidden by default) -->
                <div id="changeUsernameForm" style="display: none; background: #f0f9ff; border-radius: 10px; padding: 12px; margin-bottom: 12px;">
                    <p style="font-size: 13px; font-weight: 600; color: #1e40af; margin-bottom: 8px;">Change Username</p>
                    <input type="text" id="newUsernameInput" placeholder="New username" maxlength="20" style="width: 100%; padding: 10px; border: 1.5px solid #3b82f6; border-radius: 6px; font-size: 14px; margin-bottom: 8px; box-sizing: border-box;">
                    <div id="changeUsernameError" style="display: none; color: #ef4444; font-size: 12px; margin-bottom: 8px;"></div>
                    <div style="display: flex; gap: 8px;">
                        <button type="button" onclick="hideChangeUsernameForm()" style="flex: 1; padding: 8px; background: #e2e8f0; color: #475569; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">Cancel</button>
                        <button type="button" onclick="updateUsername()" style="flex: 1; padding: 8px; background: #3b82f6; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">Update</button>
                    </div>
                </div>
                
                <!-- Change Email Form (hidden by default) -->
                <div id="changeEmailForm" style="display: none; background: #f0f9ff; border-radius: 10px; padding: 12px; margin-bottom: 12px;">
                    <p style="font-size: 13px; font-weight: 600; color: #1e40af; margin-bottom: 8px;">Change Email</p>
                    <input type="email" id="newEmailInput" placeholder="New email address" style="width: 100%; padding: 10px; border: 1.5px solid #3b82f6; border-radius: 6px; font-size: 14px; margin-bottom: 8px; box-sizing: border-box;">
                    <input type="password" id="currentPasswordForEmail" placeholder="Current password to confirm" style="width: 100%; padding: 10px; border: 1.5px solid #e2e8f0; border-radius: 6px; font-size: 14px; margin-bottom: 8px; box-sizing: border-box;">
                    <div id="changeEmailError" style="display: none; color: #ef4444; font-size: 12px; margin-bottom: 8px;"></div>
                    <div style="display: flex; gap: 8px;">
                        <button type="button" onclick="hideChangeEmailForm()" style="flex: 1; padding: 8px; background: #e2e8f0; color: #475569; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">Cancel</button>
                        <button type="button" onclick="updateEmail()" style="flex: 1; padding: 8px; background: #3b82f6; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">Update</button>
                    </div>
                </div>
                
                <!-- Change Password Form (hidden by default) -->
                <div id="changePasswordForm" style="display: none; background: #f0f9ff; border-radius: 10px; padding: 12px; margin-bottom: 12px;">
                    <p style="font-size: 13px; font-weight: 600; color: #1e40af; margin-bottom: 8px;">Change Password</p>
                    <input type="password" id="currentPasswordInput" placeholder="Current password" style="width: 100%; padding: 10px; border: 1.5px solid #e2e8f0; border-radius: 6px; font-size: 14px; margin-bottom: 8px; box-sizing: border-box;">
                    <input type="password" id="newPasswordInput" placeholder="New password (min 6 chars)" style="width: 100%; padding: 10px; border: 1.5px solid #3b82f6; border-radius: 6px; font-size: 14px; margin-bottom: 8px; box-sizing: border-box;">
                    <div id="changePasswordError" style="display: none; color: #ef4444; font-size: 12px; margin-bottom: 8px;"></div>
                    <div style="display: flex; gap: 8px;">
                        <button type="button" onclick="hideChangePasswordForm()" style="flex: 1; padding: 8px; background: #e2e8f0; color: #475569; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">Cancel</button>
                        <button type="button" onclick="updatePassword()" style="flex: 1; padding: 8px; background: #3b82f6; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">Update</button>
                    </div>
                </div>
                
                <button type="button" onclick="showPaywall()" id="upgradeBtn" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 8px;">â­ Upgrade</button>
                <button type="button" onclick="restorePurchase()" id="restoreBtn" style="width: 100%; padding: 12px; background: #f8fafc; color: #3b82f6; border: 1.5px solid #3b82f6; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; margin-bottom: 8px;">ð Restore Purchase</button>
                <button type="button" onclick="signOutUser()" style="width: 100%; padding: 14px; background: #ef4444; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 12px;">Sign Out</button>
                
                <!-- Delete Account -->
                <button type="button" onclick="showDeleteAccountConfirm()" style="width: 100%; padding: 10px; background: transparent; color: #94a3b8; border: 1px solid #e2e8f0; border-radius: 8px; font-size: 12px; cursor: pointer;">ðï¸ Delete Account</button>
                
                <!-- Delete Account Confirmation (hidden by default) -->
                <div id="deleteAccountConfirm" style="display: none; background: #fef2f2; border: 1px solid #ef4444; border-radius: 10px; padding: 12px; margin-top: 12px;">
                    <p style="font-size: 13px; font-weight: 600; color: #991b1b; margin-bottom: 8px;">â ï¸ Delete Account Permanently?</p>
                    <p style="font-size: 12px; color: #7f1d1d; margin-bottom: 12px;">This will delete your account and all data. This cannot be undone.</p>
                    <input type="password" id="deleteAccountPassword" placeholder="Enter password to confirm" style="width: 100%; padding: 10px; border: 1.5px solid #ef4444; border-radius: 6px; font-size: 14px; margin-bottom: 8px; box-sizing: border-box;">
                    <div id="deleteAccountError" style="display: none; color: #ef4444; font-size: 12px; margin-bottom: 8px;"></div>
                    <div style="display: flex; gap: 8px;">
                        <button type="button" onclick="hideDeleteAccountConfirm()" style="flex: 1; padding: 8px; background: #e2e8f0; color: #475569; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">Cancel</button>
                        <button type="button" onclick="deleteAccount()" style="flex: 1; padding: 8px; background: #ef4444; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">Delete Forever</button>
                    </div>
                </div>
            </div>
            
            <button type="button" onclick="hideAccountModal()" style="width: 100%; padding: 12px; background: #e2e8f0; color: #475569; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; margin-top: 12px;">Close</button>
        </div>
    </div>

    <!-- Paywall Modal -->
    <div id="paywallModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 10001; align-items: center; justify-content: center; overflow-y: auto;">
        <div style="background: white; border-radius: 20px; padding: 24px; margin: 20px; max-width: 400px; width: 90%; box-shadow: 0 12px 24px rgba(0,0,0,0.3);">
            <div style="text-align: center; margin-bottom: 20px;">
                <span style="font-size: 48px;">ðï¸</span>
                <h3 style="color: #1e40af; margin: 8px 0; font-size: 22px;">Upgrade to Pro</h3>
                <p id="paywallReason" style="color: #64748b; font-size: 14px;">Unlock multi-device scoring and unlimited players</p>
            </div>
            
            <!-- Free Tier Info -->
            <div style="background: #f1f5f9; border-radius: 10px; padding: 12px; margin-bottom: 16px;">
                <p style="font-size: 12px; color: #64748b; margin: 0;"><strong>Free tier:</strong> 4 players max, single device, local only</p>
            </div>
            
            <!-- Pricing Options -->
            <div style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 16px;">
                <button type="button" onclick="selectPlan('day')" class="plan-btn" id="planDay" style="width: 100%; padding: 16px; background: white; border: 2px solid #10b981; border-radius: 12px; cursor: pointer; text-align: left; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-size: 16px; font-weight: 600; color: #1e293b;">Day Pass</div>
                        <div style="font-size: 12px; color: #64748b;">24 hours â¢ Perfect for one event</div>
                    </div>
                    <div style="font-size: 20px; font-weight: 700; color: #10b981;">$4.99</div>
                </button>
                
                <button type="button" onclick="selectPlan('week')" class="plan-btn" id="planWeek" style="width: 100%; padding: 16px; background: white; border: 2px solid #3b82f6; border-radius: 12px; cursor: pointer; text-align: left; display: flex; justify-content: space-between; align-items: center; position: relative;">
                    <div style="position: absolute; top: -8px; right: 12px; background: #3b82f6; color: white; font-size: 10px; font-weight: 600; padding: 2px 8px; border-radius: 10px;">POPULAR</div>
                    <div>
                        <div style="font-size: 16px; font-weight: 600; color: #1e293b;">Week Pass</div>
                        <div style="font-size: 12px; color: #64748b;">7 days â¢ Great for golf trips</div>
                    </div>
                    <div style="font-size: 20px; font-weight: 700; color: #3b82f6;">$9.99</div>
                </button>
                
                <button type="button" onclick="selectPlan('season')" class="plan-btn" id="planSeason" style="width: 100%; padding: 16px; background: white; border: 2px solid #f59e0b; border-radius: 12px; cursor: pointer; text-align: left; display: flex; justify-content: space-between; align-items: center; position: relative;">
                    <div style="position: absolute; top: -8px; right: 12px; background: #f59e0b; color: white; font-size: 10px; font-weight: 600; padding: 2px 8px; border-radius: 10px;">BEST VALUE</div>
                    <div>
                        <div style="font-size: 16px; font-weight: 600; color: #1e293b;">Season Pass</div>
                        <div style="font-size: 12px; color: #64748b;">1 year â¢ Unlimited everything</div>
                    </div>
                    <div style="font-size: 20px; font-weight: 700; color: #f59e0b;">$49.99</div>
                </button>
            </div>
            
            <!-- Features List -->
            <div style="background: #f0fdf4; border-radius: 10px; padding: 12px; margin-bottom: 16px;">
                <p style="font-size: 13px; font-weight: 600; color: #166534; margin-bottom: 8px;">All paid plans include:</p>
                <div style="font-size: 12px; color: #166534;">
                    <p style="margin: 4px 0;">â Unlimited players</p>
                    <p style="margin: 4px 0;">â Multi-device scoring</p>
                    <p style="margin: 4px 0;">â Cloud sync & live leaderboard</p>
                    <p style="margin: 4px 0;">â Share via QR code or link</p>
                </div>
            </div>
            
            <!-- Purchase Button -->
            <button type="button" id="purchaseBtn" onclick="processPurchase()" style="width: 100%; padding: 16px; background: #10b981; color: white; border: none; border-radius: 12px; font-size: 18px; font-weight: 700; cursor: pointer; margin-bottom: 8px;">
                Continue - $9.99
            </button>
            
            <button type="button" onclick="hidePaywall()" style="width: 100%; padding: 12px; background: transparent; color: #64748b; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">Maybe Later</button>
            
            <p style="text-align: center; font-size: 11px; color: #94a3b8; margin-top: 12px;">Secure payment powered by Stripe</p>
        </div>
    </div>

    <!-- Handicap Confirmation Dialog -->
    <div id="handicapConfirmDialog" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; border-radius: 16px; padding: 24px; margin: 20px; max-width: 400px; box-shadow: 0 8px 16px rgba(0,0,0,0.3);">
            <h3 style="color: #1e40af; margin-bottom: 12px; font-size: 20px;">Claim Player</h3>
            
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; color: #475569; font-weight: 600; font-size: 14px;">Player Name</label>
                <input type="text" id="claimPlayerNameInput" placeholder="Player Name" style="width: 100%; padding: 12px; border: 2px solid #10b981; border-radius: 8px; font-size: 16px; font-weight: 600; box-sizing: border-box;">
                <input type="hidden" id="claimPlayerOriginalName">
            </div>
            
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; color: #475569; font-weight: 600; font-size: 14px;">Your Initials</label>
                <input type="text" id="initialsInput" maxlength="3" placeholder="ABC" style="width: 100%; padding: 12px; border: 2px solid #3b82f6; border-radius: 8px; font-size: 18px; text-align: center; font-weight: 600; text-transform: uppercase; box-sizing: border-box;">
                <p style="font-size: 12px; color: #64748b; margin-top: 4px;">So the host knows who's scoring</p>
            </div>
            
            <!-- Tee Selection -->
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; color: #475569; font-weight: 600; font-size: 14px;">Playing From</label>
                <div id="claimTeeButtons" style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <!-- Tee buttons will be populated dynamically -->
                </div>
                <p id="claimTeeDefault" style="font-size: 11px; color: #64748b; margin-top: 4px;"></p>
            </div>
            
            <!-- Handicap Type Toggle -->
            <div style="margin-bottom: 12px;">
                <label style="display: block; margin-bottom: 8px; color: #475569; font-weight: 600; font-size: 14px;">Handicap Entry</label>
                <div style="display: flex; gap: 8px;">
                    <button type="button" id="hcpModeIndex" onclick="setClaimHcpMode('index')" style="flex: 1; padding: 10px; border-radius: 8px; font-size: 13px; font-weight: 600; cursor: pointer; border: 2px solid #3b82f6; background: #3b82f6; color: white;">
                        HCP Index
                    </button>
                    <button type="button" id="hcpModeCourse" onclick="setClaimHcpMode('course')" style="flex: 1; padding: 10px; border-radius: 8px; font-size: 13px; font-weight: 600; cursor: pointer; border: 2px solid #e2e8f0; background: white; color: #64748b;">
                        Course HCP
                    </button>
                </div>
            </div>
            
            <!-- Handicap Input -->
            <div style="margin-bottom: 16px;">
                <label id="handicapInputLabel" style="display: block; margin-bottom: 8px; color: #475569; font-weight: 600; font-size: 14px;">HCP Index</label>
                <input type="number" id="handicapConfirmInput" min="-10" max="54" step="0.1" placeholder="0" style="width: 100%; padding: 12px; border: 2px solid #3b82f6; border-radius: 8px; font-size: 18px; text-align: center; font-weight: 600; box-sizing: border-box;" oninput="updateClaimCourseHcp()">
                <p id="claimCalculatedHcp" style="font-size: 13px; color: #10b981; margin-top: 6px; font-weight: 600; text-align: center;"></p>
            </div>
            
            <div style="display: flex; gap: 12px;">
                <button type="button" id="handicapConfirmCancel" style="flex: 1; padding: 12px; background: #e2e8f0; color: #475569; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">Cancel</button>
                <button type="button" id="handicapConfirmOk" style="flex: 1; padding: 12px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">Claim & Score</button>
            </div>
        </div>
    </div>

    <!-- Claim Players List Modal -->
    <div id="claimPlayersModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center; overflow-y: auto;">
        <div style="background: white; border-radius: 16px; padding: 24px; margin: 20px; max-width: 500px; max-height: 80vh; overflow-y: auto; box-shadow: 0 8px 16px rgba(0,0,0,0.3);">
            <h3 style="color: #1e40af; margin-bottom: 16px; font-size: 20px;">Claim Additional Player</h3>
            <p style="color: #64748b; margin-bottom: 20px; font-size: 14px;">Select an unclaimed player to score for them</p>
            
            <div id="claimPlayersListContent">
                <!-- Player list will be populated here -->
            </div>
            
            <button type="button" onclick="document.getElementById('claimPlayersModal').style.display='none'" style="width: 100%; padding: 12px; background: #e2e8f0; color: #475569; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 16px;">
                Cancel
            </button>
        </div>
    </div>

    <!-- Manage Tournament Page (for host) -->
    <div id="playerManagementPage" class="page">
        <div style="padding: 16px; background: transparent;">
            <!-- Header with Title and Connection Status - WHITE BACKGROUND -->
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px; padding: 12px 16px; background: white; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <h2 style="color: #1e40af; font-size: 18px; margin: 0;">âï¸ Manage Tournament</h2>
                <div id="managementConnectionStatus" style="display: flex; align-items: center; gap: 4px; padding: 4px 10px; background: #f0fdf4; border: 1px solid #10b981; border-radius: 12px;">
                    <span style="width: 8px; height: 8px; border-radius: 50%; background: #10b981;"></span>
                    <span style="color: #059669; font-size: 11px; font-weight: 500;">Connected</span>
                </div>
            </div>
            
            <!-- Host/Player Toggle Row - ABOVE nav -->
            <div id="hostPlayerToggleRow" style="display: flex; justify-content: center; margin-bottom: 12px;">
                <div style="display: flex; background: white; border: 2px solid #f59e0b; border-radius: 10px; padding: 3px;">
                    <button type="button" id="toggleHostMode" onclick="setHostViewMode('host')" style="padding: 8px 20px; font-size: 13px; font-weight: 600; border-radius: 8px; border: none; background: #f59e0b; color: white; cursor: pointer;">ð Host</button>
                    <button type="button" id="togglePlayerMode" onclick="setHostViewMode('player')" style="padding: 8px 20px; font-size: 13px; font-weight: 600; border-radius: 8px; border: none; background: white; color: #92400e; cursor: pointer;">ð¤ Player</button>
                </div>
            </div>
            
            <!-- Navigation Row - NO BACKGROUND -->
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px; padding: 8px; background: transparent; border-radius: 10px; margin-bottom: 8px;">
                <button type="button" onclick="confirmBackToHome()" style="flex: 1; height: 44px; border-radius: 8px; border: none; background: #94a3b8; color: white; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Home">ð </button>
                <button type="button" onclick="copyActiveTournamentLink()" style="flex: 1; height: 44px; border-radius: 8px; border: 1.5px solid #3b82f6; background: #dbeafe; color: #3b82f6; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Copy Link">ð</button>
                <button type="button" onclick="showQRCodeForActiveTournament()" style="flex: 1; height: 44px; border-radius: 8px; border: 1.5px solid #8b5cf6; background: #ede9fe; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 6px;" title="Show QR">
                    <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="#8b5cf6" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7" rx="1"/>
                        <rect x="14" y="3" width="7" height="7" rx="1"/>
                        <rect x="3" y="14" width="7" height="7" rx="1"/>
                        <rect x="14" y="14" width="3" height="3"/>
                        <rect x="18" y="14" width="3" height="3"/>
                        <rect x="14" y="18" width="3" height="3"/>
                        <rect x="18" y="18" width="3" height="3"/>
                        <path d="M1 4V1h3M20 1h3v3M1 20v3h3M20 24h3v-3" stroke="#8b5cf6" stroke-width="2.5" stroke-linecap="round"/>
                    </svg>
                </button>
                <button type="button" onclick="saveTournamentFile()" style="flex: 1; height: 44px; border-radius: 8px; border: 1.5px solid #f97316; background: #ffedd5; color: #c2410c; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Save File">ð¾</button>
                <button type="button" onclick="showPage('scoringPage')" style="flex: 1; height: 44px; border-radius: 8px; border: 2px solid #10b981; background: #3b82f6; color: white; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Scoring">â³</button>
                <button type="button" onclick="showPage('resultsPage')" style="flex: 1; height: 44px; border-radius: 8px; border: 2px solid #d97706; background: #3b82f6; color: white; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Results">ð</button>
            </div>
            
            <!-- Reopen/Restart Buttons (for finished tournaments) -->
            <div id="finishedTournamentActions" style="display: none; background: #fef3c7; border: 2px solid #f59e0b; border-radius: 10px; padding: 12px; margin-bottom: 12px;">
                <div style="text-align: center; margin-bottom: 10px;">
                    <span style="background: #fef3c7; color: #92400e; font-size: 12px; font-weight: 700; padding: 4px 12px; border-radius: 10px; border: 1px solid #f59e0b;">ð TOURNAMENT FINISHED</span>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button type="button" onclick="reopenTournament()" style="flex: 1; padding: 12px; background: #10b981; color: white; border: none; border-radius: 8px; font-size: 13px; font-weight: 600; cursor: pointer;">
                        ð Reopen
                        <span style="display: block; font-size: 10px; font-weight: 400; opacity: 0.9;">All players can edit</span>
                    </button>
                    <button type="button" onclick="confirmRestartCurrentTournament()" style="flex: 1; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px; font-size: 13px; font-weight: 600; cursor: pointer;">
                        ð Restart
                        <span style="display: block; font-size: 10px; font-weight: 400; opacity: 0.9;">Clear all scores</span>
                    </button>
                </div>
            </div>
            
            <!-- SECTION 1: Co-hosts (Host only) -->
            <div id="coHostsSection" style="background: #faf5ff; border: 1px solid #c4b5fd; border-radius: 10px; padding: 10px; margin-bottom: 10px; display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <h3 style="color: #7c3aed; font-size: 12px; margin: 0;">ð Co-hosts</h3>
                    <span style="font-size: 10px; color: #8b5cf6;">Can manage tournament</span>
                </div>
                <div id="coHostsContent">
                    <!-- Co-hosts list generated dynamically -->
                </div>
            </div>
            
            <!-- SECTION 2: Players -->
            <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; padding: 10px; margin-bottom: 10px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <h3 style="color: #1e40af; font-size: 12px; margin: 0;">ð¥ Players</h3>
                    <button type="button" onclick="showAddPlayerForm()" style="padding: 4px 8px; background: #3b82f6; color: white; border: none; border-radius: 5px; font-size: 11px; font-weight: 600; cursor: pointer;">+ Add</button>
                </div>
                
                <!-- Add Player Form (hidden by default) -->
                <div id="addPlayerForm" style="display: none; background: #eff6ff; border: 1.5px solid #3b82f6; border-radius: 8px; padding: 10px; margin-bottom: 8px;">
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        <input type="text" id="newPlayerName" placeholder="Name" style="flex: 2; min-width: 80px; padding: 8px; border: 1.5px solid #cbd5e1; border-radius: 6px; font-size: 13px;">
                        <input type="number" id="newPlayerHandicap" placeholder="HCP" style="flex: 1; min-width: 45px; max-width: 60px; padding: 8px; border: 1.5px solid #cbd5e1; border-radius: 6px; font-size: 13px;" value="0">
                        <button type="button" onclick="addNewPlayerFromManagement()" style="padding: 8px 12px; background: #10b981; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">Add</button>
                        <button type="button" onclick="hideAddPlayerForm()" style="padding: 8px 10px; background: #e2e8f0; color: #64748b; border: none; border-radius: 6px; font-size: 13px; cursor: pointer;">â</button>
                    </div>
                </div>

                <div id="playerManagementContent">
                    <!-- Player list will be generated here -->
                </div>
            </div>
            
            <!-- SECTION 3: Tournament Details (moved up) -->
            <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; padding: 10px; margin-bottom: 10px;">
                <h3 style="color: #1e40af; font-size: 12px; margin: 0 0 8px 0;">ð Tournament Details</h3>
                
                <!-- Tournament Name + Host Code Button -->
                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <input type="text" id="manageTournamentName" placeholder="Tournament Name" style="flex: 1; padding: 8px; border: 1.5px solid #e2e8f0; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
                    <button type="button" id="hostCodeBtn" onclick="showHostCodeModal()" style="padding: 8px 12px; background: #f59e0b; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; white-space: nowrap; display: none;">
                        ð Host Code
                    </button>
                </div>
                
                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <input type="date" id="manageTournamentDate" style="flex: 1; padding: 8px; border: 1.5px solid #e2e8f0; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
                    <select id="manageTournamentCourse" onchange="updateManageTeeOptions()" style="flex: 1; padding: 8px; border: 1.5px solid #e2e8f0; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
                        <!-- Options populated dynamically -->
                    </select>
                </div>
                
                <!-- Tee Selection -->
                <div style="margin-bottom: 8px;">
                    <label style="font-size: 11px; color: #64748b; display: block; margin-bottom: 4px;">Playing Tees</label>
                    <div id="manageTeeButtons" style="display: flex; gap: 6px; flex-wrap: wrap;"></div>
                </div>
                
                <div style="display: flex; gap: 8px;">
                    <button type="button" onclick="saveTournamentDetails()" style="flex: 1; padding: 10px; background: #3b82f6; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">
                        ð¾ Save
                    </button>
                    <button type="button" onclick="confirmDeleteTournament()" style="flex: 1; padding: 10px; background: #dc2626; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">
                        ðï¸ Delete
                    </button>
                </div>
            </div>
            
            <!-- SECTION 4: Clear Scores (RED theme) -->
            <div style="background: #fef2f2; border: 1.5px solid #fca5a5; border-radius: 10px; padding: 10px; margin-bottom: 10px;">
                <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 6px;">
                    <h3 style="color: #dc2626; font-size: 12px; margin: 0;">ð Clear Scores</h3>
                    <div style="display: flex; gap: 4px;">
                        <button type="button" onclick="clearAllScores()" style="padding: 5px 8px; background: #dc2626; color: white; border: none; border-radius: 5px; font-size: 10px; font-weight: 600; cursor: pointer;">All 18</button>
                        <button type="button" onclick="clearFront9Scores()" style="padding: 5px 8px; background: white; color: #dc2626; border: 1.5px solid #dc2626; border-radius: 5px; font-size: 10px; font-weight: 600; cursor: pointer;">Front 9</button>
                        <button type="button" onclick="clearBack9Scores()" style="padding: 5px 8px; background: white; color: #dc2626; border: 1.5px solid #dc2626; border-radius: 5px; font-size: 10px; font-weight: 600; cursor: pointer;">Back 9</button>
                    </div>
                </div>
            </div>
            
            <!-- SECTION 5: Finish Tournament (HOST ONLY) -->
            <div id="finishTournamentSection" style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border: 2px solid #f59e0b; border-radius: 10px; padding: 12px; margin-bottom: 10px; display: none;">
                <h3 style="color: #92400e; font-size: 12px; margin: 0 0 8px 0;">ð Finish Tournament</h3>
                <p style="color: #92400e; font-size: 11px; margin: 0 0 10px 0; opacity: 0.8;">End the tournament for all players. Results will be saved and the tournament will be marked as complete.</p>
                <button type="button" onclick="confirmFinishTournament()" style="width: 100%; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <span style="font-size: 16px;">ð</span> Finish Tournament
                </button>
            </div>
        </div>
    </div>


    <!-- My Players Page (Non-Host) -->
    <div id="myPlayersPage" class="page">
        <div style="padding: 16px; background: transparent;">
            <!-- Header with Title, Notification Toggle, and Connection Status -->
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px; padding: 12px 16px; background: white; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <h2 style="color: #1e40af; font-size: 18px; margin: 0;">ð¤ My Players</h2>
                <button type="button" id="notificationToggleBtn" onclick="toggleWatchedNotifications()" style="padding: 6px 10px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer;" title="Notifications on - tap to mute">ð</button>
                <div id="myPlayersConnectionStatus" style="display: flex; align-items: center; gap: 4px; padding: 4px 10px; background: #f0fdf4; border: 1px solid #10b981; border-radius: 12px;">
                    <span style="width: 8px; height: 8px; border-radius: 50%; background: #10b981;"></span>
                    <span style="color: #059669; font-size: 11px; font-weight: 500;">Connected</span>
                </div>
            </div>
            
            <!-- Host/Player Toggle (only for host in player mode) - ABOVE nav row -->
            <div id="myPlayersHostToggle" style="display: none; justify-content: center; margin-bottom: 12px;">
                <div style="display: flex; background: white; border: 2px solid #f59e0b; border-radius: 10px; padding: 3px;">
                    <button type="button" id="myPlayersHostBtn" onclick="switchToHostMode()" style="padding: 8px 20px; font-size: 13px; font-weight: 600; border-radius: 8px; border: none; background: white; color: #92400e; cursor: pointer;">ð Host</button>
                    <button type="button" id="myPlayersPlayerBtn" style="padding: 8px 20px; font-size: 13px; font-weight: 600; border-radius: 8px; border: none; background: #f59e0b; color: white; cursor: pointer;">ð¤ Player</button>
                </div>
            </div>
            
            <!-- Navigation Row - NO BACKGROUND -->
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px; padding: 8px; background: transparent; border-radius: 10px; margin-bottom: 12px;">
                <button type="button" onclick="goToCorrectHomePage()" style="flex: 1; height: 44px; border-radius: 8px; border: none; background: #94a3b8; color: white; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Home">ð </button>
                <button type="button" onclick="copyActiveTournamentLink()" style="flex: 1; height: 44px; border-radius: 8px; border: 1.5px solid #3b82f6; background: #dbeafe; color: #3b82f6; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Copy Link">ð</button>
                <button type="button" onclick="showQRCodeForActiveTournament()" style="flex: 1; height: 44px; border-radius: 8px; border: 1.5px solid #8b5cf6; background: #ede9fe; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 6px;" title="Show QR">
                    <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="#8b5cf6" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7" rx="1"/>
                        <rect x="14" y="3" width="7" height="7" rx="1"/>
                        <rect x="3" y="14" width="7" height="7" rx="1"/>
                        <rect x="14" y="14" width="3" height="3"/>
                        <rect x="18" y="14" width="3" height="3"/>
                        <rect x="14" y="18" width="3" height="3"/>
                        <rect x="18" y="18" width="3" height="3"/>
                        <path d="M1 4V1h3M20 1h3v3M1 20v3h3M20 24h3v-3" stroke="#8b5cf6" stroke-width="2.5" stroke-linecap="round"/>
                    </svg>
                </button>
                <button type="button" onclick="showPage('scoringPage')" style="flex: 1; height: 44px; border-radius: 8px; border: 2px solid #10b981; background: #3b82f6; color: white; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Scoring">â³</button>
                <button type="button" onclick="showPage('resultsPage')" style="flex: 1; height: 44px; border-radius: 8px; border: 2px solid #d97706; background: #3b82f6; color: white; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;" title="Results">ð</button>
            </div>
            
            <!-- My Players Content -->
            <div id="myPlayersPageContent">
                <!-- Dynamic content here -->
            </div>
        </div>
    </div>

    <!-- Guest Home Page (Non-Host) -->
    <div id="guestHomePage" class="page">
        <div class="card" style="padding: 20px; text-align: center; position: relative; flex: 1; display: flex; flex-direction: column; justify-content: center;">
            <!-- Subscription Badge - Top Right (for logged in users) -->
            <div id="guestSubscriptionBadge" style="display: none; position: absolute; top: 12px; right: 12px; z-index: 10;">
                <span id="guestSubscriptionBadgeText" style="display: inline-block; padding: 6px 12px; background: #10b981; color: white; border-radius: 20px; font-size: 11px; font-weight: 600;">â Season Pass</span>
            </div>
            
            <!-- Logo -->
            <div style="margin-bottom: 6px;">
                <span style="font-size: 40px;">â³</span>
                <h1 style="color: #1e40af; font-size: 22px; margin: 4px 0 2px 0;">Let's Golf</h1>
                <p style="color: #64748b; font-size: 11px; margin: 0;">by Otis Williams</p>
            </div>
            
            <!-- Connection Status with Username (clickable to open profile) -->
            <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 12px;">
                <button onclick="showAccountModal()" id="guestHomeConnectionStatus" style="display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; background: #f0fdf4; border: 1px solid #10b981; border-radius: 20px; cursor: pointer;">
                    <span style="width: 8px; height: 8px; border-radius: 50%; background: #10b981;"></span>
                    <span style="color: #059669; font-size: 12px; font-weight: 500;">Connected as: <span id="guestDeviceInitials">--</span></span>
                    <span style="font-size: 11px;">âï¸</span>
                </button>
            </div>
            
            <!-- Enter Tournament Button (green scheme) - shown when NOT joined -->
            <div id="enterTournamentCard" style="background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%); border: 2px solid #10b981; border-radius: 12px; padding: 14px; margin-bottom: 12px;">
                <button type="button" id="guestEnterBtn" onclick="handleEnterTournament()" style="width: 100%; padding: 12px; background: #10b981; color: white; border: 2px solid white; border-radius: 10px; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <span style="font-size: 16px;">ðª</span> Enter Tournament
                </button>
            </div>
            
            <!-- Current Tournament Card - Light Blue theme for active -->
            <div id="guestCurrentTournament" style="background: #eff6ff; border: 2px solid #3b82f6; border-radius: 12px; padding: 14px; margin-bottom: 12px; box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);">
                <div id="guestTournamentTitle" style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 8px;">
                    <span style="font-weight: 700; color: #1e40af; font-size: 14px;">â³ Current Tournament</span>
                    <span id="guestRoleBadge" style="background: #dbeafe; color: #1e40af; font-size: 10px; font-weight: 700; padding: 2px 8px; border-radius: 10px; border: 1.5px solid #3b82f6;">ð¤ PLAYER</span>
                </div>
                <h3 id="guestTournamentName" style="color: #1e40af; font-size: 16px; margin: 0 0 4px 0;">Loading...</h3>
                <p id="guestTournamentInfo" style="color: #64748b; font-size: 12px; margin: 0 0 4px 0;"></p>
                <!-- Host identifier -->
                <p id="guestHostInfo" style="color: #64748b; font-size: 11px; margin: 0 0 12px 0; font-style: italic;">Hosted by: <span id="guestHostName">--</span></p>
                
                <!-- Active Tournament Buttons (shown when joined) - 2x2 Grid -->
                <div id="guestActiveButtons" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- Row 1: Resume Scoring | View Results -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button type="button" onclick="guestResumeScoring()" style="padding: 16px 8px; background: #3b82f6; color: white; border: none; border-radius: 10px; font-size: 13px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <span style="font-size: 20px;">â³</span>
                            <span>Resume<br>Scoring</span>
                        </button>
                        <button type="button" onclick="guestViewResults()" style="padding: 16px 8px; background: #3b82f6; color: white; border: none; border-radius: 10px; font-size: 13px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <span style="font-size: 20px;">ð</span>
                            <span>View<br>Results</span>
                        </button>
                    </div>
                    <!-- Row 2: Manage Tournament | My Players -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button type="button" id="guestHomeManageBtn" onclick="showPlayerManagement()" style="padding: 16px 8px; background: #f59e0b; color: white; border: none; border-radius: 10px; font-size: 13px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <span id="guestHomeManageBtnIcon" style="font-size: 20px;">âï¸</span>
                            <span id="guestHomeManageBtnText">Manage<br>Tournament</span>
                        </button>
                        <button type="button" onclick="showMyPlayersPage()" style="padding: 16px 8px; background: #f59e0b; color: white; border: none; border-radius: 10px; font-size: 13px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <span style="font-size: 20px;">ð¤</span>
                            <span>My<br>Players</span>
                        </button>
                    </div>
                    <!-- Row 3: Leave Tournament (full width, smaller) -->
                    <button type="button" id="guestLeaveBtn" onclick="confirmLeaveTournament()" style="width: 100%; padding: 10px; background: white; color: #64748b; border: 1.5px solid #cbd5e1; border-radius: 10px; font-size: 12px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;">
                        <span style="font-size: 14px;">ðª</span> Leave Tournament
                    </button>
                </div>
                
                <!-- Last Tournament Buttons (hidden by default, shown after leaving) -->
                <div id="guestLastTournamentButtons" style="display: none; flex-direction: column; gap: 6px;">
                    <button type="button" onclick="showPage('resultsPage')" style="width: 100%; padding: 12px; background: #3b82f6; color: white; border: 2px solid #d97706; border-radius: 10px; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <span style="font-size: 16px;">ð</span> View Results
                    </button>
                    <button type="button" onclick="deleteLastTournament()" style="width: 100%; padding: 12px; background: white; color: #ef4444; border: 2px solid #ef4444; border-radius: 10px; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <span style="font-size: 16px;">ðï¸</span> Delete Tournament
                    </button>
                </div>
            </div>
            
            <!-- Load Tournament Card - Subtle gray for secondary actions -->
            <div id="loadTournamentCard" style="background: #f8fafc; border: 1.5px solid #cbd5e1; border-radius: 12px; padding: 12px;">
                <h4 style="color: #64748b; font-size: 11px; font-weight: 700; margin: 0 0 10px 0; text-transform: uppercase; letter-spacing: 0.5px; text-align: center;">ð Load Tournament</h4>
                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- Row 1: New Tournament | Recent Tournaments -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button type="button" onclick="startNewTournament()" style="padding: 14px 8px; background: #10b981; color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <span style="font-size: 18px;">â</span>
                            <span>New<br>Tournament</span>
                        </button>
                        <button type="button" onclick="showTournamentHistoryModal()" style="padding: 14px 8px; background: #64748b; color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <span style="font-size: 18px;">ð</span>
                            <span>Recent<br>Tournaments</span>
                        </button>
                    </div>
                    <!-- Row 2: Download | Upload -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button type="button" onclick="downloadTournamentFile()" style="padding: 14px 8px; background: #6366f1; color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <span style="font-size: 18px;">ð¥</span>
                            <span>Download<br>Tournament</span>
                        </button>
                        <button type="button" onclick="uploadTournamentFile()" style="padding: 14px 8px; background: #8b5cf6; color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <span style="font-size: 18px;">ð¤</span>
                            <span>Upload<br>Tournament</span>
                        </button>
                    </div>
                </div>
                <p id="historyCount" style="color: #94a3b8; font-size: 10px; margin-top: 8px; text-align: center;"></p>
            </div>
        </div>
    </div>

    <!-- Host Home Page -->
    <div id="hostHomePage" class="page">
        <div class="card" style="padding: 20px; text-align: center; position: relative; flex: 1; display: flex; flex-direction: column; justify-content: center;">
            <!-- Subscription/Owner Badge - Top Right -->
            <div id="subscriptionBadge" style="display: none; position: absolute; top: 12px; right: 12px; z-index: 10;">
                <span id="subscriptionBadgeText" style="display: inline-block; padding: 6px 12px; background: #10b981; color: white; border-radius: 20px; font-size: 11px; font-weight: 600;">â Season Pass</span>
            </div>
            
            <!-- Logo -->
            <div style="margin-bottom: 6px;">
                <span style="font-size: 40px;">â³</span>
                <h1 style="color: #1e40af; font-size: 22px; margin: 4px 0 2px 0;">Let's Golf</h1>
                <p style="color: #64748b; font-size: 11px; margin: 0;">by Otis Williams</p>
            </div>
            
            <!-- Connection Status with Username (clickable to open profile) -->
            <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 12px;">
                <button onclick="showAccountModal()" id="hostHomeConnectionStatus" style="display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; background: #f0fdf4; border: 1px solid #10b981; border-radius: 20px; cursor: pointer;">
                    <span style="width: 8px; height: 8px; border-radius: 50%; background: #10b981;"></span>
                    <span style="color: #059669; font-size: 12px; font-weight: 500;">Connected as: <span id="hostDeviceInitials">--</span></span>
                    <span style="font-size: 11px;">âï¸</span>
                </button>
            </div>
            
            <!-- Current Tournament Card with Role Badge - Light Blue theme -->
            <div id="hostCurrentTournament" style="background: #eff6ff; border: 2px solid #3b82f6; border-radius: 12px; padding: 14px; margin-bottom: 12px; box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);">
                <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 8px;">
                    <span style="font-weight: 700; color: #1e40af; font-size: 14px;">â³ Current Tournament</span>
                    <span id="hostTournamentBadge" style="background: white; color: #f97316; font-size: 10px; font-weight: 700; padding: 2px 8px; border-radius: 10px; border: 1.5px solid #f97316;">ð HOST</span>
                </div>
                <h3 id="hostTournamentName" style="color: #1e40af; font-size: 16px; margin: 0 0 4px 0;">Loading...</h3>
                <p id="hostTournamentInfo" style="color: #64748b; font-size: 12px; margin: 0 0 4px 0;"></p>
                <!-- Host identifier (shown for non-hosts) -->
                <p id="hostPageHostInfo" style="color: #64748b; font-size: 11px; margin: 0 0 12px 0; font-style: italic; display: none;">Hosted by: <span id="hostPageHostName">--</span></p>
                
                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- Row 1: Resume Scoring | View Results -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button type="button" onclick="showPage('scoringPage')" style="padding: 16px 8px; background: #3b82f6; color: white; border: none; border-radius: 10px; font-size: 13px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <span style="font-size: 20px;">â³</span>
                            <span>Resume<br>Scoring</span>
                        </button>
                        <button type="button" onclick="showPage('resultsPage')" style="padding: 16px 8px; background: #3b82f6; color: white; border: none; border-radius: 10px; font-size: 13px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <span style="font-size: 20px;">ð</span>
                            <span>View<br>Results</span>
                        </button>
                    </div>
                    <!-- Row 2: Manage Tournament | My Players -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button type="button" id="hostHomeManageBtn" onclick="showPlayerManagement()" style="padding: 16px 8px; background: #f59e0b; color: white; border: none; border-radius: 10px; font-size: 13px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <span id="hostHomeManageBtnIcon" style="font-size: 20px;">âï¸</span>
                            <span id="hostHomeManageBtnText">Manage<br>Tournament</span>
                        </button>
                        <button type="button" onclick="showMyPlayersPage()" style="padding: 16px 8px; background: #f59e0b; color: white; border: none; border-radius: 10px; font-size: 13px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <span style="font-size: 20px;">ð¤</span>
                            <span>My<br>Players</span>
                        </button>
                    </div>
                    <!-- Row 3: Leave Tournament (full width, smaller) -->
                    <button type="button" onclick="confirmLeaveTournament()" style="width: 100%; padding: 10px; background: white; color: #64748b; border: 1.5px solid #cbd5e1; border-radius: 10px; font-size: 12px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;">
                        <span style="font-size: 14px;">ðª</span> Leave Tournament
                    </button>
                </div>
            </div>
            
            <!-- Load Tournament Card - Subtle gray for secondary actions -->
            <div id="hostLoadNewCard" style="background: #f8fafc; border: 1.5px solid #cbd5e1; border-radius: 12px; padding: 12px;">
                <h4 style="color: #64748b; font-size: 11px; font-weight: 700; margin: 0 0 10px 0; text-transform: uppercase; letter-spacing: 0.5px; text-align: center;">ð Load Tournament</h4>
                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- Row 1: New Tournament | Recent Tournaments -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button type="button" onclick="startNewTournament()" style="padding: 14px 8px; background: #10b981; color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <span style="font-size: 18px;">â</span>
                            <span>New<br>Tournament</span>
                        </button>
                        <button type="button" onclick="showTournamentHistoryModal()" style="padding: 14px 8px; background: #64748b; color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <span style="font-size: 18px;">ð</span>
                            <span>Recent<br>Tournaments</span>
                        </button>
                    </div>
                    <!-- Row 2: Download | Upload -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button type="button" onclick="downloadTournamentFile()" style="padding: 14px 8px; background: #6366f1; color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <span style="font-size: 18px;">ð¥</span>
                            <span>Download<br>Tournament</span>
                        </button>
                        <button type="button" onclick="uploadTournamentFile()" style="padding: 14px 8px; background: #8b5cf6; color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <span style="font-size: 18px;">ð¤</span>
                            <span>Upload<br>Tournament</span>
                        </button>
                    </div>
                </div>
                <p id="hostHistoryCount" style="color: #94a3b8; font-size: 10px; margin-top: 8px; text-align: center;"></p>
            </div>
        </div>
    </div>

    <!-- Live Leaderboard Page (for spectators) -->
    <div id="liveLeaderboardPage" class="page">
        <div class="card">
            <div class="tournament-info-centered">
                <p style="font-size: 32px;">ð</p>
                <h2>Live Leaderboard</h2>
                <p id="liveLeaderboardInfo"></p>
            </div>

            <!-- Game Toggle Tabs -->
            <div id="gameToggleTabs" style="display: flex; gap: 4px; margin: 20px 0; overflow-x: auto; -webkit-overflow-scrolling: touch; flex-wrap: nowrap; justify-content: flex-end;">
                <!-- Tabs will be generated dynamically -->
            </div>

            <div id="liveLeaderboardContent" style="margin-top: 16px;">
                <!-- Leaderboard will be generated here -->
            </div>

            <div style="margin-top: 20px; padding: 16px; background: rgba(255,255,255,0.1); border-radius: 12px; text-align: center;">
                <p style="color: #64748b; font-size: 14px; margin-bottom: 8px;">
                    <span id="lastUpdateTime">Just now</span> â¢ <span id="activePlayersCount">0</span> players
                </p>
                <label style="display: flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="autoRefreshToggle" checked style="width: 20px; height: 20px;">
                    <span style="color: white; font-size: 14px;">Auto-refresh</span>
                </label>
            </div>

            <button type="button" id="leaderboardActionBtn" class="btn-primary" onclick="handleLeaderboardAction()" style="width: 100%; margin-top: 16px; padding: 16px; font-size: 16px; font-weight: 700; background: linear-gradient(135deg, #10b981, #059669); border: none; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);">
                Start Scoring â³
            </button>
        </div>
    </div>

    <!-- Host Dashboard Page -->
    <div id="hostDashboardPage" class="page">
        <div class="card">
            <div class="tournament-info-centered">
                <p style="font-size: 32px;">ð®</p>
                <h2>Tournament Admin</h2>
                <p id="hostDashboardInfo"></p>
            </div>

            <div style="margin-top: 24px;">
                <h3 style="color: #1e40af; margin-bottom: 12px; font-size: 18px;">Players & Devices</h3>
                <div id="playerDeviceList">
                    <!-- Will be populated dynamically -->
                </div>
            </div>

            <div style="margin-top: 24px;">
                <h3 style="color: #1e40af; margin-bottom: 12px; font-size: 18px;">Tournament Controls</h3>
                <button type="button" class="btn-secondary" onclick="addPlayerManually()" style="width: 100%; margin-bottom: 8px;">
                    â Add Player Manually
                </button>
                <button type="button" class="btn-secondary" onclick="lockTournament(activeTournamentId)" style="width: 100%; margin-bottom: 8px;">
                    ð Lock Tournament (No More Joins)
                </button>
                <button type="button" class="btn-primary" onclick="endTournament(activeTournamentId)" style="width: 100%; margin-bottom: 8px; background: #ef4444;">
                    ð End Tournament
                </button>
            </div>

            <button type="button" class="btn-secondary" onclick="showPage('scoringPage')" style="width: 100%; margin-top: 16px;">
                Back to Scoring
            </button>
        </div>
    </div>

    <!-- Custom Confirmation Dialog (iOS-friendly) -->
    <div id="confirmDialog" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10100; align-items: center; justify-content: center;">
        <div style="background: white; border-radius: 16px; padding: 24px; margin: 20px; max-width: 400px; box-shadow: 0 8px 16px rgba(0,0,0,0.3);">
            <h3 id="confirmTitle" style="color: #1e40af; margin-bottom: 12px; font-size: 20px;">Confirm Action</h3>
            <p id="confirmMessage" style="color: #64748b; margin-bottom: 24px; font-size: 16px; line-height: 1.5;"></p>
            <div style="display: flex; gap: 12px;">
                <button type="button" id="confirmCancel" style="flex: 1; padding: 12px; background: #e2e8f0; color: #475569; border: none; border-radius: 8px; font-size: 16px; font-weight: 600;">Cancel</button>
                <button type="button" id="confirmOk" style="flex: 1; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600;">Confirm</button>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // FIREBASE CONFIGURATION & INITIALIZATION
        // ========================================
        
        // Wait for Firebase scripts to load
        function initializeFirebase() {
            if (typeof firebase === 'undefined') {
                console.error('â ï¸ Firebase scripts not loaded! Retrying...');
                setTimeout(initializeFirebase, 500);
                return;
            }
            
            console.log('â Firebase scripts loaded successfully!');
            
            const firebaseConfig = {
                apiKey: "AIzaSyDXgnAjWT0Csd0gu9D6JUbghz149hLhb90",
                authDomain: "u-lik-golf.firebaseapp.com",
                projectId: "u-lik-golf",
                storageBucket: "u-lik-golf.firebasestorage.app",
                messagingSenderId: "637984857306",
                appId: "1:637984857306:web:7d7ff315a360c3544b59e3"
            };

            // Initialize Firebase
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
            auth = firebase.auth();
            firebaseReady = true; // Mark Firebase as ready
            
            console.log('â Firebase initialized!');
            console.log('   firebaseReady:', firebaseReady);
            
            // Enable offline persistence
            db.enablePersistence({synchronizeTabs: true})
                .catch((err) => {
                    if (err.code == 'failed-precondition') {
                        console.warn('Multiple tabs open, persistence only in one tab');
                    } else if (err.code == 'unimplemented') {
                        console.warn('Browser doesn\'t support persistence');
                    }
                });

            // Skip Firebase Auth - use direct Firestore with local IDs instead
            // This avoids the auth/configuration-not-found error on iOS
            console.log('ð Setting up device authentication (no Firebase Auth required)...');
            
            // Generate persistent user ID (stored in localStorage)
            if (!localStorage.getItem('persistentUserId')) {
                localStorage.setItem('persistentUserId', 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
            }
            currentUserId = localStorage.getItem('persistentUserId');
            
            // Generate persistent device ID (stored in localStorage)
            if (!localStorage.getItem('deviceId')) {
                localStorage.setItem('deviceId', 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
            }
            currentDeviceId = localStorage.getItem('deviceId');
            
            // Initialize device name and initials from localStorage
            deviceName = localStorage.getItem('deviceName') || 'My Device';
            deviceInitials = localStorage.getItem('deviceInitials') || 'MD';
            
            authCompleted = true;
            console.log('â Device authenticated successfully (no Firebase Auth needed)!');
            console.log('   User ID:', currentUserId);
            console.log('   Device ID:', currentDeviceId);
            console.log('   Device Name:', deviceName);
            
            // Set up Firebase Auth state listener
            auth.onAuthStateChanged(async (user) => {
                console.log('ð Auth state changed:', user ? user.email : 'signed out');
                currentAuthUser = user;
                if (user) {
                    await loadUserSubscription(user.uid);
                } else {
                    userSubscription = { status: 'free', expiresAt: null, email: null };
                }
                updateAccountUI();
            });
        }
        
        // ===== SUBSCRIPTION SYSTEM =====
        
        // Load user subscription from Firestore
        async function loadUserSubscription(userId) {
            try {
                const userDoc = await db.collection('users').doc(userId).get();
                if (userDoc.exists) {
                    const data = userDoc.data();
                    userSubscription = {
                        status: data.subscriptionStatus || 'free',
                        expiresAt: data.subscriptionExpiresAt ? data.subscriptionExpiresAt.toDate() : null,
                        email: data.email
                    };
                    
                    // Check if subscription has expired
                    if (userSubscription.expiresAt && userSubscription.expiresAt < new Date()) {
                        userSubscription.status = 'free';
                        // Update in Firestore
                        await db.collection('users').doc(userId).update({
                            subscriptionStatus: 'free'
                        });
                    }
                } else {
                    // Create user document if it doesn't exist
                    await db.collection('users').doc(userId).set({
                        email: currentAuthUser.email,
                        subscriptionStatus: 'free',
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    userSubscription = { status: 'free', expiresAt: null, email: currentAuthUser.email };
                }
                console.log('ð Subscription loaded:', userSubscription);
            } catch (error) {
                console.error('Error loading subscription:', error);
                userSubscription = { status: 'free', expiresAt: null, email: null };
            }
        }
        
        // Check if user has active subscription
        function hasActiveSubscription() {
            // Developer/owner bypass - always has Pro access
            const ownerEmails = ['odub1281@gmail.com']; // Add your email(s) here
            if (currentAuthUser && ownerEmails.includes(currentAuthUser.email.toLowerCase())) {
                console.log('ð Owner bypass active for:', currentAuthUser.email);
                return true;
            }
            
            if (userSubscription.status === 'free') return false;
            if (!userSubscription.expiresAt) return false;
            return userSubscription.expiresAt > new Date();
        }
        
        // Check if action is allowed (player count, cloud features)
        function canAddMorePlayers(currentCount) {
            if (hasActiveSubscription()) return true;
            return currentCount < FREE_PLAYER_LIMIT;  // Can add if under 4 (allows up to 4 total)
        }
        
        function canUseCloudFeatures() {
            return hasActiveSubscription();
        }
        
        // Gate check - show paywall if needed
        function requireSubscription(reason) {
            if (hasActiveSubscription()) return true;
            showPaywall(reason);
            return false;
        }
        
        // Update Account UI based on auth state
        function updateAccountUI() {
            const badge = document.getElementById('subscriptionBadge');
            const badgeText = document.getElementById('subscriptionBadgeText');
            const guestBadge = document.getElementById('guestSubscriptionBadge');
            const guestBadgeText = document.getElementById('guestSubscriptionBadgeText');
            
            if (currentAuthUser) {
                // Use displayName (username) if set, otherwise fall back to email prefix
                const displayName = currentAuthUser.displayName || currentAuthUser.email.split('@')[0];
                
                // Update "Connected as" displays with username
                updateConnectedAsDisplays(displayName);
                
                // Check if owner
                const ownerEmails = ['odub1281@gmail.com'];
                const isOwner = ownerEmails.includes(currentAuthUser.email.toLowerCase());
                
                // Determine badge content
                let badgeContent = '';
                let badgeStyle = {};
                
                if (isOwner) {
                    badgeContent = 'ð Owner';
                    badgeStyle = {
                        background: '#ede9fe',
                        color: '#5b21b6',
                        border: '2px solid #7c3aed'
                    };
                } else if (hasActiveSubscription()) {
                    const plan = PLAN_PRICES[userSubscription.status];
                    badgeContent = `â ${plan ? plan.label : 'Pro'}`;
                    badgeStyle = {
                        background: '#10b981',
                        color: 'white',
                        border: 'none'
                    };
                }
                
                // Apply to host badge
                if (badge && badgeText) {
                    if (badgeContent) {
                        badge.style.display = 'block';
                        badgeText.textContent = badgeContent;
                        badgeText.style.background = badgeStyle.background;
                        badgeText.style.color = badgeStyle.color;
                        badgeText.style.border = badgeStyle.border;
                    } else {
                        badge.style.display = 'none';
                    }
                }
                
                // Apply to guest badge
                if (guestBadge && guestBadgeText) {
                    if (badgeContent) {
                        guestBadge.style.display = 'block';
                        guestBadgeText.textContent = badgeContent;
                        guestBadgeText.style.background = badgeStyle.background;
                        guestBadgeText.style.color = badgeStyle.color;
                        guestBadgeText.style.border = badgeStyle.border;
                    } else {
                        guestBadge.style.display = 'none';
                    }
                }
            } else {
                // Not logged in - hide badges, show device initials
                if (badge) badge.style.display = 'none';
                if (guestBadge) guestBadge.style.display = 'none';
                updateConnectedAsDisplays(deviceInitials || 'Guest');
            }
        }
        
        // Update all "Connected as" displays with username
        function updateConnectedAsDisplays(username) {
            const hostInitials = document.getElementById('hostDeviceInitials');
            const guestInitials = document.getElementById('guestDeviceInitials');
            
            if (hostInitials) hostInitials.textContent = username;
            if (guestInitials) guestInitials.textContent = username;
        }
        
        // Show/hide account modal
        function showAccountModal() {
            const modal = document.getElementById('accountModal');
            const loggedOut = document.getElementById('accountLoggedOut');
            const loggedIn = document.getElementById('accountLoggedIn');
            const emailEl = document.getElementById('accountEmail');
            const usernameEl = document.getElementById('accountUsername');
            const statusEl = document.getElementById('subscriptionStatus');
            const expiryEl = document.getElementById('subscriptionExpiry');
            const upgradeBtn = document.getElementById('upgradeBtn');
            const verifiedBadge = document.getElementById('emailVerifiedBadge');
            const verifyPrompt = document.getElementById('verifyEmailPrompt');
            
            // Hide all edit forms
            hideChangeEmailForm();
            hideChangePasswordForm();
            hideChangeUsernameForm();
            hideDeleteAccountConfirm();
            
            if (currentAuthUser) {
                loggedOut.style.display = 'none';
                loggedIn.style.display = 'block';
                emailEl.textContent = currentAuthUser.email;
                
                // Show username (from displayName or generate from email)
                const username = currentAuthUser.displayName || currentAuthUser.email.split('@')[0];
                usernameEl.textContent = username;
                
                // Show email verification status
                if (currentAuthUser.emailVerified) {
                    verifiedBadge.textContent = 'â Verified';
                    verifiedBadge.style.background = '#dcfce7';
                    verifiedBadge.style.color = '#166534';
                    verifiedBadge.style.display = 'inline-block';
                    verifyPrompt.style.display = 'none';
                } else {
                    verifiedBadge.textContent = 'Not verified';
                    verifiedBadge.style.background = '#fef3c7';
                    verifiedBadge.style.color = '#92400e';
                    verifiedBadge.style.display = 'inline-block';
                    verifyPrompt.style.display = 'block';
                }
                
                // Check if owner
                const ownerEmails = ['odub1281@gmail.com'];
                const isOwner = ownerEmails.includes(currentAuthUser.email.toLowerCase());
                
                if (isOwner) {
                    statusEl.textContent = 'ð Owner';
                    statusEl.style.color = '#7c3aed';
                    expiryEl.textContent = 'Unlimited access forever';
                    upgradeBtn.style.display = 'none';
                } else if (hasActiveSubscription()) {
                    const plan = PLAN_PRICES[userSubscription.status];
                    statusEl.textContent = plan ? plan.label : 'Pro';
                    statusEl.style.color = '#10b981';
                    const expiry = userSubscription.expiresAt;
                    expiryEl.textContent = `Expires: ${expiry.toLocaleDateString()}`;
                    upgradeBtn.style.display = 'none';
                } else {
                    statusEl.textContent = 'Free Plan';
                    statusEl.style.color = '#64748b';
                    expiryEl.textContent = '4 players max, single device';
                    upgradeBtn.style.display = 'block';
                }
            } else {
                loggedOut.style.display = 'block';
                loggedIn.style.display = 'none';
                // Clear form
                document.getElementById('authEmail').value = '';
                document.getElementById('authPassword').value = '';
                document.getElementById('authError').style.display = 'none';
            }
            
            modal.style.display = 'flex';
        }
        
        function hideAccountModal() {
            document.getElementById('accountModal').style.display = 'none';
        }
        
        // Auth functions
        async function signInUser() {
            const email = document.getElementById('authEmail').value.trim();
            const password = document.getElementById('authPassword').value;
            const errorEl = document.getElementById('authError');
            
            if (!email || !password) {
                errorEl.textContent = 'Please enter email and password';
                errorEl.style.display = 'block';
                return;
            }
            
            try {
                errorEl.style.display = 'none';
                await auth.signInWithEmailAndPassword(email, password);
                hideAccountModal();
                showNotification('Welcome Back!', 'Signed in successfully');
            } catch (error) {
                console.error('Sign in error:', error);
                errorEl.textContent = getAuthErrorMessage(error.code);
                errorEl.style.display = 'block';
            }
        }
        
        async function registerUser() {
            const email = document.getElementById('authEmail').value.trim();
            const password = document.getElementById('authPassword').value;
            const errorEl = document.getElementById('authError');
            
            if (!email || !password) {
                errorEl.textContent = 'Please enter email and password';
                errorEl.style.display = 'block';
                return;
            }
            
            if (password.length < 6) {
                errorEl.textContent = 'Password must be at least 6 characters';
                errorEl.style.display = 'block';
                return;
            }
            
            // Check if auth is available
            if (!auth) {
                errorEl.textContent = 'Authentication not ready. Please refresh and try again.';
                errorEl.style.display = 'block';
                console.error('Firebase auth not initialized');
                return;
            }
            
            try {
                errorEl.style.display = 'none';
                console.log('Creating account for:', email);
                const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                console.log('Account created successfully:', userCredential.user.uid);
                hideAccountModal();
                showNotification('Account Created!', 'Welcome to Let\'s Golf');
            } catch (error) {
                console.error('Register error:', error.code, error.message);
                errorEl.textContent = getAuthErrorMessage(error.code);
                errorEl.style.display = 'block';
            }
        }
        
        async function signOutUser() {
            try {
                await auth.signOut();
                hideAccountModal();
                showNotification('Signed Out', 'See you next time!');
            } catch (error) {
                console.error('Sign out error:', error);
            }
        }
        
        async function sendPasswordReset() {
            const email = document.getElementById('authEmail').value.trim();
            const errorEl = document.getElementById('authError');
            
            if (!email) {
                errorEl.textContent = 'Please enter your email first';
                errorEl.style.display = 'block';
                return;
            }
            
            try {
                await auth.sendPasswordResetEmail(email);
                errorEl.textContent = 'Password reset email sent!';
                errorEl.style.color = '#10b981';
                errorEl.style.display = 'block';
            } catch (error) {
                errorEl.textContent = getAuthErrorMessage(error.code);
                errorEl.style.color = '#ef4444';
                errorEl.style.display = 'block';
            }
        }
        
        function getAuthErrorMessage(code) {
            const messages = {
                'auth/email-already-in-use': 'Email already in use. Try signing in.',
                'auth/invalid-email': 'Invalid email address',
                'auth/user-not-found': 'No account found with this email',
                'auth/wrong-password': 'Incorrect password',
                'auth/weak-password': 'Password must be at least 6 characters',
                'auth/too-many-requests': 'Too many attempts. Try again later.',
                'auth/network-request-failed': 'Network error. Check your connection.',
                'auth/operation-not-allowed': 'Email/password sign-in not enabled. Contact support.',
                'auth/configuration-not-found': 'Auth not configured. Enable Email/Password in Firebase Console.',
                'auth/invalid-api-key': 'Invalid API key. Contact support.',
                'auth/app-deleted': 'App was deleted. Please refresh.',
                'auth/invalid-credential': 'Invalid email or password'
            };
            return messages[code] || `Error: ${code || 'Unknown'}. Please try again.`;
        }
        
        // Paywall functions
        function showPaywall(reason) {
            const modal = document.getElementById('paywallModal');
            const reasonEl = document.getElementById('paywallReason');
            
            if (reason) {
                reasonEl.textContent = reason;
            } else {
                reasonEl.textContent = 'Unlock multi-device scoring and unlimited players';
            }
            
            // Default to week plan
            selectPlan('week');
            modal.style.display = 'flex';
        }
        
        function hidePaywall() {
            document.getElementById('paywallModal').style.display = 'none';
        }
        
        function selectPlan(plan) {
            selectedPlan = plan;
            const price = PLAN_PRICES[plan].price;
            
            // Update button
            document.getElementById('purchaseBtn').textContent = `Continue - $${price.toFixed(2)}`;
            
            // Plan colors
            const planColors = {
                day: { border: '#10b981', fill: '#f0fdf4', text: '#10b981' },
                week: { border: '#3b82f6', fill: '#eff6ff', text: '#3b82f6' },
                season: { border: '#f59e0b', fill: '#fffbeb', text: '#f59e0b' }
            };
            
            // Update visual selection
            ['day', 'week', 'season'].forEach(p => {
                const btn = document.getElementById('plan' + p.charAt(0).toUpperCase() + p.slice(1));
                const colors = planColors[p];
                
                if (p === plan) {
                    // Selected - colored fill and thick border
                    btn.style.background = colors.fill;
                    btn.style.borderColor = colors.border;
                    btn.style.borderWidth = '3px';
                } else {
                    // Unselected - white fill, normal border
                    btn.style.background = 'white';
                    btn.style.borderColor = colors.border;
                    btn.style.borderWidth = '2px';
                }
            });
        }
        
        async function processPurchase() {
            // Check if user is logged in
            if (!currentAuthUser) {
                hidePaywall();
                showAccountModal();
                showNotification('Sign In Required', 'Please create an account or sign in to purchase');
                return;
            }
            
            const plan = PLAN_PRICES[selectedPlan];
            
            if (STRIPE_TEST_MODE) {
                // TEST MODE: Simulate purchase (for development/testing)
                try {
                    const expiresAt = new Date();
                    expiresAt.setDate(expiresAt.getDate() + plan.days);
                    
                    await db.collection('users').doc(currentAuthUser.uid).update({
                        subscriptionStatus: selectedPlan,
                        subscriptionExpiresAt: firebase.firestore.Timestamp.fromDate(expiresAt),
                        lastPurchase: {
                            plan: selectedPlan,
                            price: plan.price,
                            purchasedAt: firebase.firestore.FieldValue.serverTimestamp(),
                            testMode: true
                        }
                    });
                    
                    userSubscription = {
                        status: selectedPlan,
                        expiresAt: expiresAt,
                        email: currentAuthUser.email
                    };
                    
                    hidePaywall();
                    updateAccountUI();
                    showNotification('ð Test Purchase Complete!', `${plan.label} activated until ${expiresAt.toLocaleDateString()}`);
                    
                } catch (error) {
                    console.error('Purchase error:', error);
                    showNotification('Error', 'Purchase failed. Please try again.');
                }
            } else {
                // PRODUCTION MODE: Redirect to Stripe Payment Link
                const paymentLink = STRIPE_PAYMENT_LINKS[selectedPlan];
                
                if (!paymentLink || paymentLink.includes('YOUR_')) {
                    showNotification('Not Configured', 'Payment links not yet configured. Please contact support.');
                    return;
                }
                
                // Add user info to the payment link URL
                // Stripe will capture this in the custom field
                const uid = currentAuthUser.uid;
                const email = encodeURIComponent(currentAuthUser.email);
                
                // Construct the URL with prefilled email and client reference
                // Format: https://buy.stripe.com/xxx?prefilled_email=xxx&client_reference_id=xxx
                const separator = paymentLink.includes('?') ? '&' : '?';
                const fullUrl = `${paymentLink}${separator}prefilled_email=${email}&client_reference_id=${uid}`;
                
                // Store pending purchase info (will be verified when user returns)
                localStorage.setItem('pendingPurchase', JSON.stringify({
                    plan: selectedPlan,
                    uid: uid,
                    timestamp: Date.now()
                }));
                
                hidePaywall();
                
                // Open Stripe in new tab (or redirect)
                window.open(fullUrl, '_blank');
                
                showNotification('Opening Stripe', 'Complete your purchase in the new tab. Return here when done.');
            }
        }
        
        // Check for returning from Stripe payment
        function checkPaymentReturn() {
            const urlParams = new URLSearchParams(window.location.search);
            const paymentSuccess = urlParams.get('payment_success');
            const plan = urlParams.get('plan');
            
            if (paymentSuccess === 'true' && plan) {
                // Clear URL params
                window.history.replaceState({}, document.title, window.location.pathname);
                
                showNotification('ð Payment Received!', `Your ${PLAN_PRICES[plan]?.label || 'subscription'} is being activated...`);
                
                // Reload subscription status (webhook should have updated it)
                if (currentAuthUser) {
                    setTimeout(() => {
                        loadUserSubscription(currentAuthUser.uid);
                    }, 2000);
                }
            }
            
            // Also check for pending purchase on page load
            const pending = localStorage.getItem('pendingPurchase');
            if (pending && currentAuthUser) {
                const { plan, uid, timestamp } = JSON.parse(pending);
                // If purchase was less than 1 hour ago, check status
                if (Date.now() - timestamp < 3600000 && uid === currentAuthUser.uid) {
                    // Silently reload subscription to see if it was activated
                    loadUserSubscription(currentAuthUser.uid);
                }
                localStorage.removeItem('pendingPurchase');
            }
        }
        
        // Restore purchase - reload subscription from Firebase
        async function restorePurchase() {
            if (!currentAuthUser) {
                showNotification('Sign In Required', 'Please sign in to restore your purchase');
                return;
            }
            
            showNotification('Checking...', 'Looking for your subscription...');
            
            try {
                await loadUserSubscription(currentAuthUser.uid);
                updateAccountUI();
                
                if (hasActiveSubscription()) {
                    showNotification('â Restored!', `Your ${PLAN_PRICES[userSubscription.status]?.label || 'subscription'} is active`);
                } else {
                    showNotification('No Active Subscription', 'No subscription found. If you recently purchased, please wait a few minutes and try again.');
                }
            } catch (error) {
                console.error('Restore error:', error);
                showNotification('Error', 'Could not check subscription status. Please try again.');
            }
        }
        
        // Send email verification
        async function sendVerificationEmail() {
            if (!currentAuthUser) return;
            
            try {
                await currentAuthUser.sendEmailVerification();
                showNotification('ð§ Email Sent', 'Check your inbox for verification link');
            } catch (error) {
                console.error('Verification email error:', error);
                if (error.code === 'auth/too-many-requests') {
                    showNotification('Please Wait', 'Verification email already sent. Check your inbox.');
                } else {
                    showNotification('Error', 'Could not send verification email. Try again later.');
                }
            }
        }
        
        // Show/hide change email form
        function showChangeEmailForm() {
            document.getElementById('changeEmailForm').style.display = 'block';
            document.getElementById('changePasswordForm').style.display = 'none';
            document.getElementById('newEmailInput').value = '';
            document.getElementById('currentPasswordForEmail').value = '';
            document.getElementById('changeEmailError').style.display = 'none';
        }
        
        function hideChangeEmailForm() {
            document.getElementById('changeEmailForm').style.display = 'none';
        }
        
        // Show/hide change password form
        function showChangePasswordForm() {
            document.getElementById('changePasswordForm').style.display = 'block';
            document.getElementById('changeEmailForm').style.display = 'none';
            document.getElementById('currentPasswordInput').value = '';
            document.getElementById('newPasswordInput').value = '';
            document.getElementById('changePasswordError').style.display = 'none';
        }
        
        function hideChangePasswordForm() {
            document.getElementById('changePasswordForm').style.display = 'none';
        }
        
        // Update email
        async function updateEmail() {
            const newEmail = document.getElementById('newEmailInput').value.trim();
            const currentPassword = document.getElementById('currentPasswordForEmail').value;
            const errorEl = document.getElementById('changeEmailError');
            
            if (!newEmail) {
                errorEl.textContent = 'Please enter new email';
                errorEl.style.display = 'block';
                return;
            }
            
            if (!currentPassword) {
                errorEl.textContent = 'Please enter current password to confirm';
                errorEl.style.display = 'block';
                return;
            }
            
            try {
                // Re-authenticate user first
                const credential = firebase.auth.EmailAuthProvider.credential(
                    currentAuthUser.email,
                    currentPassword
                );
                await currentAuthUser.reauthenticateWithCredential(credential);
                
                // Update email
                await currentAuthUser.updateEmail(newEmail);
                
                // Send verification to new email
                await currentAuthUser.sendEmailVerification();
                
                hideChangeEmailForm();
                showNotification('â Email Updated', 'Verification sent to new email');
                
                // Refresh the modal display
                showAccountModal();
                
            } catch (error) {
                console.error('Update email error:', error);
                errorEl.textContent = getAuthErrorMessage(error.code);
                errorEl.style.display = 'block';
            }
        }
        
        // Update password
        async function updatePassword() {
            const currentPassword = document.getElementById('currentPasswordInput').value;
            const newPassword = document.getElementById('newPasswordInput').value;
            const errorEl = document.getElementById('changePasswordError');
            
            if (!currentPassword) {
                errorEl.textContent = 'Please enter current password';
                errorEl.style.display = 'block';
                return;
            }
            
            if (!newPassword || newPassword.length < 6) {
                errorEl.textContent = 'New password must be at least 6 characters';
                errorEl.style.display = 'block';
                return;
            }
            
            try {
                // Re-authenticate user first
                const credential = firebase.auth.EmailAuthProvider.credential(
                    currentAuthUser.email,
                    currentPassword
                );
                await currentAuthUser.reauthenticateWithCredential(credential);
                
                // Update password
                await currentAuthUser.updatePassword(newPassword);
                
                hideChangePasswordForm();
                showNotification('â Password Updated', 'Your password has been changed');
                
            } catch (error) {
                console.error('Update password error:', error);
                errorEl.textContent = getAuthErrorMessage(error.code);
                errorEl.style.display = 'block';
            }
        }
        
        // Show/hide change username form
        function showChangeUsernameForm() {
            document.getElementById('changeUsernameForm').style.display = 'block';
            document.getElementById('changeEmailForm').style.display = 'none';
            document.getElementById('changePasswordForm').style.display = 'none';
            document.getElementById('newUsernameInput').value = currentAuthUser?.displayName || '';
            document.getElementById('changeUsernameError').style.display = 'none';
        }
        
        function hideChangeUsernameForm() {
            const form = document.getElementById('changeUsernameForm');
            if (form) form.style.display = 'none';
        }
        
        // Update username
        async function updateUsername() {
            const newUsername = document.getElementById('newUsernameInput').value.trim();
            const errorEl = document.getElementById('changeUsernameError');
            
            if (!newUsername || newUsername.length < 2) {
                errorEl.textContent = 'Username must be at least 2 characters';
                errorEl.style.display = 'block';
                return;
            }
            
            if (newUsername.length > 20) {
                errorEl.textContent = 'Username must be 20 characters or less';
                errorEl.style.display = 'block';
                return;
            }
            
            try {
                await currentAuthUser.updateProfile({
                    displayName: newUsername
                });
                
                // Also save to localStorage as deviceInitials for compatibility
                localStorage.setItem('deviceInitials', newUsername);
                deviceInitials = newUsername;
                
                hideChangeUsernameForm();
                showNotification('â Username Updated', `Now showing as "${newUsername}"`);
                
                // Refresh the modal display
                showAccountModal();
                
                // Update the account button and Connected As displays
                updateAccountUI();
                
            } catch (error) {
                console.error('Update username error:', error);
                errorEl.textContent = 'Failed to update username. Try again.';
                errorEl.style.display = 'block';
            }
        }
        
        // Show/hide delete account confirmation
        function showDeleteAccountConfirm() {
            document.getElementById('deleteAccountConfirm').style.display = 'block';
            document.getElementById('deleteAccountPassword').value = '';
            document.getElementById('deleteAccountError').style.display = 'none';
        }
        
        function hideDeleteAccountConfirm() {
            const form = document.getElementById('deleteAccountConfirm');
            if (form) form.style.display = 'none';
        }
        
        // Delete account permanently
        async function deleteAccount() {
            const password = document.getElementById('deleteAccountPassword').value;
            const errorEl = document.getElementById('deleteAccountError');
            
            if (!password) {
                errorEl.textContent = 'Please enter your password to confirm';
                errorEl.style.display = 'block';
                return;
            }
            
            try {
                // Re-authenticate user first
                const credential = firebase.auth.EmailAuthProvider.credential(
                    currentAuthUser.email,
                    password
                );
                await currentAuthUser.reauthenticateWithCredential(credential);
                
                const uid = currentAuthUser.uid;
                
                // Delete user's subscription data from Firestore
                try {
                    await db.collection('subscriptions').doc(uid).delete();
                } catch (e) {
                    console.log('No subscription to delete or error:', e);
                }
                
                // Delete the Firebase Auth account
                await currentAuthUser.delete();
                
                // Clear local state
                currentAuthUser = null;
                userSubscription = { status: 'free', expiresAt: null, email: null };
                
                hideAccountModal();
                updateAccountUI();
                showNotification('Account Deleted', 'Your account has been permanently deleted');
                
            } catch (error) {
                console.error('Delete account error:', error);
                errorEl.textContent = getAuthErrorMessage(error.code);
                errorEl.style.display = 'block';
            }
        }
        
        // ===== END SUBSCRIPTION SYSTEM =====
        
        // Start initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeFirebase);
        } else {
            initializeFirebase();
        }

        // Global Firebase state
        let db = null;
        let auth = null;
        let currentUserId = null;
        let currentDeviceId = null;
        let deviceName = null;
        let deviceInitials = null;
        
        // Subscription state
        let currentAuthUser = null;  // Firebase auth user
        let userSubscription = {
            status: 'free',  // 'free', 'day', 'week', 'season'
            expiresAt: null,
            email: null
        };
        let selectedPlan = 'week';  // Default selection in paywall
        
        // ===== STRIPE CONFIGURATION =====
        // TO SET UP STRIPE:
        // 1. Go to Stripe Dashboard > Payment Links
        // 2. Create 3 payment links (Day Pass $4.99, Week Pass $9.99, Season Pass $49.99)
        // 3. For each link, add a custom field to collect the user's Firebase UID:
        //    - Add "Custom field" > "Short answer" > Label: "User ID" > Required
        // 4. Set the success URL to your app URL with ?payment_success=true&plan=day (or week/season)
        // 5. Copy the payment link URLs below
        // 6. Set up a webhook in Stripe to listen for checkout.session.completed
        //    and update Firebase with the subscription info
        
        const STRIPE_PAYMENT_LINKS = {
            day: 'https://buy.stripe.com/YOUR_DAY_PASS_LINK',      // Replace with your actual link
            week: 'https://buy.stripe.com/YOUR_WEEK_PASS_LINK',    // Replace with your actual link
            season: 'https://buy.stripe.com/YOUR_SEASON_PASS_LINK' // Replace with your actual link
        };
        
        // For testing without real Stripe, set this to true
        // This will simulate purchases (writes directly to Firebase)
        const STRIPE_TEST_MODE = true;  // Set to false when you have real Stripe links
        
        const PLAN_PRICES = {
            day: { price: 4.99, label: 'Day Pass', days: 1 },
            week: { price: 9.99, label: 'Week Pass', days: 7 },
            season: { price: 49.99, label: 'Season Pass', days: 365 }
        };
        const FREE_PLAYER_LIMIT = 4;
        
        // Player order storage (per device)
        let playerOrder = {
            claimed: [],   // Player names in custom order
            watching: []   // Watched player names in custom order
        };
        
        // Results filter
        let currentResultsFilter = 'all'; // 'all' or 'mine'
        let unsubscribeFunctions = [];
        let authCompleted = false;
        let firebaseReady = false; // Track if Firebase is loaded and initialized

        // CRITICAL FALLBACK: Set timer immediately on page load
        // This creates persistent IDs if Firebase init fails
        console.log('â° Starting 3-second fallback timer...');
        setTimeout(() => {
            if (!authCompleted && !currentUserId) {
                console.warn('â±ï¸ Firebase initialization timeout');
                
                // Check if Firebase loaded
                if (typeof firebase !== 'undefined' && firebaseReady) {
                    console.log('Firebase loaded but auth not complete - creating device IDs');
                    authCompleted = true;
                    
                    // Generate persistent user ID (stored in localStorage)
                    if (!localStorage.getItem('persistentUserId')) {
                        localStorage.setItem('persistentUserId', 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
                    }
                    currentUserId = localStorage.getItem('persistentUserId');
                    
                    // Generate persistent device ID (stored in localStorage)
                    if (!localStorage.getItem('deviceId')) {
                        localStorage.setItem('deviceId', 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
                    }
                    currentDeviceId = localStorage.getItem('deviceId');
                    
                    // Initialize device name and initials
                    deviceName = localStorage.getItem('deviceName') || 'My Device';
                    deviceInitials = localStorage.getItem('deviceInitials') || 'MD';
                    
                    console.log('â Device IDs created via fallback');
                    console.log('   User ID:', currentUserId);
                    console.log('   Device ID:', currentDeviceId);
                } else {
                    console.error('â Firebase not loaded - Multi-Device mode unavailable');
                    console.log('   Please use Single-Device mode or refresh the page');
                }
            } else {
                console.log('â Device IDs already set, no fallback needed');
            }
        }, 3000);

        // ========================================
        // COURSE DATA
        // ========================================
        
        // Course data with tee information for course handicap calculation
        const courses = {
            hidden_valley: {
                name: "Hidden Valley Golf Club",
                city: "Norco",
                state: "CA",
                totalPar: 72,
                tees: {
                    black: { name: "Black", rating: 74.0, slope: 140, yardage: 6880 },
                    blue: { name: "Blue", rating: 71.4, slope: 132, yardage: 6292 },
                    white: { name: "White", rating: 68.7, slope: 124, yardage: 5772 },
                    silver: { name: "Silver", rating: 66.6, slope: 117, yardage: 5330 },
                    red: { name: "Red", rating: 63.6, slope: 111, yardage: 4698 }
                },
                defaultTee: "white",
                holes: [
                    { number: 1, par: 5, handicap: 11 },
                    { number: 2, par: 4, handicap: 3 },
                    { number: 3, par: 4, handicap: 15 },
                    { number: 4, par: 4, handicap: 9 },
                    { number: 5, par: 3, handicap: 5 },
                    { number: 6, par: 5, handicap: 7 },
                    { number: 7, par: 4, handicap: 17 },
                    { number: 8, par: 3, handicap: 13 },
                    { number: 9, par: 4, handicap: 1 },
                    { number: 10, par: 4, handicap: 6 },
                    { number: 11, par: 5, handicap: 14 },
                    { number: 12, par: 4, handicap: 12 },
                    { number: 13, par: 3, handicap: 16 },
                    { number: 14, par: 4, handicap: 18 },
                    { number: 15, par: 5, handicap: 8 },
                    { number: 16, par: 3, handicap: 10 },
                    { number: 17, par: 4, handicap: 4 },
                    { number: 18, par: 4, handicap: 2 }
                ]
            },
            indian_hills: {
                name: "Indian Hills Golf Club",
                city: "Riverside",
                state: "CA",
                totalPar: 70,
                tees: {
                    blue: { name: "Blue", rating: 70.1, slope: 125, yardage: 6125 },
                    white: { name: "White", rating: 68.8, slope: 122, yardage: 5829 },
                    gold: { name: "Gold", rating: 67.5, slope: 118, yardage: 5502 }
                },
                defaultTee: "white",
                holes: [
                    { number: 1, par: 4, handicap: 5 },
                    { number: 2, par: 4, handicap: 15 },
                    { number: 3, par: 3, handicap: 7 },
                    { number: 4, par: 4, handicap: 3 },
                    { number: 5, par: 3, handicap: 11 },
                    { number: 6, par: 4, handicap: 9 },
                    { number: 7, par: 4, handicap: 17 },
                    { number: 8, par: 5, handicap: 13 },
                    { number: 9, par: 4, handicap: 1 },
                    { number: 10, par: 4, handicap: 8 },
                    { number: 11, par: 3, handicap: 16 },
                    { number: 12, par: 4, handicap: 18 },
                    { number: 13, par: 4, handicap: 12 },
                    { number: 14, par: 4, handicap: 6 },
                    { number: 15, par: 3, handicap: 14 },
                    { number: 16, par: 4, handicap: 4 },
                    { number: 17, par: 4, handicap: 2 },
                    { number: 18, par: 5, handicap: 10 }
                ]
            },
            jurupa_hills: {
                name: "Jurupa Hills Country Club",
                city: "Riverside",
                state: "CA",
                totalPar: 70,
                tees: {
                    blue: { name: "Blue", rating: 69.1, slope: 122, yardage: 6124 },
                    white: { name: "White", rating: 67.8, slope: 119, yardage: 5846 },
                    gold: { name: "Gold", rating: 71.3, slope: 119, yardage: 5405 }
                },
                defaultTee: "white",
                holes: [
                    { number: 1, par: 4, handicap: 4 },
                    { number: 2, par: 4, handicap: 2 },
                    { number: 3, par: 3, handicap: 16 },
                    { number: 4, par: 4, handicap: 10 },
                    { number: 5, par: 4, handicap: 14 },
                    { number: 6, par: 4, handicap: 8 },
                    { number: 7, par: 5, handicap: 6 },
                    { number: 8, par: 3, handicap: 18 },
                    { number: 9, par: 4, handicap: 12 },
                    { number: 10, par: 4, handicap: 7 },
                    { number: 11, par: 4, handicap: 1 },
                    { number: 12, par: 4, handicap: 13 },
                    { number: 13, par: 4, handicap: 3 },
                    { number: 14, par: 3, handicap: 17 },
                    { number: 15, par: 5, handicap: 11 },
                    { number: 16, par: 4, handicap: 9 },
                    { number: 17, par: 4, handicap: 5 },
                    { number: 18, par: 3, handicap: 15 }
                ]
            },
            green_river: {
                name: "Green River Golf Club",
                city: "Corona",
                state: "CA",
                totalPar: 71,
                tees: {
                    black: { name: "Black", rating: 73.3, slope: 130, yardage: 6827 },
                    blue: { name: "Blue", rating: 71.9, slope: 127, yardage: 6487 },
                    white: { name: "White", rating: 69.8, slope: 122, yardage: 6030 },
                    gold: { name: "Gold", rating: 67.9, slope: 117, yardage: 5545 }
                },
                defaultTee: "white",
                holes: [
                    { number: 1, par: 4, handicap: 9 },
                    { number: 2, par: 3, handicap: 15 },
                    { number: 3, par: 5, handicap: 7 },
                    { number: 4, par: 3, handicap: 13 },
                    { number: 5, par: 5, handicap: 3 },
                    { number: 6, par: 4, handicap: 5 },
                    { number: 7, par: 5, handicap: 1 },
                    { number: 8, par: 3, handicap: 17 },
                    { number: 9, par: 4, handicap: 11 },
                    { number: 10, par: 4, handicap: 4 },
                    { number: 11, par: 4, handicap: 18 },
                    { number: 12, par: 4, handicap: 8 },
                    { number: 13, par: 3, handicap: 16 },
                    { number: 14, par: 4, handicap: 12 },
                    { number: 15, par: 4, handicap: 10 },
                    { number: 16, par: 3, handicap: 14 },
                    { number: 17, par: 5, handicap: 2 },
                    { number: 18, par: 4, handicap: 6 }
                ]
            },
            shandin_hills: {
                name: "Shandin Hills Golf Club",
                city: "San Bernardino",
                state: "CA",
                totalPar: 72,
                tees: {
                    black: { name: "Black", rating: 70.5, slope: 127, yardage: 6517 },
                    white: { name: "White", rating: 69.1, slope: 124, yardage: 6202 },
                    red: { name: "Red", rating: 66.3, slope: 113, yardage: 5592 }
                },
                defaultTee: "white",
                holes: [
                    { number: 1, par: 5, handicap: 17 },
                    { number: 2, par: 4, handicap: 3 },
                    { number: 3, par: 3, handicap: 11 },
                    { number: 4, par: 4, handicap: 9 },
                    { number: 5, par: 4, handicap: 1 },
                    { number: 6, par: 4, handicap: 5 },
                    { number: 7, par: 3, handicap: 15 },
                    { number: 8, par: 5, handicap: 7 },
                    { number: 9, par: 4, handicap: 13 },
                    { number: 10, par: 4, handicap: 4 },
                    { number: 11, par: 3, handicap: 10 },
                    { number: 12, par: 4, handicap: 18 },
                    { number: 13, par: 4, handicap: 16 },
                    { number: 14, par: 5, handicap: 12 },
                    { number: 15, par: 3, handicap: 8 },
                    { number: 16, par: 4, handicap: 2 },
                    { number: 17, par: 5, handicap: 6 },
                    { number: 18, par: 4, handicap: 14 }
                ]
            }
        };
        
        // Favorite courses stored in localStorage
        let favoriteCourses = JSON.parse(localStorage.getItem('golf_favorite_courses') || '[]');
        
        // Custom courses added by users (also stored in localStorage)
        let customCourses = JSON.parse(localStorage.getItem('golf_custom_courses') || '{}');
        
        // Currently selected tee for tournament
        let selectedTee = null;

        let courseData = null; // No default course - user must select

        let currentPlayerCount = 1;
        let nextPlayerId = 2;
        const maxPlayers = 40;

        // Swipe-to-delete functionality
        let touchStartX = 0;
        let touchStartY = 0;
        let touchCurrentX = 0;
        let swipingRow = null;
        let isScrolling = null;

        // Initialize autocomplete, quick add, and swipe after page loads
        window.addEventListener('load', function() {
            // Set today's date as default
            const dateInput = document.getElementById('tournamentDate');
            if (dateInput) {
                dateInput.valueAsDate = new Date();
            }
            
            initializeAutocomplete();
            renderQuickAddButtons();
            initializeSwipeGestures();
            
            // Check for shared tournament in URL
            loadTournamentFromURL();
        });

        function initializeSwipeGestures() {
            // Setup swipe-to-delete for player rows
            const playerList = document.getElementById('playerList');
            if (!playerList) return;

            let touchStartX = 0;
            let touchStartY = 0;
            let touchCurrentX = 0;
            let swipingRow = null;
            let isScrolling = null;
            let touchStartedOnInput = false;

            playerList.addEventListener('touchstart', function(e) {
                const row = e.target.closest('.player-row');
                if (!row) return;

                // Check if touch started on an input element - if so, don't enable swipe
                touchStartedOnInput = (e.target.tagName === 'INPUT' || e.target.classList.contains('course-hcp-display'));
                
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                swipingRow = row;
                isScrolling = null;
                touchCurrentX = touchStartX; // Initialize to prevent accidental swipe
            }, { passive: true });

            playerList.addEventListener('touchmove', function(e) {
                if (!swipingRow || touchStartedOnInput) return;

                touchCurrentX = e.touches[0].clientX;
                const touchCurrentY = e.touches[0].clientY;
                const diffX = touchStartX - touchCurrentX;
                const diffY = touchStartY - touchCurrentY;

                // Determine if scrolling vertically or swiping horizontally
                // Require more horizontal movement before considering it a swipe
                if (isScrolling === null) {
                    // Need at least 15px horizontal movement AND more horizontal than vertical
                    if (Math.abs(diffX) > 15 && Math.abs(diffX) > Math.abs(diffY) * 1.5) {
                        isScrolling = false; // Horizontal swipe
                    } else if (Math.abs(diffY) > 10) {
                        isScrolling = true; // Vertical scroll
                    }
                    // If neither threshold met, keep waiting
                }

                // If scrolling vertically or undetermined, don't swipe
                if (isScrolling !== false) return;

                // Prevent vertical scroll while swiping
                e.preventDefault();

                // Only allow swipe left
                if (diffX > 0 && diffX <= 100) {
                    swipingRow.style.transform = `translateX(-${diffX}px)`;
                }
            }, { passive: false });

            playerList.addEventListener('touchend', function(e) {
                if (!swipingRow) return;
                
                // If touch started on input, just reset and return
                if (touchStartedOnInput) {
                    swipingRow = null;
                    touchStartedOnInput = false;
                    isScrolling = null;
                    return;
                }

                const diffX = touchStartX - touchCurrentX;

                // Require more movement (75px instead of 50px) to trigger delete position
                if (diffX > 75 && isScrolling === false) {
                    swipingRow.classList.add('swiped');
                    swipingRow.style.transform = 'translateX(-100px)';
                } else {
                    // Snap back
                    swipingRow.classList.remove('swiped');
                    swipingRow.style.transform = 'translateX(0)';
                }

                // Reset
                swipingRow = null;
                isScrolling = null;
                touchStartX = 0;
                touchCurrentX = 0;
                touchStartedOnInput = false;
            }, { passive: true });

            // Click on delete area to delete
            playerList.addEventListener('click', function(e) {
                const row = e.target.closest('.player-row.swiped');
                if (!row) return;

                const rect = row.getBoundingClientRect();
                const clickX = e.clientX;

                // If clicked on the revealed delete button area
                if (clickX > rect.right - 20) {
                    const playerId = row.getAttribute('data-player');
                    deletePlayerRow(playerId);
                } else {
                    // Clicked elsewhere, close the swipe
                    row.classList.remove('swiped');
                    row.style.transform = 'translateX(0)';
                }
            });
        }

        // Delete player row with animation
        function deletePlayerRow(playerId) {
            const row = document.querySelector(`[data-player="${playerId}"]`);
            if (!row) return;
            
            // Don't allow deleting if only 1 player remains
            if (currentPlayerCount <= 1) {
                alert('You must have at least one player');
                row.classList.remove('swiped');
                row.style.transform = 'translateX(0)';
                return;
            }
            
            // Add deleting animation
            row.classList.add('deleting');
            
            // Remove after animation
            setTimeout(() => {
                row.remove();
                currentPlayerCount--;
                
                // Re-enable Add button if was at max
                if (currentPlayerCount < maxPlayers) {
                    document.getElementById('addPlayerBtn').disabled = false;
                    document.getElementById('addPlayerBtn').innerHTML = '<span style="font-size: 20px; font-weight: 600;">+</span> Add Player';
                }
                
                // CRITICAL: Reset all swipe state variables
                swipingRow = null;
                isScrolling = null;
                touchStartX = 0;
                touchCurrentX = 0;
                touchStartY = 0;
                
                // Remove swiped class from any other rows that might have it
                const allRows = document.querySelectorAll('.player-row.swiped');
                allRows.forEach(r => {
                    r.classList.remove('swiped');
                    r.style.transform = 'translateX(0)';
                });
            }, 300);
        }

        // Render quick add buttons for frequent players
        function renderQuickAddButtons() {
            const quickAddSection = document.getElementById('quickAddSection');
            
            // Safety check - this element only exists on setup page
            if (!quickAddSection) {
                return;
            }
            
            // Get all players from history
            const allPlayers = Object.values(playerHistory)
                .sort((a, b) => b.usageCount - a.usageCount);
            
            if (allPlayers.length === 0) {
                quickAddSection.style.display = 'none';
                return;
            }
            
            quickAddSection.style.display = 'block';
        }
        
        // Show Quick Add Modal
        function showQuickAddModal() {
            const allPlayers = Object.values(playerHistory)
                .sort((a, b) => b.usageCount - a.usageCount);
            
            if (allPlayers.length === 0) {
                showNotification('No Players', 'Add players manually to build your roster');
                return;
            }
            
            // Get currently added player names to pre-check them
            const currentPlayers = [];
            document.querySelectorAll('.player-name-input').forEach(input => {
                if (input.value.trim()) {
                    currentPlayers.push(input.value.trim().toLowerCase());
                }
            });
            
            const modal = document.createElement('div');
            modal.id = 'quickAddModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            let playerListHtml = allPlayers.map((player, index) => {
                const isAlreadyAdded = currentPlayers.includes(player.name.toLowerCase());
                return `
                    <label style="display: flex; align-items: center; gap: 12px; padding: 12px; background: ${isAlreadyAdded ? '#f0fdf4' : '#f8fafc'}; border: 2px solid ${isAlreadyAdded ? '#10b981' : '#e2e8f0'}; border-radius: 10px; cursor: pointer;">
                        <input type="checkbox" name="quickAddPlayer" value="${index}" ${isAlreadyAdded ? 'checked disabled' : ''} 
                            style="width: 20px; height: 20px; accent-color: #3b82f6;">
                        <div style="flex: 1;">
                            <div style="font-weight: 600; color: #1e293b; font-size: 15px;">${player.name}</div>
                            <div style="font-size: 12px; color: #64748b;">HCP Index: ${player.handicap}</div>
                        </div>
                        ${isAlreadyAdded ? '<span style="font-size: 11px; color: #10b981; font-weight: 600;">Added</span>' : ''}
                    </label>
                `;
            }).join('');
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; max-width: 400px; width: 100%; max-height: 85vh; display: flex; flex-direction: column;">
                    <div style="padding: 16px 20px; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center;">
                        <h2 style="color: #1e40af; font-size: 18px; margin: 0; display: flex; align-items: center; gap: 8px;">
                            <span>ð¥</span> Quick Add Players
                        </h2>
                        <button onclick="closeQuickAddModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b; line-height: 1;">â</button>
                    </div>
                    
                    <div style="padding: 16px 20px; overflow-y: auto; flex: 1;">
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            ${playerListHtml}
                        </div>
                    </div>
                    
                    <div style="padding: 16px 20px; border-top: 1px solid #e2e8f0; display: flex; gap: 10px;">
                        <button onclick="selectAllQuickAdd()" style="flex: 1; padding: 12px; background: #f1f5f9; border: 2px solid #cbd5e1; border-radius: 10px; color: #475569; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Select All
                        </button>
                        <button onclick="addSelectedPlayers()" style="flex: 1; padding: 12px; background: #3b82f6; border: none; border-radius: 10px; color: white; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Add Selected
                        </button>
                    </div>
                    
                    <div style="padding: 0 20px 16px 20px;">
                        <button onclick="showManageRosterModal()" style="width: 100%; padding: 10px; background: transparent; border: none; color: #64748b; font-size: 13px; cursor: pointer; text-decoration: underline;">
                            Manage Roster
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeQuickAddModal();
            };
        }
        
        function closeQuickAddModal() {
            const modal = document.getElementById('quickAddModal');
            if (modal) modal.remove();
        }
        
        function selectAllQuickAdd() {
            const checkboxes = document.querySelectorAll('#quickAddModal input[name="quickAddPlayer"]:not(:disabled)');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            checkboxes.forEach(cb => cb.checked = !allChecked);
        }
        
        function addSelectedPlayers() {
            const allPlayers = Object.values(playerHistory).sort((a, b) => b.usageCount - a.usageCount);
            const checkboxes = document.querySelectorAll('#quickAddModal input[name="quickAddPlayer"]:checked:not(:disabled)');
            
            let addedCount = 0;
            checkboxes.forEach(cb => {
                const player = allPlayers[parseInt(cb.value)];
                if (player) {
                    quickAddPlayer(player.name, player.handicap);
                    addedCount++;
                }
            });
            
            closeQuickAddModal();
            
            if (addedCount > 0) {
                showNotification('Added', `${addedCount} player${addedCount !== 1 ? 's' : ''} added`);
            }
        }
        
        // Show Manage Roster Modal
        function showManageRosterModal() {
            closeQuickAddModal();
            
            const allPlayers = Object.values(playerHistory).sort((a, b) => a.name.localeCompare(b.name));
            
            const modal = document.createElement('div');
            modal.id = 'manageRosterModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            let playerListHtml = allPlayers.length > 0 ? allPlayers.map((player, idx) => `
                <div class="roster-edit-row" data-original-name="${player.name.replace(/"/g, '&quot;')}" style="display: flex; align-items: center; gap: 8px; padding: 10px; background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 10px;">
                    <input type="text" class="roster-name-edit" value="${player.name.replace(/"/g, '&quot;')}" 
                        style="flex: 1; min-width: 0; padding: 8px 10px; border: 1px solid #cbd5e1; border-radius: 6px; font-size: 14px; font-weight: 600; color: #1e293b;">
                    <input type="text" class="roster-hcp-edit" value="${player.handicap}" inputmode="decimal" pattern="-?[0-9.]*"
                        style="width: 60px; padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; font-size: 14px; text-align: center; color: #1e293b;">
                    <button onclick="deleteQuickAddPlayer('${player.name.replace(/'/g, "\\'")}')" 
                        style="padding: 8px 10px; background: #fee2e2; border: none; border-radius: 8px; color: #ef4444; font-size: 14px; cursor: pointer; flex-shrink: 0;">
                        ðï¸
                    </button>
                </div>
            `).join('') : '<p style="text-align: center; color: #64748b; padding: 20px;">No players in roster yet</p>';
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; max-width: 400px; width: 100%; max-height: 85vh; display: flex; flex-direction: column;">
                    <div style="padding: 16px 20px; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center;">
                        <h2 style="color: #1e40af; font-size: 18px; margin: 0;">âï¸ Manage Roster</h2>
                        <button onclick="closeManageRosterModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b; line-height: 1;">â</button>
                    </div>
                    
                    <!-- Column headers for edit mode -->
                    <div style="padding: 8px 20px 0 20px; display: flex; gap: 8px;">
                        <div style="flex: 1; font-size: 11px; color: #64748b; font-weight: 600; text-transform: uppercase; padding-left: 10px;">Name</div>
                        <div style="width: 60px; font-size: 11px; color: #64748b; font-weight: 600; text-transform: uppercase; text-align: center;">HCP</div>
                        <div style="width: 46px;"></div>
                    </div>
                    
                    <div style="padding: 8px 20px 16px 20px; overflow-y: auto; flex: 1;">
                        <div id="rosterEditList" style="display: flex; flex-direction: column; gap: 8px;">
                            ${playerListHtml}
                        </div>
                    </div>
                    
                    <div style="padding: 16px 20px; border-top: 1px solid #e2e8f0; display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="saveRosterEdits()" style="width: 100%; padding: 12px; background: #10b981; border: none; border-radius: 10px; color: white; font-size: 14px; font-weight: 600; cursor: pointer;">
                            â Save Changes
                        </button>
                        <button onclick="closeManageRosterModal(); showQuickAddModal();" style="width: 100%; padding: 12px; background: #f59e0b; border: none; border-radius: 10px; color: white; font-size: 14px; font-weight: 600; cursor: pointer;">
                            â Back to Quick Add
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeManageRosterModal();
            };
        }
        
        // Save roster edits from Manage Roster modal
        function saveRosterEdits() {
            const rows = document.querySelectorAll('#rosterEditList .roster-edit-row');
            let changes = 0;
            
            rows.forEach(row => {
                const originalName = row.getAttribute('data-original-name');
                const nameInput = row.querySelector('.roster-name-edit');
                const hcpInput = row.querySelector('.roster-hcp-edit');
                
                if (!nameInput || !hcpInput) return;
                
                const newName = nameInput.value.trim();
                const newHcp = parseFloat(hcpInput.value) || 0;
                
                if (!newName) return; // Skip empty names
                
                // Check if name changed
                if (originalName !== newName) {
                    // Create new entry with new name
                    const oldData = playerHistory[originalName];
                    if (oldData) {
                        playerHistory[newName] = {
                            name: newName,
                            handicap: newHcp,
                            usageCount: oldData.usageCount,
                            lastUsed: oldData.lastUsed
                        };
                        delete playerHistory[originalName];
                        changes++;
                    }
                } else if (playerHistory[originalName] && playerHistory[originalName].handicap !== newHcp) {
                    // Just update handicap
                    playerHistory[originalName].handicap = newHcp;
                    changes++;
                }
            });
            
            if (changes > 0) {
                localStorage.setItem('indianHillsPlayerHistory', JSON.stringify(playerHistory));
                showNotification('Saved', `${changes} player${changes !== 1 ? 's' : ''} updated`);
            }
            
            closeManageRosterModal();
            showQuickAddModal();
        }
        
        function closeManageRosterModal() {
            const modal = document.getElementById('manageRosterModal');
            if (modal) modal.remove();
        }
        
        // Delete a player from quick-add history
        function deleteQuickAddPlayer(playerName) {
            if (confirm(`Remove ${playerName} from roster?`)) {
                delete playerHistory[playerName];
                localStorage.setItem('indianHillsPlayerHistory', JSON.stringify(playerHistory));
                renderQuickAddButtons();
                // Refresh the manage roster modal if it's open
                const manageModal = document.getElementById('manageRosterModal');
                if (manageModal) {
                    closeManageRosterModal();
                    showManageRosterModal();
                }
                showNotification('Removed', `${playerName} removed from roster`);
            }
        }

        // Quick add a player to the first empty row or create new row
        function quickAddPlayer(name, handicap) {
            // Find first empty player row
            const playerRows = document.querySelectorAll('.player-row');
            let emptyRow = null;
            
            for (let row of playerRows) {
                const playerId = row.getAttribute('data-player');
                const nameInput = document.getElementById(`player${playerId}`);
                if (nameInput && nameInput.value.trim() === '') {
                    emptyRow = { row, playerId };
                    break;
                }
            }
            
            if (emptyRow) {
                // Fill empty row
                document.getElementById(`player${emptyRow.playerId}`).value = name;
                document.getElementById(`hcp${emptyRow.playerId}`).value = handicap;
                updateCourseHandicap(emptyRow.playerId);
            } else {
                // Add new row
                if (currentPlayerCount >= maxPlayers) {
                    alert(`Maximum of ${maxPlayers} players reached`);
                    return;
                }
                
                addPlayerRow();
                // Fill the newly added row
                document.getElementById(`player${nextPlayerId - 1}`).value = name;
                document.getElementById(`hcp${nextPlayerId - 1}`).value = handicap;
                updateCourseHandicap(nextPlayerId - 1);
            }
            
            // Refresh team setup if team game is selected
            refreshTeamSetupIfNeeded();
        }

        // Warn before page refresh if there's active data
        // Initialize autocomplete on all player name inputs
        function initializeAutocomplete() {
            const playerList = document.getElementById('playerList');
            if (!playerList) return;

            playerList.addEventListener('input', function(e) {
                // Refresh team setup if player name or handicap changes
                if (e.target.classList.contains('player-name-input') || e.target.classList.contains('player-hcp-input')) {
                    refreshTeamSetupIfNeeded();
                }
                
                if (!e.target.classList.contains('player-name-input')) return;
                
                const input = e.target;
                const row = input.closest('.player-row');
                if (!row) return;
                
                const query = input.value;
                
                // Remove existing suggestions
                const existingSuggestions = row.querySelector('.autocomplete-suggestions');
                if (existingSuggestions) {
                    existingSuggestions.remove();
                }
                
                if (!query || query.length < 1) {
                    row.classList.remove('has-suggestions');
                    return;
                }
                
                const suggestions = getPlayerSuggestions(query);
                if (suggestions.length === 0) {
                    row.classList.remove('has-suggestions');
                    return;
                }
                
                // Create suggestions dropdown
                const suggestionsDiv = document.createElement('div');
                suggestionsDiv.className = 'autocomplete-suggestions show';
                
                suggestions.forEach(player => {
                    const item = document.createElement('div');
                    item.className = 'suggestion-item';
                    item.innerHTML = `
                        <span class="suggestion-name">${player.name}</span>
                        <span class="suggestion-hcp">HCP: ${player.handicap}</span>
                    `;
                    
                    item.addEventListener('click', function(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        input.value = player.name;
                        
                        // Auto-fill handicap
                        const playerId = row.getAttribute('data-player');
                        const hcpInput = document.getElementById(`hcp${playerId}`);
                        if (hcpInput) {
                            hcpInput.value = player.handicap;
                        }
                        
                        suggestionsDiv.remove();
                        row.classList.remove('has-suggestions');
                        
                        // Refresh team setup
                        refreshTeamSetupIfNeeded();
                    });
                    
                    suggestionsDiv.appendChild(item);
                });
                
                row.appendChild(suggestionsDiv);
                row.classList.add('has-suggestions');
            });
            
            // Close suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.classList.contains('player-name-input') && 
                    !e.target.closest('.autocomplete-suggestions')) {
                    document.querySelectorAll('.autocomplete-suggestions').forEach(s => s.remove());
                    document.querySelectorAll('.player-row').forEach(r => r.classList.remove('has-suggestions'));
                }
            });
        }


        // Add new player row
        function addPlayerRow() {
            console.log('addPlayerRow called, currentPlayerCount:', currentPlayerCount, 'FREE_PLAYER_LIMIT:', FREE_PLAYER_LIMIT);
            
            if (currentPlayerCount >= maxPlayers) {
                alert(`Maximum of ${maxPlayers} players reached`);
                return;
            }
            
            // Gate check: Free tier limited to 4 players
            // currentPlayerCount is BEFORE adding, so check if adding one more would exceed limit
            if (!hasActiveSubscription() && currentPlayerCount >= FREE_PLAYER_LIMIT) {
                showPaywall(`Free plan allows ${FREE_PLAYER_LIMIT} players. Upgrade for unlimited players!`);
                return;
            }

            currentPlayerCount++;
            const playerList = document.getElementById('playerList');
            
            const newRow = document.createElement('div');
            newRow.className = 'player-row';
            newRow.setAttribute('data-player', nextPlayerId);
            newRow.innerHTML = `
                <input type="text" class="player-name-input" placeholder="Player Name" id="player${nextPlayerId}">
                <input type="text" class="player-hcp-input" placeholder="HCP" id="hcp${nextPlayerId}" pattern="-?[0-9.]*" inputmode="decimal" oninput="updateCourseHandicap(${nextPlayerId})">
                <div class="course-hcp-display" id="courseHcp${nextPlayerId}" title="Course handicap for this round">-</div>
            `;
            
            playerList.appendChild(newRow);
            nextPlayerId++;
            
            // Disable button if at max
            if (currentPlayerCount >= maxPlayers) {
                document.getElementById('addPlayerBtn').disabled = true;
                document.getElementById('addPlayerBtn').textContent = `Maximum ${maxPlayers} Players`;
            }
        }

        // Delete player row with animation

        let tournamentData = {
            id: '',
            date: '',
            gameType: '',
            course: '',
            players: [],
            teams: []
        };

        // Generate unique tournament ID
        function generateTournamentId() {
            return 'T' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }

        // ===== UI ENHANCEMENT FUNCTIONS =====
        
        // Generate player avatar color based on name
        function getPlayerColor(playerName) {
            const colors = [
                '#3b82f6', // Blue
                '#10b981', // Green
                '#f59e0b', // Orange
                '#8b5cf6', // Purple
                '#ef4444', // Red
                '#06b6d4', // Cyan
                '#ec4899', // Pink
                '#f97316', // Deep Orange
                '#14b8a6', // Teal
                '#a855f7'  // Violet
            ];
            
            // Hash the name to get consistent color
            let hash = 0;
            for (let i = 0; i < playerName.length; i++) {
                hash = playerName.charCodeAt(i) + ((hash << 5) - hash);
            }
            return colors[Math.abs(hash) % colors.length];
        }

        // Get player initials
        function getPlayerInitials(playerName) {
            const words = playerName.trim().split(' ');
            if (words.length === 1) {
                return words[0].substring(0, 2).toUpperCase();
            }
            return (words[0][0] + words[words.length - 1][0]).toUpperCase();
        }

        // Create player avatar HTML
        function createPlayerAvatar(playerName, large = false) {
            const initials = getPlayerInitials(playerName);
            const color = getPlayerColor(playerName);
            const sizeClass = large ? 'player-avatar-large' : 'player-avatar';
            return `<span class="player-avatar ${sizeClass}" style="background: ${color};">${initials}</span>`;
        }

        // Get score color class based on par
        function getScoreClass(score, par) {
            if (score === 0) return 'score-par';
            const diff = score - par;
            if (diff <= -2) return 'score-eagle';
            if (diff === -1) return 'score-birdie';
            if (diff === 0) return 'score-par';
            if (diff === 1) return 'score-bogey';
            return 'score-double';
        }

        // Trigger confetti animation
        function showConfetti() {
            const colors = ['#fbbf24', '#3b82f6', '#10b981', '#ef4444', '#8b5cf6'];
            const confettiCount = 50;
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
                confetti.style.animationDelay = (Math.random() * 0.5) + 's';
                confetti.style.animation = 'confetti-fall linear forwards';
                
                document.body.appendChild(confetti);
                
                setTimeout(() => confetti.remove(), 5000);
            }
        }

        // Add pulse animation to element
        function pulseElement(element) {
            element.classList.add('score-changed');
            setTimeout(() => element.classList.remove('score-changed'), 300);
        }

        // Calculate tournament progress
        function getTournamentProgress() {
            if (!tournamentData.players || tournamentData.players.length === 0) return 0;
            
            let totalHoles = 0;
            let completedHoles = 0;
            
            tournamentData.players.forEach(player => {
                player.scores.forEach(score => {
                    totalHoles++;
                    if (score > 0) completedHoles++;
                });
            });
            
            return totalHoles > 0 ? (completedHoles / totalHoles) * 100 : 0;
        }
        
        // Current hole for hole view
        let currentHole = 0; // 0-17 (holes 1-18)
        let currentView = 'hole'; // 'player' or 'hole' - default to hole view

        // Format date from YYYY-MM-DD string without timezone issues
        function formatDateDisplay(dateString) {
            if (!dateString) return '';
            const [year, month, day] = dateString.split('-');
            const date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
        }

        // Player history for auto-complete and handicap memory
        let playerHistory = JSON.parse(localStorage.getItem('indianHillsPlayerHistory') || '{}');
        // Format: { "PlayerName": { name: "PlayerName", handicap: 10, lastUsed: timestamp, usageCount: 5 } }

        // Save player history
        function savePlayerHistory() {
            localStorage.setItem('indianHillsPlayerHistory', JSON.stringify(playerHistory));
        }

        // Update player in history
        function updatePlayerHistory(name, handicap) {
            if (!name || name.trim() === '') return;
            
            const normalizedName = name.trim();
            if (!playerHistory[normalizedName]) {
                playerHistory[normalizedName] = {
                    name: normalizedName,
                    handicap: handicap || 0,
                    lastUsed: Date.now(),
                    usageCount: 1
                };
            } else {
                playerHistory[normalizedName].handicap = handicap || playerHistory[normalizedName].handicap;
                playerHistory[normalizedName].lastUsed = Date.now();
                playerHistory[normalizedName].usageCount++;
            }
            savePlayerHistory();
        }

        // Get player suggestions sorted by usage and recency
        function getPlayerSuggestions(query) {
            query = query.toLowerCase().trim();
            if (!query) {
                // Return most recent players
                return Object.values(playerHistory)
                    .sort((a, b) => b.lastUsed - a.lastUsed)
                    .slice(0, 5);
            }
            
            // Filter and sort by match quality
            return Object.values(playerHistory)
                .filter(p => p.name.toLowerCase().includes(query))
                .sort((a, b) => {
                    // Exact match first
                    const aExact = a.name.toLowerCase() === query ? 1 : 0;
                    const bExact = b.name.toLowerCase() === query ? 1 : 0;
                    if (aExact !== bExact) return bExact - aExact;
                    
                    // Then by usage count
                    if (a.usageCount !== b.usageCount) return b.usageCount - a.usageCount;
                    
                    // Then by recency
                    return b.lastUsed - a.lastUsed;
                })
                .slice(0, 5);
        }

        // Update course when selection changes
        function updateCourse() {
            const selectedCourse = document.getElementById('courseSelect').value;
            const teeSection = document.getElementById('teeSelectionSection');
            
            // Handle special options
            if (selectedCourse === 'search_course') {
                document.getElementById('courseSelect').value = '';
                showCourseSearchModal();
                return;
            }
            
            if (selectedCourse === 'custom_course') {
                document.getElementById('courseSelect').value = '';
                showCustomCourseModal();
                return;
            }
            
            // Handle favorite course selection (fav_xxx format)
            if (selectedCourse && selectedCourse.startsWith('fav_')) {
                const favId = selectedCourse.replace('fav_', '');
                const favorite = favoriteCourses.find(f => String(f.id) === favId);
                
                if (favorite) {
                    // First check if this is a built-in course (favId matches a built-in course key)
                    if (courses[favId]) {
                        document.getElementById('courseSelect').value = favId;
                        courseData = courses[favId];
                        if (courseData && courseData.tees) {
                            teeSection.style.display = 'block';
                            renderTeeButtons(favId);
                        }
                        updateFavoriteButton();
                        return;
                    }
                    
                    // Check if we already have this course loaded as API course
                    const apiKey = 'api_' + favId;
                    if (customCourses[apiKey]) {
                        // Already loaded - just use it
                        document.getElementById('courseSelect').value = apiKey;
                        courseData = customCourses[apiKey];
                        if (courseData && courseData.tees) {
                            teeSection.style.display = 'block';
                            renderTeeButtons(apiKey);
                        }
                        updateFavoriteButton();
                        return;
                    }
                    
                    // Need to fetch from API - we have hardcoded key now
                    showNotification('Loading...', `Fetching ${favorite.name} data`);
                    selectSearchedCourse(favId);
                }
                return;
            }
            
            if (selectedCourse) {
                // Get course from built-in or custom courses
                courseData = courses[selectedCourse] || customCourses[selectedCourse];
                
                if (courseData && courseData.tees) {
                    // Show tee selection
                    teeSection.style.display = 'block';
                    renderTeeButtons(selectedCourse);
                } else {
                    teeSection.style.display = 'none';
                    selectedTee = null;
                }
            } else {
                courseData = null;
                teeSection.style.display = 'none';
                selectedTee = null;
            }
            
            // Update the favorite star button
            updateFavoriteButton();
            
            // Update all course handicaps when course changes
            updateAllCourseHandicaps();
        }
        
        // Render tee selection buttons
        // Format tee name for display (shorten combo tees to 3 letters each)
        function formatTeeName(teeName) {
            if (!teeName) return '';
            
            // Check if it's a combo tee (contains / or -)
            if (teeName.includes('/') || teeName.includes('-')) {
                const separator = teeName.includes('/') ? '/' : '-';
                const parts = teeName.split(separator);
                const shortened = parts.map(part => {
                    const trimmed = part.trim().toUpperCase();
                    // Common abbreviations
                    if (trimmed === 'BLACK') return 'BLK';
                    if (trimmed === 'BLUE') return 'BLU';
                    if (trimmed === 'WHITE') return 'WHT';
                    if (trimmed === 'GOLD') return 'GLD';
                    if (trimmed === 'RED') return 'RED';
                    if (trimmed === 'GREEN') return 'GRN';
                    if (trimmed === 'SILVER') return 'SLV';
                    // Default: first 3 characters
                    return trimmed.substring(0, 3);
                });
                return shortened.join('/');
            }
            
            return teeName;
        }
        
        function renderTeeButtons(courseKey) {
            const course = courses[courseKey] || customCourses[courseKey];
            const container = document.getElementById('teeButtons');
            const infoDiv = document.getElementById('teeInfo');
            
            if (!course || !course.tees) {
                container.innerHTML = '';
                infoDiv.innerHTML = '';
                return;
            }
            
            const teeColors = {
                black: '#1e293b',
                blue: '#3b82f6',
                white: '#e2e8f0',
                gold: '#fbbf24',
                silver: '#94a3b8',
                red: '#ef4444',
                green: '#10b981'
            };
            
            let html = '';
            const teeKeys = Object.keys(course.tees);
            
            teeKeys.forEach((teeKey, index) => {
                const tee = course.tees[teeKey];
                const isDefault = teeKey === course.defaultTee;
                const bgColor = teeColors[teeKey] || '#64748b';
                const textColor = (teeKey === 'white' || teeKey === 'gold' || teeKey === 'silver') ? '#1e293b' : 'white';
                // For white tee, use gray border when not selected so it's visible
                const defaultBorderColor = teeKey === 'white' ? '#cbd5e1' : bgColor;
                const isSelected = selectedTee === teeKey || (!selectedTee && isDefault);
                
                // Format the display name (shorten combos)
                const displayName = formatTeeName(tee.name);
                
                // Double border effect: white inner, blue outer when selected
                const selectedStyle = isSelected 
                    ? 'border: 3px solid white; box-shadow: 0 0 0 3px #3b82f6;' 
                    : `border: 3px solid ${defaultBorderColor};`;
                
                html += `
                    <button type="button" onclick="selectTee('${teeKey}')" id="teeBtn_${teeKey}"
                        style="flex: 1; min-width: 60px; padding: 10px 8px; ${selectedStyle}
                        background: ${bgColor}; color: ${textColor}; border-radius: 8px; font-size: 13px; font-weight: 700; 
                        cursor: pointer;"
                        title="${tee.name}">
                        ${displayName}
                    </button>
                `;
                
                // Auto-select default tee
                if (isSelected && !selectedTee) {
                    selectedTee = teeKey;
                }
            });
            
            container.innerHTML = html;
            updateTeeInfo();
        }
        
        // Select a tee
        function selectTee(teeKey) {
            selectedTee = teeKey;
            const courseKey = document.getElementById('courseSelect').value;
            renderTeeButtons(courseKey);
            // Recalculate all course handicaps with new tee
            updateAllCourseHandicaps();
        }
        
        // Update tee info display
        function updateTeeInfo() {
            const infoDiv = document.getElementById('teeInfo');
            const courseKey = document.getElementById('courseSelect').value;
            const course = courses[courseKey] || customCourses[courseKey];
            
            if (!course || !selectedTee || !course.tees[selectedTee]) {
                infoDiv.innerHTML = '';
                return;
            }
            
            const tee = course.tees[selectedTee];
            infoDiv.innerHTML = `
                <span style="font-weight: 600;">${tee.yardage} yds</span> â¢ 
                Rating: <span style="font-weight: 600;">${tee.rating}</span> â¢ 
                Slope: <span style="font-weight: 600;">${tee.slope}</span>
            `;
        }
        
        // Calculate course handicap from index
        function calculateCourseHandicap(handicapIndex, slope, rating, par) {
            if (handicapIndex === null || handicapIndex === undefined || isNaN(handicapIndex)) return null;
            // USGA Formula: Course Handicap = Handicap Index Ã (Slope Rating Ã· 113) + (Course Rating - Par)
            const courseHcp = handicapIndex * (slope / 113) + (rating - par);
            return Math.round(courseHcp);
        }
        
        // Update course handicap display for a single player
        function updateCourseHandicap(playerId) {
            const indexInput = document.getElementById(`hcp${playerId}`);
            const courseHcpDisplay = document.getElementById(`courseHcp${playerId}`);
            
            if (!indexInput || !courseHcpDisplay) return;
            
            const indexValue = parseFloat(indexInput.value);
            
            if (!isNaN(indexValue)) {
                // Get the selected tee's slope and rating
                const selectedTee = document.querySelector('.tee-btn.selected');
                let courseHcp;
                
                if (selectedTee && courseData && courseData.tees) {
                    const teeId = selectedTee.getAttribute('data-tee');
                    const teeData = courseData.tees[teeId];
                    
                    if (teeData && teeData.slope && teeData.rating && courseData.totalPar) {
                        // Use proper USGA formula
                        courseHcp = calculateCourseHandicap(indexValue, teeData.slope, teeData.rating, courseData.totalPar);
                    } else {
                        // Fallback: just round the index
                        courseHcp = Math.round(indexValue);
                    }
                } else {
                    // No tee selected or no course data - just round
                    courseHcp = Math.round(indexValue);
                }
                
                courseHcpDisplay.textContent = courseHcp;
                courseHcpDisplay.title = 'Course handicap for this round';
            } else {
                courseHcpDisplay.textContent = '-';
                courseHcpDisplay.title = 'Enter handicap';
            }
        }
        
        // Update all course handicaps when tee selection changes
        function updateAllCourseHandicaps() {
            const playerRows = document.querySelectorAll('.player-row');
            playerRows.forEach(row => {
                const playerId = row.getAttribute('data-player');
                if (playerId) {
                    updateCourseHandicap(playerId);
                }
            });
        }
        
        // Show course search modal
        function showCourseSearchModal() {
            // Remove existing modal if any
            const existingModal = document.getElementById('courseSearchModal');
            if (existingModal) existingModal.remove();
            
            const modal = document.createElement('div');
            modal.id = 'courseSearchModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 20px; max-width: 400px; width: 95%; max-height: 80vh; overflow-y: auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h2 style="color: #1e40af; font-size: 18px; margin: 0;">ð Search Courses</h2>
                        <button onclick="closeCourseSearchModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">â</button>
                    </div>
                    
                    <div style="display: flex; gap: 8px; margin-bottom: 16px;">
                        <input type="text" id="courseSearchInput" placeholder="Course name or city..." 
                            style="flex: 1; padding: 12px; border: 2px solid #3b82f6; border-radius: 8px; font-size: 14px;"
                            onkeypress="if(event.key === 'Enter') searchCourses();">
                        <button onclick="searchCourses()" style="padding: 12px 16px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-weight: 700; cursor: pointer;">
                            Search
                        </button>
                    </div>
                    
                    <div id="courseSearchResults" style="min-height: 100px;">
                        <p style="text-align: center; color: #94a3b8; font-size: 14px; padding: 24px;">
                            Enter a course name or city to search
                        </p>
                    </div>
                    
                    <button onclick="closeCourseSearchModal()" style="width: 100%; margin-top: 16px; padding: 12px; background: #64748b; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeCourseSearchModal();
            };
            
            document.getElementById('courseSearchInput').focus();
        }
        
        // Close course search modal
        function closeCourseSearchModal() {
            const modal = document.getElementById('courseSearchModal');
            if (modal) modal.remove();
        }
        
        // Hardcoded API key for Golf Course API
        const GOLF_API_KEY = 'WYX3P2U672HYTIWKZ223YGFNNI';
        
        // Search courses via API
        async function searchCourses() {
            const searchTerm = document.getElementById('courseSearchInput').value.trim();
            const resultsDiv = document.getElementById('courseSearchResults');
            
            if (!searchTerm) {
                resultsDiv.innerHTML = '<p style="text-align: center; color: #ef4444; font-size: 14px; padding: 24px;">Please enter a course name or city</p>';
                return;
            }
            
            resultsDiv.innerHTML = '<p style="text-align: center; color: #3b82f6; font-size: 14px; padding: 24px;">ð Searching...</p>';
            
            try {
                const response = await fetch(`https://api.golfcourseapi.com/v1/search?search_query=${encodeURIComponent(searchTerm)}`, {
                    headers: {
                        'Authorization': `Key ${GOLF_API_KEY}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.courses || data.courses.length === 0) {
                    resultsDiv.innerHTML = '<p style="text-align: center; color: #94a3b8; font-size: 14px; padding: 24px;">No courses found. Try a different search.</p>';
                    return;
                }
                
                let html = '';
                data.courses.slice(0, 10).forEach(course => {
                    const isFavorite = favoriteCourses.some(f => f.id === course.id);
                    html += `
                        <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; padding: 12px; margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; color: #1e293b; font-size: 14px;">${course.club_name || course.course_name}</div>
                                    <div style="font-size: 12px; color: #64748b;">${course.location?.city || ''}, ${course.location?.state || ''}</div>
                                </div>
                                <button onclick="toggleFavorite('${course.id}', '${(course.club_name || course.course_name).replace(/'/g, "\\'")}', '${course.location?.city || ''}', '${course.location?.state || ''}')" 
                                    style="background: none; border: none; font-size: 20px; cursor: pointer;">
                                    ${isFavorite ? 'â­' : 'â'}
                                </button>
                            </div>
                            <button onclick="selectSearchedCourse('${course.id}')" 
                                style="width: 100%; margin-top: 8px; padding: 8px; background: #10b981; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                                Select Course
                            </button>
                        </div>
                    `;
                });
                
                resultsDiv.innerHTML = html;
                
            } catch (error) {
                console.error('Course search error:', error);
                resultsDiv.innerHTML = `<p style="text-align: center; color: #ef4444; font-size: 14px; padding: 24px;">
                    Error: ${error.message}<br><br>
                    <span style="font-size: 12px; color: #64748b;">Make sure your API key is valid and you have network access.</span>
                </p>`;
            }
        }
        
        // Toggle favorite for currently selected course
        function toggleCurrentCourseFavorite() {
            const select = document.getElementById('courseSelect');
            const selectedValue = select.value;
            
            if (!selectedValue || selectedValue === 'search_course' || selectedValue === 'custom_course') {
                return;
            }
            
            // Get course info
            let courseId, courseName, city, state;
            
            if (selectedValue.startsWith('api_')) {
                // API course
                courseId = selectedValue.replace('api_', '');
                const course = customCourses[selectedValue];
                courseName = course?.name || 'Unknown';
                city = course?.city || '';
                state = course?.state || '';
            } else if (selectedValue.startsWith('custom_')) {
                // Custom course
                courseId = selectedValue;
                const course = customCourses[selectedValue];
                courseName = course?.name || 'Unknown';
                city = course?.city || '';
                state = course?.state || '';
            } else {
                // Built-in course
                courseId = selectedValue;
                const course = courses[selectedValue];
                courseName = course?.name || 'Unknown';
                city = course?.city || '';
                state = course?.state || '';
            }
            
            // Toggle favorite
            const index = favoriteCourses.findIndex(f => String(f.id) === String(courseId));
            
            if (index >= 0) {
                favoriteCourses.splice(index, 1);
                showNotification('Removed', `${courseName} removed from favorites`);
            } else {
                favoriteCourses.push({ id: courseId, name: courseName, city, state });
                showNotification('Favorited â­', `${courseName} added to favorites`);
            }
            
            localStorage.setItem('golf_favorite_courses', JSON.stringify(favoriteCourses));
            updateFavoritesDropdown();
            updateFavoriteButton();
        }
        
        // Update the favorite button star based on current selection
        function updateFavoriteButton() {
            const select = document.getElementById('courseSelect');
            const btn = document.getElementById('favoriteBtn');
            const selectedValue = select.value;
            
            if (!btn) return;
            
            // Hide for special options or no selection
            if (!selectedValue || selectedValue === 'search_course' || selectedValue === 'custom_course' || selectedValue.startsWith('fav_')) {
                btn.style.display = 'none';
                return;
            }
            
            btn.style.display = 'flex';
            btn.style.alignItems = 'center';
            btn.style.justifyContent = 'center';
            
            // Check if current course is favorited
            let courseId = selectedValue;
            if (selectedValue.startsWith('api_')) {
                courseId = selectedValue.replace('api_', '');
            }
            
            const isFavorite = favoriteCourses.some(f => String(f.id) === String(courseId));
            btn.textContent = isFavorite ? 'â­' : 'â';
            btn.style.borderColor = isFavorite ? '#fbbf24' : '#e2e8f0';
            btn.style.background = isFavorite ? '#fef3c7' : 'white';
            btn.title = isFavorite ? 'Remove from favorites' : 'Add to favorites';
        }
        
        // Toggle favorite course (from search results)
        function toggleFavorite(courseId, name, city, state) {
            const index = favoriteCourses.findIndex(f => String(f.id) === String(courseId));
            
            if (index >= 0) {
                favoriteCourses.splice(index, 1);
            } else {
                favoriteCourses.push({ id: courseId, name, city, state });
            }
            
            localStorage.setItem('golf_favorite_courses', JSON.stringify(favoriteCourses));
            updateFavoritesDropdown();
            updateFavoriteButton();
            
            // Refresh search results if modal is open
            const resultsDiv = document.getElementById('courseSearchResults');
            if (resultsDiv && document.getElementById('courseSearchInput')?.value) {
                searchCourses();
            }
        }
        
        // Update favorites in dropdown
        function updateFavoritesDropdown() {
            const optgroup = document.getElementById('favoritesOptgroup');
            if (!optgroup) return;
            
            if (favoriteCourses.length === 0) {
                optgroup.style.display = 'none';
                optgroup.innerHTML = '';
                return;
            }
            
            optgroup.style.display = 'block';
            optgroup.innerHTML = favoriteCourses.map(fav => 
                `<option value="fav_${fav.id}">${fav.name}</option>`
            ).join('');
        }
        
        // Select a searched course
        async function selectSearchedCourse(courseId) {
            // Show loading state
            const resultsDiv = document.getElementById('courseSearchResults');
            if (resultsDiv) {
                resultsDiv.innerHTML = '<p style="text-align: center; color: #3b82f6; font-size: 14px; padding: 24px;">ð Loading course data...</p>';
            }
            
            try {
                // Fetch full course details
                const response = await fetch(`https://api.golfcourseapi.com/v1/courses/${courseId}`, {
                    headers: {
                        'Authorization': `Key ${GOLF_API_KEY}`
                    }
                });
                
                if (!response.ok) throw new Error('Failed to fetch course details');
                
                const data = await response.json();
                const course = data.course || data; // Handle both {course: {...}} and direct object
                
                console.log('API Course Data:', course);
                
                // Convert to our format and save as custom course
                const courseKey = 'api_' + courseId;
                const convertedCourse = {
                    name: course.club_name || course.course_name,
                    city: course.location?.city || '',
                    state: course.location?.state || '',
                    totalPar: 72, // Will be set from tee data
                    tees: {},
                    holes: []
                };
                
                // Convert tees - API returns {male: [...], female: [...]}
                // We'll use male tees by default (most common for men's clubs)
                let teesArray = [];
                if (course.tees) {
                    if (course.tees.male && Array.isArray(course.tees.male)) {
                        teesArray = course.tees.male;
                    } else if (course.tees.female && Array.isArray(course.tees.female)) {
                        teesArray = course.tees.female;
                    } else if (Array.isArray(course.tees)) {
                        // Fallback if it's just an array
                        teesArray = course.tees;
                    }
                }
                
                console.log('Tees array:', teesArray);
                
                // Process each tee
                let holesFromTee = null;
                teesArray.forEach(tee => {
                    const teeKey = tee.tee_name?.toLowerCase().replace(/\s+/g, '_') || 'default';
                    convertedCourse.tees[teeKey] = {
                        name: tee.tee_name || 'Default',
                        rating: parseFloat(tee.course_rating) || 72,
                        slope: parseInt(tee.slope_rating) || 113,
                        yardage: parseInt(tee.total_yards) || 6000,
                        par: parseInt(tee.par_total) || 72
                    };
                    
                    // Get total par from first tee with par_total
                    if (tee.par_total && !convertedCourse.totalPar) {
                        convertedCourse.totalPar = parseInt(tee.par_total);
                    }
                    
                    // Get holes data from first tee that has it
                    if (!holesFromTee && tee.holes && Array.isArray(tee.holes) && tee.holes.length > 0) {
                        holesFromTee = tee.holes;
                    }
                });
                
                // If no tees, create a default
                if (Object.keys(convertedCourse.tees).length === 0) {
                    convertedCourse.tees.default = { name: 'Default', rating: 72, slope: 113, yardage: 6000, par: 72 };
                }
                convertedCourse.defaultTee = Object.keys(convertedCourse.tees)[0];
                
                // Convert holes from tee data
                if (holesFromTee && holesFromTee.length > 0) {
                    convertedCourse.holes = holesFromTee.map((h, i) => ({
                        number: i + 1,
                        par: parseInt(h.par) || 4,
                        handicap: parseInt(h.handicap) || (i + 1)
                    }));
                    // Calculate totalPar from holes if not set
                    if (!convertedCourse.totalPar) {
                        convertedCourse.totalPar = convertedCourse.holes.reduce((sum, h) => sum + h.par, 0);
                    }
                } else {
                    // Create default 18 holes based on par 72
                    const defaultPars = [4,4,3,4,5,4,3,4,5,4,4,3,4,5,4,3,4,4];
                    for (let i = 0; i < 18; i++) {
                        convertedCourse.holes.push({ 
                            number: i + 1, 
                            par: defaultPars[i] || 4, 
                            handicap: i + 1 
                        });
                    }
                }
                
                console.log('Converted course:', convertedCourse);
                
                // Save to custom courses
                customCourses[courseKey] = convertedCourse;
                localStorage.setItem('golf_custom_courses', JSON.stringify(customCourses));
                
                // Add option to dropdown and select it
                const select = document.getElementById('courseSelect');
                const existingOption = select.querySelector(`option[value="${courseKey}"]`);
                if (!existingOption) {
                    const option = document.createElement('option');
                    option.value = courseKey;
                    option.textContent = convertedCourse.name;
                    select.querySelector('optgroup[label="ð Local Courses"]').appendChild(option);
                }
                
                select.value = courseKey;
                closeCourseSearchModal();
                updateCourse();
                
                // Show success with tee count
                const teeCount = Object.keys(convertedCourse.tees).length;
                const teeNames = Object.values(convertedCourse.tees).map(t => t.name).join(', ');
                showNotification('Course Added', `${convertedCourse.name} (${teeCount} tees: ${teeNames})`);
                
            } catch (error) {
                console.error('Error selecting course:', error);
                alert('Failed to load course details. Please try again.');
            }
        }
        
        // Show custom course modal
        function showCustomCourseModal() {
            const existingModal = document.getElementById('customCourseModal');
            if (existingModal) existingModal.remove();
            
            const modal = document.createElement('div');
            modal.id = 'customCourseModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 20px; max-width: 400px; width: 95%; max-height: 80vh; overflow-y: auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h2 style="color: #1e40af; font-size: 18px; margin: 0;">âï¸ Add Custom Course</h2>
                        <button onclick="closeCustomCourseModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">â</button>
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Course Name *</label>
                        <input type="text" id="customCourseName" placeholder="e.g., Pine Valley Golf Club" 
                            style="width: 100%; padding: 10px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px;">
                    </div>
                    
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <div style="flex: 1;">
                            <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Par *</label>
                            <input type="number" id="customCoursePar" placeholder="72" value="72"
                                style="width: 100%; padding: 10px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px;">
                        </div>
                        <div style="flex: 1;">
                            <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Slope *</label>
                            <input type="number" id="customCourseSlope" placeholder="113" value="113"
                                style="width: 100%; padding: 10px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px;">
                        </div>
                        <div style="flex: 1;">
                            <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Rating *</label>
                            <input type="number" id="customCourseRating" placeholder="72.0" value="72.0" step="0.1"
                                style="width: 100%; padding: 10px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px;">
                        </div>
                    </div>
                    
                    <p style="font-size: 11px; color: #94a3b8; margin-bottom: 16px; text-align: center;">
                        ð¡ Find slope & rating on the course scorecard or website
                    </p>
                    
                    <div style="display: flex; gap: 8px;">
                        <button onclick="closeCustomCourseModal()" style="flex: 1; padding: 12px; background: #e2e8f0; color: #475569; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                        <button onclick="saveCustomCourse()" style="flex: 1; padding: 12px; background: #10b981; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
                            Add Course
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeCustomCourseModal();
            };
            
            document.getElementById('customCourseName').focus();
        }
        
        // Close custom course modal
        function closeCustomCourseModal() {
            const modal = document.getElementById('customCourseModal');
            if (modal) modal.remove();
        }
        
        // Save custom course
        function saveCustomCourse() {
            const name = document.getElementById('customCourseName').value.trim();
            const par = parseInt(document.getElementById('customCoursePar').value) || 72;
            const slope = parseInt(document.getElementById('customCourseSlope').value) || 113;
            const rating = parseFloat(document.getElementById('customCourseRating').value) || 72.0;
            
            if (!name) {
                alert('Please enter a course name');
                return;
            }
            
            const courseKey = 'custom_' + Date.now();
            
            // Create default holes based on par
            const holes = [];
            const parDistribution = par <= 70 ? [4,4,3,4,3,4,4,5,4,4,3,4,4,4,3,4,4,5] : 
                                    par <= 72 ? [4,4,3,4,3,5,4,5,4,4,3,4,4,4,3,4,5,5] :
                                    [5,4,3,5,3,5,4,5,4,5,4,4,4,4,3,4,5,5];
            
            for (let i = 0; i < 18; i++) {
                holes.push({
                    number: i + 1,
                    par: parDistribution[i] || 4,
                    handicap: i + 1
                });
            }
            
            const customCourse = {
                name: name,
                totalPar: par,
                tees: {
                    default: { name: 'Default', rating: rating, slope: slope, yardage: 6000 }
                },
                defaultTee: 'default',
                holes: holes
            };
            
            customCourses[courseKey] = customCourse;
            localStorage.setItem('golf_custom_courses', JSON.stringify(customCourses));
            
            // Add to dropdown
            const select = document.getElementById('courseSelect');
            const option = document.createElement('option');
            option.value = courseKey;
            option.textContent = name;
            select.querySelector('optgroup[label="ð Local Courses"]').appendChild(option);
            
            select.value = courseKey;
            closeCustomCourseModal();
            updateCourse();
            
            showNotification('Course Added', `${name} is ready to use`);
        }
        
        // Initialize favorites dropdown on page load
        function initializeCourseDropdown() {
            updateFavoritesDropdown();
            
            // Add custom courses to dropdown
            const select = document.getElementById('courseSelect');
            const localGroup = select.querySelector('optgroup[label="ð Local Courses"]');
            
            Object.keys(customCourses).forEach(key => {
                const course = customCourses[key];
                const option = document.createElement('option');
                option.value = key;
                option.textContent = course.name;
                localGroup.appendChild(option);
            });
        }

        // Handle game type changes to show/hide team setup
        // Best Ball setup configuration
        let bestBallConfig = {
            playersPerTeam: 2,
            scoresPerHole: 1,
            format: 'stroke' // 'stroke' or 'match'
        };
        
        function handleGameTypeChange() {
            const gameType = document.getElementById('gameType').value;
            const teamSection = document.getElementById('teamSetupSection');
            const bestBallSection = document.getElementById('bestBallSetupSection');
            
            if (gameType === 'Best Ball') {
                // Show Best Ball setup options
                if (bestBallSection) bestBallSection.style.display = 'block';
                teamSection.style.display = 'block';
                renderTeamSetup(gameType);
            } else {
                // Hide Best Ball setup
                if (bestBallSection) bestBallSection.style.display = 'none';
                teamSection.style.display = 'none';
            }
        }
        
        // Set Best Ball option
        function setBestBallOption(field, value) {
            bestBallConfig[field] = value;
            
            // Update button styles
            const buttons = document.querySelectorAll(`.bestball-option-btn[data-field="${field}"]`);
            buttons.forEach(btn => {
                const btnValue = btn.dataset.value;
                const isSelected = (field === 'format') ? btnValue === value : parseInt(btnValue) === value;
                
                if (isSelected) {
                    btn.style.background = '#10b981';
                    btn.style.borderColor = '#10b981';
                    btn.style.color = 'white';
                } else {
                    btn.style.background = 'white';
                    btn.style.borderColor = '#d1d5db';
                    btn.style.color = '#475569';
                }
            });
            
            // Update team setup to reflect new players per team
            if (field === 'playersPerTeam') {
                renderTeamSetup('Best Ball');
            }
        }

        // Refresh team setup if a team game is currently selected
        function refreshTeamSetupIfNeeded() {
            const gameType = document.getElementById('gameType').value;
            if (gameType === 'Best Ball') {
                renderTeamSetup(gameType);
            }
        }

        // Render team setup based on game type
        function renderTeamSetup(gameType) {
            const content = document.getElementById('teamSetupContent');
            
            // Use bestBallConfig for players per team
            const playersPerTeam = bestBallConfig.playersPerTeam;
            
            // Get current player names from the player list
            const playerNames = [];
            const playerRows = document.querySelectorAll('.player-row');
            playerRows.forEach((row, index) => {
                const nameInput = row.querySelector('.player-name-input');
                const hcpInput = row.querySelector('.player-hcp-input');
                if (nameInput && nameInput.value.trim()) {
                    playerNames.push({
                        index: index,
                        name: nameInput.value.trim(),
                        handicap: hcpInput ? hcpInput.value : '0'
                    });
                }
            });
            
            // Calculate number of teams based on player count
            const totalPlayers = playerNames.length;
            const numTeams = totalPlayers > 0 ? Math.ceil(totalPlayers / playersPerTeam) : 2;
            
            content.innerHTML = '';
            
            if (totalPlayers === 0) {
                content.innerHTML = '<p style="color: #64748b; font-size: 14px; padding: 12px;">Add players first to create teams</p>';
                return;
            }
            
            // Create team selection dropdowns
            for (let t = 0; t < numTeams; t++) {
                const teamDiv = document.createElement('div');
                teamDiv.className = 'team-container';
                
                let teamHtml = `<div class="team-header">Team ${t + 1}</div>`;
                
                for (let p = 0; p < playersPerTeam; p++) {
                    teamHtml += `
                        <select class="team-member-select" id="team${t}_player${p}">
                            <option value="">Select Player ${p + 1}</option>
                    `;
                    
                    // Add options for each added player
                    playerNames.forEach(player => {
                        teamHtml += `<option value="${player.index}">${player.name} (${player.handicap})</option>`;
                    });
                    
                    teamHtml += `</select>`;
                }
                
                teamDiv.innerHTML = teamHtml;
                content.appendChild(teamDiv);
            }
        }

        // Auto-save functionality
        function saveToLocalStorage() {
            try {
                const data = {
                    ...tournamentData,
                    _activeTournamentId: activeTournamentId,
                    _tournamentMode: tournamentMode,
                    _isHost: isHost,
                    _hostForTournament: activeTournamentId ? activeTournamentId : null, // Tie host to specific tournament
                    _hasJoinedTournament: hasJoinedTournament, // Track if user has joined
                    _hostViewMode: hostViewMode, // Host's current view mode
                    _scoreTimestamps: scoreTimestamps, // NEWEST WINS: Save score timestamps
                    _deletedPlayers: deletedPlayers, // Tombstones for deleted players
                    _lastSaved: new Date().toISOString()
                };
                
                const jsonData = JSON.stringify(data);
                
                // Track save time for conflict resolution
                localStorage.setItem('_lastLocalSaveTime', Date.now().toString());
                
                // Save to localStorage
                localStorage.setItem('indianHillsScoring', jsonData);
                
                // VERIFY save worked by reading it back
                const verification = localStorage.getItem('indianHillsScoring');
                
                if (!verification) {
                    console.error('â SAVE VERIFICATION FAILED - localStorage returned null');
                    throw new Error('Save verification failed');
                }
                
                if (verification !== jsonData) {
                    console.error('â SAVE VERIFICATION FAILED - Data mismatch');
                    throw new Error('Save data mismatch');
                }
                
                console.log('â Data saved and verified successfully');
                showSaveIndicator();
                return true;
                
            } catch (error) {
                console.error('â SAVE ERROR:', error);
                
                // Retry once
                try {
                    console.log('ð Retrying save...');
                    const retryData = {
                        ...tournamentData,
                        _activeTournamentId: activeTournamentId,
                        _tournamentMode: tournamentMode,
                        _isHost: isHost,
                        _hostForTournament: activeTournamentId ? activeTournamentId : null,
                        _hasJoinedTournament: hasJoinedTournament,
                        _hostViewMode: hostViewMode,
                        _scoreTimestamps: scoreTimestamps,
                        _deletedPlayers: deletedPlayers,
                        _lastSaved: new Date().toISOString()
                    };
                    localStorage.setItem('indianHillsScoring', JSON.stringify(retryData));
                    console.log('â Retry successful');
                    showSaveIndicator();
                    return true;
                } catch (retryError) {
                    console.error('â RETRY FAILED:', retryError);
                    showSaveError();
                    return false;
                }
            }
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('indianHillsScoring');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    activeTournamentId = data._activeTournamentId || null;
                    tournamentMode = data._tournamentMode || 'single';
                    
                    // IMPROVED HOST RESTORATION: Only restore host if it matches the tournament
                    const savedHostForTournament = data._hostForTournament || null;
                    if (savedHostForTournament && savedHostForTournament === activeTournamentId) {
                        isHost = data._isHost || false;
                        console.log('ð Host status restored for tournament:', activeTournamentId);
                    } else if (data._isHost && activeTournamentId) {
                        // Fallback for old data format
                        isHost = data._isHost;
                        console.log('ð Host status restored (legacy format)');
                    } else {
                        isHost = false;
                    }
                    
                    // Restore join status and host view mode
                    hasJoinedTournament = data._hasJoinedTournament || false;
                    hostViewMode = data._hostViewMode || 'host';
                    
                    // NEWEST WINS: Restore score timestamps and tombstones
                    scoreTimestamps = data._scoreTimestamps || {};
                    deletedPlayers = data._deletedPlayers || {};
                    
                    // AUTO-FIX: If there's a Firebase tournament ID, it MUST be multi-device mode
                    // Firebase IDs look like T1768522029360yc63i0 (T + 13-digit timestamp + random)
                    // Local IDs look like Tmkhhwu1sfr3ql (T + base36 timestamp, shorter)
                    const isFirebaseIdLoad = activeTournamentId && /^T\d{13}/.test(activeTournamentId);
                    if (isFirebaseIdLoad && tournamentMode !== 'multi') {
                        console.log('ð§ AUTO-FIX: Detected Firebase tournament ID, forcing multi-device mode');
                        tournamentMode = 'multi';
                        isHost = true;
                    }
                    
                    // Hosts are always considered joined
                    if (isHost) {
                        hasJoinedTournament = true;
                    }
                    
                    delete data._activeTournamentId;
                    delete data._tournamentMode;
                    delete data._isHost;
                    delete data._hostForTournament;
                    delete data._hasJoinedTournament;
                    delete data._hostViewMode;
                    delete data._scoreTimestamps;
                    delete data._deletedPlayers;
                    delete data._lastSaved;
                    tournamentData = data;
                    console.log('â Loaded tournament data from localStorage');
                    console.log('ð Mode:', tournamentMode, '| Host:', isHost, '| TournamentID:', activeTournamentId);
                    console.log('ð HasJoined:', hasJoinedTournament, '| HostViewMode:', hostViewMode);
                    console.log('ð ScoreTimestamps:', Object.keys(scoreTimestamps).length, '| DeletedPlayers:', Object.keys(deletedPlayers).length);
                    return true;
                } catch (error) {
                    console.error('â Error parsing saved data:', error);
                    return false;
                }
            }
            return false;
        }
        
        // Visual save indicator
        function showSaveIndicator() {
            // Remove any existing indicator
            let indicator = document.getElementById('saveIndicator');
            if (indicator) {
                indicator.remove();
            }
            
            // Create new indicator
            indicator = document.createElement('div');
            indicator.id = 'saveIndicator';
            indicator.innerHTML = 'â Saved';
            indicator.style.cssText = `
                position: fixed;
                top: 70px;
                right: 20px;
                background: #10b981;
                color: white;
                padding: 8px 16px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 600;
                z-index: 10000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                animation: slideIn 0.3s ease-out;
            `;
            
            document.body.appendChild(indicator);
            
            // Remove after 1 second
            setTimeout(() => {
                if (indicator && indicator.parentNode) {
                    indicator.style.animation = 'slideOut 0.3s ease-out';
                    setTimeout(() => {
                        if (indicator && indicator.parentNode) {
                            indicator.remove();
                        }
                    }, 300);
                }
            }, 1000);
        }
        
        function showSaveError() {
            // Remove any existing indicator
            let indicator = document.getElementById('saveIndicator');
            if (indicator) {
                indicator.remove();
            }
            
            // Create error indicator
            indicator = document.createElement('div');
            indicator.id = 'saveIndicator';
            indicator.innerHTML = 'â ï¸ Save Failed!';
            indicator.style.cssText = `
                position: fixed;
                top: 70px;
                right: 20px;
                background: #ef4444;
                color: white;
                padding: 8px 16px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 600;
                z-index: 10000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            `;
            
            document.body.appendChild(indicator);
            
            // Keep it visible longer
            setTimeout(() => {
                if (indicator && indicator.parentNode) {
                    indicator.remove();
                }
            }, 3000);
        }
        
        // Verify that a specific score was saved correctly
        async function verifyScoreSaved(playerIndex, holeIndex, expectedScore) {
            try {
                // Longer delay for iOS to ensure localStorage write completes
                await new Promise(resolve => setTimeout(resolve, 150));
                
                const saved = localStorage.getItem('indianHillsScoring');
                if (!saved) {
                    console.error('â VERIFY: No saved data found in localStorage');
                    return false;
                }
                
                const data = JSON.parse(saved);
                const actualScore = data.players[playerIndex].scores[holeIndex];
                
                if (actualScore === expectedScore) {
                    console.log('â VERIFY: Score verified -', 
                        data.players[playerIndex].name, 
                        'Hole', holeIndex + 1, 
                        '=', actualScore);
                    return true;
                } else {
                    console.error('â VERIFY: Score mismatch!', 
                        'Expected:', expectedScore, 
                        'Got:', actualScore);
                    return false;
                }
            } catch (error) {
                console.error('â VERIFY: Error during verification:', error);
                return false;
            }
        }

        // ========================================
        // FIREBASE TOURNAMENT MANAGEMENT SYSTEM
        // ========================================
        
        // Current tournament state
        let activeTournamentId = null;
        let isHost = false;
        let isCoHost = false; // True if current device is a co-host
        let isGuestUser = false; // True if joined via invite link (no home access)
        let hasJoinedTournament = false; // True if user has claimed/watched players or joined as viewer
        let hostViewMode = 'host'; // 'host' or 'player' - for hosts to toggle their view
        let claimedPlayers = []; // Players this device can edit
        let tournamentUnsubscribe = null;
        let lastFirebaseWriteTime = 0; // Track when we last wrote to Firebase
        
        // Helper function to check if current device can manage tournament
        function canManageTournament() {
            return isHost || isCoHost;
        }
        
        // Helper function to check if host/co-host is in player view mode
        function isHostInPlayerMode() {
            return (isHost || canManageTournament()) && hostViewMode === 'player';
        }
        
        // NEWEST-WINS SYNC: Track score timestamps and deletion tombstones
        let scoreTimestamps = {}; // { "playerName-holeIndex": timestamp }
        let deletedPlayers = {}; // { "playerName": deletedAtTimestamp } - tombstones to prevent zombies
        
        // STATS TRACKER: Track which stats are enabled and player stats data
        let statsTrackerConfig = {
            putts: false,
            dots: false,
            fir: false,  // Fairway in Regulation (not on par 3s)
            gir: false   // Green in Regulation
        };
        
        // AUTO-ADVANCE: Settings and state
        let autoAdvanceEnabled = true; // Default enabled
        let autoAdvanceTimer = null;
        let autoAdvanceCountdown = 3; // seconds
        
        // Load auto-advance setting from localStorage
        function loadAutoAdvanceSetting() {
            const saved = localStorage.getItem('autoAdvanceEnabled');
            if (saved !== null) {
                autoAdvanceEnabled = saved === 'true';
            }
        }
        
        // Save auto-advance setting
        function saveAutoAdvanceSetting() {
            localStorage.setItem('autoAdvanceEnabled', autoAdvanceEnabled);
        }
        
        // Toggle auto-advance on/off
        function toggleAutoAdvance() {
            autoAdvanceEnabled = !autoAdvanceEnabled;
            saveAutoAdvanceSetting();
            showNotification(
                autoAdvanceEnabled ? 'â Auto-Advance ON' : 'â¸ï¸ Auto-Advance OFF',
                autoAdvanceEnabled ? 'Will auto-advance when hole is complete' : 'Manual hole changes only'
            );
        }
        
        // Check if all players have completed the current hole (scores + enabled stats)
        function isHoleComplete(holeIndex) {
            if (!tournamentData || !tournamentData.players) return false;
            
            // Get players we're tracking (claimed + watched for non-hosts, all for hosts)
            let playersToCheck = [];
            
            if (tournamentMode === 'multi' && (!canManageTournament() || isHostInPlayerMode())) {
                // Non-host: only check claimed players (not watched - we don't control their stats)
                playersToCheck = tournamentData.players.filter(p => p.claimedBy === currentDeviceId);
            } else {
                // Host: check all players
                playersToCheck = tournamentData.players;
            }
            
            if (playersToCheck.length === 0) return false;
            
            for (const player of playersToCheck) {
                // Check score
                const score = player.scores ? player.scores[holeIndex] : null;
                if (!score || score === 0) {
                    return false;
                }
                
                // Check enabled stats
                const stats = playerStats[player.name];
                
                // Check putts if enabled
                if (statsTrackerConfig.putts) {
                    const putts = stats?.putts?.[holeIndex];
                    if (putts === null || putts === undefined) {
                        return false;
                    }
                }
                
                // Check dots if enabled
                if (statsTrackerConfig.dots) {
                    const dots = stats?.dots?.[holeIndex];
                    if (dots === null || dots === undefined) {
                        return false;
                    }
                }
                
                // Check FIR if enabled (skip par 3s)
                if (statsTrackerConfig.fir) {
                    const holePar = courseData?.holes?.[holeIndex]?.par || 4;
                    if (holePar > 3) { // Only check FIR on non-par-3s
                        const fir = stats?.fir?.[holeIndex];
                        if (fir === null || fir === undefined) {
                            return false;
                        }
                    }
                }
                
                // Check GIR if enabled
                if (statsTrackerConfig.gir) {
                    const gir = stats?.gir?.[holeIndex];
                    if (gir === null || gir === undefined) {
                        return false;
                    }
                }
            }
            
            return true;
        }
        
        // Check and trigger auto-advance if hole is complete
        function checkAutoAdvance() {
            if (!autoAdvanceEnabled) return;
            if (currentHole === undefined) return;
            if (autoAdvanceTimer) return; // Already counting down
            
            // Only check in hole view
            const holeViewContent = document.getElementById('holeViewContent');
            if (!holeViewContent || !holeViewContent.innerHTML) return;
            
            if (isHoleComplete(currentHole)) {
                // Don't auto-advance from hole 18
                if (currentHole === 17) {
                    showNotification('ð Round Complete!', 'All scores entered for hole 18');
                    return;
                }
                
                startAutoAdvanceCountdown();
            }
        }
        
        // Start countdown for auto-advance
        function startAutoAdvanceCountdown() {
            let countdown = autoAdvanceCountdown;
            const nextHole = currentHole + 2; // Display as 1-indexed
            
            // Show countdown toast
            showAutoAdvanceToast(countdown, nextHole);
            
            autoAdvanceTimer = setInterval(() => {
                countdown--;
                
                if (countdown <= 0) {
                    clearInterval(autoAdvanceTimer);
                    autoAdvanceTimer = null;
                    hideAutoAdvanceToast();
                    
                    // Actually advance to next hole
                    goToNextHole();
                    showNotification('â³', `Now on Hole ${nextHole}`);
                } else {
                    updateAutoAdvanceToast(countdown);
                }
            }, 1000);
        }
        
        // Cancel auto-advance countdown
        function cancelAutoAdvance() {
            if (autoAdvanceTimer) {
                clearInterval(autoAdvanceTimer);
                autoAdvanceTimer = null;
            }
            hideAutoAdvanceToast();
        }
        
        // Show auto-advance toast
        function showAutoAdvanceToast(seconds, nextHole) {
            // Remove existing toast if any
            hideAutoAdvanceToast();
            
            const toast = document.createElement('div');
            toast.id = 'autoAdvanceToast';
            toast.style.cssText = `
                position: fixed;
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                color: white;
                padding: 12px 20px;
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 10002;
                display: flex;
                align-items: center;
                gap: 12px;
                font-size: 14px;
                font-weight: 600;
                animation: slideUp 0.3s ease;
            `;
            
            toast.innerHTML = `
                <span>â Hole complete! Next hole in <span id="autoAdvanceSeconds">${seconds}</span>...</span>
                <button onclick="cancelAutoAdvance()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 6px 12px; border-radius: 6px; font-weight: 600; cursor: pointer;">
                    Stay
                </button>
            `;
            
            document.body.appendChild(toast);
        }
        
        // Update countdown in toast
        function updateAutoAdvanceToast(seconds) {
            const secondsEl = document.getElementById('autoAdvanceSeconds');
            if (secondsEl) {
                secondsEl.textContent = seconds;
            }
        }
        
        // Hide auto-advance toast
        function hideAutoAdvanceToast() {
            const toast = document.getElementById('autoAdvanceToast');
            if (toast) toast.remove();
        }
        
        // Player stats data: { "playerName": { putts: [hole1, hole2...], dots: [...], fir: [...], gir: [...] } }
        let playerStats = {};
        
        // Load stats config from localStorage
        function loadStatsConfig() {
            const saved = localStorage.getItem('statsTrackerConfig');
            if (saved) {
                try {
                    statsTrackerConfig = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading stats config:', e);
                }
            }
        }
        
        // Save stats config to localStorage
        function saveStatsConfig() {
            localStorage.setItem('statsTrackerConfig', JSON.stringify(statsTrackerConfig));
        }
        
        // Toggle a stat on/off
        function toggleStat(statName) {
            statsTrackerConfig[statName] = !statsTrackerConfig[statName];
            saveStatsConfig();
            showMyPlayersPage(); // Refresh the page to update UI
        }
        
        // Initialize player stats for a player if not exists
        function initPlayerStats(playerName) {
            if (!playerStats[playerName]) {
                playerStats[playerName] = {
                    putts: new Array(18).fill(null),
                    dots: new Array(18).fill(null),
                    fir: new Array(18).fill(null),
                    gir: new Array(18).fill(null)
                };
            }
        }
        
        // Update a stat for a player on a specific hole
        function updatePlayerStat(playerName, statType, holeIndex, value) {
            initPlayerStats(playerName);
            playerStats[playerName][statType][holeIndex] = value;
            savePlayerStatsToLocalStorage();
            
            // Check if hole is complete for auto-advance
            setTimeout(() => checkAutoAdvance(), 500);
        }
        
        // Save player stats to localStorage
        function savePlayerStatsToLocalStorage() {
            localStorage.setItem('playerStats', JSON.stringify(playerStats));
        }
        
        // Load player stats from localStorage
        function loadPlayerStatsFromLocalStorage() {
            const saved = localStorage.getItem('playerStats');
            if (saved) {
                try {
                    playerStats = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading player stats:', e);
                    playerStats = {};
                }
            }
        }
        
        // Get stat totals for a player
        function getPlayerStatTotals(playerName) {
            initPlayerStats(playerName);
            const stats = playerStats[playerName];
            
            // Calculate putts total
            const puttsTotal = stats.putts.reduce((sum, val) => sum + (val || 0), 0);
            const puttsHoles = stats.putts.filter(v => v !== null).length;
            
            // Calculate dots total
            const dotsTotal = stats.dots.reduce((sum, val) => sum + (val || 0), 0);
            
            // Calculate FIR (only count non-par-3 holes)
            let firHit = 0, firTotal = 0;
            if (courseData && courseData.holes) {
                courseData.holes.forEach((hole, i) => {
                    if (hole.par !== 3 && stats.fir[i] !== null) {
                        firTotal++;
                        if (stats.fir[i]) firHit++;
                    }
                });
            }
            
            // Calculate GIR
            let girHit = 0, girTotal = 0;
            stats.gir.forEach(val => {
                if (val !== null) {
                    girTotal++;
                    if (val) girHit++;
                }
            });
            
            return { puttsTotal, puttsHoles, dotsTotal, firHit, firTotal, girHit, girTotal };
        }
        
        // ==================== STATS HISTORY SYSTEM ====================
        
        const MAX_STATS_HISTORY = 50; // Keep last 50 rounds of stats
        
        // Get stats history from localStorage
        function getStatsHistory() {
            try {
                const history = localStorage.getItem('statsHistory');
                return history ? JSON.parse(history) : [];
            } catch (error) {
                console.error('Error reading stats history:', error);
                return [];
            }
        }
        
        // Save stats history to localStorage
        function saveStatsHistory(history) {
            try {
                localStorage.setItem('statsHistory', JSON.stringify(history));
            } catch (error) {
                console.error('Error saving stats history:', error);
            }
        }
        
        // Save current round stats to history
        function saveStatsToHistory() {
            if (!tournamentData || !tournamentData.players) return;
            
            const history = getStatsHistory();
            
            // Create stats entry for this round
            const roundStats = {
                id: activeTournamentId || `local_${Date.now()}`,
                date: tournamentData.date || new Date().toISOString().split('T')[0],
                course: tournamentData.course || 'Unknown',
                courseName: getCourseDisplayName(tournamentData.course),
                gameType: tournamentData.gameType || 'Stroke Play',
                savedAt: Date.now(),
                players: {}
            };
            
            // Save each player's stats and scores
            tournamentData.players.forEach(player => {
                const stats = playerStats[player.name] || {
                    putts: new Array(18).fill(null),
                    dots: new Array(18).fill(null),
                    fir: new Array(18).fill(null),
                    gir: new Array(18).fill(null)
                };
                
                // Calculate totals
                const totals = getPlayerStatTotals(player.name);
                const totalScore = player.scores ? player.scores.reduce((sum, s) => sum + (s || 0), 0) : 0;
                const holesPlayed = player.scores ? player.scores.filter(s => s > 0).length : 0;
                
                roundStats.players[player.name] = {
                    scores: [...(player.scores || [])],
                    handicap: player.handicap || 0,
                    handicapIndex: player.handicapIndex || null,
                    totalScore: totalScore,
                    holesPlayed: holesPlayed,
                    putts: [...stats.putts],
                    dots: [...stats.dots],
                    fir: [...stats.fir],
                    gir: [...stats.gir],
                    totals: totals
                };
            });
            
            // Remove existing entry for same tournament ID if present
            const filteredHistory = history.filter(h => h.id !== roundStats.id);
            
            // Add new entry at the beginning
            filteredHistory.unshift(roundStats);
            
            // Keep only last N rounds
            const trimmedHistory = filteredHistory.slice(0, MAX_STATS_HISTORY);
            
            saveStatsHistory(trimmedHistory);
            console.log('â Stats saved to history:', roundStats.id);
            
            return roundStats;
        }
        
        // Get aggregated stats for a specific player across all rounds
        function getPlayerAggregateStats(playerName, dateFilter = 'all') {
            let history = getStatsHistory();
            
            // Apply date filter
            if (dateFilter !== 'all') {
                const now = new Date();
                let cutoffDate;
                
                switch (dateFilter) {
                    case '7d':
                        cutoffDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                        break;
                    case '30d':
                        cutoffDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                        break;
                    case '90d':
                        cutoffDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
                        break;
                    case 'ytd':
                        cutoffDate = new Date(now.getFullYear(), 0, 1); // Jan 1 of current year
                        break;
                    default:
                        cutoffDate = null;
                }
                
                if (cutoffDate) {
                    history = history.filter(round => {
                        const roundDate = new Date(round.date + 'T00:00:00');
                        return roundDate >= cutoffDate;
                    });
                }
            }
            
            let totalRounds = 0;
            let totalPutts = 0;
            let totalPuttsHoles = 0;
            let totalDots = 0;
            let totalDotsRounds = 0;
            let firHit = 0;
            let firTotal = 0;
            let girHit = 0;
            let girTotal = 0;
            let totalStrokes = 0;
            let totalHolesPlayed = 0;
            let rounds = [];
            
            history.forEach(round => {
                const playerData = round.players[playerName];
                if (playerData && playerData.holesPlayed > 0) {
                    totalRounds++;
                    
                    // Scores
                    totalStrokes += playerData.totalScore || 0;
                    totalHolesPlayed += playerData.holesPlayed || 0;
                    
                    // Putts
                    if (playerData.totals) {
                        if (playerData.totals.puttsHoles > 0) {
                            totalPutts += playerData.totals.puttsTotal || 0;
                            totalPuttsHoles += playerData.totals.puttsHoles || 0;
                        }
                        
                        // Dots
                        if (playerData.totals.dotsTotal > 0) {
                            totalDots += playerData.totals.dotsTotal || 0;
                            totalDotsRounds++;
                        }
                        
                        // FIR
                        firHit += playerData.totals.firHit || 0;
                        firTotal += playerData.totals.firTotal || 0;
                        
                        // GIR
                        girHit += playerData.totals.girHit || 0;
                        girTotal += playerData.totals.girTotal || 0;
                    }
                    
                    // Add to rounds list
                    rounds.push({
                        date: round.date,
                        course: round.courseName || round.course,
                        score: playerData.totalScore,
                        holes: playerData.holesPlayed,
                        putts: playerData.totals?.puttsTotal || 0,
                        puttsHoles: playerData.totals?.puttsHoles || 0,
                        dots: playerData.totals?.dotsTotal || 0,
                        fir: playerData.totals?.firHit || 0,
                        firTotal: playerData.totals?.firTotal || 0,
                        gir: playerData.totals?.girHit || 0,
                        girTotal: playerData.totals?.girTotal || 0
                    });
                }
            });
            
            return {
                totalRounds,
                avgScore: totalHolesPlayed > 0 ? (totalStrokes / totalHolesPlayed * 18).toFixed(1) : '--',
                avgPutts: totalPuttsHoles > 0 ? (totalPutts / totalPuttsHoles * 18).toFixed(1) : '--',
                puttsPerHole: totalPuttsHoles > 0 ? (totalPutts / totalPuttsHoles).toFixed(2) : '--',
                avgDots: totalDotsRounds > 0 ? (totalDots / totalDotsRounds).toFixed(1) : '--',
                firPct: firTotal > 0 ? ((firHit / firTotal) * 100).toFixed(0) + '%' : '--',
                girPct: girTotal > 0 ? ((girHit / girTotal) * 100).toFixed(0) + '%' : '--',
                rounds: rounds.slice(0, 10) // Last 10 rounds
            };
        }
        
        // Show stats history modal
        function showStatsHistoryModal(playerName = null, dateFilter = 'all') {
            const history = getStatsHistory();
            
            // Get unique players from history
            const allPlayers = new Set();
            history.forEach(round => {
                Object.keys(round.players).forEach(name => allPlayers.add(name));
            });
            
            // If no player specified, use first player or current user's claimed players
            if (!playerName && allPlayers.size > 0) {
                // Try to find a claimed player
                if (tournamentData && tournamentData.players) {
                    const claimed = tournamentData.players.find(p => p.claimedBy === currentDeviceId);
                    if (claimed && allPlayers.has(claimed.name)) {
                        playerName = claimed.name;
                    }
                }
                // Fallback to first player in history
                if (!playerName) {
                    playerName = Array.from(allPlayers)[0];
                }
            }
            
            const modal = document.createElement('div');
            modal.id = 'statsHistoryModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.85); z-index: 10001;
                display: flex; align-items: center; justify-content: center;
                padding: 20px;
            `;
            
            if (history.length === 0) {
                modal.innerHTML = `
                    <div style="background: white; border-radius: 16px; padding: 24px; max-width: 400px; width: 100%; text-align: center;">
                        <h3 style="margin: 0 0 16px 0; color: #1e40af;">ð Stats History</h3>
                        <p style="color: #64748b; margin-bottom: 20px;">No stats history yet. Complete a round with stat tracking enabled to see your history here.</p>
                        <button onclick="document.getElementById('statsHistoryModal').remove()" 
                            style="padding: 12px 24px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
                            Got It
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);
                return;
            }
            
            // Store current filter state for updates
            window.statsHistoryDateFilter = dateFilter;
            
            const stats = getPlayerAggregateStats(playerName, dateFilter);
            
            // Player selector dropdown
            const playerOptions = Array.from(allPlayers).map(name => 
                `<option value="${name}" ${name === playerName ? 'selected' : ''}>${name}</option>`
            ).join('');
            
            // Date filter options
            const dateFilters = [
                { value: 'all', label: 'All Time' },
                { value: '7d', label: 'Last 7 Days' },
                { value: '30d', label: 'Last 30 Days' },
                { value: '90d', label: 'Last 90 Days' },
                { value: 'ytd', label: 'This Year' }
            ];
            const dateFilterOptions = dateFilters.map(f => 
                `<option value="${f.value}" ${f.value === dateFilter ? 'selected' : ''}>${f.label}</option>`
            ).join('');
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; max-width: 500px; width: 100%; max-height: 85vh; overflow-y: auto;">
                    <div style="padding: 20px; border-bottom: 1px solid #e2e8f0; position: sticky; top: 0; background: white; border-radius: 16px 16px 0 0; z-index: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <h3 style="margin: 0; color: #1e40af;">ð Stats History</h3>
                            <button onclick="document.getElementById('statsHistoryModal').remove()" 
                                style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">Ã</button>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <select id="statsPlayerSelect" onchange="updateStatsHistoryPlayer(this.value)" 
                                style="flex: 1; padding: 10px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px; color: #1e40af;">
                                ${playerOptions}
                            </select>
                            <select id="statsDateFilter" onchange="updateStatsHistoryDateFilter(this.value)" 
                                style="flex: 1; padding: 10px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px; color: #64748b;">
                                ${dateFilterOptions}
                            </select>
                        </div>
                    </div>
                    
                    <div id="statsHistoryContent" style="padding: 20px;">
                        ${renderStatsHistoryContent(playerName, stats)}
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
        }
        
        // Update stats history when player selection changes
        function updateStatsHistoryPlayer(playerName) {
            const dateFilter = window.statsHistoryDateFilter || 'all';
            const stats = getPlayerAggregateStats(playerName, dateFilter);
            const content = document.getElementById('statsHistoryContent');
            if (content) {
                content.innerHTML = renderStatsHistoryContent(playerName, stats);
            }
        }
        
        // Update stats history when date filter changes
        function updateStatsHistoryDateFilter(dateFilter) {
            window.statsHistoryDateFilter = dateFilter;
            const playerSelect = document.getElementById('statsPlayerSelect');
            const playerName = playerSelect ? playerSelect.value : null;
            if (playerName) {
                const stats = getPlayerAggregateStats(playerName, dateFilter);
                const content = document.getElementById('statsHistoryContent');
                if (content) {
                    content.innerHTML = renderStatsHistoryContent(playerName, stats);
                }
            }
        }
        
        // Render stats history content
        function renderStatsHistoryContent(playerName, stats) {
            if (stats.totalRounds === 0) {
                return `<p style="text-align: center; color: #64748b;">No rounds found for ${playerName}</p>`;
            }
            
            let roundsHtml = '';
            stats.rounds.forEach((round, idx) => {
                const scoreColor = round.holes === 18 ? '#1e40af' : '#64748b';
                roundsHtml += `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; ${idx < stats.rounds.length - 1 ? 'border-bottom: 1px solid #f1f5f9;' : ''}">
                        <div>
                            <div style="font-weight: 600; color: #1e293b; font-size: 13px;">${round.course}</div>
                            <div style="font-size: 11px; color: #64748b;">${formatDate(round.date)}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-weight: 700; color: ${scoreColor}; font-size: 16px;">${round.score}</div>
                            <div style="font-size: 10px; color: #94a3b8;">${round.holes} holes</div>
                        </div>
                    </div>
                `;
            });
            
            return `
                <!-- Aggregate Stats -->
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 20px;">
                    <div style="background: linear-gradient(135deg, #3b82f6, #1e40af); border-radius: 12px; padding: 14px; text-align: center; color: white;">
                        <div style="font-size: 11px; opacity: 0.9; margin-bottom: 4px;">Rounds</div>
                        <div style="font-size: 24px; font-weight: 700;">${stats.totalRounds}</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #10b981, #059669); border-radius: 12px; padding: 14px; text-align: center; color: white;">
                        <div style="font-size: 11px; opacity: 0.9; margin-bottom: 4px;">Avg Score</div>
                        <div style="font-size: 24px; font-weight: 700;">${stats.avgScore}</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #8b5cf6, #6d28d9); border-radius: 12px; padding: 14px; text-align: center; color: white;">
                        <div style="font-size: 11px; opacity: 0.9; margin-bottom: 4px;">Avg Putts</div>
                        <div style="font-size: 24px; font-weight: 700;">${stats.avgPutts}</div>
                    </div>
                </div>
                
                <!-- Detailed Stats -->
                <div style="background: #f8fafc; border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                    <div style="font-weight: 600; color: #1e293b; margin-bottom: 12px; font-size: 14px;">Performance Averages</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: #64748b; font-size: 13px;">Putts/Hole:</span>
                            <span style="font-weight: 600; color: #1e293b;">${stats.puttsPerHole}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: #64748b; font-size: 13px;">Avg Dots:</span>
                            <span style="font-weight: 600; color: #10b981;">${stats.avgDots}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: #64748b; font-size: 13px;">FIR %:</span>
                            <span style="font-weight: 600; color: #1e293b;">${stats.firPct}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: #64748b; font-size: 13px;">GIR %:</span>
                            <span style="font-weight: 600; color: #1e293b;">${stats.girPct}</span>
                        </div>
                    </div>
                </div>
                
                <!-- Recent Rounds -->
                <div>
                    <div style="font-weight: 600; color: #1e293b; margin-bottom: 12px; font-size: 14px;">Recent Rounds</div>
                    <div style="background: white; border: 1px solid #e2e8f0; border-radius: 12px; padding: 12px;">
                        ${roundsHtml || '<p style="text-align: center; color: #94a3b8; font-size: 13px;">No rounds yet</p>'}
                    </div>
                </div>
                
                <!-- Clear History Button -->
                <button onclick="confirmClearStatsHistory()" 
                    style="width: 100%; margin-top: 20px; padding: 12px; background: #fee2e2; color: #dc2626; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 13px;">
                    ðï¸ Clear Stats History
                </button>
            `;
        }
        
        // Format date helper
        function formatDate(dateStr) {
            try {
                const date = new Date(dateStr + 'T00:00:00');
                return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            } catch {
                return dateStr;
            }
        }
        
        // Confirm clear stats history
        function confirmClearStatsHistory() {
            if (confirm('Are you sure you want to clear all stats history? This cannot be undone.')) {
                saveStatsHistory([]);
                document.getElementById('statsHistoryModal').remove();
                showNotification('ðï¸ Cleared', 'Stats history has been cleared');
            }
        }
        
        // ==================== END STATS HISTORY ====================
        
        // Show stat popup for putts/dots (numeric input)
        function showStatPopup(playerName, statType, holeIndex) {
            initPlayerStats(playerName);
            const currentVal = playerStats[playerName][statType][holeIndex];
            
            const modal = document.createElement('div');
            modal.id = 'statPopupModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            const title = statType === 'putts' ? 'â³ Putts' : '<span style="color: #10b981;">â</span> Dots';
            
            // Build buttons for 0-4
            let buttonsRow1 = '';
            for (let i = 0; i <= 4; i++) {
                const isSelected = currentVal === i;
                buttonsRow1 += `
                    <button onclick="setStatValue('${playerName}', '${statType}', ${holeIndex}, ${i})" 
                        style="width: 52px; height: 52px; border-radius: 10px; border: 2px solid ${isSelected ? '#3b82f6' : '#e2e8f0'}; 
                        background: ${isSelected ? '#3b82f6' : 'white'}; color: ${isSelected ? 'white' : '#1e293b'}; 
                        font-size: 22px; font-weight: 700; cursor: pointer;">${i}</button>
                `;
            }
            
            // Check if current value is 5+
            const isManualSelected = currentVal !== null && currentVal >= 5;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; max-width: 340px; width: 90%; text-align: center;">
                    <h2 style="color: #1e40af; margin-bottom: 8px; font-size: 20px;">${title}</h2>
                    <p style="color: #64748b; font-size: 13px; margin-bottom: 16px;">Hole ${holeIndex + 1} â¢ ${playerName}</p>
                    <div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 12px;">
                        ${buttonsRow1}
                    </div>
                    <div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 20px;">
                        <button onclick="showManualStatInput('${playerName}', '${statType}', ${holeIndex})" 
                            style="width: 80px; height: 52px; border-radius: 10px; border: 2px solid ${isManualSelected ? '#3b82f6' : '#e2e8f0'}; 
                            background: ${isManualSelected ? '#3b82f6' : 'white'}; color: ${isManualSelected ? 'white' : '#1e293b'}; 
                            font-size: 20px; font-weight: 700; cursor: pointer;">${isManualSelected ? currentVal : '#'}</button>
                    </div>
                    <div style="display: flex; gap: 12px;">
                        <button onclick="clearStatValue('${playerName}', '${statType}', ${holeIndex})" 
                            style="flex: 1; padding: 12px; background: #fee2e2; color: #ef4444; border: none; border-radius: 10px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Clear
                        </button>
                        <button onclick="closeStatPopup()" 
                            style="flex: 1; padding: 12px; background: #e2e8f0; color: #64748b; border: none; border-radius: 10px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeStatPopup();
            };
        }
        
        // Show manual input for stat values 5+
        function showManualStatInput(playerName, statType, holeIndex) {
            const currentVal = playerStats[playerName]?.[statType]?.[holeIndex];
            const defaultVal = currentVal >= 5 ? currentVal : 5;
            
            const input = prompt(`Enter ${statType} count:`, defaultVal);
            if (input !== null) {
                const val = parseInt(input);
                if (!isNaN(val) && val >= 0) {
                    setStatValue(playerName, statType, holeIndex, val);
                }
            }
        }
        
        // Set stat value and close popup
        function setStatValue(playerName, statType, holeIndex, value) {
            updatePlayerStat(playerName, statType, holeIndex, value);
            closeStatPopup();
            renderHoleView(); // Refresh the view
        }
        
        // Clear stat value
        function clearStatValue(playerName, statType, holeIndex) {
            updatePlayerStat(playerName, statType, holeIndex, null);
            closeStatPopup();
            renderHoleView();
        }
        
        // Close stat popup
        function closeStatPopup() {
            const modal = document.getElementById('statPopupModal');
            if (modal) modal.remove();
        }
        
        // Toggle boolean stat (FIR/GIR) - cycles through null -> true -> false -> null
        function toggleBooleanStat(playerName, statType, holeIndex) {
            initPlayerStats(playerName);
            const currentVal = playerStats[playerName][statType][holeIndex];
            
            let newVal;
            if (currentVal === null || currentVal === undefined) {
                newVal = true; // First tap = hit
            } else if (currentVal === true) {
                newVal = false; // Second tap = miss
            } else {
                newVal = null; // Third tap = clear
            }
            
            updatePlayerStat(playerName, statType, holeIndex, newVal);
            renderHoleView();
        }
        
        // ==================== JOIN CODE FUNCTIONS ====================
        
        // Generate a random join code (4 letters + 2 numbers, e.g., GOLF42)
        function generateJoinCode() {
            const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ'; // Excluded I and O to avoid confusion
            const numbers = '0123456789';
            
            let code = '';
            for (let i = 0; i < 4; i++) {
                code += letters.charAt(Math.floor(Math.random() * letters.length));
            }
            for (let i = 0; i < 2; i++) {
                code += numbers.charAt(Math.floor(Math.random() * numbers.length));
            }
            
            return code;
        }
        
        // Check if a join code is already in use
        async function isJoinCodeTaken(code) {
            try {
                const snapshot = await db.collection('tournaments')
                    .where('joinCode', '==', code.toUpperCase())
                    .limit(1)
                    .get();
                return !snapshot.empty;
            } catch (error) {
                console.error('Error checking join code:', error);
                return true; // Assume taken on error to be safe
            }
        }
        
        // Generate a unique join code (retry if taken)
        async function generateUniqueJoinCode() {
            let code = generateJoinCode();
            let attempts = 0;
            const maxAttempts = 10;
            
            while (await isJoinCodeTaken(code) && attempts < maxAttempts) {
                code = generateJoinCode();
                attempts++;
            }
            
            if (attempts >= maxAttempts) {
                console.warn('Could not generate unique code after max attempts, using timestamp fallback');
                code = generateJoinCode() + Date.now().toString().slice(-2);
            }
            
            return code;
        }
        
        // Generate host code for co-host access (6 alphanumeric characters)
        function generateHostCode() {
            // Generate host code in same format as join code: 4 letters + 2 numbers
            const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ'; // Excluded I and O to avoid confusion
            const numbers = '0123456789';
            
            let code = '';
            for (let i = 0; i < 4; i++) {
                code += letters.charAt(Math.floor(Math.random() * letters.length));
            }
            for (let i = 0; i < 2; i++) {
                code += numbers.charAt(Math.floor(Math.random() * numbers.length));
            }
            
            return code;
        }
        
        // Look up tournament by join code
        async function findTournamentByCode(code) {
            try {
                const normalizedCode = code.toUpperCase().trim();
                
                // Validate format: 4 letters + 2 numbers
                if (!/^[A-Z]{4}[0-9]{2}$/.test(normalizedCode)) {
                    return { success: false, error: 'Invalid code format. Use 4 letters + 2 numbers (e.g., GOLF42)' };
                }
                
                const snapshot = await db.collection('tournaments')
                    .where('joinCode', '==', normalizedCode)
                    .limit(1)
                    .get();
                
                if (snapshot.empty) {
                    return { success: false, error: 'Tournament not found. Check the code and try again.' };
                }
                
                const tournamentDoc = snapshot.docs[0];
                const tournament = tournamentDoc.data();
                
                if (tournament.status === 'ended') {
                    return { success: false, error: 'This tournament has ended.' };
                }
                
                return { success: true, tournamentId: tournamentDoc.id, tournament: tournament };
            } catch (error) {
                console.error('Error finding tournament by code:', error);
                return { success: false, error: 'Failed to look up tournament. Please try again.' };
            }
        }
        
        // Validate join code format (4 letters + 2 numbers)
        function isValidJoinCodeFormat(code) {
            return /^[A-Za-z]{4}[0-9]{2}$/.test(code.trim());
        }
        
        // Update join code for a tournament (host only)
        async function updateJoinCode(tournamentId, newCode) {
            try {
                const normalizedCode = newCode.toUpperCase().trim();
                
                // Validate format
                if (!isValidJoinCodeFormat(normalizedCode)) {
                    return { success: false, error: 'Invalid format. Use 4 letters + 2 numbers (e.g., GOLF42)' };
                }
                
                // Check if code is already taken by another tournament
                const snapshot = await db.collection('tournaments')
                    .where('joinCode', '==', normalizedCode)
                    .limit(1)
                    .get();
                
                if (!snapshot.empty && snapshot.docs[0].id !== tournamentId) {
                    return { success: false, error: 'This code is already in use. Try another.' };
                }
                
                // Update the tournament
                await db.collection('tournaments').doc(tournamentId).update({
                    joinCode: normalizedCode,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                return { success: true, code: normalizedCode };
            } catch (error) {
                console.error('Error updating join code:', error);
                return { success: false, error: 'Failed to update code. Please try again.' };
            }
        }
        
        // ==================== END JOIN CODE FUNCTIONS ====================
        
        // Create a new cloud tournament
        async function createCloudTournament(tournamentConfig) {
            try {
                // Check if Firebase is loaded
                if (typeof firebase === 'undefined' || !db) {
                    console.error('Firebase not ready - firebase:', typeof firebase, 'db:', !!db);
                    throw new Error('Firebase is not loaded yet. Please wait a moment and try again.');
                }
                
                // Wait for authentication if not ready
                if (!currentUserId || !currentDeviceId) {
                    console.log('Waiting for Firebase authentication...');
                    console.log('currentUserId:', currentUserId, 'currentDeviceId:', currentDeviceId);
                    
                    await new Promise((resolve) => {
                        let attempts = 0;
                        const checkAuth = setInterval(() => {
                            attempts++;
                            console.log(`Auth check attempt ${attempts}:`, currentUserId, currentDeviceId);
                            if (currentUserId && currentDeviceId) {
                                console.log('Authentication successful!');
                                clearInterval(checkAuth);
                                resolve();
                            }
                        }, 100);
                        // Timeout after 10 seconds
                        setTimeout(() => {
                            console.log('Authentication timeout after 10 seconds');
                            clearInterval(checkAuth);
                            resolve();
                        }, 10000);
                    });
                }
                
                // If still not authenticated, throw error
                if (!currentUserId || !currentDeviceId) {
                    console.error('Auth failed - currentUserId:', currentUserId, 'currentDeviceId:', currentDeviceId);
                    throw new Error('Device authentication failed. Please refresh the page and try again.');
                }
                
                const tournamentId = 'T' + Date.now() + Math.random().toString(36).substr(2, 6);
                
                // Generate join code (4 letters + 2 numbers)
                const joinCode = await generateUniqueJoinCode();
                
                // Generate host code (6 alphanumeric characters for co-host access)
                const hostCode = generateHostCode();
                
                // Get course data to store with tournament - try multiple sources
                let tournamentCourseData = courses[tournamentConfig.course] || customCourses[tournamentConfig.course];
                
                // Fallback to global courseData if it matches
                if (!tournamentCourseData && courseData && courseData.holes) {
                    console.log('ð Using global courseData for tournament');
                    tournamentCourseData = courseData;
                }
                
                console.log('Tournament course data check:', {
                    course: tournamentConfig.course,
                    foundInCourses: !!courses[tournamentConfig.course],
                    foundInCustom: !!customCourses[tournamentConfig.course],
                    usingGlobal: tournamentCourseData === courseData,
                    hasData: !!tournamentCourseData,
                    hasHoles: tournamentCourseData?.holes?.length
                });
                
                // Create tournament in Firestore (no Firebase Auth required)
                console.log('Creating cloud tournament:', tournamentId);
                const tournament = {
                    id: tournamentId,
                    ...tournamentConfig,
                    joinCode: joinCode,
                    hostCode: hostCode, // Secret code to gain co-host access
                    hostDevice: currentDeviceId, // Original host device
                    hostDeviceId: currentDeviceId,
                    hostUserId: currentUserId,
                    hostName: currentAuthUser?.displayName || deviceInitials || 'Host', // Host's display name
                    coHosts: [], // Array of device IDs with co-host access
                    status: 'open', // open, active, locked, ended
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    // Store course data so it's available when loading later
                    courseData: tournamentCourseData ? {
                        name: tournamentCourseData.name,
                        holes: tournamentCourseData.holes,
                        totalPar: tournamentCourseData.totalPar,
                        tees: tournamentCourseData.tees
                    } : null,
                    // Keep players from tournamentConfig (don't overwrite with empty array)
                    devices: {
                        [currentDeviceId]: {
                            name: getDeviceName(),
                            userId: currentUserId,
                            connectedAt: firebase.firestore.FieldValue.serverTimestamp(),
                            lastActive: firebase.firestore.FieldValue.serverTimestamp(),
                            isHost: true
                        }
                    },
                    enabledGames: tournamentConfig.enabledGames || [tournamentConfig.gameType]
                };
                
                console.log('Creating tournament:', tournamentId);
                await db.collection('tournaments').doc(tournamentId).set(tournament);
                
                activeTournamentId = tournamentId;
                isHost = true;
                
                // Add to tournament history
                addToTournamentHistory({
                    id: tournamentId,
                    joinCode: joinCode,
                    name: tournamentConfig.name || '',
                    course: tournamentConfig.course,
                    date: tournamentConfig.date,
                    gameType: tournamentConfig.gameType,
                    playerCount: tournamentConfig.players ? tournamentConfig.players.length : 0,
                    role: 'host'
                });
                
                console.log('Tournament created successfully!');
                return tournamentId;
            } catch (error) {
                console.error('Error creating tournament:', error);
                // Don't show alert here - let the calling function handle it
                throw error; // Re-throw so the catch in startScoring can handle it
            }
        }
        
        // Join existing tournament
        async function joinTournament(tournamentId, playerInfo) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                
                if (!tournamentDoc.exists) {
                    alert('Tournament not found!');
                    return false;
                }
                
                const tournament = tournamentDoc.data();
                
                if (tournament.status === 'ended') {
                    alert('This tournament has ended!');
                    return false;
                }
                
                // Add player and register device
                await tournamentRef.update({
                    players: firebase.firestore.FieldValue.arrayUnion({
                        ...playerInfo,
                        joinedAt: new Date().toISOString(),
                        claimedBy: currentDeviceId,
                        scores: new Array(18).fill(null)
                    }),
                    [`devices.${currentDeviceId}`]: {
                        name: getDeviceName(),
                        userId: currentUserId,
                        connectedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastActive: firebase.firestore.FieldValue.serverTimestamp(),
                        isHost: false
                    }
                });
                
                activeTournamentId = tournamentId;
                claimedPlayers = [playerInfo.name];
                
                // Subscribe to tournament updates
                subscribToTournamentUpdates(tournamentId);
                
                return true;
            } catch (error) {
                console.error('Error joining tournament:', error);
                alert('Failed to join tournament. Please try again.');
                return false;
            }
        }
        
        // Claim additional players (for scoring a foursome)
        async function claimAdditionalPlayer(tournamentId, playerName) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Find the player
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) {
                    alert('Player not found!');
                    return false;
                }
                
                const player = tournament.players[playerIndex];
                
                // Check if already claimed
                if (player.claimedBy && player.claimedBy !== currentDeviceId) {
                    alert(`${playerName} is already being scored by another device!`);
                    return false;
                }
                
                // Claim the player
                tournament.players[playerIndex].claimedBy = currentDeviceId;
                
                await tournamentRef.update({
                    players: tournament.players
                });
                
                claimedPlayers.push(playerName);
                return true;
            } catch (error) {
                console.error('Error claiming player:', error);
                return false;
            }
        }
        
        // Update player score
        async function updatePlayerScore(tournamentId, playerName, holeIndex, score) {
            console.log('ð¥ updatePlayerScore called:');
            console.log('   tournamentId:', tournamentId);
            console.log('   playerName:', playerName);
            console.log('   holeIndex:', holeIndex);
            console.log('   score:', score);
            
            // NEWEST WINS: Record timestamp for this score change
            const now = Date.now();
            const timestampKey = `${playerName}-${holeIndex}`;
            scoreTimestamps[timestampKey] = now;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                
                // Use a transaction to ensure atomic read-modify-write
                // This prevents race conditions where multiple devices overwrite each other
                await db.runTransaction(async (transaction) => {
                    const tournamentDoc = await transaction.get(tournamentRef);
                    
                    if (!tournamentDoc.exists) {
                        throw new Error('Tournament does not exist');
                    }
                    
                    const tournament = tournamentDoc.data();
                    console.log('   Fetched tournament from Firebase (in transaction)');
                    
                    const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                    if (playerIndex === -1) {
                        throw new Error('Player not found: ' + playerName);
                    }
                    
                    console.log('   Found player at index:', playerIndex);
                    
                    // Check permissions - hosts and co-hosts can edit any player
                    if (!canManageTournament() && tournament.players[playerIndex].claimedBy !== currentDeviceId) {
                        throw new Error('Permission denied - not your player');
                    }
                    
                    console.log('   Permission check passed');
                    
                    // Initialize scores array if it doesn't exist
                    if (!tournament.players[playerIndex].scores) {
                        tournament.players[playerIndex].scores = new Array(18).fill(null);
                        console.log('   Initialized scores array');
                    }
                    
                    // Initialize scoreTimestamps array if it doesn't exist
                    if (!tournament.players[playerIndex].scoreTimestamps) {
                        tournament.players[playerIndex].scoreTimestamps = new Array(18).fill(0);
                    }
                    
                    // Only update if our score is newer or no timestamp exists
                    const existingTimestamp = tournament.players[playerIndex].scoreTimestamps[holeIndex] || 0;
                    if (now >= existingTimestamp) {
                        tournament.players[playerIndex].scores[holeIndex] = score;
                        tournament.players[playerIndex].scoreTimestamps[holeIndex] = now;
                        console.log('   Updated score with timestamp:', now);
                    } else {
                        console.log('   Skipping update - existing score is newer');
                    }
                    
                    // Mark that WE are writing to Firebase
                    lastFirebaseWriteTime = Date.now();
                    
                    // Update with the LATEST player array from Firebase (not our local stale copy)
                    transaction.update(tournamentRef, {
                        players: tournament.players,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                });
                
                console.log('â Score successfully written to Firebase via transaction!');
                return true;
            } catch (error) {
                console.error('â Error updating score:', error);
                console.error('   Error details:', error.message);
                
                // If permission denied, show alert
                if (error.message && error.message.includes('Permission denied')) {
                    alert('You cannot edit this player\'s scores!');
                }
                
                return false;
            }
        }
        
        // Subscribe to real-time tournament updates
        function subscribToTournamentUpdates(tournamentId) {
            console.log('ð¡ Subscribing to tournament updates:', tournamentId);
            
            if (tournamentUnsubscribe) {
                tournamentUnsubscribe();
            }
            
            tournamentUnsubscribe = db.collection('tournaments')
                .doc(tournamentId)
                .onSnapshot((doc) => {
                    if (doc.exists) {
                        const tournament = doc.data();
                        console.log('ð¥ Received tournament update from Firebase');
                        console.log('   Players:', tournament.players.length);
                        console.log('   Sample scores:', tournament.players[0]?.scores?.slice(0, 3));
                        
                        // CHECK FOR WATCHED PLAYER SCORE CHANGES (before updating local state)
                        checkWatchedPlayerScoreChanges(tournament);
                        
                        // FIX: Always process updates - the NEWEST-WINS merge logic in 
                        // updateLocalTournamentState will handle conflicts properly.
                        // We no longer skip updates entirely just because we recently wrote.
                        // The merge logic compares timestamps per-hole, so our recent write
                        // will be preserved while still accepting other devices' scores.
                        
                        const timeSinceOurWrite = Date.now() - lastFirebaseWriteTime;
                        if (lastFirebaseWriteTime > 0 && timeSinceOurWrite < 2000) {
                            console.log('ð Recent write detected (' + timeSinceOurWrite + 'ms ago) - still merging but our scores protected by timestamps');
                        }
                        
                        updateLocalTournamentState(tournament);
                        updateLiveLeaderboard(tournament);
                        
                        // Refresh UI if on scoring page - BUT not if user is actively editing
                        if (document.getElementById('scoringPage').classList.contains('active')) {
                            const activeElement = document.activeElement;
                            const isEditingScore = activeElement && 
                                                 (activeElement.classList.contains('score-input') || 
                                                  activeElement.tagName === 'INPUT');
                            
                            if (!isEditingScore) {
                                // Clear any pending refresh
                                if (window.subscriptionRefreshTimeout) {
                                    clearTimeout(window.subscriptionRefreshTimeout);
                                }
                                
                                // Debounce: Wait 300ms after last update before re-rendering
                                console.log('ð Scheduling scoring page refresh...');
                                window.subscriptionRefreshTimeout = setTimeout(() => {
                                    console.log('ð Refreshing scoring page UI from subscription');
                                    renderScoringPage();
                                }, 300);
                            } else {
                                console.log('â¸ï¸ User is editing - skipping refresh');
                            }
                        }
                        
                        // Check for notifications
                        if (tournament.status === 'ended' && !sessionStorage.getItem('tournamentEndedNotified_' + tournamentId)) {
                            sessionStorage.setItem('tournamentEndedNotified_' + tournamentId, 'true');
                            showNotification('Tournament Complete!', 'Tap to view final results');
                        }
                    } else {
                        console.warn('â ï¸ Tournament document does not exist');
                    }
                }, (error) => {
                    console.error('â Error listening to tournament:', error);
                });
        }
        
        // Notification mute state
        let watchedPlayerNotificationsMuted = false;
        
        // Load mute state from localStorage
        function loadNotificationMuteState() {
            const muted = localStorage.getItem('watchedPlayerNotificationsMuted');
            watchedPlayerNotificationsMuted = muted === 'true';
        }
        
        // Toggle notification mute
        function toggleWatchedNotifications() {
            watchedPlayerNotificationsMuted = !watchedPlayerNotificationsMuted;
            localStorage.setItem('watchedPlayerNotificationsMuted', watchedPlayerNotificationsMuted);
            
            // Update UI
            updateNotificationToggleUI();
            
            showNotification(
                watchedPlayerNotificationsMuted ? 'ð Muted' : 'ð Unmuted',
                watchedPlayerNotificationsMuted ? 'Score notifications silenced' : 'You\'ll see score updates'
            );
        }
        
        // Update the notification toggle button UI
        function updateNotificationToggleUI() {
            const btn = document.getElementById('notificationToggleBtn');
            if (btn) {
                if (watchedPlayerNotificationsMuted) {
                    btn.innerHTML = 'ð';
                    btn.title = 'Notifications muted - tap to unmute';
                    btn.style.background = '#94a3b8';
                } else {
                    btn.innerHTML = 'ð';
                    btn.title = 'Notifications on - tap to mute';
                    btn.style.background = '#3b82f6';
                }
            }
        }
        
        // Check for score changes on watched players and notify
        function checkWatchedPlayerScoreChanges(newTournament) {
            // Skip if muted or no local data yet
            if (watchedPlayerNotificationsMuted) return;
            if (!tournamentData || !tournamentData.players) return;
            if (!playerOrder || !playerOrder.watching || playerOrder.watching.length === 0) return;
            
            // Get list of watched player names
            const watchedNames = playerOrder.watching;
            
            newTournament.players.forEach(newPlayer => {
                // Only check watched players (not claimed by us)
                if (!watchedNames.includes(newPlayer.name)) return;
                if (newPlayer.claimedBy === currentDeviceId) return; // Don't notify for our own players
                
                // Find the old player data
                const oldPlayer = tournamentData.players.find(p => p.name === newPlayer.name);
                if (!oldPlayer) return;
                
                // Compare scores hole by hole
                for (let i = 0; i < 18; i++) {
                    const oldScore = oldPlayer.scores ? oldPlayer.scores[i] : null;
                    const newScore = newPlayer.scores ? newPlayer.scores[i] : null;
                    
                    // Detect new score entry (was null/0, now has value)
                    if ((!oldScore || oldScore === 0) && newScore && newScore > 0) {
                        const holeNum = i + 1;
                        const par = courseData?.holes?.[i]?.par || 4;
                        const diff = newScore - par;
                        let diffText = '';
                        if (diff === 0) diffText = ' (Par)';
                        else if (diff < 0) diffText = ` (${diff})`;
                        else diffText = ` (+${diff})`;
                        
                        // Get first name for shorter notification
                        const firstName = newPlayer.name.split(' ')[0];
                        
                        showNotification(
                            `ðï¸ ${firstName}`,
                            `Scored ${newScore}${diffText} on Hole ${holeNum}`
                        );
                        
                        console.log(`ð Watched player notification: ${newPlayer.name} scored ${newScore} on hole ${holeNum}`);
                        
                        // Only show one notification per update (don't spam if multiple holes updated)
                        return;
                    }
                }
            });
        }
        
        // Update local state from cloud data - NEWEST WINS approach
        function updateLocalTournamentState(tournament) {
            console.log('ð¥ NEWEST-WINS SYNC: Merging tournament data from cloud:', {
                players: tournament.players.length,
                hasScores: tournament.players.some(p => p.scores && p.scores.some(s => s > 0))
            });
            
            // CRITICAL: Load course data from tournament if we don't have it
            if ((!courseData || !courseData.holes) && tournament.courseData) {
                console.log('ð Loading courseData from Firebase tournament:', tournament.courseData.name);
                courseData = tournament.courseData;
                customCourses[tournament.course] = tournament.courseData;
            }
            
            // Sync tombstones from Firebase - merge with local tombstones
            const cloudTombstones = tournament.deletedPlayers || {};
            Object.keys(cloudTombstones).forEach(playerName => {
                const cloudTimestamp = cloudTombstones[playerName];
                const localTimestamp = deletedPlayers[playerName] || 0;
                // Keep the most recent tombstone
                if (cloudTimestamp > localTimestamp) {
                    deletedPlayers[playerName] = cloudTimestamp;
                    console.log(`ðª¦ TOMBSTONE synced from cloud: "${playerName}" deleted at ${cloudTimestamp}`);
                }
            });
            
            // Initialize tournamentData if it doesn't exist
            if (!tournamentData) {
                tournamentData = {
                    id: tournament.id,
                    name: tournament.name || '',
                    date: tournament.date,
                    course: tournament.course,
                    gameType: tournament.gameType,
                    enabledGames: tournament.enabledGames || [tournament.gameType],
                    players: [],
                    teams: tournament.teams || [],
                    courseData: tournament.courseData
                };
            }
            
            // Also ensure courseData is in tournamentData
            if (tournament.courseData && !tournamentData.courseData) {
                tournamentData.courseData = tournament.courseData;
            }
            
            // Always update non-score data from cloud
            tournamentData.date = tournament.date;
            tournamentData.course = tournament.course;
            tournamentData.gameType = tournament.gameType;
            tournamentData.enabledGames = tournament.enabledGames || [tournament.gameType];
            tournamentData.name = tournament.name || '';
            
            // NEWEST-WINS: Merge players intelligently
            const now = Date.now();
            const mergedPlayers = [];
            
            // Build a map of local players by name
            const localPlayerMap = {};
            if (tournamentData.players) {
                tournamentData.players.forEach(p => {
                    localPlayerMap[p.name] = p;
                });
            }
            
            // Process cloud players
            tournament.players.forEach(cloudPlayer => {
                const localPlayer = localPlayerMap[cloudPlayer.name];
                
                // Check if this player was deleted locally (tombstone check)
                const deletedAt = deletedPlayers[cloudPlayer.name];
                const cloudPlayerAddedAt = cloudPlayer.addedAt ? new Date(cloudPlayer.addedAt).getTime() : 0;
                
                if (deletedAt && cloudPlayerAddedAt < deletedAt) {
                    console.log(`ðª¦ TOMBSTONE: Blocking zombie player "${cloudPlayer.name}" (deleted at ${deletedAt}, added at ${cloudPlayerAddedAt})`);
                    return; // Skip this player - they were deleted after being added
                }
                
                if (!localPlayer) {
                    // New player from cloud - accept them
                    console.log(`â NEW PLAYER from cloud: ${cloudPlayer.name}`);
                    mergedPlayers.push({
                        name: cloudPlayer.name,
                        handicap: cloudPlayer.handicap,
                        scores: cloudPlayer.scores || new Array(18).fill(null),
                        putts: cloudPlayer.putts || new Array(18).fill(null),
                        claimedBy: cloudPlayer.claimedBy,
                        addedAt: cloudPlayer.addedAt || now
                    });
                } else {
                    // Existing player - MERGE scores using timestamps (newest wins)
                    const mergedScores = new Array(18).fill(null);
                    
                    for (let holeIdx = 0; holeIdx < 18; holeIdx++) {
                        const localScore = localPlayer.scores ? localPlayer.scores[holeIdx] : null;
                        const cloudScore = cloudPlayer.scores ? cloudPlayer.scores[holeIdx] : null;
                        const timestampKey = `${cloudPlayer.name}-${holeIdx}`;
                        const localTimestamp = scoreTimestamps[timestampKey] || 0;
                        const cloudTimestamp = cloudPlayer.scoreTimestamps ? (cloudPlayer.scoreTimestamps[holeIdx] || 0) : 0;
                        
                        // NEWEST WINS logic
                        if (localScore !== null && cloudScore !== null) {
                            // Both have scores - use newest
                            if (localTimestamp >= cloudTimestamp) {
                                mergedScores[holeIdx] = localScore;
                                console.log(`ð¡ï¸ KEPT LOCAL: ${cloudPlayer.name} H${holeIdx + 1} = ${localScore} (local: ${localTimestamp}, cloud: ${cloudTimestamp})`);
                            } else {
                                mergedScores[holeIdx] = cloudScore;
                                // Update our timestamp to cloud's
                                scoreTimestamps[timestampKey] = cloudTimestamp;
                                console.log(`âï¸ TOOK CLOUD: ${cloudPlayer.name} H${holeIdx + 1} = ${cloudScore} (local: ${localTimestamp}, cloud: ${cloudTimestamp})`);
                            }
                        } else if (localScore !== null) {
                            // Only local has score - keep it
                            mergedScores[holeIdx] = localScore;
                            console.log(`ð¡ï¸ LOCAL ONLY: ${cloudPlayer.name} H${holeIdx + 1} = ${localScore}`);
                        } else if (cloudScore !== null) {
                            // Only cloud has score - accept it
                            mergedScores[holeIdx] = cloudScore;
                            if (cloudTimestamp) {
                                scoreTimestamps[timestampKey] = cloudTimestamp;
                            }
                            console.log(`âï¸ CLOUD ONLY: ${cloudPlayer.name} H${holeIdx + 1} = ${cloudScore}`);
                        }
                        // else both null - keep null
                    }
                    
                    mergedPlayers.push({
                        name: cloudPlayer.name,
                        handicap: cloudPlayer.handicap,
                        scores: mergedScores,
                        putts: cloudPlayer.putts || localPlayer.putts || new Array(18).fill(null),
                        claimedBy: cloudPlayer.claimedBy, // Always use cloud's claim status
                        addedAt: cloudPlayer.addedAt || localPlayer.addedAt || now
                    });
                    
                    // Remove from local map since we processed it
                    delete localPlayerMap[cloudPlayer.name];
                }
            });
            
            // Add any local players that weren't in cloud (unless deleted)
            Object.values(localPlayerMap).forEach(localPlayer => {
                // Check if this player was deleted (has tombstone)
                const deletedAt = deletedPlayers[localPlayer.name];
                if (deletedAt) {
                    console.log(`ðª¦ TOMBSTONE BLOCK: Not re-adding local player "${localPlayer.name}" (deleted at ${deletedAt})`);
                    return; // Don't re-add deleted players
                }
                
                // Only keep local-only players if they were recently added (within last 5 minutes)
                // This helps with offline support while preventing stale data from persisting
                const addedAt = localPlayer.addedAt || 0;
                const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
                
                if (addedAt > fiveMinutesAgo) {
                    console.log(`ð  LOCAL ONLY PLAYER: ${localPlayer.name} (keeping - recently added)`);
                    mergedPlayers.push(localPlayer);
                } else {
                    console.log(`ðï¸ REMOVING STALE LOCAL PLAYER: ${localPlayer.name} (not in cloud, added ${Math.round((Date.now() - addedAt) / 60000)}m ago)`);
                    // Don't add - this player was removed from cloud and shouldn't persist
                }
            });
            
            tournamentData.players = mergedPlayers;
            
            // Update co-host status
            const coHosts = tournament.coHosts || [];
            isCoHost = coHosts.includes(currentDeviceId);
            console.log('ð Co-host status:', isCoHost, '| CoHosts:', coHosts);
            
            console.log('â NEWEST-WINS SYNC complete:', {
                finalPlayerCount: tournamentData.players.length,
                sampleScores: tournamentData.players[0]?.scores?.slice(0, 3)
            });
            
            // Save merged state
            saveToLocalStorage();
        }
        
        // Host/Co-host: Reassign player to different device
        async function reassignPlayer(tournamentId, playerName, newDeviceId) {
            if (!canManageTournament()) {
                alert('Only hosts and co-hosts can reassign players!');
                return false;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) return false;
                
                tournament.players[playerIndex].claimedBy = newDeviceId;
                
                await tournamentRef.update({
                    players: tournament.players
                });
                
                return true;
            } catch (error) {
                console.error('Error reassigning player:', error);
                return false;
            }
        }
        
        // Host/Co-host: Lock tournament (no more joins)
        async function lockTournament(tournamentId) {
            if (!canManageTournament()) return false;
            
            try {
                await db.collection('tournaments').doc(tournamentId).update({
                    status: 'locked',
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error locking tournament:', error);
                return false;
            }
        }
        
        // Host/Co-host: End tournament
        async function endTournament(tournamentId) {
            if (!canManageTournament()) return false;
            
            try {
                await db.collection('tournaments').doc(tournamentId).update({
                    status: 'ended',
                    endedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Send notifications to all players
                sendTournamentEndNotification(tournamentId);
                
                return true;
            } catch (error) {
                console.error('Error ending tournament:', error);
                return false;
            }
        }
        
        // Host: Add player manually during tournament
        function addPlayerManually() {
            if (!canManageTournament()) {
                showNotification('Error', 'Only hosts can add players');
                return;
            }
            
            const modal = document.createElement('div');
            modal.id = 'addPlayerModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; max-width: 340px; width: 100%;">
                    <h2 style="color: #1e40af; font-size: 18px; margin: 0 0 16px 0; text-align: center;">â Add Player</h2>
                    
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 6px; color: #475569; font-weight: 600; font-size: 14px;">Player Name</label>
                        <input type="text" id="manualPlayerName" placeholder="Enter name" 
                            style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 16px; box-sizing: border-box;">
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 6px; color: #475569; font-weight: 600; font-size: 14px;">HCP Index</label>
                        <input type="number" id="manualPlayerHcp" placeholder="0" step="0.1" min="-10" max="54"
                            style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 16px; text-align: center; box-sizing: border-box;">
                    </div>
                    
                    <div style="display: flex; gap: 12px;">
                        <button onclick="closeAddPlayerModal()" 
                            style="flex: 1; padding: 14px; background: #f1f5f9; border: none; border-radius: 10px; color: #475569; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                        <button onclick="submitManualPlayer()" 
                            style="flex: 1; padding: 14px; background: #10b981; border: none; border-radius: 10px; color: white; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Add Player
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Focus the name input
            setTimeout(() => document.getElementById('manualPlayerName')?.focus(), 100);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeAddPlayerModal();
            };
        }
        
        function closeAddPlayerModal() {
            const modal = document.getElementById('addPlayerModal');
            if (modal) modal.remove();
        }
        
        async function submitManualPlayer() {
            const nameInput = document.getElementById('manualPlayerName');
            const hcpInput = document.getElementById('manualPlayerHcp');
            
            const name = nameInput?.value.trim();
            const handicapIndex = parseFloat(hcpInput?.value) || 0;
            
            if (!name) {
                showNotification('Error', 'Please enter a player name');
                return;
            }
            
            // Check if player already exists
            if (tournamentData.players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                showNotification('Error', 'Player already exists in tournament');
                return;
            }
            
            // Calculate course handicap
            let courseHandicap = handicapIndex;
            if (courseData && courseData.tees && tournamentData.tee) {
                const teeData = courseData.tees[tournamentData.tee];
                if (teeData) {
                    courseHandicap = calculateCourseHandicap(handicapIndex, teeData.slope, teeData.rating, courseData.totalPar);
                }
            }
            
            const newPlayer = {
                name: name,
                handicapIndex: handicapIndex,
                handicap: courseHandicap,
                scores: new Array(18).fill(0),
                claimedBy: null
            };
            
            try {
                // Add to Firebase
                const updatedPlayers = [...tournamentData.players, newPlayer];
                await db.collection('tournaments').doc(activeTournamentId).update({
                    players: updatedPlayers,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update local
                tournamentData.players = updatedPlayers;
                saveToLocalStorage();
                
                closeAddPlayerModal();
                showNotification('Added', `${name} added to tournament`);
                
                // Update player history for quick add
                updatePlayerHistory(name, handicapIndex);
                
            } catch (error) {
                console.error('Error adding player:', error);
                showNotification('Error', 'Could not add player');
            }
        }
        
        // Get device name for display
        function getDeviceName() {
            const deviceType = /iPhone/i.test(navigator.userAgent) ? 'iPhone' :
                              /iPad/i.test(navigator.userAgent) ? 'iPad' :
                              /Android/i.test(navigator.userAgent) ? 'Android' :
                              'Device';
            
            // Try to get a friendly name from localStorage
            const customName = localStorage.getItem('deviceName');
            return customName || deviceType;
        }
        
        // Send tournament end notification
        function sendTournamentEndNotification(tournamentId) {
            // This will use web push notifications if permitted
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification('ð Tournament Complete!', {
                    body: 'Tap to view final results',
                    icon: '/apple-touch-icon.png',
                    badge: '/apple-touch-icon.png',
                    tag: 'tournament-ended-' + tournamentId
                });
            }
        }
        
        // Request notification permission
        function requestNotificationPermission() {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        console.log('Notifications enabled');
                    }
                });
            }
        }
        
        // Show in-app notification
        function showNotification(title, message, requireDismiss = false) {
            // Create notification UI element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #1e40af;
                color: white;
                padding: 16px 24px;
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                max-width: 90%;
                text-align: center;
                animation: slideDown 0.3s ease;
            `;
            
            notification.innerHTML = `
                <div style="font-weight: 700; margin-bottom: 4px;">${title}</div>
                <div style="font-size: 14px;">${message}</div>
                ${requireDismiss ? '<button onclick="this.parentElement.remove()" style="margin-top: 12px; background: white; color: #1e40af; border: none; padding: 8px 16px; border-radius: 6px; font-weight: 600; cursor: pointer;">OK</button>' : ''}
            `;
            
            document.body.appendChild(notification);
            
            // Auto-dismiss after 4 seconds only if not requiring manual dismissal
            if (!requireDismiss) {
                setTimeout(() => {
                    notification.style.animation = 'slideUp 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }, 4000);
            }
        }
        
        // Generate shareable tournament link
        function getShareLink(tournamentId) {
            return window.location.origin + window.location.pathname + '?join=' + tournamentId;
        }
        
        // Check URL for join parameter on page load
        function checkForJoinLink() {
            const urlParams = new URLSearchParams(window.location.search);
            const joinId = urlParams.get('join');
            if (joinId) {
                // Mark as guest user - they can only participate in this tournament
                isGuestUser = true;
                hasJoinedTournament = false; // Not joined yet, just arrived via link
                
                // Load tournament data first for display
                db.collection('tournaments').doc(joinId).get()
                    .then(doc => {
                        if (doc.exists) {
                            const tournament = doc.data();
                            activeTournamentId = joinId;
                            tournamentMode = 'multi';
                            isHost = false;
                            
                            tournamentData = {
                                id: joinId,
                                name: tournament.name || '',
                                date: tournament.date,
                                gameType: tournament.gameType,
                                course: tournament.course,
                                players: tournament.players || [],
                                teams: tournament.teams || [],
                                courseData: tournament.courseData // Include embedded course data!
                            };
                            
                            // Load course data from tournament if available
                            if (tournament.courseData) {
                                courseData = tournament.courseData;
                                customCourses[tournament.course] = tournament.courseData;
                                console.log('ð Loaded course data from joined tournament:', tournament.courseData.name);
                            } else {
                                // Try to load from built-in courses
                                courseData = courses[tournament.course] || customCourses[tournament.course];
                            }
                            
                            saveToLocalStorage();
                            subscribToTournamentUpdates(joinId);
                            
                            // Go directly to My Players page for claiming
                            showMyPlayersPage();
                        } else {
                            showNotification('Error', 'Tournament not found');
                            showPage('hostHomePage');
                            updateHostHomePage();
                        }
                    })
                    .catch(error => {
                        console.error('Error loading tournament from link:', error);
                        showNotification('Error', 'Failed to load tournament');
                        showPage('hostHomePage');
                        updateHostHomePage();
                    });
            } else {
                // No join link - check if device has claimed players from a previous session
                checkForPreviousSession();
            }
        }
        
        // Check if this device has claimed players from a previous session
        async function checkForPreviousSession() {
            const savedData = localStorage.getItem('indianHillsScoring');
            if (!savedData) return;
            
            try {
                const data = JSON.parse(savedData);
                const savedTournamentId = data._activeTournamentId;
                const savedMode = data._tournamentMode;
                
                // Only check for multi-device tournaments
                if (savedMode !== 'multi' || !savedTournamentId) return;
                
                // Check if tournament still exists and this device has claimed players
                const tournamentDoc = await db.collection('tournaments').doc(savedTournamentId).get();
                if (!tournamentDoc.exists) {
                    console.log('Previous tournament no longer exists');
                    // Clear the old data
                    localStorage.removeItem('indianHillsScoring');
                    return;
                }
                
                const tournament = tournamentDoc.data();
                
                // Skip if tournament is finished - don't show Welcome Back for finished tournaments
                if (tournament.isFinished) {
                    console.log('Previous tournament is finished - clearing session');
                    localStorage.removeItem('indianHillsScoring');
                    localStorage.removeItem('activeTournamentId');
                    return;
                }
                
                const myClaimedPlayers = tournament.players.filter(p => p.claimedBy === currentDeviceId);
                
                if (myClaimedPlayers.length > 0) {
                    // Device has claimed players - show Keep/Release dialog
                    showKeepReleaseDialog(savedTournamentId, tournament, myClaimedPlayers);
                }
            } catch (error) {
                console.error('Error checking for previous session:', error);
            }
        }
        
        // Show dialog asking user to Keep or Release their claimed players
        function showKeepReleaseDialog(tournamentId, tournament, claimedPlayers) {
            const playerNames = claimedPlayers.map(p => p.name).join(', ');
            const tournamentName = tournament.name || `${tournament.course} - ${tournament.gameType}`;
            
            const modal = document.createElement('div');
            modal.id = 'keepReleaseModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; max-width: 400px; width: 100%; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 16px;">â³</div>
                    <h2 style="color: #1e40af; margin-bottom: 12px; font-size: 20px;">Welcome Back!</h2>
                    <p style="color: #64748b; margin-bottom: 16px; font-size: 14px;">
                        You were scoring for <strong>${playerNames}</strong> in:
                    </p>
                    <p style="color: #1e293b; font-weight: 600; margin-bottom: 20px; padding: 12px; background: #f1f5f9; border-radius: 8px;">
                        ${tournamentName}
                    </p>
                    <p style="color: #64748b; margin-bottom: 24px; font-size: 14px;">
                        Would you like to continue scoring or select different players?
                    </p>
                    <div style="display: flex; gap: 12px;">
                        <button onclick="handleReleaseAndChoose('${tournamentId}')" style="flex: 1; padding: 14px; background: #ef4444; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Release & Choose
                        </button>
                        <button onclick="handleKeepPlayers('${tournamentId}')" style="flex: 1; padding: 14px; background: #10b981; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Keep & Continue
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Keep claimed players and continue scoring
        async function handleKeepPlayers(tournamentId) {
            document.getElementById('keepReleaseModal')?.remove();
            
            try {
                const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                if (!tournamentDoc.exists) {
                    showNotification('Error', 'Tournament no longer exists');
                    return;
                }
                
                const tournament = tournamentDoc.data();
                
                // Set up tournament state
                activeTournamentId = tournamentId;
                tournamentMode = 'multi';
                isHost = false;
                
                // Get claimed players
                claimedPlayers = tournament.players
                    .filter(p => p.claimedBy === currentDeviceId)
                    .map(p => p.name);
                
                // Load tournament data
                tournamentData = {
                    id: tournamentId,
                    name: tournament.name || '',
                    date: tournament.date,
                    gameType: tournament.gameType,
                    course: tournament.course,
                    players: tournament.players,
                    teams: tournament.teams || [],
                    courseData: tournament.courseData
                };
                
                // Load course data
                if (tournament.courseData) {
                    courseData = tournament.courseData;
                    customCourses[tournament.course] = tournament.courseData;
                } else {
                    courseData = courses[tournament.course] || customCourses[tournament.course];
                }
                
                saveToLocalStorage();
                subscribToTournamentUpdates(tournamentId);
                
                // Go directly to scoring
                renderScoringPage();
                showPage('scoringPage');
                switchToHoleView();
                
                showNotification('Welcome Back!', `Continuing with ${claimedPlayers.join(', ')}`);
            } catch (error) {
                console.error('Error keeping players:', error);
                showNotification('Error', 'Failed to restore session');
            }
        }
        
        // Release all claimed players and show join screen
        async function handleReleaseAndChoose(tournamentId) {
            document.getElementById('keepReleaseModal')?.remove();
            
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                if (!tournamentDoc.exists) {
                    showNotification('Error', 'Tournament no longer exists');
                    return;
                }
                
                const tournament = tournamentDoc.data();
                
                // Release all players claimed by this device
                let released = [];
                tournament.players.forEach(p => {
                    if (p.claimedBy === currentDeviceId) {
                        released.push(p.name);
                        p.claimedBy = null;
                    }
                });
                
                // Update tournament
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Clear local claimed players
                claimedPlayers = [];
                playerOrder.claimed = [];
                savePlayerOrder();
                
                // Set up tournament state
                activeTournamentId = tournamentId;
                tournamentMode = 'multi';
                isHost = false;
                
                // Load tournament data
                tournamentData = {
                    id: tournamentId,
                    name: tournament.name || '',
                    date: tournament.date,
                    gameType: tournament.gameType,
                    course: tournament.course,
                    players: tournament.players,
                    teams: tournament.teams || [],
                    courseData: tournament.courseData
                };
                
                // Load course data
                if (tournament.courseData) {
                    courseData = tournament.courseData;
                    customCourses[tournament.course] = tournament.courseData;
                } else {
                    courseData = courses[tournament.course] || customCourses[tournament.course];
                }
                
                saveToLocalStorage();
                subscribToTournamentUpdates(tournamentId);
                
                // Show join screen with available players
                showJoinTournamentScreen(tournamentId);
                
                showNotification('Players Released', `${released.join(', ')} are now available`);
            } catch (error) {
                console.error('Error releasing players:', error);
                showNotification('Error', 'Failed to release players');
            }
        }
        
        // Generate share link and display it
        function generateShareLink(tournamentId) {
            const shareLink = getShareLink(tournamentId);
            
            // Show notification with option to view
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: white;
                color: #1e40af;
                padding: 16px 24px;
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                max-width: 90%;
                text-align: center;
            `;
            notification.innerHTML = `
                <div style="font-weight: 700; margin-bottom: 8px;">ð Tournament Ready!</div>
                <div style="font-size: 14px; margin-bottom: 12px;">Share this link or QR code for others to join</div>
                <button onclick="copyShareLink('${shareLink}')" style="padding: 8px 16px; background: #1e40af; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; margin-right: 8px;">
                    ð Copy Link
                </button>
                <button onclick="showQRCode('${tournamentId}')" style="padding: 8px 16px; background: #10b981; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
                    ð± Show QR
                </button>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideDown 0.3s ease reverse';
                setTimeout(() => notification.remove(), 300);
            }, 8000);
        }
        
        // Copy share link to clipboard
        function copyShareLink(link) {
            navigator.clipboard.writeText(link).then(() => {
                showNotification('Copied!', 'Share link copied to clipboard');
            }).catch(() => {
                // Fallback for older browsers
                const input = document.createElement('input');
                input.value = link;
                document.body.appendChild(input);
                input.select();
                document.execCommand('copy');
                document.body.removeChild(input);
                showNotification('Copied!', 'Share link copied to clipboard');
            });
        }
        
        // Show QR code for tournament
        async function showQRCode(tournamentId) {
            const link = getShareLink(tournamentId);
            
            // Get current join code from Firebase
            let joinCode = '------';
            try {
                const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                if (tournamentDoc.exists) {
                    joinCode = tournamentDoc.data().joinCode || '------';
                }
            } catch (error) {
                console.error('Error fetching join code:', error);
            }
            
            // Create modal with QR code
            const modal = document.createElement('div');
            modal.id = 'qrCodeModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 10001;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; padding: 24px; border-radius: 16px; max-width: 400px; width: 90%; text-align: center;">
                    <h2 style="color: #1e40af; margin-bottom: 16px;">Share Tournament</h2>
                    
                    <!-- Join Code Section -->
                    <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border: 2px solid #10b981; border-radius: 12px; padding: 16px; margin-bottom: 16px;">
                        <div style="font-size: 13px; color: #065f46; font-weight: 600; margin-bottom: 8px;">JOIN CODE</div>
                        <div style="display: flex; align-items: center; justify-content: center; gap: 12px;">
                            <span id="joinCodeDisplay" style="font-size: 32px; font-weight: 800; color: #065f46; letter-spacing: 3px; font-family: monospace;">${joinCode}</span>
                            ${isHost ? `<button onclick="showEditJoinCodeModal('${tournamentId}', '${joinCode}')" style="padding: 6px 10px; background: #10b981; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;" title="Edit Code">âï¸</button>` : ''}
                        </div>
                        <button onclick="copyJoinCode('${joinCode}')" style="margin-top: 10px; padding: 8px 16px; background: #065f46; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                            ð Copy Code
                        </button>
                    </div>
                    
                    <!-- Divider -->
                    <div style="display: flex; align-items: center; margin: 16px 0;">
                        <div style="flex: 1; height: 1px; background: #e2e8f0;"></div>
                        <span style="padding: 0 12px; color: #94a3b8; font-size: 12px;">OR SCAN</span>
                        <div style="flex: 1; height: 1px; background: #e2e8f0;"></div>
                    </div>
                    
                    <!-- QR Code -->
                    <div id="tempQRCode" style="display: inline-block; padding: 12px; background: white; border: 1px solid #e2e8f0; border-radius: 8px;"></div>
                    
                    <!-- Link -->
                    <p style="color: #64748b; font-size: 11px; margin-top: 12px; word-break: break-all;">${link}</p>
                    
                    <button onclick="this.closest('div[style*=fixed]').remove()" style="margin-top: 16px; padding: 12px 24px; background: #64748b; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; width: 100%;">
                        Close
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Generate QR code
            new QRCode(document.getElementById('tempQRCode'), {
                text: link,
                width: 200,
                height: 200
            });
            
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
        }
        
        // Copy join code to clipboard
        function copyJoinCode(code) {
            navigator.clipboard.writeText(code).then(() => {
                showNotification('Copied!', `Join code ${code} copied to clipboard`);
            }).catch(() => {
                showNotification('Copy Failed', 'Please try again');
            });
        }
        
        // Show edit join code modal
        function showEditJoinCodeModal(tournamentId, currentCode) {
            const editModal = document.createElement('div');
            editModal.id = 'editJoinCodeModal';
            editModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.9);
                z-index: 10002;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            editModal.innerHTML = `
                <div style="background: white; padding: 24px; border-radius: 16px; max-width: 340px; width: 90%; text-align: center;">
                    <h3 style="color: #1e40af; margin-bottom: 8px; font-size: 20px;">Edit Join Code</h3>
                    <p style="color: #64748b; font-size: 13px; margin-bottom: 16px;">4 letters + 2 numbers (e.g., GOLF42)</p>
                    
                    <input type="text" id="newJoinCodeInput" value="${currentCode}" maxlength="6" 
                        style="width: 100%; padding: 16px; font-size: 28px; font-weight: 800; text-align: center; 
                        border: 2px solid #3b82f6; border-radius: 10px; letter-spacing: 4px; font-family: monospace;
                        text-transform: uppercase;"
                        oninput="this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0,6)">
                    
                    <p id="joinCodeError" style="color: #ef4444; font-size: 13px; margin-top: 8px; min-height: 20px;"></p>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 16px;">
                        <button onclick="document.getElementById('editJoinCodeModal').remove()" 
                            style="padding: 14px; background: #f1f5f9; color: #475569; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                        <button onclick="saveNewJoinCode('${tournamentId}')" 
                            style="padding: 14px; background: #10b981; color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer;">
                            Save
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(editModal);
            
            // Focus and select input
            setTimeout(() => {
                const input = document.getElementById('newJoinCodeInput');
                input.focus();
                input.select();
            }, 100);
        }
        
        // Save new join code
        async function saveNewJoinCode(tournamentId) {
            const input = document.getElementById('newJoinCodeInput');
            const errorEl = document.getElementById('joinCodeError');
            const newCode = input.value.toUpperCase().trim();
            
            // Validate format
            if (!isValidJoinCodeFormat(newCode)) {
                errorEl.textContent = 'Must be 4 letters + 2 numbers';
                input.style.borderColor = '#ef4444';
                return;
            }
            
            // Show loading state
            errorEl.textContent = 'Checking...';
            errorEl.style.color = '#64748b';
            
            const result = await updateJoinCode(tournamentId, newCode);
            
            if (result.success) {
                // Update the display in the QR modal
                const displayEl = document.getElementById('joinCodeDisplay');
                if (displayEl) {
                    displayEl.textContent = result.code;
                }
                
                // Close edit modal
                document.getElementById('editJoinCodeModal').remove();
                
                showNotification('Code Updated!', `Join code changed to ${result.code}`);
            } else {
                errorEl.textContent = result.error;
                errorEl.style.color = '#ef4444';
                input.style.borderColor = '#ef4444';
            }
        }
        
        // Show share buttons on scoring page (for multi-device mode)
        
        // Show QR code for active tournament (legacy - kept for compatibility)
        function showQRCodeForActiveTournament() {
            // Gate check: Cloud features require subscription
            if (!canUseCloudFeatures()) {
                showPaywall('QR codes require a subscription. Upgrade to enable multi-device scoring!');
                return;
            }
            
            if (activeTournamentId) {
                showQRCode(activeTournamentId);
            } else {
                alert('No active tournament!');
            }
        }
        
        // Copy active tournament link (legacy - kept for compatibility)
        function copyActiveTournamentLink() {
            // Gate check: Cloud features require subscription
            if (!canUseCloudFeatures()) {
                showPaywall('Share links require a subscription. Upgrade to enable multi-device scoring!');
                return;
            }
            
            if (activeTournamentId) {
                const link = getShareLink(activeTournamentId);
                copyShareLink(link);
            } else {
                alert('No active tournament!');
            }
        }
        
        // Show QR code from Resume section
        function showQRFromResume() {
            console.log('=== QR CODE DEBUG ===');
            console.log('showQRFromResume called');
            console.log('activeTournamentId:', activeTournamentId);
            console.log('tournamentMode:', tournamentMode);
            console.log('isHost:', isHost);
            
            if (activeTournamentId) {
                console.log('â Tournament ID found - showing QR code');
                showQRCode(activeTournamentId);
            } else {
                console.error('â No active tournament ID');
                showNotification('No Active Tournament', 'Please start a multi-device tournament first');
            }
        }
        
        // Go to Manage/My Players from Resume section
        function goToManageFromResume() {
            // First resume to load the tournament data
            resumeSavedRound();
            
            // Then navigate to appropriate page based on role
            setTimeout(() => {
                if (canManageTournament()) {
                    showPlayerManagement();
                } else {
                    showMyPlayersPage();
                }
            }, 100);
        }
        
        // Copy link from Resume section
        function copyLinkFromResume() {
            if (activeTournamentId) {
                const link = getShareLink(activeTournamentId);
                navigator.clipboard.writeText(link).then(() => {
                    showNotification('Link Copied!', 'Share link copied to clipboard');
                }).catch(() => {
                    showNotification('Copy Failed', 'Please try again');
                });
            } else {
                showNotification('No Active Tournament', 'Please start a multi-device tournament first');
            }
        }
        
        // Save tournament to file
        function saveTournamentFile() {
            if (!activeTournamentId) {
                showNotification('No Active Tournament', 'Please start a multi-device tournament first');
                return;
            }
            
            try {
                // Create tournament export object
                const exportData = {
                    tournamentId: activeTournamentId,
                    tournamentData: tournamentData,
                    tournamentMode: tournamentMode,
                    savedAt: new Date().toISOString(),
                    version: '1.0'
                };
                
                // Convert to JSON
                const jsonStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                
                // Create download link
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                // Create filename with tournament info
                const date = tournamentData.date || new Date().toISOString().split('T')[0];
                const name = tournamentData.name ? tournamentData.name.replace(/[^a-z0-9]/gi, '_') : 'tournament';
                a.download = `${name}_${date}_${activeTournamentId}.json`;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification('Tournament Saved!', 'File downloaded successfully');
            } catch (error) {
                console.error('Error saving tournament:', error);
                showNotification('Save Failed', 'Could not save tournament file');
            }
        }
        
        // Upload and load tournament from file
        function uploadTournamentFile() {
            // Create hidden file input
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const data = JSON.parse(text);
                    
                    // Validate the file has required fields
                    if (!data.tournamentData || !data.tournamentData.players) {
                        showNotification('Invalid File', 'This file does not contain valid tournament data');
                        return;
                    }
                    
                    // Load the tournament data
                    tournamentData = data.tournamentData;
                    tournamentMode = data.tournamentMode || 'single';
                    activeTournamentId = data.tournamentId || null;
                    
                    // Set course data
                    if (tournamentData.course) {
                        courseData = courses[tournamentData.course] || customCourses[tournamentData.course];
                        // If course data was stored with tournament, use it
                        if (!courseData && tournamentData.courseData) {
                            courseData = tournamentData.courseData;
                            customCourses[tournamentData.course] = tournamentData.courseData;
                        }
                    }
                    
                    // If it was a multi-device tournament, set host status
                    if (tournamentMode === 'multi' && activeTournamentId) {
                        isHost = true;
                        // Subscribe to updates if Firebase available
                        if (db) {
                            subscribToTournamentUpdates(activeTournamentId);
                        }
                    }
                    
                    // Add to history
                    addToTournamentHistory({
                        id: activeTournamentId || 'local_' + Date.now(),
                        name: tournamentData.name || 'Uploaded Tournament',
                        course: tournamentData.course,
                        date: tournamentData.date,
                        gameType: tournamentData.gameType,
                        role: isHost ? 'host' : 'player'
                    });
                    
                    saveToLocalStorage();
                    
                    showNotification('Tournament Loaded!', tournamentData.name || 'Uploaded Tournament');
                    
                    // Navigate to appropriate page
                    if (isHost) {
                        updateHostHomePage();
                        showPage('hostHomePage');
                    } else {
                        renderScoringPage();
                        showPage('scoringPage');
                    }
                    
                } catch (error) {
                    console.error('Error loading tournament file:', error);
                    showNotification('Load Failed', 'Could not read tournament file');
                }
            };
            
            input.click();
        }

        // ========================================
        // END FIREBASE FUNCTIONS
        // ========================================

        // Page navigation
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId).classList.add('active');
            
            // Render scoring page when navigating to it
            if (pageId === 'scoringPage') {
                renderScoringPage();
            }
            
            // Render results page when navigating to it
            if (pageId === 'resultsPage') {
                renderResultsPage();
                // Save stats to history when viewing results
                saveStatsToHistory();
            }
            
            // Hide Home button for guest users (they can only access this tournament)
            if (isGuestUser) {
                const homeBtn = document.getElementById('backToSetupBtn');
                if (homeBtn) {
                    homeBtn.style.display = 'none';
                }
                
                // On results page, hide finish button for non-hosts (handled in renderResultsPage)
                const finishBtn = document.getElementById('newRoundBtnTop');
                if (finishBtn && !canManageTournament()) {
                    finishBtn.style.display = 'none';
                }
            }
            
            // Refresh quick add buttons and check for saved round when returning to setup page
            if (pageId === 'setupPage') {
                renderQuickAddButtons();
                checkForSavedRound(); // Update resume section with share buttons if needed
                
                // Show/hide Cancel button based on whether there's a backup OR an active tournament to return to
                const cancelBtn = document.getElementById('setupCancelBtn');
                if (cancelBtn) {
                    if (previousTournamentBackup || (activeTournamentId && tournamentData && tournamentData.players)) {
                        cancelBtn.style.display = 'block';
                    } else {
                        cancelBtn.style.display = 'none';
                    }
                }
                
                // Extra check: If multi-device tournament is active, ensure buttons are visible
                if (tournamentMode === 'multi' && activeTournamentId) {
                    // Multiple checks at different intervals for iOS
                    setTimeout(() => {
                        const shareButtons = document.getElementById('resumeShareButtons');
                        if (shareButtons) {
                            console.log('ð Setup page shown (50ms) - forcing share buttons visible');
                            shareButtons.classList.add('visible');
                            shareButtons.style.setProperty('display', 'grid', 'important');
                            shareButtons.style.setProperty('visibility', 'visible', 'important');
                        }
                    }, 50);
                    
                    setTimeout(() => {
                        const shareButtons = document.getElementById('resumeShareButtons');
                        if (shareButtons) {
                            console.log('ð Setup page shown (200ms) - forcing share buttons visible');
                            shareButtons.classList.add('visible');
                            shareButtons.style.setProperty('display', 'grid', 'important');
                            shareButtons.style.setProperty('visibility', 'visible', 'important');
                        }
                    }, 200);
                    
                    setTimeout(() => {
                        const shareButtons = document.getElementById('resumeShareButtons');
                        if (shareButtons) {
                            console.log('ð Setup page shown (500ms) - forcing share buttons visible');
                            shareButtons.classList.add('visible');
                            shareButtons.style.setProperty('display', 'grid', 'important');
                            shareButtons.style.setProperty('visibility', 'visible', 'important');
                        }
                    }, 500);
                }
            }
        }

        // GHIN Posting Score Modal
        function showGhinModal(playerName, handicap, playerIndex) {
            const player = tournamentData.players[playerIndex];
            if (!player || !courseData) {
                showNotification('Error', 'Could not load player data');
                return;
            }
            
            // Calculate Course Handicap if we have slope
            // Course Handicap = Handicap Index Ã (Slope Rating / 113)
            // For simplicity, we'll use the stored handicap as course handicap
            const courseHandicap = handicap;
            
            // Calculate GHIN-adjusted scores (Net Double Bogey max)
            let front9Raw = 0, back9Raw = 0;
            let front9Adjusted = 0, back9Adjusted = 0;
            let adjustedHoles = [];
            
            for (let i = 0; i < 18; i++) {
                const score = player.scores[i] || 0;
                const hole = courseData.holes[i];
                
                if (score > 0) {
                    // Calculate strokes received on this hole
                    // Strokes are allocated based on hole handicap (Hcp 1 gets first stroke, etc.)
                    let strokesReceived = 0;
                    if (courseHandicap > 0) {
                        // Positive handicap: receive strokes
                        if (hole.handicap <= courseHandicap) strokesReceived = 1;
                        if (hole.handicap <= courseHandicap - 18) strokesReceived = 2;
                        if (hole.handicap <= courseHandicap - 36) strokesReceived = 3;
                    } else if (courseHandicap < 0) {
                        // Plus handicap (negative): give strokes (max is lower)
                        const absHcp = Math.abs(courseHandicap);
                        if (hole.handicap <= absHcp) strokesReceived = -1;
                    }
                    
                    // Net Double Bogey = Par + 2 + strokes received
                    const maxScore = hole.par + 2 + strokesReceived;
                    const adjustedScore = Math.min(score, maxScore);
                    
                    if (adjustedScore < score) {
                        adjustedHoles.push(hole.number);
                    }
                    
                    // Track raw and adjusted
                    if (i < 9) {
                        front9Raw += score;
                        front9Adjusted += adjustedScore;
                    } else {
                        back9Raw += score;
                        back9Adjusted += adjustedScore;
                    }
                }
            }
            
            const totalRaw = front9Raw + back9Raw;
            const totalAdjusted = front9Adjusted + back9Adjusted;
            
            // Build modal
            const modal = document.createElement('div');
            modal.id = 'ghinModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            const adjustmentNote = adjustedHoles.length > 0 
                ? `<p style="color: #64748b; font-size: 12px; margin: 12px 0 0 0;">Adjusted holes: ${adjustedHoles.join(', ')}<br><span style="font-size: 11px;">(Net Double Bogey applied)</span></p>`
                : `<p style="color: #10b981; font-size: 12px; margin: 12px 0 0 0;">â No adjustments needed</p>`;
            
            const front9Display = front9Adjusted > 0 ? front9Adjusted : '-';
            const back9Display = back9Adjusted > 0 ? back9Adjusted : '-';
            const totalDisplay = totalAdjusted > 0 ? totalAdjusted : '-';
            
            const front9Note = (front9Raw !== front9Adjusted && front9Raw > 0) ? ` <span style="color: #64748b; font-size: 12px;">(was ${front9Raw})</span>` : '';
            const back9Note = (back9Raw !== back9Adjusted && back9Raw > 0) ? ` <span style="color: #64748b; font-size: 12px;">(was ${back9Raw})</span>` : '';
            const totalNote = (totalRaw !== totalAdjusted && totalRaw > 0) ? ` <span style="color: #64748b; font-size: 12px;">(was ${totalRaw})</span>` : '';
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; max-width: 320px; width: 100%; text-align: center;">
                    <div style="font-size: 32px; margin-bottom: 8px;">ð</div>
                    <h2 style="color: #1e40af; font-size: 16px; margin: 0 0 4px 0;">GHIN Posting Score</h2>
                    <p style="color: #64748b; font-size: 13px; margin: 0 0 16px 0;">${playerName} (HCP ${handicap >= 0 ? handicap : handicap})</p>
                    
                    <div style="background: #f8fafc; border-radius: 12px; padding: 16px; margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #e2e8f0;">
                            <span style="color: #64748b; font-weight: 600;">Front 9</span>
                            <span style="color: #1e40af; font-weight: 700; font-size: 18px;">${front9Display}${front9Note}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #e2e8f0;">
                            <span style="color: #64748b; font-weight: 600;">Back 9</span>
                            <span style="color: #1e40af; font-weight: 700; font-size: 18px;">${back9Display}${back9Note}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                            <span style="color: #1e40af; font-weight: 700;">Total</span>
                            <span style="color: #1e40af; font-weight: 700; font-size: 20px;">${totalDisplay}${totalNote}</span>
                        </div>
                    </div>
                    
                    ${adjustmentNote}
                    
                    <div style="display: flex; gap: 8px; margin-top: 16px;">
                        <button onclick="copyGhinScore('${playerName}', ${front9Adjusted}, ${back9Adjusted}, ${totalAdjusted})" style="flex: 1; padding: 12px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            ð Copy
                        </button>
                        <button onclick="closeGhinModal()" style="flex: 1; padding: 12px; background: #e2e8f0; color: #475569; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Close
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeGhinModal();
            };
        }
        
        function closeGhinModal() {
            const modal = document.getElementById('ghinModal');
            if (modal) modal.remove();
        }
        
        function copyGhinScore(playerName, front9, back9, total) {
            const text = `${playerName} GHIN Score: Front 9: ${front9 || '-'}, Back 9: ${back9 || '-'}, Total: ${total || '-'}`;
            navigator.clipboard.writeText(text).then(() => {
                showNotification('Copied!', 'GHIN score copied to clipboard');
            }).catch(() => {
                showNotification('Copy Failed', 'Could not copy to clipboard');
            });
        }
        
        // ========================================
        // COURSE NOTES SYSTEM
        // ========================================
        
        // Get all course notes from localStorage
        function getAllCourseNotes() {
            try {
                const notes = localStorage.getItem('courseNotes');
                return notes ? JSON.parse(notes) : {};
            } catch (e) {
                console.error('Error loading course notes:', e);
                return {};
            }
        }
        
        // Save all course notes to localStorage
        function saveAllCourseNotes(notes) {
            try {
                localStorage.setItem('courseNotes', JSON.stringify(notes));
            } catch (e) {
                console.error('Error saving course notes:', e);
            }
        }
        
        // Get note for a specific course and hole
        function getCourseNote(courseId, holeNumber) {
            const notes = getAllCourseNotes();
            return notes[courseId]?.[holeNumber] || '';
        }
        
        // Save note for a specific course and hole
        function saveCourseNote(courseId, holeNumber, noteText) {
            const notes = getAllCourseNotes();
            
            if (!notes[courseId]) {
                notes[courseId] = {};
            }
            
            if (noteText.trim()) {
                notes[courseId][holeNumber] = noteText.trim();
            } else {
                // Delete empty notes
                delete notes[courseId][holeNumber];
                // Clean up empty course objects
                if (Object.keys(notes[courseId]).length === 0) {
                    delete notes[courseId];
                }
            }
            
            saveAllCourseNotes(notes);
        }
        
        // Get count of notes for a course
        function getCourseNotesCount(courseId) {
            const notes = getAllCourseNotes();
            return notes[courseId] ? Object.keys(notes[courseId]).length : 0;
        }
        
        // Show course note modal
        function showCourseNoteModal(holeNumber) {
            const courseId = tournamentData.course;
            const courseName = getCourseDisplayName(courseId);
            const existingNote = getCourseNote(courseId, holeNumber);
            
            const modal = document.createElement('div');
            modal.id = 'courseNoteModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; max-width: 360px; width: 100%;">
                    <div style="text-align: center; margin-bottom: 16px;">
                        <div style="font-size: 32px; margin-bottom: 8px;">ð</div>
                        <h2 style="color: #1e40af; font-size: 16px; margin: 0;">Hole ${holeNumber} Notes</h2>
                        <p style="color: #64748b; font-size: 12px; margin: 4px 0 0 0;">${courseName}</p>
                    </div>
                    
                    <textarea id="courseNoteText" placeholder="Add your notes for this hole...&#10;&#10;Examples:&#10;â¢ Aim left off tee&#10;â¢ Club up, plays long&#10;â¢ Watch for false front" style="width: 100%; height: 150px; padding: 12px; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 14px; resize: none; box-sizing: border-box; font-family: inherit;">${existingNote}</textarea>
                    
                    <div style="display: flex; gap: 8px; margin-top: 16px;">
                        <button onclick="saveCourseNoteFromModal(${holeNumber})" style="flex: 1; padding: 12px; background: #10b981; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            ð¾ Save
                        </button>
                        <button onclick="closeCourseNoteModal()" style="flex: 1; padding: 12px; background: #e2e8f0; color: #475569; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                    
                    ${existingNote ? `
                        <button onclick="deleteCourseNoteFromModal(${holeNumber})" style="width: 100%; margin-top: 8px; padding: 10px; background: white; color: #ef4444; border: 2px solid #ef4444; border-radius: 8px; font-size: 13px; font-weight: 600; cursor: pointer;">
                            ðï¸ Delete Note
                        </button>
                    ` : ''}
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Focus textarea
            setTimeout(() => {
                document.getElementById('courseNoteText').focus();
            }, 100);
            
            // Close on backdrop click
            modal.onclick = (e) => {
                if (e.target === modal) closeCourseNoteModal();
            };
        }
        
        function closeCourseNoteModal() {
            const modal = document.getElementById('courseNoteModal');
            if (modal) modal.remove();
        }
        
        function saveCourseNoteFromModal(holeNumber) {
            const textarea = document.getElementById('courseNoteText');
            const noteText = textarea.value;
            const courseId = tournamentData.course;
            
            saveCourseNote(courseId, holeNumber, noteText);
            closeCourseNoteModal();
            
            // Re-render hole view to update button color
            renderHoleView();
            
            showNotification('ð Saved', noteText.trim() ? 'Note saved for this hole' : 'Note cleared');
        }
        
        function deleteCourseNoteFromModal(holeNumber) {
            const courseId = tournamentData.course;
            saveCourseNote(courseId, holeNumber, '');
            closeCourseNoteModal();
            renderHoleView();
            showNotification('ðï¸ Deleted', 'Note removed');
        }

        // Custom confirmation dialog (iOS-friendly)
        function showConfirm(title, message, onConfirm) {
            const dialog = document.getElementById('confirmDialog');
            const titleEl = document.getElementById('confirmTitle');
            const messageEl = document.getElementById('confirmMessage');
            const okBtn = document.getElementById('confirmOk');
            const cancelBtn = document.getElementById('confirmCancel');
            
            titleEl.textContent = title;
            messageEl.textContent = message;
            dialog.style.display = 'flex';
            
            // Remove old listeners
            const newOkBtn = okBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
            
            // Add new listeners
            newOkBtn.addEventListener('click', function() {
                dialog.style.display = 'none';
                onConfirm();
            });
            
            newCancelBtn.addEventListener('click', function() {
                dialog.style.display = 'none';
            });
        }
        
        function hideConfirmDialog() {
            const dialog = document.getElementById('confirmDialog');
            if (dialog) {
                dialog.style.display = 'none';
            }
        }

        // Back button - shows resume option if there's an active game
        function confirmBackToHome() {
            console.log('confirmBackToHome called:', {
                tournamentMode,
                isHost,
                isCoHost,
                canManage: canManageTournament(),
                activeTournamentId
            });
            
            // Hosts and co-hosts go to host home page
            if (tournamentMode === 'multi' && canManageTournament()) {
                console.log('-> Going to Host Home Page');
                showHostHomePage();
            }
            // Non-hosts/non-co-hosts go to guest home page
            else if (tournamentMode === 'multi' && !canManageTournament()) {
                console.log('-> Going to Guest Home Page');
                showGuestHomePage();
            } 
            // Single device mode - show a simple round home or go to setup with current data
            else {
                console.log('-> Single device mode - showing round options');
                // For single-device mode, show a confirmation dialog
                if (tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                    // There's an active round - ask what they want to do
                    const choice = confirm('Round in progress.\n\nOK = Resume Scoring\nCancel = Go to Setup (to start new round)');
                    if (choice) {
                        // Resume scoring - just stay on scoring page
                        renderScoringPage();
                        showPage('scoringPage');
                    } else {
                        // Go to setup but clear backup so Cancel doesn't restore old data
                        previousTournamentBackup = null;
                        showPage('setupPage');
                        // Show Resume button
                        const resumeBtn = document.getElementById('resumeScoringBtn');
                        if (resumeBtn) resumeBtn.style.display = 'block';
                        // Hide cancel button since there's no backup to restore
                        const cancelBtn = document.getElementById('setupCancelBtn');
                        if (cancelBtn) cancelBtn.style.display = 'none';
                    }
                } else {
                    // No active round - just go to setup
                    showPage('setupPage');
                }
            }
        }
        
        // Show Host Home Page
        function showHostHomePage() {
            // Populate tournament info
            if (tournamentData) {
                document.getElementById('hostTournamentName').textContent = tournamentData.name || 'Tournament';
                document.getElementById('hostTournamentInfo').textContent = 
                    `${tournamentData.course || ''} â¢ ${formatDateDisplay(tournamentData.date) || ''}`;
            }
            
            // Update device initials display
            updateDeviceInitialsDisplay();
            
            showPage('hostHomePage');
        }
        
        // Update Host Home Page (called when returning to host home)
        function updateHostHomePage() {
            const currentTournamentCard = document.getElementById('hostCurrentTournament');
            
            // Check if we have an active tournament
            if (tournamentData && tournamentData.players && tournamentData.players.length > 0 && activeTournamentId) {
                // Show current tournament card
                if (currentTournamentCard) currentTournamentCard.style.display = 'block';
                
                // Populate tournament info
                document.getElementById('hostTournamentName').textContent = tournamentData.name || 'Tournament';
                const courseName = courseData?.name || tournamentData.course || '';
                document.getElementById('hostTournamentInfo').textContent = 
                    `${courseName} â¢ ${formatDateDisplay(tournamentData.date) || ''}`;
                
                // Update device initials display
                const initialsEl = document.getElementById('hostDeviceInitials');
                if (initialsEl) {
                    initialsEl.textContent = deviceInitials || 'MD';
                }
                
                // Update role badge based on user's actual role
                const badge = document.getElementById('hostTournamentBadge');
                const hostInfo = document.getElementById('hostPageHostInfo');
                const hostName = document.getElementById('hostPageHostName');
                
                if (badge) {
                    if (isHost) {
                        badge.textContent = 'ð HOST';
                        badge.style.background = 'white';
                        badge.style.color = '#f97316';
                        badge.style.borderColor = '#f97316';
                        if (hostInfo) hostInfo.style.display = 'none';
                    } else if (canManageTournament()) {
                        badge.textContent = 'â­ CO-HOST';
                        badge.style.background = '#fef3c7';
                        badge.style.color = '#92400e';
                        badge.style.borderColor = '#f59e0b';
                        if (hostInfo) hostInfo.style.display = 'none';
                    } else {
                        badge.textContent = 'ð¤ PLAYER';
                        badge.style.background = '#dbeafe';
                        badge.style.color = '#1e40af';
                        badge.style.borderColor = '#3b82f6';
                        // Show host info for non-hosts
                        if (hostInfo && hostName) {
                            hostInfo.style.display = 'block';
                            hostName.textContent = getHostDisplayName();
                        }
                    }
                }
                
                // Also update Guest Home host info
                updateGuestHomeHostInfo();
            } else {
                // No active tournament - hide the current tournament card
                if (currentTournamentCard) currentTournamentCard.style.display = 'none';
            }
            
            // Always update history count
            updateHistoryCountDisplay();
        }
        
        // Get host display name from tournament data
        function getHostDisplayName() {
            if (!tournamentData) return '--';
            
            // First try hostName (display name saved at creation)
            if (tournamentData.hostName) {
                return tournamentData.hostName;
            }
            
            // Try hostUsername
            if (tournamentData.hostUsername) {
                return tournamentData.hostUsername;
            }
            
            // Fall back to hostDeviceId (device initials)
            if (tournamentData.hostDeviceId) {
                return tournamentData.hostDeviceId;
            }
            
            if (tournamentData.hostDevice) {
                return tournamentData.hostDevice;
            }
            
            return 'Unknown';
        }
        
        // Update Guest Home host info
        function updateGuestHomeHostInfo() {
            const hostNameEl = document.getElementById('guestHostName');
            if (hostNameEl) {
                hostNameEl.textContent = getHostDisplayName();
            }
        }
        
        // Generate smart info line with progressive shortening
        function generateSmartInfoLine(containerId) {
            if (!tournamentData || !courseData) return;
            
            const container = document.getElementById(containerId);
            if (!container) return;
            
            const tournamentName = tournamentData.name || 'Tournament';
            const gameType = tournamentData.gameType || 'Stroke Play';
            const courseName = courseData.name || tournamentData.course;
            const dateStr = formatDateDisplay(tournamentData.date);
            
            // Get course initials (e.g., "Jurupa Hills Country Club" -> "JHCC")
            const courseInitials = courseName.split(' ')
                .map(word => word.charAt(0).toUpperCase())
                .join('');
            
            // Short date format (MM/DD/YY)
            const shortDate = formatShortDate(tournamentData.date);
            
            // Get container width
            const containerWidth = container.parentElement ? container.parentElement.clientWidth - 40 : 300;
            
            // Create a hidden span to measure text width
            const measureSpan = document.createElement('span');
            measureSpan.style.cssText = 'position: absolute; visibility: hidden; white-space: nowrap; font-size: 12px; font-weight: 600;';
            document.body.appendChild(measureSpan);
            
            // Level 1: Full version
            let infoText = `${tournamentName} | ${gameType} | ${courseName} | ${dateStr}`;
            measureSpan.textContent = infoText;
            
            if (measureSpan.offsetWidth > containerWidth) {
                // Level 2: Abbreviate course name
                infoText = `${tournamentName} | ${gameType} | ${courseInitials} | ${dateStr}`;
                measureSpan.textContent = infoText;
                
                if (measureSpan.offsetWidth > containerWidth) {
                    // Level 3: Also shorten date
                    infoText = `${tournamentName} | ${gameType} | ${courseInitials} | ${shortDate}`;
                }
            }
            
            // Clean up
            document.body.removeChild(measureSpan);
            
            container.textContent = infoText;
        }
        
        // Format date as MM/DD/YY
        function formatShortDate(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString + 'T12:00:00');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const year = String(date.getFullYear()).slice(-2);
            return `${month}/${day}/${year}`;
        }

        // Track if we came from Host Home for the back button
        let previousTournamentBackup = null;
        
        // Start a completely new tournament - clear all existing data
        function startNewTournament() {
            // BACKUP current tournament data before clearing (so we can restore if user cancels)
            const currentSaved = localStorage.getItem('indianHillsScoring');
            if (currentSaved) {
                previousTournamentBackup = currentSaved;
            }
            
            // Clear tournament data in memory (but keep backup)
            tournamentData = {
                name: '',
                date: new Date().toISOString().split('T')[0],
                course: '',
                gameType: 'Stroke Play',
                players: [],
                teams: []
            };
            
            // Clear active tournament ID and host status for new tournament
            activeTournamentId = null;
            tournamentMode = 'single'; // Will become multi when started
            isHost = false;
            hasJoinedTournament = false;
            courseData = null;
            
            // Clear player stats
            clearAllPlayerStats();
            
            // DON'T clear localStorage yet - keep it as backup until new tournament is started
            // localStorage.removeItem('indianHillsScoring');
            
            // Reset form fields
            const nameInput = document.getElementById('tournamentName');
            const dateInput = document.getElementById('tournamentDate');
            const courseSelect = document.getElementById('courseSelect');
            const gameType = document.getElementById('gameType');
            const playerList = document.getElementById('playerList');
            
            if (nameInput) nameInput.value = '';
            if (dateInput) dateInput.valueAsDate = new Date();
            if (courseSelect) courseSelect.value = '';
            if (gameType) gameType.value = 'Stroke Play';
            if (playerList) playerList.innerHTML = '';
            
            // Navigate to setup page
            showPage('setupPage');
            
            console.log('â Started new tournament setup - backup saved:', !!previousTournamentBackup);
        }
        
        // Cancel setup and return to home
        function cancelSetup() {
            goToHomePage();
        }
        
        // Go to appropriate home page based on role
        function goToHomePage() {
            // If we have a backup, restore it
            if (previousTournamentBackup) {
                try {
                    const data = JSON.parse(previousTournamentBackup);
                    
                    // Restore globals
                    activeTournamentId = data._activeTournamentId;
                    tournamentMode = data._tournamentMode || 'multi';
                    isHost = data._isHost || true;
                    hasJoinedTournament = true;
                    
                    // Restore tournament data
                    const metadataKeys = ['_activeTournamentId', '_tournamentMode', '_isHost', '_hostForTournament', 
                                        '_hasJoinedTournament', '_hostViewMode', '_scoreTimestamps', '_deletedPlayers', '_lastSaved'];
                    metadataKeys.forEach(key => delete data[key]);
                    tournamentData = data;
                    courseData = courses[tournamentData.course] || customCourses[tournamentData.course];
                    
                    // Reconnect to Firebase
                    if (activeTournamentId) {
                        subscribToTournamentUpdates(activeTournamentId);
                    }
                    
                    // Clear backup
                    previousTournamentBackup = null;
                    
                    // Navigate to correct home page
                    goToCorrectHomePage();
                    return;
                } catch (e) {
                    console.error('Error restoring backup:', e);
                }
            }
            
            // Fallback - check current state and go to correct home page
            if (activeTournamentId && tournamentData && tournamentData.name) {
                goToCorrectHomePage();
            } else if (hasJoinedTournament && activeTournamentId) {
                showGuestHomePage();
            } else {
                // No active tournament - just go to guest home page
                // This ensures user is never stuck on setup page
                showPage('guestHomePage');
            }
        }
        
        // Go to correct home page based on isHost status (for navigation from any page)
        function goToCorrectHomePage() {
            // Hosts and co-hosts go to host home page
            if (isHost || canManageTournament()) {
                updateHostHomePage();
                const currentTournamentCard = document.getElementById('hostCurrentTournament');
                if (currentTournamentCard && activeTournamentId) {
                    currentTournamentCard.style.display = 'block';
                }
                showPage('hostHomePage');
            } else {
                showGuestHomePage();
            }
        }
        
        // Clear all player stats from localStorage
        function clearAllPlayerStats() {
            playerStats = {};
            localStorage.removeItem('playerStats');
            console.log('â Player stats cleared');
        }
        
        function confirmBackToSetup() {
            console.log('=== CONFIRM BACK TO SETUP ===');
            console.log('tournamentMode:', tournamentMode);
            console.log('activeTournamentId:', activeTournamentId);
            console.log('isHost:', isHost);
            
            showPage('setupPage');
            
            // Show Resume Scoring button if there are active scores
            if (tournamentData.players && tournamentData.players.length > 0) {
                const resumeBtn = document.getElementById('resumeScoringBtn');
                if (resumeBtn) {
                    resumeBtn.style.display = 'block';
                }
            }
            
            // FORCE share buttons check after a moment (for iOS)
            setTimeout(() => {
                console.log('ð Checking share buttons after back to setup...');
                const shareButtons = document.getElementById('resumeShareButtons');
                console.log('  shareButtons element:', shareButtons);
                console.log('  display:', shareButtons?.style.display);
                console.log('  visibility:', shareButtons?.style.visibility);
                console.log('  classList:', shareButtons?.classList);
                
                if (tournamentMode === 'multi' && activeTournamentId && shareButtons) {
                    console.log('  ð§ FORCING VISIBLE');
                    shareButtons.classList.add('visible');
                    shareButtons.style.setProperty('display', 'grid', 'important');
                    shareButtons.style.setProperty('visibility', 'visible', 'important');
                }
            }, 100);
        }

        // Resume scoring - go back to scoring page with existing data
        function resumeScoring() {
            renderScoringPage();
            showPage('scoringPage');
            
            // Start in Holes view by default
            switchToHoleView();
        }

        // Start scoring from setup page
        // ========================================
        // TOURNAMENT MODE SELECTION & UI HANDLERS
        // ========================================
        
        let tournamentMode = 'multi'; // Always multi-device mode now
        let isOnline = navigator.onLine; // Track connection status
        
        // Connection status monitoring
        function updateConnectionStatus() {
            isOnline = navigator.onLine;
            const dot = document.getElementById('connectionDot');
            const text = document.getElementById('connectionText');
            const statusContainer = document.getElementById('connectionStatus');
            const scoringDot = document.getElementById('scoringConnectionDot');
            const setupDot = document.getElementById('setupConnectionDot');
            
            if (dot && text) {
                if (isOnline) {
                    dot.style.background = '#10b981';
                    text.textContent = 'Online - Scores sync across devices';
                    if (statusContainer) statusContainer.style.background = 'rgba(16, 185, 129, 0.2)';
                } else {
                    dot.style.background = '#ef4444';
                    text.textContent = 'Offline - Scores saved locally';
                    if (statusContainer) statusContainer.style.background = 'rgba(239, 68, 68, 0.2)';
                }
            }
            
            // Update scoring page dot
            if (scoringDot) {
                scoringDot.style.background = isOnline ? '#10b981' : '#ef4444';
                scoringDot.title = isOnline ? 'Online - Syncing' : 'Offline - Local only';
            }
            
            // Update setup page dot
            if (setupDot) {
                setupDot.style.background = isOnline ? '#10b981' : '#ef4444';
                setupDot.title = isOnline ? 'Online' : 'Offline';
            }
            
            // Also update management page status if visible
            updateManagementConnectionStatus();
        }
        
        function updateManagementConnectionStatus() {
            const manageDot = document.getElementById('manageConnectionDot');
            const manageText = document.getElementById('manageConnectionText');
            
            if (manageDot && manageText) {
                if (isOnline) {
                    manageDot.style.background = '#10b981';
                    manageText.textContent = 'Connected - Real-time sync active';
                    manageText.style.color = '#065f46';
                } else {
                    manageDot.style.background = '#ef4444';
                    manageText.textContent = 'Offline - Changes saved locally';
                    manageText.style.color = '#991b1b';
                }
            }
        }
        
        // Listen for online/offline events
        window.addEventListener('online', () => {
            updateConnectionStatus();
            showNotification('Back Online', 'Syncing scores...');
            // Try to sync any pending changes
            if (activeTournamentId && tournamentData) {
                saveToLocalStorage();
            }
        });
        
        window.addEventListener('offline', () => {
            updateConnectionStatus();
            showNotification('Offline', 'Scores will be saved locally');
        });
        
        // Initialize connection status on page load
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(updateConnectionStatus, 500);
            initializeCourseDropdown();
            loadNotificationMuteState();
            loadAutoAdvanceSetting();
            
            // Check if returning from Stripe payment
            setTimeout(checkPaymentReturn, 1000);
            
            // CRITICAL: Check for saved round and navigate to appropriate home page
            // Delay slightly to ensure Firebase is initialized
            setTimeout(() => {
                checkForSavedRound(true);
            }, 300);
        });
        
        function selectScoringMode(mode) {
            // Always use multi-device mode now
            tournamentMode = 'multi';
            requestNotificationPermission();
        }
        
        // ==================== JOIN BY CODE UI FUNCTIONS ====================
        
        // Validate join code input and enable/disable button
        function validateJoinCodeInput() {
            const input = document.getElementById('joinCodeInput');
            const btn = document.getElementById('joinByCodeBtn');
            const errorEl = document.getElementById('joinCodeInputError');
            
            if (!input || !btn) return;
            
            const code = input.value.trim();
            const isValid = isValidJoinCodeFormat(code);
            
            btn.disabled = !isValid;
            btn.style.opacity = isValid ? '1' : '0.5';
            
            // Clear error when typing
            if (errorEl) errorEl.textContent = '';
        }
        
        // Join tournament by code
        async function joinByCode() {
            const input = document.getElementById('joinCodeInput');
            const btn = document.getElementById('joinByCodeBtn');
            const errorEl = document.getElementById('joinCodeInputError');
            
            if (!input) return;
            
            const code = input.value.trim();
            
            // Validate format
            if (!isValidJoinCodeFormat(code)) {
                if (errorEl) errorEl.textContent = 'Enter 4 letters + 2 numbers (e.g., GOLF42)';
                return;
            }
            
            // Show loading state
            btn.disabled = true;
            btn.textContent = '...';
            if (errorEl) errorEl.textContent = '';
            
            try {
                const result = await findTournamentByCode(code);
                
                if (result.success) {
                    // Clear input
                    input.value = '';
                    validateJoinCodeInput();
                    
                    // Navigate to join tournament screen
                    showJoinTournamentScreen(result.tournamentId);
                } else {
                    if (errorEl) errorEl.textContent = result.error;
                }
            } catch (error) {
                console.error('Error joining by code:', error);
                if (errorEl) errorEl.textContent = 'Something went wrong. Please try again.';
            } finally {
                // Reset button
                btn.disabled = false;
                btn.textContent = 'Join';
                validateJoinCodeInput();
            }
        }
        
        // ==================== END JOIN BY CODE UI FUNCTIONS ====================
        
        // ==================== GUEST/HOST HOME JOIN BY CODE ====================
        
        // Validate guest join code input
        function validateGuestJoinCode() {
            const input = document.getElementById('guestJoinCodeInput');
            const btn = document.getElementById('guestJoinCodeBtn');
            
            if (!input || !btn) return;
            
            const code = input.value.trim();
            const isValid = isValidJoinCodeFormat(code);
            
            btn.disabled = !isValid;
            btn.style.opacity = isValid ? '1' : '0.5';
            
            // Clear error when typing
            const errorEl = document.getElementById('guestJoinCodeError');
            if (errorEl) errorEl.textContent = '';
        }
        
        // Guest join by code
        async function guestJoinByCode() {
            const input = document.getElementById('guestJoinCodeInput');
            const btn = document.getElementById('guestJoinCodeBtn');
            const errorEl = document.getElementById('guestJoinCodeError');
            
            if (!input) return;
            
            const code = input.value.trim();
            
            if (!isValidJoinCodeFormat(code)) {
                if (errorEl) errorEl.textContent = 'Enter 4 letters + 2 numbers';
                return;
            }
            
            btn.disabled = true;
            btn.textContent = '...';
            if (errorEl) errorEl.textContent = '';
            
            try {
                const result = await findTournamentByCode(code);
                
                if (result.success) {
                    input.value = '';
                    validateGuestJoinCode();
                    showJoinTournamentScreen(result.tournamentId);
                } else {
                    if (errorEl) errorEl.textContent = result.error;
                }
            } catch (error) {
                console.error('Error:', error);
                if (errorEl) errorEl.textContent = 'Something went wrong. Try again.';
            } finally {
                btn.disabled = false;
                btn.textContent = 'Join';
                validateGuestJoinCode();
            }
        }
        
        // Validate host join code input
        function validateHostJoinCode() {
            const input = document.getElementById('hostJoinCodeInput');
            const btn = document.getElementById('hostJoinCodeBtn');
            
            if (!input || !btn) return;
            
            const code = input.value.trim();
            const isValid = isValidJoinCodeFormat(code);
            
            btn.disabled = !isValid;
            btn.style.opacity = isValid ? '1' : '0.5';
            
            const errorEl = document.getElementById('hostJoinCodeError');
            if (errorEl) errorEl.textContent = '';
        }
        
        // Host join by code
        async function hostJoinByCode() {
            const input = document.getElementById('hostJoinCodeInput');
            const btn = document.getElementById('hostJoinCodeBtn');
            const errorEl = document.getElementById('hostJoinCodeError');
            
            if (!input) return;
            
            const code = input.value.trim();
            
            if (!isValidJoinCodeFormat(code)) {
                if (errorEl) errorEl.textContent = 'Enter 4 letters + 2 numbers';
                return;
            }
            
            btn.disabled = true;
            btn.textContent = '...';
            if (errorEl) errorEl.textContent = '';
            
            try {
                const result = await findTournamentByCode(code);
                
                if (result.success) {
                    input.value = '';
                    validateHostJoinCode();
                    showJoinTournamentScreen(result.tournamentId);
                } else {
                    if (errorEl) errorEl.textContent = result.error;
                }
            } catch (error) {
                console.error('Error:', error);
                if (errorEl) errorEl.textContent = 'Something went wrong. Try again.';
            } finally {
                btn.disabled = false;
                btn.textContent = 'Join';
                validateHostJoinCode();
            }
        }
        
        // ==================== TOURNAMENT HISTORY ====================
        
        const MAX_TOURNAMENT_HISTORY = 5;
        
        // Get tournament history from localStorage
        function getTournamentHistory() {
            try {
                const history = localStorage.getItem('tournamentHistory');
                return history ? JSON.parse(history) : [];
            } catch (error) {
                console.error('Error reading tournament history:', error);
                return [];
            }
        }
        
        // Save tournament history to localStorage
        function saveTournamentHistory(history) {
            try {
                localStorage.setItem('tournamentHistory', JSON.stringify(history));
            } catch (error) {
                console.error('Error saving tournament history:', error);
            }
        }
        
        // Add tournament to history (called when joining/creating)
        function addToTournamentHistory(tournamentInfo) {
            const history = getTournamentHistory();
            
            // Remove existing entry for this tournament if present
            const filteredHistory = history.filter(t => t.id !== tournamentInfo.id);
            
            // Add new entry at the beginning
            const newEntry = {
                id: tournamentInfo.id,
                joinCode: tournamentInfo.joinCode || '',
                name: tournamentInfo.name || 'Unnamed Tournament',
                course: tournamentInfo.course || '',
                courseName: tournamentInfo.courseName || getCourseDisplayName(tournamentInfo.course),
                date: tournamentInfo.date || new Date().toISOString().split('T')[0],
                gameType: tournamentInfo.gameType || '',
                playerCount: tournamentInfo.playerCount || 0,
                role: tournamentInfo.role || 'player', // 'host', 'player', 'viewer'
                isFinished: tournamentInfo.isFinished || false,
                lastAccess: Date.now()
            };
            
            filteredHistory.unshift(newEntry);
            
            // Keep only last N tournaments
            const trimmedHistory = filteredHistory.slice(0, MAX_TOURNAMENT_HISTORY);
            
            saveTournamentHistory(trimmedHistory);
            updateHistoryCountDisplay();
            
            return trimmedHistory;
        }
        
        // Remove tournament from history
        function removeFromTournamentHistory(tournamentId) {
            const history = getTournamentHistory();
            const filteredHistory = history.filter(t => t.id !== tournamentId);
            saveTournamentHistory(filteredHistory);
            updateHistoryCountDisplay();
            return filteredHistory;
        }
        
        // Clear all tournament history
        function clearTournamentHistory() {
            saveTournamentHistory([]);
            updateHistoryCountDisplay();
        }
        
        // Get course display name helper
        function getCourseDisplayName(courseKey) {
            const courseNames = {
                'green_river': 'Green River GC',
                'hidden_valley': 'Hidden Valley GC',
                'indian_hills': 'Indian Hills GC',
                'jurupa_hills': 'Jurupa Hills CC'
            };
            return courseNames[courseKey] || courseKey || 'Unknown Course';
        }
        
        // Update history count display on Guest Home and Host Home
        function updateHistoryCountDisplay() {
            const history = getTournamentHistory();
            const countText = history.length > 0 
                ? `${history.length} tournament${history.length !== 1 ? 's' : ''} saved`
                : 'No saved tournaments';
            
            // Update guest home page
            const countEl = document.getElementById('historyCount');
            if (countEl) {
                countEl.textContent = countText;
            }
            
            // Update host home page
            const hostCountEl = document.getElementById('hostHistoryCount');
            if (hostCountEl) {
                hostCountEl.textContent = countText;
            }
            
            // Update setup page
            const setupCountEl = document.getElementById('setupHistoryCount');
            if (setupCountEl) {
                setupCountEl.textContent = countText;
            }
        }
        
        // Format date for display
        function formatTournamentDate(dateStr) {
            if (!dateStr) return 'Unknown date';
            try {
                const date = new Date(dateStr);
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                
                if (date.toDateString() === today.toDateString()) {
                    return 'Today';
                } else if (date.toDateString() === yesterday.toDateString()) {
                    return 'Yesterday';
                } else {
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                }
            } catch (e) {
                return dateStr;
            }
        }
        
        // Show tournament history modal
        async function showTournamentHistoryModal() {
            const history = getTournamentHistory();
            
            const modal = document.createElement('div');
            modal.id = 'tournamentHistoryModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 10001;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            // Show modal immediately with loading state if we have history to fetch
            if (history.length > 0 && db) {
                modal.innerHTML = `
                    <div style="background: white; border-radius: 16px; padding: 20px; max-width: 400px; width: 95%; max-height: 80vh; overflow-y: auto;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                            <h2 style="color: #1e40af; font-size: 20px; margin: 0;">ð Load Tournament</h2>
                            <button onclick="closeTournamentHistoryModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">â</button>
                        </div>
                        <div style="text-align: center; padding: 40px;">
                            <div style="font-size: 24px; margin-bottom: 12px;">â³</div>
                            <p style="color: #64748b;">Loading tournament data...</p>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }
            
            let historyHTML = '';
            
            if (history.length === 0) {
                historyHTML = `
                    <div style="text-align: center; padding: 24px; color: #64748b;">
                        <span style="font-size: 48px; display: block; margin-bottom: 12px;">ð­</span>
                        <p style="font-size: 14px;">No tournaments in history</p>
                        <p style="font-size: 12px; margin-top: 8px;">Join a tournament using a code to get started!</p>
                    </div>
                `;
            } else {
                // Fetch fresh data from Firebase for each tournament
                const freshHistory = [];
                for (const t of history) {
                    try {
                        if (db && t.id) {
                            const doc = await db.collection('tournaments').doc(t.id).get();
                            if (doc.exists) {
                                const fbData = doc.data();
                                freshHistory.push({
                                    ...t,
                                    name: fbData.name || t.name,
                                    playerCount: fbData.players?.length || t.playerCount || 0,
                                    date: fbData.date || t.date,
                                    isFinished: fbData.status === 'ended' || t.isFinished
                                });
                            } else {
                                // Tournament no longer exists in Firebase
                                freshHistory.push({ ...t, playerCount: t.playerCount || 0 });
                            }
                        } else {
                            freshHistory.push(t);
                        }
                    } catch (err) {
                        console.warn('Could not fetch tournament', t.id, err);
                        freshHistory.push(t);
                    }
                }
                
                // Sort by date (most recent first)
                const sortedHistory = [...freshHistory].sort((a, b) => {
                    const dateA = new Date(a.date || 0);
                    const dateB = new Date(b.date || 0);
                    return dateB - dateA;
                });
                
                historyHTML = sortedHistory.map((t, idx) => {
                    const roleIcon = t.role === 'host' ? 'ð' : t.role === 'viewer' ? 'ð' : 'ðï¸';
                    const roleText = t.role === 'host' ? 'Host' : t.role === 'viewer' ? 'Viewer' : 'Player';
                    const finishedBadge = t.isFinished ? `<span style="background: #fef3c7; color: #92400e; font-size: 9px; font-weight: 700; padding: 2px 6px; border-radius: 4px; margin-left: 6px;">FINISHED</span>` : '';
                    
                    return `
                        <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; padding: 12px; margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; color: #1e293b; font-size: 14px; margin-bottom: 2px;">
                                        ${t.name || 'Unnamed Tournament'}${finishedBadge}
                                    </div>
                                    <div style="font-size: 12px; color: #64748b;">
                                        ${t.courseName || getCourseDisplayName(t.course)} â¢ ${t.playerCount || 0} players â¢ ${formatTournamentDate(t.date)}
                                    </div>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <span style="font-size: 12px;">${roleIcon}</span>
                                    <span style="font-size: 11px; color: #64748b;">${roleText}</span>
                                </div>
                            </div>
                            <div style="display: flex; gap: 8px; align-items: center;">
                                ${t.joinCode ? `<span style="font-family: monospace; font-weight: 700; font-size: 13px; color: #3b82f6; background: #eff6ff; padding: 4px 8px; border-radius: 4px;">${t.joinCode}</span>` : ''}
                                <button onclick="loadTournamentFromHistory('${t.id}')" style="flex: 1; padding: 10px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                                    Load
                                </button>
                                <button onclick="confirmRemoveFromHistory('${t.id}', '${(t.name || 'Tournament').replace(/'/g, "\\'")}')" style="padding: 10px 12px; background: #fee2e2; color: #ef4444; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;" title="Remove">
                                    ðï¸
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            // Update or create the modal with final content
            const existingModal = document.getElementById('tournamentHistoryModal');
            const targetModal = existingModal || modal;
            
            targetModal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 20px; max-width: 400px; width: 95%; max-height: 80vh; overflow-y: auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h2 style="color: #1e40af; font-size: 20px; margin: 0;">ð Load Tournament</h2>
                        <button onclick="closeTournamentHistoryModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">â</button>
                    </div>
                    
                    <!-- Join by Code Section (First) -->
                    <div style="background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border: 2px solid #3b82f6; border-radius: 12px; padding: 14px; margin-bottom: 16px;">
                        <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 10px;">
                            <span style="font-size: 18px;">ð«</span>
                            <span style="font-weight: 700; color: #1e40af; font-size: 13px;">Enter Code</span>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="historyJoinCodeInput" placeholder="ABCD12" maxlength="6" 
                                style="flex: 1; padding: 12px; font-size: 16px; font-weight: 700; text-align: center; 
                                border: 2px solid #3b82f6; border-radius: 8px; letter-spacing: 2px; font-family: monospace;
                                text-transform: uppercase; background: white;"
                                oninput="this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0,6);"
                                onkeypress="if(event.key === 'Enter') joinFromHistoryModal();">
                            <button onclick="joinFromHistoryModal()" style="padding: 12px 20px; background: #10b981; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 700; cursor: pointer;">
                                Join
                            </button>
                        </div>
                        <p style="font-size: 11px; color: #64748b; margin-top: 6px; text-align: center;">Works with Join Code or Host Code</p>
                        <p id="historyJoinError" style="color: #ef4444; font-size: 12px; margin-top: 4px; text-align: center; min-height: 16px;"></p>
                    </div>
                    
                    <!-- Previous Tournaments Section -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span style="font-size: 13px; font-weight: 700; color: #64748b; text-transform: uppercase;">Previous Tournaments</span>
                        ${history.length > 0 ? `<button onclick="confirmClearHistory()" style="padding: 4px 8px; background: #fee2e2; color: #ef4444; border: none; border-radius: 4px; font-size: 10px; cursor: pointer;">Clear All</button>` : ''}
                    </div>
                    
                    <div id="historyList" style="max-height: 300px; overflow-y: auto;">
                        ${historyHTML}
                    </div>
                    
                    <button onclick="closeTournamentHistoryModal()" style="width: 100%; margin-top: 16px; padding: 14px; background: #64748b; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;
            
            // Only append if not already in DOM
            if (!existingModal) {
                document.body.appendChild(targetModal);
            }
            
            targetModal.onclick = (e) => {
                if (e.target === targetModal) {
                    closeTournamentHistoryModal();
                }
            };
        }
        
        // Close tournament history modal
        function closeTournamentHistoryModal() {
            const modal = document.getElementById('tournamentHistoryModal');
            if (modal) modal.remove();
        }
        
        // Load tournament from history
        async function loadTournamentFromHistory(tournamentId) {
            closeTournamentHistoryModal();
            
            // Check if Firebase is available
            if (!db) {
                showNotification('Offline', 'Cannot load tournament - no database connection');
                return;
            }
            
            // Show loading notification
            showNotification('Loading...', 'Connecting to tournament');
            
            try {
                // Check if tournament still exists in Firebase
                const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                
                if (!tournamentDoc.exists) {
                    showNotification('Not Found', 'This tournament no longer exists');
                    removeFromTournamentHistory(tournamentId);
                    return;
                }
                
                const tournament = tournamentDoc.data();
                
                // Check if this device is the original host
                const isOriginalHost = tournament.hostDevice === currentDeviceId;
                
                // Check if tournament is finished
                if (tournament.isFinished && isOriginalHost) {
                    // Load directly into View Only mode (no more modal prompt)
                    activeTournamentId = tournamentId;
                    tournamentData = tournament;
                    isHost = true;
                    tournamentMode = 'multi';
                    
                    // Load course data - check local first, then use stored data from tournament
                    courseData = courses[tournament.course] || customCourses[tournament.course];
                    if (!courseData && tournament.courseData) {
                        // Use course data stored with tournament
                        courseData = tournament.courseData;
                        // Also add to customCourses for this session
                        customCourses[tournament.course] = tournament.courseData;
                        console.log('ð Loaded course data from tournament:', tournament.courseData.name);
                    }
                    
                    // Subscribe to updates
                    subscribToTournamentUpdates(tournamentId);
                    
                    saveToLocalStorage();
                    
                    // Go to Host Home with finished status
                    updateHostHomePage();
                    updateHostHomeBadge();
                    
                    // Show current tournament card
                    const currentTournamentCard = document.getElementById('hostCurrentTournament');
                    if (currentTournamentCard) {
                        currentTournamentCard.style.display = 'block';
                    }
                    
                    showPage('hostHomePage');
                    showNotification('View Only', 'Finished tournament loaded. Use Tournament Management to reopen or restart.');
                    return;
                }
                
                if (isOriginalHost) {
                    // Device is the host - go straight to host home
                    activeTournamentId = tournamentId;
                    tournamentData = tournament;
                    isHost = true;
                    tournamentMode = 'multi';
                    
                    // Load course data - check local first, then use stored data from tournament
                    courseData = courses[tournament.course] || customCourses[tournament.course];
                    if (!courseData && tournament.courseData) {
                        // Use course data stored with tournament
                        courseData = tournament.courseData;
                        // Also add to customCourses for this session
                        customCourses[tournament.course] = tournament.courseData;
                        console.log('ð Loaded course data from tournament:', tournament.courseData.name);
                    }
                    
                    // Subscribe to updates
                    subscribToTournamentUpdates(tournamentId);
                    
                    saveToLocalStorage();
                    updateHostHomePage();
                    
                    // Show current tournament card
                    const currentTournamentCard = document.getElementById('hostCurrentTournament');
                    if (currentTournamentCard) {
                        currentTournamentCard.style.display = 'block';
                    }
                    
                    showPage('hostHomePage');
                    showNotification('Welcome Back', 'Loaded as host');
                } else {
                    // Go to player join screen (no host choice - must use Host Code)
                    showJoinTournamentScreen(tournamentId);
                }
                
            } catch (error) {
                console.error('Error loading tournament:', error);
                showNotification('Error', `Could not load tournament: ${error.message || 'Unknown error'}`);
            }
        }
        
        // Show options for loading a finished tournament (host only)
        function showFinishedTournamentOptions(tournamentId, tournament) {
            const modal = document.createElement('div');
            modal.id = 'finishedTournamentModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            const tournamentName = tournament.name || 'Tournament';
            const courseName = (courses[tournament.course] || customCourses[tournament.course])?.name || tournament.course;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; max-width: 360px; width: 100%; text-align: center;">
                    <div style="font-size: 40px; margin-bottom: 12px;">ð</div>
                    <h2 style="color: #1e40af; font-size: 18px; margin: 0 0 4px 0;">${tournamentName}</h2>
                    <span style="background: #fef3c7; color: #92400e; font-size: 11px; font-weight: 700; padding: 3px 10px; border-radius: 10px;">FINISHED</span>
                    <p style="color: #64748b; font-size: 13px; margin: 12px 0 20px 0;">${courseName} â¢ ${tournament.date || 'Today'}</p>
                    
                    <p style="color: #475569; font-size: 14px; margin-bottom: 20px;">What would you like to do?</p>
                    
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="loadFinishedTournament('${tournamentId}', 'view')" 
                            style="width: 100%; padding: 14px; background: #3b82f6; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            ðï¸ View Only
                            <span style="display: block; font-size: 11px; font-weight: 400; opacity: 0.9;">Players frozen, host can edit</span>
                        </button>
                        <button onclick="loadFinishedTournament('${tournamentId}', 'continue')" 
                            style="width: 100%; padding: 14px; background: #10b981; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            â¶ï¸ Continue Tournament
                            <span style="display: block; font-size: 11px; font-weight: 400; opacity: 0.9;">Unfreeze, all can edit/score</span>
                        </button>
                        <button onclick="confirmRestartTournament('${tournamentId}')" 
                            style="width: 100%; padding: 14px; background: #ef4444; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            ð Restart Tournament
                            <span style="display: block; font-size: 11px; font-weight: 400; opacity: 0.9;">Clear all scores & claims</span>
                        </button>
                    </div>
                    
                    <button onclick="closeFinishedTournamentModal()" 
                        style="margin-top: 16px; padding: 12px; background: transparent; color: #64748b; border: none; font-size: 14px; cursor: pointer; width: 100%;">
                        Cancel
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeFinishedTournamentModal();
            };
        }
        
        function closeFinishedTournamentModal() {
            const modal = document.getElementById('finishedTournamentModal');
            if (modal) modal.remove();
        }
        
        // Load finished tournament with specified mode
        async function loadFinishedTournament(tournamentId, mode) {
            closeFinishedTournamentModal();
            
            try {
                const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                const tournament = tournamentDoc.data();
                
                if (mode === 'continue') {
                    // Unfreeze the tournament
                    await db.collection('tournaments').doc(tournamentId).update({ isFinished: false });
                    tournament.isFinished = false;
                }
                // For 'view' mode, keep isFinished = true but allow host to edit
                
                activeTournamentId = tournamentId;
                tournamentData = tournament;
                isHost = true;
                courseData = courses[tournament.course] || customCourses[tournament.course];
                saveToLocalStorage();
                updateHostHomePage();
                
                // Show current tournament card
                document.getElementById('hostCurrentTournament').style.display = 'block';
                
                // Update badge to show status
                const badge = document.getElementById('hostTournamentBadge');
                if (badge) {
                    if (tournament.isFinished) {
                        badge.innerHTML = 'ð HOST <span style="background: #fef3c7; color: #92400e; font-size: 9px; margin-left: 4px; padding: 1px 4px; border-radius: 3px;">VIEW</span>';
                    } else {
                        badge.textContent = 'ð HOST';
                    }
                }
                
                showPage('hostHomePage');
                showNotification('Loaded', mode === 'continue' ? 'Tournament resumed' : 'Viewing finished tournament');
                
            } catch (error) {
                console.error('Error loading finished tournament:', error);
                showNotification('Error', 'Failed to load tournament');
            }
        }
        
        // Confirm restart tournament
        function confirmRestartTournament(tournamentId) {
            closeFinishedTournamentModal();
            
            showConfirm(
                'ð Restart Tournament?',
                'This will clear ALL scores and player claims. The tournament will start fresh as if no one had ever joined. This cannot be undone!',
                async function() {
                    try {
                        const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                        const tournament = tournamentDoc.data();
                        
                        // Reset all players - clear scores and claims
                        const resetPlayers = tournament.players.map(p => ({
                            ...p,
                            scores: new Array(18).fill(null),
                            claimedBy: null,
                            deviceInitials: null
                        }));
                        
                        // Update Firebase
                        await db.collection('tournaments').doc(tournamentId).update({
                            players: resetPlayers,
                            isFinished: false
                        });
                        
                        // Load the reset tournament
                        tournament.players = resetPlayers;
                        tournament.isFinished = false;
                        
                        activeTournamentId = tournamentId;
                        tournamentMode = 'multi';
                        tournamentData = tournament;
                        isHost = true;
                        hasJoinedTournament = true;
                        courseData = courses[tournament.course] || customCourses[tournament.course];
                        
                        // CRITICAL: Clear ALL player stats - both general and tournament-specific
                        clearAllPlayerStats();
                        localStorage.removeItem('playerStats_' + tournamentId);
                        
                        saveToLocalStorage();
                        subscribToTournamentUpdates(tournamentId);
                        
                        hideConfirmDialog();
                        updateHostHomePage();
                        document.getElementById('hostCurrentTournament').style.display = 'block';
                        showPage('hostHomePage');
                        showNotification('Restarted', 'Tournament has been reset');
                        
                    } catch (error) {
                        console.error('Error restarting tournament:', error);
                        showNotification('Error', 'Failed to restart tournament');
                        hideConfirmDialog();
                    }
                }
            );
        }
        
        // Show dialog to choose between joining as player or host
        function showJoinOrHostDialog(tournamentId, tournament) {
            const modal = document.createElement('div');
            modal.id = 'joinOrHostModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10001;
                display: flex; align-items: center; justify-content: center; padding: 20px;
            `;
            
            const tournamentName = tournament.name || 'Tournament';
            const courseName = (courses[tournament.course] || customCourses[tournament.course])?.name || tournament.course;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; max-width: 340px; width: 100%; text-align: center;">
                    <div style="font-size: 40px; margin-bottom: 12px;">â³</div>
                    <h2 style="color: #1e40af; font-size: 18px; margin: 0 0 8px 0;">${tournamentName}</h2>
                    <p style="color: #64748b; font-size: 13px; margin: 0 0 20px 0;">${courseName} â¢ ${tournament.date || 'Today'}</p>
                    
                    <p style="color: #475569; font-size: 14px; margin-bottom: 20px;">How would you like to join?</p>
                    
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <button onclick="joinAsPlayerFromDialog('${tournamentId}')" 
                            style="width: 100%; padding: 16px; background: #3b82f6; color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px;">
                            <span style="font-size: 20px;">ð¤</span> Join as Player
                        </button>
                        <button onclick="joinAsHostFromDialog('${tournamentId}')" 
                            style="width: 100%; padding: 16px; background: #f97316; color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px;">
                            <span style="font-size: 20px;">ð</span> Join as Host
                        </button>
                    </div>
                    
                    <button onclick="closeJoinOrHostDialog()" 
                        style="margin-top: 16px; padding: 12px; background: transparent; color: #64748b; border: none; font-size: 14px; cursor: pointer; width: 100%;">
                        Cancel
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.onclick = (e) => {
                if (e.target === modal) closeJoinOrHostDialog();
            };
        }
        
        function closeJoinOrHostDialog() {
            const modal = document.getElementById('joinOrHostModal');
            if (modal) modal.remove();
        }
        
        async function joinAsPlayerFromDialog(tournamentId) {
            closeJoinOrHostDialog();
            // Navigate to join screen for player selection
            showJoinTournamentScreen(tournamentId);
        }
        
        async function joinAsHostFromDialog(tournamentId) {
            closeJoinOrHostDialog();
            
            try {
                // Ensure device ID is initialized
                if (!currentDeviceId) {
                    currentDeviceId = localStorage.getItem('deviceId');
                    if (!currentDeviceId) {
                        currentDeviceId = 'device_' + Math.random().toString(36).substr(2, 9);
                        localStorage.setItem('deviceId', currentDeviceId);
                    }
                }
                
                // Ensure device name/initials are set
                if (!deviceName) {
                    deviceName = localStorage.getItem('deviceName') || 'Host Device';
                }
                if (!deviceInitials) {
                    deviceInitials = localStorage.getItem('deviceInitials') || 'HD';
                }
                
                const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                
                if (!tournamentDoc.exists) {
                    showNotification('Not Found', 'Tournament no longer exists');
                    return;
                }
                
                const tournament = tournamentDoc.data();
                
                // Take over as host
                await db.collection('tournaments').doc(tournamentId).update({
                    hostDevice: currentDeviceId,
                    [`devices.${currentDeviceId}`]: {
                        name: deviceName,
                        initials: deviceInitials,
                        isHost: true,
                        joinedAt: firebase.firestore.FieldValue.serverTimestamp()
                    }
                });
                
                // Set local state
                activeTournamentId = tournamentId;
                tournamentData = { ...tournament, hostDevice: currentDeviceId };
                isHost = true;
                courseData = courses[tournament.course] || customCourses[tournament.course];
                saveToLocalStorage();
                
                // Go to host home page
                updateHostHomePage();
                showPage('hostHomePage');
                showNotification('Host Mode', 'You are now the tournament host');
                
            } catch (error) {
                console.error('Error joining as host:', error);
                showNotification('Error', `Could not take over as host: ${error.message || 'Unknown error'}`);
            }
        }
        
        // Join from history modal (checks both Join Code and Host Code)
        async function joinFromHistoryModal() {
            const input = document.getElementById('historyJoinCodeInput');
            const errorEl = document.getElementById('historyJoinError');
            
            if (!input) return;
            
            const code = input.value.trim().toUpperCase();
            
            if (!isValidJoinCodeFormat(code)) {
                if (errorEl) errorEl.textContent = 'Enter 4 letters + 2 numbers (e.g., ABCD12)';
                return;
            }
            
            if (errorEl) {
                errorEl.textContent = 'Looking up...';
                errorEl.style.color = '#64748b';
            }
            
            try {
                // First, try to find by Join Code
                const joinCodeResult = await findTournamentByCode(code);
                
                if (joinCodeResult.success) {
                    closeTournamentHistoryModal();
                    
                    // Fetch tournament data to check host status
                    const tournamentDoc = await db.collection('tournaments').doc(joinCodeResult.tournamentId).get();
                    
                    if (tournamentDoc.exists) {
                        const tournament = tournamentDoc.data();
                        
                        // Check if this device is the original host
                        const isOriginalHost = tournament.hostDevice === currentDeviceId;
                        
                        if (isOriginalHost) {
                            // Device is the host - go straight to host home
                            activeTournamentId = joinCodeResult.tournamentId;
                            tournamentData = tournament;
                            isHost = true;
                            courseData = courses[tournament.course] || customCourses[tournament.course];
                            saveToLocalStorage();
                            updateHostHomePage();
                            showPage('hostHomePage');
                            showNotification('Welcome Back', 'Loaded as host');
                        } else {
                            // Go to player join screen
                            showJoinTournamentScreen(joinCodeResult.tournamentId);
                        }
                    } else {
                        showNotification('Error', 'Tournament not found');
                    }
                    return;
                }
                
                // Not a Join Code - try Host Code
                const hostCodeSnapshot = await db.collection('tournaments')
                    .where('hostCode', '==', code)
                    .limit(1)
                    .get();
                
                if (!hostCodeSnapshot.empty) {
                    const tournamentDoc = hostCodeSnapshot.docs[0];
                    const tournament = tournamentDoc.data();
                    const tournamentId = tournamentDoc.id;
                    
                    // Check if tournament is still active
                    if (tournament.status === 'ended') {
                        if (errorEl) {
                            errorEl.textContent = 'This tournament has ended';
                            errorEl.style.color = '#ef4444';
                        }
                        return;
                    }
                    
                    closeTournamentHistoryModal();
                    
                    // Grant co-host access
                    const coHosts = tournament.coHosts || [];
                    if (!coHosts.includes(currentDeviceId)) {
                        coHosts.push(currentDeviceId);
                        await db.collection('tournaments').doc(tournamentId).update({
                            coHosts: coHosts,
                            [`devices.${currentDeviceId}`]: {
                                name: deviceName || 'Co-Host Device',
                                initials: deviceInitials || 'CH',
                                isCoHost: true,
                                joinedAt: firebase.firestore.FieldValue.serverTimestamp()
                            },
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                    
                    // Set local state
                    activeTournamentId = tournamentId;
                    tournamentData = tournament;
                    isHost = false;
                    isCoHost = true;
                    courseData = courses[tournament.course] || customCourses[tournament.course];
                    
                    // Add to tournament history
                    addToTournamentHistory({
                        id: tournamentId,
                        joinCode: tournament.joinCode,
                        name: tournament.name || '',
                        date: tournament.date,
                        course: tournament.course,
                        courseName: courseData?.name || tournament.course,
                        role: 'cohost'
                    });
                    
                    saveToLocalStorage();
                    
                    // Go to player join screen to claim players
                    showJoinTournamentScreen(tournamentId);
                    showNotification('Co-Host Access! ð', 'You now have co-host privileges');
                    return;
                }
                
                // Neither Join Code nor Host Code found
                if (errorEl) {
                    errorEl.textContent = 'Code not found. Check and try again.';
                    errorEl.style.color = '#ef4444';
                }
                
            } catch (error) {
                console.error('Error joining by code:', error);
                if (errorEl) {
                    errorEl.textContent = 'Something went wrong. Try again.';
                    errorEl.style.color = '#ef4444';
                }
            }
        }
        
        // Join as Co-Host from history modal (using host code)
        
        // Confirm remove from history
        function confirmRemoveFromHistory(tournamentId, tournamentName) {
            showConfirm(
                'Remove from History?',
                `Remove "${tournamentName}" from your saved tournaments?`,
                function() {
                    removeFromTournamentHistory(tournamentId);
                    hideConfirmDialog();
                    // Refresh the modal
                    closeTournamentHistoryModal();
                    showTournamentHistoryModal();
                    showNotification('Removed', 'Tournament removed from history');
                }
            );
        }
        
        // Confirm clear all history
        function confirmClearHistory() {
            showConfirm(
                'Clear All History?',
                'This will remove all saved tournaments from your device.',
                function() {
                    clearTournamentHistory();
                    hideConfirmDialog();
                    closeTournamentHistoryModal();
                    showTournamentHistoryModal();
                    showNotification('Cleared', 'Tournament history cleared');
                }
            );
        }
        
        // ==================== END TOURNAMENT HISTORY ====================
        
        // Show join tournament screen
        // Track selected players for joining
        let joinSelections = {
            claim: [],  // Players to score for
            watch: [],  // Players to watch
            tournamentId: null
        };
        
        function showJoinTournamentScreen(tournamentId) {
            // Reset selections
            joinSelections = { claim: [], watch: [], tournamentId: tournamentId };
            
            // Load tournament info
            db.collection('tournaments').doc(tournamentId).get()
                .then(doc => {
                    if (doc.exists) {
                        const tournament = doc.data();
                        
                        // AUTO-REJOIN: Check if this device already has claimed players
                        if (tournament.players && tournament.players.length > 0) {
                            const claimedByThisDevice = tournament.players.filter(p => p.claimedBy === currentDeviceId);
                            if (claimedByThisDevice.length > 0) {
                                // Device recognized with claimed players - bypass join screen!
                                console.log(`ð Auto-rejoin: Found ${claimedByThisDevice.length} claimed players for device ${currentDeviceId}`);
                                
                                // Set up tournament data and go directly to scoring
                                tournamentData = {
                                    id: tournamentId,
                                    name: tournament.name || '',
                                    date: tournament.date,
                                    gameType: tournament.gameType,
                                    course: tournament.course,
                                    players: tournament.players,
                                    teams: tournament.teams || [],
                                    courseData: tournament.courseData
                                };
                                activeTournamentId = tournamentId;
                                tournamentMode = 'multi';
                                isHost = false;
                                
                                // Set up course data - prefer embedded data from tournament
                                if (tournament.courseData) {
                                    courseData = tournament.courseData;
                                    customCourses[tournament.course] = tournament.courseData;
                                } else if (tournament.course && courses[tournament.course]) {
                                    courseData = courses[tournament.course];
                                } else if (customCourses[tournament.course]) {
                                    courseData = customCourses[tournament.course];
                                }
                                
                                // Update claimed players list
                                claimedPlayers = claimedByThisDevice.map(p => p.name);
                                playerOrder.claimed = claimedPlayers;
                                savePlayerOrder();
                                saveToLocalStorage();
                                
                                // Set up real-time listener
                                subscribToTournamentUpdates(tournamentId);
                                
                                // Add to tournament history
                                addToTournamentHistory({
                                    id: tournamentId,
                                    joinCode: tournament.joinCode || '',
                                    name: tournament.name || '',
                                    course: tournament.course,
                                    date: tournament.date,
                                    gameType: tournament.gameType,
                                    role: 'player'
                                });
                                
                                // Go directly to scoring page
                                renderScoringPage();
                                showPage('scoringPage');
                                switchToHoleView();
                                
                                showNotification('Welcome Back!', `Scoring for ${claimedPlayers.join(', ')}`);
                                return;
                            }
                        }
                        
                        const infoEl = document.getElementById('joinTournamentInfo');
                        infoEl.textContent = `${tournament.course} â¢ ${tournament.date} â¢ ${tournament.gameType}`;
                        
                        // Show existing players if any
                        if (tournament.players && tournament.players.length > 0) {
                            document.getElementById('joinExistingPlayers').style.display = 'block';
                            document.getElementById('joinDivider').style.display = 'block';
                            document.getElementById('joinBottomOptions').style.display = 'block';
                            const listEl = document.getElementById('existingPlayersList');
                            
                            listEl.innerHTML = tournament.players.map((p, index) => {
                                const colors = [
                                    { bg: '#dbeafe', border: '#3b82f6', text: '#1e40af' },
                                    { bg: '#fef3c7', border: '#f59e0b', text: '#92400e' },
                                    { bg: '#d1fae5', border: '#10b981', text: '#065f46' },
                                    { bg: '#fce7f3', border: '#ec4899', text: '#9f1239' },
                                    { bg: '#e0e7ff', border: '#6366f1', text: '#3730a3' },
                                ];
                                const color = colors[index % colors.length];
                                const isClaimed = p.claimedBy;
                                
                                return `
                                    <div id="playerRow_${index}" class="join-player-row" data-player="${p.name}" data-handicap="${p.handicap}" data-index="${index}"
                                        style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                                        
                                        <!-- Player Info Button -->
                                        <div style="flex: 1; padding: 14px 16px; background: ${isClaimed ? '#f1f5f9' : color.bg}; border: 2px solid ${isClaimed ? '#94a3b8' : color.border}; border-radius: 10px; opacity: ${isClaimed ? '0.6' : '1'};">
                                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                                <span style="display: flex; align-items: center; gap: 10px; color: ${isClaimed ? '#64748b' : color.text}; font-weight: 600;">
                                                    <span style="font-size: 20px;">${isClaimed ? 'ð' : 'â³'}</span>
                                                    <span>${p.name}</span>
                                                </span>
                                                <span style="background: white; padding: 3px 10px; border-radius: 16px; font-size: 13px; font-weight: 700; color: ${isClaimed ? '#64748b' : color.text};">
                                                    ${p.handicap}
                                                </span>
                                            </div>
                                        </div>
                                        
                                        ${!isClaimed ? `
                                        <!-- Claim Button -->
                                        <button type="button" onclick="toggleJoinSelection(${index}, 'claim', '${p.name}')" id="claimBtn_${index}"
                                            style="width: 48px; height: 48px; border-radius: 10px; border: 2px solid #10b981; background: white; color: #10b981; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;"
                                            title="Score for this player">
                                            â
                                        </button>
                                        
                                        <!-- Watch Button -->
                                        <button type="button" onclick="toggleJoinSelection(${index}, 'watch', '${p.name}')" id="watchBtn_${index}"
                                            style="width: 48px; height: 48px; border-radius: 10px; border: 2px solid #64748b; background: white; color: #64748b; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;"
                                            title="Watch this player">
                                            ð
                                        </button>
                                        ` : `
                                        <div style="width: 104px; text-align: center; font-size: 11px; color: #64748b;">Claimed</div>
                                        `}
                                    </div>
                                `;
                            }).join('');
                        } else {
                            document.getElementById('joinExistingPlayers').style.display = 'none';
                            document.getElementById('joinDivider').style.display = 'block';
                            document.getElementById('joinBottomOptions').style.display = 'block';
                        }
                        
                        // Hide join button initially
                        document.getElementById('joinTournamentBtnContainer').style.display = 'none';
                        document.getElementById('selectionSummary').style.display = 'none';
                        
                        showPage('joinPage');
                        
                        // Store tournament ID for form submission
                        document.getElementById('joinTournamentForm').dataset.tournamentId = tournamentId;
                    } else {
                        showNotification('Error', 'Tournament not found!');
                        showPage('setupPage');
                    }
                })
                .catch(error => {
                    console.error('Error loading tournament:', error);
                    showNotification('Error', 'Failed to load tournament. Please try again.');
                    showPage('setupPage');
                });
        }
        
        function toggleJoinSelection(index, type, playerName) {
            const claimBtn = document.getElementById(`claimBtn_${index}`);
            const watchBtn = document.getElementById(`watchBtn_${index}`);
            
            if (type === 'claim') {
                const idx = joinSelections.claim.indexOf(playerName);
                if (idx > -1) {
                    // Deselect claim
                    joinSelections.claim.splice(idx, 1);
                    claimBtn.style.background = 'white';
                    claimBtn.style.color = '#10b981';
                } else {
                    // Select claim, remove from watch if there
                    joinSelections.claim.push(playerName);
                    claimBtn.style.background = '#10b981';
                    claimBtn.style.color = 'white';
                    
                    // Remove from watch
                    const watchIdx = joinSelections.watch.indexOf(playerName);
                    if (watchIdx > -1) {
                        joinSelections.watch.splice(watchIdx, 1);
                        watchBtn.style.background = 'white';
                        watchBtn.style.color = '#64748b';
                    }
                }
            } else if (type === 'watch') {
                const idx = joinSelections.watch.indexOf(playerName);
                if (idx > -1) {
                    // Deselect watch
                    joinSelections.watch.splice(idx, 1);
                    watchBtn.style.background = 'white';
                    watchBtn.style.color = '#64748b';
                } else {
                    // Select watch, remove from claim if there
                    joinSelections.watch.push(playerName);
                    watchBtn.style.background = '#64748b';
                    watchBtn.style.color = 'white';
                    
                    // Remove from claim
                    const claimIdx = joinSelections.claim.indexOf(playerName);
                    if (claimIdx > -1) {
                        joinSelections.claim.splice(claimIdx, 1);
                        claimBtn.style.background = 'white';
                        claimBtn.style.color = '#10b981';
                    }
                }
            }
            
            updateJoinSelectionUI();
        }
        
        function updateJoinSelectionUI() {
            const hasSelections = joinSelections.claim.length > 0 || joinSelections.watch.length > 0;
            
            document.getElementById('joinTournamentBtnContainer').style.display = hasSelections ? 'block' : 'none';
            document.getElementById('selectionSummary').style.display = hasSelections ? 'block' : 'none';
            document.getElementById('claimCount').textContent = joinSelections.claim.length;
            document.getElementById('watchCount').textContent = joinSelections.watch.length;
        }
        
        async function executeJoinTournament() {
            if (joinSelections.claim.length === 0 && joinSelections.watch.length === 0) {
                showNotification('Select Players', 'Please select at least one player to claim or watch');
                return;
            }
            
            // If claiming players, need initials - but auto-use logged in name if available
            if (joinSelections.claim.length > 0) {
                let playerInitials;
                
                // Check if user is logged in - use their display name
                if (currentAuthUser && currentAuthUser.displayName) {
                    playerInitials = currentAuthUser.displayName;
                    console.log('ð§ Using logged-in user name:', playerInitials);
                } else if (currentAuthUser && currentAuthUser.email) {
                    // Use email username (before @)
                    playerInitials = currentAuthUser.email.split('@')[0];
                    console.log('ð§ Using email username:', playerInitials);
                } else {
                    // Not logged in - prompt for initials
                    playerInitials = prompt('Enter your initials (so host knows who\'s scoring):');
                    if (!playerInitials) return;
                    playerInitials = playerInitials.toUpperCase();
                }
                
                localStorage.setItem('deviceInitials', playerInitials);
                deviceInitials = playerInitials;
            }
            
            try {
                const tournamentId = joinSelections.tournamentId;
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Claim selected players
                for (const playerName of joinSelections.claim) {
                    const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                    if (playerIndex > -1 && !tournament.players[playerIndex].claimedBy) {
                        tournament.players[playerIndex].claimedBy = currentDeviceId;
                    }
                }
                
                // Initialize devices if needed
                if (!tournament.devices) tournament.devices = {};
                const deviceInitialsValue = localStorage.getItem('deviceInitials') || 'Guest';
                tournament.devices[currentDeviceId] = {
                    name: deviceInitialsValue,
                    initials: deviceInitialsValue,
                    joinedAt: new Date().toISOString()
                };
                
                // Save to Firebase
                await tournamentRef.update({
                    players: tournament.players,
                    devices: tournament.devices,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Set local state
                activeTournamentId = tournamentId;
                tournamentMode = 'multi';
                isHost = false;
                isGuestUser = true;
                hasJoinedTournament = true; // Mark as joined
                claimedPlayers = joinSelections.claim;
                playerOrder.watching = joinSelections.watch;
                savePlayerOrder();
                
                // Load tournament data
                tournamentData = {
                    id: tournamentId,
                    name: tournament.name || '',
                    date: tournament.date,
                    gameType: tournament.gameType,
                    course: tournament.course,
                    players: tournament.players,
                    teams: tournament.teams || [],
                    courseData: tournament.courseData
                };
                
                // Load course data
                if (tournament.courseData) {
                    courseData = tournament.courseData;
                    customCourses[tournament.course] = tournament.courseData;
                } else {
                    courseData = courses[tournament.course] || customCourses[tournament.course];
                }
                
                saveToLocalStorage();
                subscribToTournamentUpdates(tournamentId);
                
                // Add to tournament history
                addToTournamentHistory({
                    id: tournamentId,
                    joinCode: tournament.joinCode || '',
                    name: tournament.name || '',
                    course: tournament.course,
                    date: tournament.date,
                    gameType: tournament.gameType,
                    role: joinSelections.claim.length > 0 ? 'player' : 'viewer'
                });
                
                // Navigate based on what was selected
                if (joinSelections.claim.length > 0) {
                    renderScoringPage();
                    showPage('scoringPage');
                    switchToHoleView();
                    showNotification('Ready!', `Scoring for ${joinSelections.claim.join(', ')}`);
                } else {
                    renderScoringPage();
                    showPage('scoringPage');
                    showNotification('Watching', `Following ${joinSelections.watch.join(', ')}`);
                }
            } catch (error) {
                console.error('Error joining tournament:', error);
                showNotification('Error', 'Failed to join tournament');
            }
        }
        
        async function joinAsViewer() {
            try {
                const tournamentId = joinSelections.tournamentId;
                const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
                const tournament = tournamentDoc.data();
                
                // Set local state as viewer only
                activeTournamentId = tournamentId;
                tournamentMode = 'multi';
                isHost = false;
                isGuestUser = true;
                hasJoinedTournament = true; // Mark as joined (as viewer)
                claimedPlayers = [];
                
                tournamentData = {
                    id: tournamentId,
                    name: tournament.name || '',
                    date: tournament.date,
                    gameType: tournament.gameType,
                    course: tournament.course,
                    players: tournament.players,
                    teams: tournament.teams || []
                };
                
                saveToLocalStorage();
                subscribToTournamentUpdates(tournamentId);
                
                // Add to tournament history
                addToTournamentHistory({
                    id: tournamentId,
                    joinCode: tournament.joinCode || '',
                    name: tournament.name || '',
                    course: tournament.course,
                    date: tournament.date,
                    gameType: tournament.gameType,
                    role: 'viewer'
                });
                
                renderScoringPage();
                showPage('scoringPage');
                showNotification('Viewing', 'Watching the tournament');
            } catch (error) {
                console.error('Error joining as viewer:', error);
                showNotification('Error', 'Failed to join');
            }
        }
        
        function showAddNewPlayerForm() {
            document.getElementById('joinExistingPlayers').style.display = 'none';
            document.getElementById('joinDivider').style.display = 'none';
            document.getElementById('joinBottomOptions').style.display = 'none';
            document.getElementById('joinTournamentBtnContainer').style.display = 'none';
            document.getElementById('joinTournamentForm').style.display = 'block';
        }
        
        function hideAddNewPlayerForm() {
            document.getElementById('joinExistingPlayers').style.display = 'block';
            document.getElementById('joinDivider').style.display = 'block';
            document.getElementById('joinBottomOptions').style.display = 'block';
            document.getElementById('joinTournamentForm').style.display = 'none';
            updateJoinSelectionUI();
        }
        
        // Handle join tournament form submission
        document.addEventListener('DOMContentLoaded', () => {
            // Set default date to today
            const today = new Date();
            const dateStr = today.toISOString().split('T')[0];
            const dateInput = document.getElementById('tournamentDate');
            if (dateInput && !dateInput.value) {
                dateInput.value = dateStr;
            }
            
            // Check if URL has join parameter
            checkForJoinLink();
            
            const joinForm = document.getElementById('joinTournamentForm');
            if (joinForm) {
                joinForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const tournamentId = joinForm.dataset.tournamentId;
                    const playerInfo = {
                        name: document.getElementById('joinPlayerName').value.trim(),
                        handicap: parseFloat(document.getElementById('joinPlayerHandicap').value) || 0,
                        email: document.getElementById('joinPlayerEmail').value.trim(),
                        phone: document.getElementById('joinPlayerPhone').value.trim()
                    };
                    
                    const success = await joinTournament(tournamentId, playerInfo);
                    
                    if (success) {
                        isGuestUser = true; // Mark as guest - no home access
                        showNotification('Joined!', 'You\'ve joined the tournament');
                        // Navigate to scoring
                        renderScoringPage();
                        showPage('scoringPage');
                    }
                });
            }
        });
        
        // Show handicap confirmation dialog
        // Claim dialog state
        let claimHcpMode = 'index'; // 'index' or 'course'
        let claimSelectedTee = null;
        let claimPlayerHandicapIndex = null;
        
        function showHandicapConfirmDialog(tournamentId, playerName, currentHandicap) {
            const dialog = document.getElementById('handicapConfirmDialog');
            const nameInput = document.getElementById('claimPlayerNameInput');
            const originalNameInput = document.getElementById('claimPlayerOriginalName');
            const handicapInput = document.getElementById('handicapConfirmInput');
            const initialsInput = document.getElementById('initialsInput');
            const cancelBtn = document.getElementById('handicapConfirmCancel');
            const okBtn = document.getElementById('handicapConfirmOk');
            
            // Set editable name field and store original name
            nameInput.value = playerName;
            originalNameInput.value = playerName;
            
            // Get player's handicap index from tournament data - round to nearest tenth
            const player = tournamentData?.players?.find(p => p.name === playerName);
            const rawIndex = player?.handicapIndex ?? currentHandicap;
            claimPlayerHandicapIndex = Math.round(rawIndex * 10) / 10; // Round to nearest tenth
            
            // Reset to default mode
            claimHcpMode = 'index';
            setClaimHcpMode('index');
            
            // Set initial handicap value (rounded to tenth)
            handicapInput.value = claimPlayerHandicapIndex;
            
            // Set selected tee to tournament default
            claimSelectedTee = tournamentData?.tee || null;
            
            // Render tee buttons
            renderClaimTeeButtons();
            
            // Update calculated course HCP display
            updateClaimCourseHcp();
            
            // Pre-fill initials if saved
            const savedInitials = localStorage.getItem('deviceInitials') || '';
            initialsInput.value = savedInitials;
            
            dialog.style.display = 'flex';
            
            // Focus on initials input if empty, otherwise handicap
            setTimeout(() => {
                if (!savedInitials) {
                    initialsInput.focus();
                } else {
                    handicapInput.focus();
                }
            }, 100);
            
            // Auto-uppercase initials
            initialsInput.addEventListener('input', (e) => {
                e.target.value = e.target.value.toUpperCase();
            });
            
            // Cancel handler
            const handleCancel = () => {
                dialog.style.display = 'none';
                cancelBtn.removeEventListener('click', handleCancel);
                okBtn.removeEventListener('click', handleOk);
            };
            
            // OK handler
            const handleOk = () => {
                const newName = nameInput.value.trim();
                const originalName = originalNameInput.value;
                const initials = initialsInput.value.trim().toUpperCase();
                
                if (!newName) {
                    alert('Please enter a player name');
                    nameInput.focus();
                    return;
                }
                
                if (!initials) {
                    alert('Please enter your initials');
                    initialsInput.focus();
                    return;
                }
                
                // Round handicap index to nearest tenth
                let handicapIndexRaw = parseFloat(handicapInput.value) || 0;
                let handicapIndex = Math.round(handicapIndexRaw * 10) / 10;
                
                // Calculate final course handicap (always whole number)
                let finalCourseHcp;
                
                if (claimHcpMode === 'index') {
                    // Calculate course handicap from index
                    if (courseData && courseData.tees && claimSelectedTee) {
                        const teeData = courseData.tees[claimSelectedTee];
                        if (teeData) {
                            finalCourseHcp = calculateCourseHandicap(handicapIndex, teeData.slope, teeData.rating, courseData.totalPar);
                        } else {
                            finalCourseHcp = Math.round(handicapIndex);
                        }
                    } else {
                        finalCourseHcp = Math.round(handicapIndex);
                    }
                } else {
                    // Course HCP mode - use entered value directly (round to whole)
                    finalCourseHcp = Math.round(parseFloat(handicapInput.value) || 0);
                    handicapIndex = null; // Mark as manually entered
                }
                
                // Save initials for next time
                localStorage.setItem('deviceInitials', initials);
                
                dialog.style.display = 'none';
                cancelBtn.removeEventListener('click', handleCancel);
                okBtn.removeEventListener('click', handleOk);
                
                // Pass additional data for tee, mode, and name change
                selectExistingPlayerWithTee(tournamentId, originalName, finalCourseHcp, initials, {
                    tee: claimSelectedTee,
                    handicapIndex: handicapIndex,
                    hcpMode: claimHcpMode,
                    needsHcpConfirmation: false,
                    newName: newName !== originalName ? newName : null
                });
            };
            
            cancelBtn.addEventListener('click', handleCancel);
            okBtn.addEventListener('click', handleOk);
            
            // Enter key to confirm on both inputs
            const handleEnterKey = (e) => {
                if (e.key === 'Enter') {
                    handleOk();
                }
            };
            
            handicapInput.addEventListener('keyup', handleEnterKey);
            initialsInput.addEventListener('keyup', handleEnterKey);
        }
        
        function setClaimHcpMode(mode) {
            claimHcpMode = mode;
            const indexBtn = document.getElementById('hcpModeIndex');
            const courseBtn = document.getElementById('hcpModeCourse');
            const label = document.getElementById('handicapInputLabel');
            const calcDisplay = document.getElementById('claimCalculatedHcp');
            const input = document.getElementById('handicapConfirmInput');
            
            if (mode === 'index') {
                indexBtn.style.background = '#3b82f6';
                indexBtn.style.color = 'white';
                indexBtn.style.borderColor = '#3b82f6';
                courseBtn.style.background = 'white';
                courseBtn.style.color = '#64748b';
                courseBtn.style.borderColor = '#e2e8f0';
                label.textContent = 'HCP Index';
                input.step = '0.1';
                input.placeholder = '0.0';
                calcDisplay.style.display = 'block';
                // Restore index value
                if (claimPlayerHandicapIndex !== null) {
                    input.value = claimPlayerHandicapIndex;
                }
            } else {
                courseBtn.style.background = '#3b82f6';
                courseBtn.style.color = 'white';
                courseBtn.style.borderColor = '#3b82f6';
                indexBtn.style.background = 'white';
                indexBtn.style.color = '#64748b';
                indexBtn.style.borderColor = '#e2e8f0';
                label.textContent = 'Course HCP';
                input.step = '1';
                input.placeholder = '0';
                calcDisplay.style.display = 'none';
                // Convert to course HCP if we have index
                if (claimPlayerHandicapIndex !== null && courseData?.tees?.[claimSelectedTee]) {
                    const teeData = courseData.tees[claimSelectedTee];
                    input.value = calculateCourseHandicap(claimPlayerHandicapIndex, teeData.slope, teeData.rating, courseData.totalPar);
                }
            }
            updateClaimCourseHcp();
        }
        
        function renderClaimTeeButtons() {
            const container = document.getElementById('claimTeeButtons');
            const defaultNote = document.getElementById('claimTeeDefault');
            
            if (!container) return;
            
            if (!courseData || !courseData.tees) {
                container.innerHTML = '<span style="color: #64748b; font-size: 13px;">No tee data available</span>';
                return;
            }
            
            const teeColors = {
                black: '#1e293b',
                blue: '#3b82f6',
                white: '#f1f5f9',
                gold: '#fbbf24',
                red: '#ef4444'
            };
            
            const tournamentTee = tournamentData?.tee || null;
            
            container.innerHTML = Object.keys(courseData.tees).map(teeKey => {
                const tee = courseData.tees[teeKey];
                const bgColor = teeColors[teeKey] || '#94a3b8';
                const textColor = (teeKey === 'white' || teeKey === 'gold') ? '#1e293b' : 'white';
                const isSelected = claimSelectedTee === teeKey;
                const isDefault = tournamentTee === teeKey;
                const borderColor = isSelected ? '#10b981' : (teeKey === 'white' ? '#cbd5e1' : bgColor);
                
                // Format the display name (shorten combos)
                const displayName = formatTeeName(tee.name || teeKey);
                
                return `
                    <button type="button" onclick="selectClaimTee('${teeKey}')" style="
                        padding: 8px 14px;
                        background: ${bgColor};
                        color: ${textColor};
                        border: 3px solid ${borderColor};
                        border-radius: 8px;
                        font-size: 12px;
                        font-weight: 600;
                        cursor: pointer;
                        position: relative;
                        ${isSelected ? 'box-shadow: 0 0 0 2px #10b981;' : ''}
                    " title="${tee.name || teeKey}">
                        ${displayName}
                        ${isDefault ? ' â' : ''}
                    </button>
                `;
            }).join('');
            
            if (tournamentTee) {
                const teeName = courseData.tees[tournamentTee]?.name || tournamentTee;
                defaultNote.textContent = `â = Tournament default (${teeName})`;
            } else {
                defaultNote.textContent = '';
            }
        }
        
        function selectClaimTee(teeKey) {
            claimSelectedTee = teeKey;
            renderClaimTeeButtons();
            updateClaimCourseHcp();
        }
        
        function updateClaimCourseHcp() {
            const input = document.getElementById('handicapConfirmInput');
            const calcDisplay = document.getElementById('claimCalculatedHcp');
            
            if (!calcDisplay) return;
            
            if (claimHcpMode === 'course') {
                calcDisplay.style.display = 'none';
                calcDisplay.textContent = '';
                return;
            }
            
            const indexValue = parseFloat(input?.value) || 0;
            
            if (courseData && courseData.tees && claimSelectedTee) {
                const teeData = courseData.tees[claimSelectedTee];
                if (teeData) {
                    const courseHcp = calculateCourseHandicap(indexValue, teeData.slope, teeData.rating, courseData.totalPar);
                    calcDisplay.textContent = `Course HCP: ${courseHcp}`;
                    calcDisplay.style.display = 'block';
                    return;
                }
            }
            
            calcDisplay.textContent = `Course HCP: ${Math.round(indexValue)}`;
            calcDisplay.style.display = 'block';
        }
        
        // Select existing player when joining
        async function selectExistingPlayer(tournamentId, playerName, confirmedHandicap, userInitials) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) {
                    alert('Player not found!');
                    return;
                }
                
                const player = tournament.players[playerIndex];
                
                // Check if already claimed
                if (player.claimedBy) {
                    alert(`${playerName} is already being scored by another device!`);
                    return;
                }
                
                // Initialize devices object if it doesn't exist
                if (!tournament.devices) {
                    tournament.devices = {};
                }
                
                // Create or update device entry with initials
                if (userInitials) {
                    tournament.devices[currentDeviceId] = {
                        name: userInitials,
                        initials: userInitials,
                        joinedAt: new Date().toISOString()
                    };
                }
                
                // Update handicap if provided
                if (confirmedHandicap !== undefined && confirmedHandicap !== player.handicap) {
                    tournament.players[playerIndex].handicap = confirmedHandicap;
                }
                
                // Save changes before claiming
                await tournamentRef.update({
                    players: tournament.players,
                    devices: tournament.devices,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Claim this player
                const claimed = await claimAdditionalPlayer(tournamentId, playerName);
                if (claimed) {
                    activeTournamentId = tournamentId;
                    tournamentMode = 'multi';
                    // Only set isHost to false if NOT already the host
                    // (hosts claiming players should retain host status)
                    if (!isHost) {
                        isHost = false; // Not the host, just a participant
                    }
                    
                    // Add to claimed players list if not already there
                    if (!claimedPlayers.includes(playerName)) {
                        claimedPlayers.push(playerName);
                    }
                    
                    // Load tournament data into local tournamentData
                    tournamentData = {
                        id: tournamentId,
                        name: tournament.name || '',
                        date: tournament.date,
                        gameType: tournament.gameType,
                        course: tournament.course,
                        players: tournament.players,
                        teams: tournament.teams || []
                    };
                    
                    // Save to localStorage
                    saveToLocalStorage();
                    
                    // Subscribe to updates
                    subscribToTournamentUpdates(tournamentId);
                    
                    // Check if we should return to My Players page
                    if (claimingFromMyPlayersModal || window.returnToMyPlayersPage) {
                        claimingFromMyPlayersModal = false;
                        window.returnToMyPlayersPage = false;
                        showNotification('Claimed!', `Now scoring for ${playerName}`);
                        showMyPlayersPage(); // Return to My Players page
                    } else {
                        // FIXED: Ensure scoring page shows content by defaulting to Hole View
                        currentView = 'hole'; // Force hole view
                        renderScoringPage();
                        showPage('scoringPage');
                        
                        // Delay hole view render to ensure tournamentData is fully loaded
                        setTimeout(() => {
                            switchToHoleView();
                        }, 100);
                        
                        showNotification('Ready to Score!', `You're scoring for ${playerName}`);
                    }
                }
            } catch (error) {
                console.error('Error selecting player:', error);
                alert('Failed to select player');
            }
        }
        
        // Select existing player with tee and HCP mode info
        async function selectExistingPlayerWithTee(tournamentId, playerName, confirmedHandicap, userInitials, options = {}) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) {
                    alert('Player not found!');
                    return;
                }
                
                const player = tournament.players[playerIndex];
                
                // Check if already claimed
                if (player.claimedBy) {
                    alert(`${playerName} is already being scored by another device!`);
                    return;
                }
                
                // Initialize devices object if it doesn't exist
                if (!tournament.devices) {
                    tournament.devices = {};
                }
                
                // Create or update device entry with initials
                if (userInitials) {
                    tournament.devices[currentDeviceId] = {
                        name: userInitials,
                        initials: userInitials,
                        joinedAt: new Date().toISOString()
                    };
                }
                
                // Handle name change if provided
                const finalPlayerName = options.newName || playerName;
                if (options.newName) {
                    tournament.players[playerIndex].name = options.newName;
                }
                
                // Update player with handicap and tee info
                tournament.players[playerIndex].handicap = confirmedHandicap;
                tournament.players[playerIndex].tee = options.tee || tournament.tee;
                tournament.players[playerIndex].handicapIndex = options.handicapIndex;
                tournament.players[playerIndex].hcpMode = options.hcpMode || 'index';
                tournament.players[playerIndex].needsHcpConfirmation = false; // Confirmed on claim
                
                // Save changes before claiming
                await tournamentRef.update({
                    players: tournament.players,
                    devices: tournament.devices,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Claim this player (use final name after possible rename)
                const claimed = await claimAdditionalPlayer(tournamentId, finalPlayerName);
                if (claimed) {
                    activeTournamentId = tournamentId;
                    tournamentMode = 'multi';
                    // Only set isHost to false if NOT already the host
                    if (!isHost) {
                        isHost = false;
                    }
                    
                    if (!claimedPlayers.includes(finalPlayerName)) {
                        claimedPlayers.push(finalPlayerName);
                    }
                    
                    tournamentData = {
                        id: tournamentId,
                        name: tournament.name || '',
                        date: tournament.date,
                        gameType: tournament.gameType,
                        course: tournament.course,
                        tee: tournament.tee,
                        players: tournament.players,
                        teams: tournament.teams || []
                    };
                    
                    saveToLocalStorage();
                    subscribToTournamentUpdates(tournamentId);
                    
                    if (claimingFromMyPlayersModal || window.returnToMyPlayersPage) {
                        claimingFromMyPlayersModal = false;
                        window.returnToMyPlayersPage = false;
                        showNotification('Claimed!', `Now scoring for ${finalPlayerName}`);
                        showMyPlayersPage();
                    } else {
                        currentView = 'hole';
                        renderScoringPage();
                        showPage('scoringPage');
                        setTimeout(() => switchToHoleView(), 100);
                        showNotification('Ready to Score!', `You're scoring for ${playerName}`);
                    }
                }
            } catch (error) {
                console.error('Error selecting player:', error);
                alert('Failed to select player');
            }
        }
        
        // Handle leaderboard action button click
        function handleLeaderboardAction() {
            // If user has claimed players and tournament data loaded, go to scoring
            if (activeTournamentId && tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                renderScoringPage();
                showPage('scoringPage');
                switchToHoleView();
            } else {
                // Otherwise go to setup page
                showPage('setupPage');
            }
        }
        
        // Show list of unclaimed players for additional claims
        async function showClaimPlayersList() {
            if (!activeTournamentId) {
                showNotification('Error', 'No active tournament');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const modal = document.getElementById('claimPlayersModal');
                const content = document.getElementById('claimPlayersListContent');
                
                // Filter unclaimed players
                const unclaimedPlayers = tournament.players.filter(p => !p.claimedBy);
                
                if (unclaimedPlayers.length === 0) {
                    content.innerHTML = `
                        <div style="text-align: center; padding: 40px 20px;">
                            <p style="font-size: 40px; margin-bottom: 12px;">â</p>
                            <p style="color: #64748b; font-size: 16px;">All players have been claimed!</p>
                        </div>
                    `;
                } else {
                    content.innerHTML = unclaimedPlayers.map((p, index) => {
                        const colors = [
                            { bg: '#dbeafe', border: '#3b82f6', text: '#1e40af' },
                            { bg: '#fef3c7', border: '#f59e0b', text: '#92400e' },
                            { bg: '#d1fae5', border: '#10b981', text: '#065f46' },
                            { bg: '#fce7f3', border: '#ec4899', text: '#9f1239' },
                            { bg: '#e0e7ff', border: '#6366f1', text: '#3730a3' },
                        ];
                        const color = colors[index % colors.length];
                        
                        return `
                            <button type="button"
                                onclick="claimAdditionalPlayerFromList('${p.name}', ${p.handicap})"
                                style="
                                    width: 100%;
                                    padding: 16px;
                                    margin-bottom: 12px;
                                    background: ${color.bg};
                                    border: 2px solid ${color.border};
                                    border-radius: 12px;
                                    color: ${color.text};
                                    font-size: 16px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    display: flex;
                                    align-items: center;
                                    justify-content: space-between;
                                    transition: all 0.2s;
                                ">
                                <span style="display: flex; align-items: center; gap: 12px;">
                                    <span style="font-size: 24px;">â³</span>
                                    <span>${p.name}</span>
                                </span>
                                <span style="background: white; padding: 4px 12px; border-radius: 20px; font-size: 14px;">
                                    HCP ${p.handicap}
                                </span>
                            </button>
                        `;
                    }).join('');
                }
                
                modal.style.display = 'flex';
            } catch (error) {
                console.error('Error loading players:', error);
                showNotification('Error', 'Failed to load players');
            }
        }
        
        // Claim additional player from the list
        function claimAdditionalPlayerFromList(playerName, currentHandicap) {
            // Close the modal
            document.getElementById('claimPlayersModal').style.display = 'none';
            // Show handicap confirmation dialog
            showHandicapConfirmDialog(activeTournamentId, playerName, currentHandicap);
        }
        
        // Update Live leaderboard display
        function updateLiveLeaderboard(tournament) {
            if (!tournament || !tournament.players) return;
            
            // Update tournament info header
            const infoEl = document.getElementById('liveLeaderboardInfo');
            if (infoEl) {
                let infoText = tournament.date || '';
                if (tournament.name) {
                    infoText = tournament.name + (tournament.date ? ' â¢ ' + tournament.date : '');
                }
                infoEl.textContent = infoText;
            }
            
            const content = document.getElementById('liveLeaderboardContent');
            if (!content) return;
            
            // Get current game type from tabs or use first enabled game
            const enabledGames = tournament.enabledGames || [tournament.gameType];
            const currentGame = document.querySelector('.game-tab.active')?.dataset.gameType || enabledGames[0];
            
            // Calculate results for current game - show ALL players
            const results = calculateGameResults(tournament.players, currentGame, tournament.course);
            
            // Render leaderboard - ALL players, not just top 10
            content.innerHTML = results.map((player, index) => {
                const medal = index === 0 ? 'ð¥' : index === 1 ? 'ð¥' : index === 2 ? 'ð¥' : '';
                const rankClass = index === 0 ? 'first' : index === 1 ? 'second' : index === 2 ? 'third' : '';
                
                // Count holes played
                const holesPlayed = player.scores ? player.scores.filter(s => s > 0).length : 0;
                const thruText = holesPlayed === 18 ? 'F' : holesPlayed > 0 ? `${holesPlayed}` : '-';
                
                return `
                    <div class="leaderboard-entry ${rankClass}" onclick="showPlayerScorecardPopup('${player.name.replace(/'/g, "\\'")}')" style="cursor: pointer;">
                        <div class="leaderboard-rank">${medal || (index + 1) + '.'}</div>
                        <div class="leaderboard-name" style="flex: 1;">
                            ${player.name}
                            <span style="font-size: 10px; color: #94a3b8; margin-left: 4px;">thru ${thruText}</span>
                        </div>
                        <div class="leaderboard-score">${player.displayScore}</div>
                    </div>
                `;
            }).join('');
            
            // Update info
            document.getElementById('activePlayersCount').textContent = tournament.players.length;
            document.getElementById('lastUpdateTime').textContent = 'Just now';
            
            // Update action button based on whether user can score
            const actionBtn = document.getElementById('leaderboardActionBtn');
            if (actionBtn) {
                if (activeTournamentId && tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                    actionBtn.textContent = 'Start Scoring â³';
                    actionBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                    actionBtn.style.boxShadow = '0 4px 12px rgba(16, 185, 129, 0.4)';
                } else {
                    actionBtn.textContent = 'Back to Home';
                    actionBtn.style.background = '#94a3b8';
                    actionBtn.style.boxShadow = 'none';
                }
            }
        }
        
        // Show player scorecard popup
        function showPlayerScorecardPopup(playerName) {
            // Find the player data
            const player = tournamentData?.players?.find(p => p.name === playerName);
            if (!player) return;
            
            // Get course data
            const course = courses[tournamentData.course] || customCourses[tournamentData.course];
            if (!course) return;
            
            // Calculate totals
            const frontNine = player.scores.slice(0, 9).reduce((sum, s) => sum + (s || 0), 0);
            const backNine = player.scores.slice(9, 18).reduce((sum, s) => sum + (s || 0), 0);
            const total = frontNine + backNine;
            const toPar = total - course.totalPar;
            const toParDisplay = toPar === 0 ? 'E' : toPar > 0 ? `+${toPar}` : toPar;
            
            // Build scorecard HTML
            let html = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10002; display: flex; align-items: center; justify-content: center; padding: 16px;" onclick="this.remove()">
                    <div style="background: white; border-radius: 16px; padding: 20px; max-width: 400px; width: 100%; max-height: 85vh; overflow-y: auto;" onclick="event.stopPropagation()">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                            <div>
                                <div style="font-size: 18px; font-weight: 700; color: #1e293b;">${playerName}</div>
                                <div style="font-size: 13px; color: #64748b;">HCP: ${player.handicap || 0}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 24px; font-weight: 700; color: ${toPar < 0 ? '#ef4444' : toPar > 0 ? '#3b82f6' : '#10b981'};">${toParDisplay}</div>
                                <div style="font-size: 13px; color: #64748b;">${total} total</div>
                            </div>
                        </div>
                        
                        <div style="background: #f8fafc; border-radius: 12px; overflow: hidden; margin-bottom: 16px;">
                            <!-- Front 9 -->
                            <div style="background: #1e40af; color: white; padding: 8px 12px; font-weight: 700; font-size: 13px;">Front 9</div>
                            <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                                <tr style="background: #e2e8f0;">
                                    <td style="padding: 6px 8px; font-weight: 600;">Hole</td>
                                    ${[1,2,3,4,5,6,7,8,9].map(h => `<td style="padding: 6px 4px; text-align: center; font-weight: 600;">${h}</td>`).join('')}
                                    <td style="padding: 6px 8px; text-align: center; font-weight: 700; background: #cbd5e1;">OUT</td>
                                </tr>
                                <tr>
                                    <td style="padding: 6px 8px; color: #64748b;">Par</td>
                                    ${course.holes.slice(0,9).map(h => `<td style="padding: 6px 4px; text-align: center; color: #64748b;">${h.par}</td>`).join('')}
                                    <td style="padding: 6px 8px; text-align: center; font-weight: 600; background: #f1f5f9;">${course.holes.slice(0,9).reduce((s,h) => s + h.par, 0)}</td>
                                </tr>
                                <tr style="background: white;">
                                    <td style="padding: 6px 8px; font-weight: 600;">Score</td>
                                    ${player.scores.slice(0,9).map((s, i) => {
                                        const par = course.holes[i].par;
                                        const diff = s ? s - par : 0;
                                        let bg = 'transparent', color = '#1e293b';
                                        if (s && diff <= -2) { bg = '#fbbf24'; color = '#1e293b'; } // Eagle
                                        else if (s && diff === -1) { bg = '#ef4444'; color = 'white'; } // Birdie
                                        else if (s && diff === 1) { bg = '#3b82f6'; color = 'white'; } // Bogey
                                        else if (s && diff >= 2) { bg = '#1e40af'; color = 'white'; } // Double+
                                        return `<td style="padding: 6px 4px; text-align: center; background: ${bg}; color: ${color}; font-weight: ${s ? '600' : '400'};">${s || '-'}</td>`;
                                    }).join('')}
                                    <td style="padding: 6px 8px; text-align: center; font-weight: 700; background: #e2e8f0;">${frontNine || '-'}</td>
                                </tr>
                            </table>
                            
                            <!-- Back 9 -->
                            <div style="background: #1e40af; color: white; padding: 8px 12px; font-weight: 700; font-size: 13px;">Back 9</div>
                            <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                                <tr style="background: #e2e8f0;">
                                    <td style="padding: 6px 8px; font-weight: 600;">Hole</td>
                                    ${[10,11,12,13,14,15,16,17,18].map(h => `<td style="padding: 6px 4px; text-align: center; font-weight: 600;">${h}</td>`).join('')}
                                    <td style="padding: 6px 8px; text-align: center; font-weight: 700; background: #cbd5e1;">IN</td>
                                </tr>
                                <tr>
                                    <td style="padding: 6px 8px; color: #64748b;">Par</td>
                                    ${course.holes.slice(9,18).map(h => `<td style="padding: 6px 4px; text-align: center; color: #64748b;">${h.par}</td>`).join('')}
                                    <td style="padding: 6px 8px; text-align: center; font-weight: 600; background: #f1f5f9;">${course.holes.slice(9,18).reduce((s,h) => s + h.par, 0)}</td>
                                </tr>
                                <tr style="background: white;">
                                    <td style="padding: 6px 8px; font-weight: 600;">Score</td>
                                    ${player.scores.slice(9,18).map((s, i) => {
                                        const par = course.holes[i + 9].par;
                                        const diff = s ? s - par : 0;
                                        let bg = 'transparent', color = '#1e293b';
                                        if (s && diff <= -2) { bg = '#fbbf24'; color = '#1e293b'; } // Eagle
                                        else if (s && diff === -1) { bg = '#ef4444'; color = 'white'; } // Birdie
                                        else if (s && diff === 1) { bg = '#3b82f6'; color = 'white'; } // Bogey
                                        else if (s && diff >= 2) { bg = '#1e40af'; color = 'white'; } // Double+
                                        return `<td style="padding: 6px 4px; text-align: center; background: ${bg}; color: ${color}; font-weight: ${s ? '600' : '400'};">${s || '-'}</td>`;
                                    }).join('')}
                                    <td style="padding: 6px 8px; text-align: center; font-weight: 700; background: #e2e8f0;">${backNine || '-'}</td>
                                </tr>
                            </table>
                        </div>
                        
                        <button onclick="this.parentElement.parentElement.remove()" style="width: 100%; padding: 12px; background: #64748b; color: white; border: none; border-radius: 8px; font-weight: 600; font-size: 14px; cursor: pointer;">
                            Close
                        </button>
                    </div>
                </div>
            `;
            
            const popup = document.createElement('div');
            popup.innerHTML = html;
            document.body.appendChild(popup.firstElementChild);
        }
        
        // Calculate game results (simplified version)
        function calculateGameResults(players, gameType, course) {
            // This is a simplified calculation - full logic would match your existing results calculation
            return players.map(player => {
                const totalScore = player.scores.reduce((sum, score) => sum + (score || 0), 0);
                const holesPlayed = player.scores.filter(s => s > 0).length;
                const par = courses[course]?.totalPar || customCourses[course]?.totalPar || 72;
                const toPar = totalScore - par;
                const displayScore = toPar >= 0 ? `+${toPar}` : toPar;
                
                return {
                    name: player.name,
                    totalScore,
                    holesPlayed,
                    scores: player.scores,
                    toPar,
                    displayScore: holesPlayed === 0 ? '-' : `${totalScore} (${displayScore === '+0' ? 'E' : displayScore})`
                };
            }).sort((a, b) => {
                // Sort by holes played (more holes = higher priority), then by score
                if (a.holesPlayed === 0 && b.holesPlayed > 0) return 1;
                if (b.holesPlayed === 0 && a.holesPlayed > 0) return -1;
                if (a.holesPlayed === 0 && b.holesPlayed === 0) return 0;
                return a.totalScore - b.totalScore;
            });
        }
        
        // Render game toggle tabs
        function renderGameTabs(enabledGames) {
            const tabsContainer = document.getElementById('gameToggleTabs');
            if (!tabsContainer) return;
            
            const gameLabels = {
                'Stroke Play Gross': 'Gross',
                'Stroke Play Net': 'Net',
                'Gross Skins': 'Skins',
                'Net Skins (Full Hcp)': 'Net Skins',
                'Stableford': 'Stableford'
            };
            
            tabsContainer.innerHTML = enabledGames.map((game, index) => `
                <button class="game-tab ${index === 0 ? 'active' : ''}" data-game-type="${game}" onclick="switchGameTab('${game}')">
                    ${gameLabels[game] || game}
                </button>
            `).join('');
        }
        
        // Switch active game tab
        function switchGameTab(gameType) {
            document.querySelectorAll('.game-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.gameType === gameType);
            });
            
            // Reload leaderboard for new game type
            if (activeTournamentId) {
                db.collection('tournaments').doc(activeTournamentId).get()
                    .then(doc => {
                        if (doc.exists) {
                            updateLiveLeaderboard(doc.data());
                        }
                    });
            }
        }

        // ========================================
        // MAIN SCORING FUNCTION (MODIFIED FOR CLOUD)
        // ========================================
        
        function startScoring() {
            const date = document.getElementById('tournamentDate').value;
            const tournamentName = document.getElementById('tournamentName').value.trim();
            const gameType = document.getElementById('gameType').value;
            const selectedCourse = document.getElementById('courseSelect').value;
            
            // Validate date selection
            if (!date) {
                alert('Please select a date');
                return;
            }
            
            // Validate game type selection
            if (!gameType) {
                alert('Please select a game type');
                return;
            }
            
            // Validate course selection
            if (!selectedCourse) {
                alert('Please select a course');
                return;
            }
            
            // Update course data
            courseData = courses[selectedCourse] || customCourses[selectedCourse];
            
            // Get tee data for course handicap calculation
            const teeData = (courseData && selectedTee && courseData.tees) ? courseData.tees[selectedTee] : null;
            
            const players = [];
            // Loop through all player rows (they may not be sequential)
            const playerRows = document.querySelectorAll('.player-row');
            playerRows.forEach(row => {
                const playerId = row.getAttribute('data-player');
                const nameInput = document.getElementById(`player${playerId}`);
                const hcpInput = document.getElementById(`hcp${playerId}`);
                
                if (nameInput && hcpInput) {
                    const name = nameInput.value.trim();
                    const indexValue = parseFloat(hcpInput.value);
                    
                    // Calculate course handicap if we have tee data, otherwise use the input value
                    let courseHcp = 0;
                    let handicapIndex = null;
                    
                    if (!isNaN(indexValue)) {
                        handicapIndex = indexValue;
                        if (teeData && courseData) {
                            courseHcp = calculateCourseHandicap(indexValue, teeData.slope, teeData.rating, courseData.totalPar);
                        } else {
                            // No tee data - use raw index rounded
                            courseHcp = Math.round(indexValue);
                        }
                    }
                    
                    if (name) {
                        players.push({
                            name: name,
                            handicap: courseHcp,
                            handicapIndex: handicapIndex,
                            scores: new Array(18).fill(0)
                        });
                    }
                }
            });

            if (players.length === 0) {
                alert('Please enter at least one player name');
                return;
            }

            // Save players to history
            players.forEach(player => {
                updatePlayerHistory(player.name, player.handicap);
            });

            // Capture team assignments for Best Ball games
            let teams = [];
            if (gameType.includes('Best Ball')) {
                const numTeams = 2;
                const playersPerTeam = gameType === '2-Man Best Ball' ? 2 : gameType === '3-Man Best Ball' ? 3 : 4;
                
                for (let t = 0; t < numTeams; t++) {
                    const teamPlayers = [];
                    for (let p = 0; p < playersPerTeam; p++) {
                        const playerIndex = document.getElementById(`team${t}_player${p}`).value;
                        if (playerIndex !== '') {
                            teamPlayers.push(parseInt(playerIndex));
                        }
                    }
                    if (teamPlayers.length > 0) {
                        teams.push(teamPlayers);
                    }
                }
                
                if (teams.length < 2) {
                    alert('Please assign players to both teams');
                    return;
                }
            }

            tournamentData = {
                id: generateTournamentId(),
                name: tournamentName || '', // Optional tournament name
                date: date,
                gameType: gameType,
                course: selectedCourse,
                tee: selectedTee, // Store which tees were played
                players: players,
                teams: teams
            };

            // Hide Resume button when starting fresh
            const resumeBtn = document.getElementById('resumeScoringBtn');
            if (resumeBtn) {
                resumeBtn.style.display = 'none';
            }

            // Pro users always get multi-device mode
            console.log('ð¯ startScoring - checking subscription:', {
                hasActive: hasActiveSubscription(),
                currentAuthUser: currentAuthUser?.email,
                tournamentModeBefore: tournamentMode
            });
            if (hasActiveSubscription()) {
                tournamentMode = 'multi';
                console.log('ð¯ Pro user detected - set tournamentMode to multi');
            }

            // Handle based on scoring mode
            if (tournamentMode === 'multi') {
                // Gate check: Cloud features require subscription
                if (!canUseCloudFeatures()) {
                    // Check if they have more than FREE_PLAYER_LIMIT players
                    if (players.length > FREE_PLAYER_LIMIT) {
                        showPaywall(`Free plan allows ${FREE_PLAYER_LIMIT} players. You have ${players.length}. Upgrade for unlimited players and multi-device!`);
                        return;
                    }
                    // Allow single-device mode for free users with <= 4 players
                    tournamentMode = 'single';
                    showNotification('Single-Device Mode', `Free plan - scoring on this device only. Upgrade for multi-device!`);
                }
                
                // Create cloud tournament (only if we still have multi mode)
                if (tournamentMode === 'multi') {
                    // REQUIRE SIGN-IN to create tournaments (so host is never unknown)
                    if (!currentAuthUser) {
                        showNotification('Sign In Required', 'Please sign in to host a tournament');
                        // Show sign-in modal
                        showSignInModal();
                        return;
                    }
                    
                    createCloudTournament({
                    name: tournamentName || '', // Optional tournament name
                    date: date,
                    gameType: gameType,
                    course: selectedCourse,
                    tee: selectedTee, // Store which tees were played
                    players: players.map(p => ({
                        ...p,
                        scores: new Array(18).fill(null),
                        claimedBy: null // No one claimed yet
                    })),
                    teams: teams,
                    enabledGames: [gameType] // Can add more games later
                }).then(tournamentId => {
                    if (tournamentId) {
                        activeTournamentId = tournamentId;
                        isHost = true;
                        tournamentMode = 'multi'; // Ensure this is set
                        
                        // Ensure courseData is loaded
                        if (!courseData) {
                            courseData = courses[selectedCourse] || customCourses[selectedCourse];
                            console.log('ðï¸ Loaded courseData in success callback:', courseData?.name);
                        }
                        
                        console.log('ð¯ Tournament created successfully:', {
                            tournamentId,
                            isHost,
                            tournamentMode,
                            activeTournamentId,
                            courseDataLoaded: !!courseData,
                            playersCount: tournamentData?.players?.length
                        });
                        
                        // CLEAR the backup - new tournament is now the active one
                        previousTournamentBackup = null;
                        localStorage.removeItem('indianHillsScoring'); // Clear old data before saving new
                        
                        // Subscribe to real-time updates
                        subscribToTournamentUpdates(tournamentId);
                        
                        // Continue to scoring
                        saveToLocalStorage();
                        renderScoringPage();
                        showPage('scoringPage');
                        switchToHoleView();
                        
                        // Show notification
                        showNotification('Tournament Created!', 'Go back to Setup page to share QR/Link');
                    } else {
                        // If tournament creation returned null (shouldn't happen with throw, but just in case)
                        console.error('Tournament creation returned null');
                        throw new Error('Tournament creation failed');
                    }
                }).catch(error => {
                    console.error('Tournament creation error:', error);
                    
                    // Show single consolidated error message
                    const errorMsg = error.message || 'Unknown error';
                    showNotification('Multi-Device Mode Failed', `Switching to Single-Device mode. Error: ${errorMsg}`, true);
                    
                    // Fall back to single-device mode
                    tournamentMode = 'single';
                    document.getElementById('singleDeviceBtn').classList.add('active');
                    document.getElementById('multiDeviceBtn').classList.remove('active');
                    
                    saveToLocalStorage();
                    renderScoringPage();
                    showPage('scoringPage');
                    switchToHoleView();
                });
                } else {
                    // Downgraded to single-device mode for free users
                    previousTournamentBackup = null;
                    localStorage.removeItem('indianHillsScoring');
                    
                    saveToLocalStorage();
                    renderScoringPage();
                    showPage('scoringPage');
                    switchToHoleView();
                }
            } else {
                // Single-device mode - existing behavior
                // CLEAR the backup - new tournament is now the active one
                previousTournamentBackup = null;
                localStorage.removeItem('indianHillsScoring'); // Clear old data before saving new
                
                // CRITICAL: Clear old Firebase tournament ID for single-device mode
                activeTournamentId = null;
                isHost = true; // In single-device mode, user is always the "host"
                hasJoinedTournament = false;
                
                saveToLocalStorage();
                renderScoringPage();
                showPage('scoringPage');
                switchToHoleView();
            }
        }

        // Show player management page (host only)
        async function showPlayerManagement() {
            if (!activeTournamentId || !canManageTournament()) {
                showNotification('Not Available', 'Only hosts and co-hosts can manage the tournament');
                return;
            }
            
            try {
                // Check if db is available
                if (!db) {
                    showNotification('Offline', 'Cannot load - no database connection');
                    return;
                }
                
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                
                if (!tournamentDoc.exists) {
                    showNotification('Not Found', 'Tournament not found in database');
                    return;
                }
                
                const tournament = tournamentDoc.data();
                
                if (!tournament) {
                    showNotification('Error', 'Tournament data is empty');
                    return;
                }
                
                // Update local tournamentData
                tournamentData = tournament;
                
                // Populate tournament details form
                const nameInput = document.getElementById('manageTournamentName');
                const dateInput = document.getElementById('manageTournamentDate');
                const courseSelect = document.getElementById('manageTournamentCourse');
                
                if (nameInput) nameInput.value = tournament.name || '';
                if (dateInput) dateInput.value = tournament.date || '';
                
                if (courseSelect) {
                    courseSelect.innerHTML = '';
                    Object.keys(courses).forEach(courseKey => {
                        const option = document.createElement('option');
                        option.value = courseKey;
                        option.textContent = courses[courseKey].name;
                        if (courseKey === tournament.course) {
                            option.selected = true;
                        }
                        courseSelect.appendChild(option);
                    });
                    // Also add custom courses
                    Object.keys(customCourses).forEach(courseKey => {
                        const option = document.createElement('option');
                        option.value = courseKey;
                        option.textContent = customCourses[courseKey].name;
                        if (courseKey === tournament.course) {
                            option.selected = true;
                        }
                        courseSelect.appendChild(option);
                    });
                }
                
                // Store current tee selection for management
                managementSelectedTee = tournament.tee || null;
                
                // Render tee buttons
                updateManageTeeOptions();
                
                // Update connection status
                const statusDiv = document.getElementById('managementConnectionStatus');
                if (statusDiv) {
                    if (isOnline) {
                        statusDiv.innerHTML = `
                            <span style="width: 8px; height: 8px; border-radius: 50%; background: #10b981;"></span>
                            <span style="color: #059669; font-size: 12px; font-weight: 500;">Connected</span>
                        `;
                        statusDiv.parentElement.style.background = '#f0fdf4';
                        statusDiv.parentElement.style.borderColor = '#10b981';
                    } else {
                        statusDiv.innerHTML = `
                            <span style="width: 8px; height: 8px; border-radius: 50%; background: #ef4444;"></span>
                            <span style="color: #991b1b; font-size: 12px; font-weight: 500;">Offline</span>
                        `;
                        statusDiv.parentElement.style.background = '#fef2f2';
                        statusDiv.parentElement.style.borderColor = '#fca5a5';
                    }
                }
                
                // Generate player cards with reorder buttons
                const content = document.getElementById('playerManagementContent');
                const playerCount = tournament.players.length;
                
                content.innerHTML = tournament.players.map((p, index) => {
                    const claimedDevice = p.claimedBy ? tournament.devices[p.claimedBy] : null;
                    const isHostPlayer = p.claimedBy === currentDeviceId;
                    const deviceDisplay = claimedDevice ? (claimedDevice.initials || claimedDevice.name) : null;
                    const holesPlayed = p.scores ? p.scores.filter(s => s !== null && s !== undefined).length : 0;
                    const totalScore = p.scores ? p.scores.reduce((sum, s) => sum + (s || 0), 0) : 0;
                    const needsConfirmation = p.needsHcpConfirmation;
                    
                    return `
                        <div style="
                            background: ${needsConfirmation ? '#fef3c7' : (p.claimedBy ? '#f0fdf4' : 'white')};
                            border: 1.5px solid ${needsConfirmation ? '#f59e0b' : (p.claimedBy ? '#10b981' : '#e2e8f0')};
                            border-radius: 8px;
                            padding: 10px;
                            margin-bottom: 8px;
                            display: flex;
                            align-items: center;
                            gap: 8px;
                        ">
                            <!-- Reorder Buttons -->
                            <div style="display: flex; flex-direction: column; gap: 2px;">
                                <button onclick="movePlayerUp(${index})" ${index === 0 ? 'disabled' : ''} style="width: 24px; height: 20px; border: none; background: ${index === 0 ? '#e2e8f0' : '#dbeafe'}; color: ${index === 0 ? '#94a3b8' : '#3b82f6'}; border-radius: 4px; font-size: 10px; cursor: ${index === 0 ? 'default' : 'pointer'}; display: flex; align-items: center; justify-content: center;">â</button>
                                <button onclick="movePlayerDown(${index})" ${index === playerCount - 1 ? 'disabled' : ''} style="width: 24px; height: 20px; border: none; background: ${index === playerCount - 1 ? '#e2e8f0' : '#dbeafe'}; color: ${index === playerCount - 1 ? '#94a3b8' : '#3b82f6'}; border-radius: 4px; font-size: 10px; cursor: ${index === playerCount - 1 ? 'default' : 'pointer'}; display: flex; align-items: center; justify-content: center;">â</button>
                            </div>
                            
                            <!-- Player Info - New Layout -->
                            <div style="flex: 1; min-width: 0;">
                                <!-- Row 1: Name + HCP + Indicator -->
                                <div style="display: flex; align-items: center; gap: 4px;">
                                    <span style="font-weight: 600; color: #1e293b; font-size: 14px;">${p.name}</span>
                                    <span style="color: #64748b; font-size: 12px;">(${p.handicap})</span>
                                    ${needsConfirmation ? `<span title="Needs HCP confirmation" style="cursor: help;">â ï¸</span>` : ''}
                                </div>
                                <!-- Row 2: Holes + Score + Device -->
                                <div style="font-size: 11px; color: #64748b; margin-top: 2px; display: flex; align-items: center; gap: 6px;">
                                    <span>${holesPlayed > 0 ? `${holesPlayed} holes â¢ Score: ${totalScore}` : 'No scores yet'}</span>
                                    ${p.claimedBy ? `
                                        <span>â¢</span>
                                        <span style="color: #10b981; font-weight: 600;">â ${deviceDisplay}</span>
                                    ` : `
                                        <span>â¢</span>
                                        <span style="color: #94a3b8;">Unclaimed</span>
                                    `}
                                </div>
                            </div>
                            
                            <!-- Action Buttons -->
                            <div style="display: flex; gap: 4px; flex-shrink: 0;">
                                ${needsConfirmation ? `
                                    <button onclick="confirmPlayerHcp('${p.name}')" style="padding: 4px 6px; background: #f59e0b; color: white; border: none; border-radius: 4px; font-size: 10px; cursor: pointer;">Confirm</button>
                                ` : ''}
                                ${p.claimedBy && !isHostPlayer ? `
                                    <button onclick="unclaimPlayer('${p.name}')" style="padding: 4px 6px; background: white; color: #64748b; border: 1px solid #d1d5db; border-radius: 4px; font-size: 10px; cursor: pointer;">Release</button>
                                ` : ''}
                                <button onclick="editPlayerFromManagement('${p.name}', ${p.handicap})" style="padding: 4px 6px; background: #dbeafe; color: #1e40af; border: none; border-radius: 4px; font-size: 10px; cursor: pointer;">Edit</button>
                                <button onclick="deletePlayerFromTournament('${p.name}')" style="padding: 4px 6px; background: #fee2e2; color: #dc2626; border: none; border-radius: 4px; font-size: 10px; cursor: pointer;">ðï¸</button>
                            </div>
                        </div>
                    `;
                }).join('');
                
                if (tournament.players.length === 0) {
                    content.innerHTML = '<p style="text-align: center; color: #64748b; padding: 20px;">No players added yet</p>';
                }
                
                showPage('playerManagementPage');
                
                // Update the Host/Player toggle UI
                updateHostViewModeUI();
                
                // Show/hide Host Code button (only for original host)
                const hostCodeBtn = document.getElementById('hostCodeBtn');
                const becomeCoHostSection = document.getElementById('becomeCoHostSection');
                const isOriginalHost = tournament.hostDevice === currentDeviceId;
                
                if (hostCodeBtn) {
                    hostCodeBtn.style.display = isOriginalHost ? 'block' : 'none';
                }
                
                // Show "Become Co-Host" section for non-hosts who aren't already co-hosts
                if (becomeCoHostSection) {
                    const isCoHost = tournament.coHosts && tournament.coHosts.includes(currentDeviceId);
                    becomeCoHostSection.style.display = (!isOriginalHost && !isCoHost) ? 'block' : 'none';
                }
                
                // Render co-hosts section (host only)
                renderCoHostsSection();
                
                // Show/hide finished tournament actions
                const finishedActions = document.getElementById('finishedTournamentActions');
                if (finishedActions) {
                    if (tournament.isFinished) {
                        finishedActions.style.display = 'block';
                    } else {
                        finishedActions.style.display = 'none';
                    }
                }
                
                // Show Finish Tournament section only for hosts (when tournament is not finished)
                const finishSection = document.getElementById('finishTournamentSection');
                if (finishSection) {
                    const isOrigHost = tournament.hostDevice === currentDeviceId;
                    finishSection.style.display = (isOrigHost && !tournament.isFinished) ? 'block' : 'none';
                }
            } catch (error) {
                console.error('Error loading tournament management:', error);
                showNotification('Error', 'Failed to load tournament management');
            }
        }
        
        // Move player up in the list
        async function movePlayerUp(index) {
            if (index <= 0) return;
            await swapPlayers(index, index - 1);
        }
        
        // Move player down in the list
        async function movePlayerDown(index) {
            if (!tournamentData || index >= tournamentData.players.length - 1) return;
            await swapPlayers(index, index + 1);
        }
        
        // Swap two players in the list
        async function swapPlayers(indexA, indexB) {
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Swap players
                const temp = tournament.players[indexA];
                tournament.players[indexA] = tournament.players[indexB];
                tournament.players[indexB] = temp;
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update local data
                tournamentData.players = tournament.players;
                saveToLocalStorage();
                
                // Refresh the page
                showPlayerManagement();
            } catch (error) {
                console.error('Error reordering players:', error);
                showNotification('Error', 'Failed to reorder players');
            }
        }
        
        // ========================================
        // CO-HOST MANAGEMENT FUNCTIONS
        // ========================================
        
        // Render co-hosts section in management page
        async function renderCoHostsSection() {
            const section = document.getElementById('coHostsSection');
            const content = document.getElementById('coHostsContent');
            
            if (!section || !content) return;
            
            // Only show for the original host (not co-hosts)
            if (!isHost) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const coHosts = tournament.coHosts || [];
                const devices = tournament.devices || {};
                const connectedDevices = tournament.connectedDevices || {};
                
                // Get device IDs that have claimed players (still actively in tournament)
                const activeDeviceIds = new Set();
                tournament.players.forEach(player => {
                    if (player.claimedBy) {
                        activeDeviceIds.add(player.claimedBy);
                    }
                });
                
                // Also include devices in connectedDevices
                Object.keys(connectedDevices).forEach(id => activeDeviceIds.add(id));
                
                // Get list of devices that could be promoted (has claimed players or connected, not host, not already co-host)
                const availableDevices = Object.entries(devices).filter(([deviceId, device]) => {
                    // Must not be current device (host)
                    if (deviceId === currentDeviceId) return false;
                    // Must not already be a co-host
                    if (coHosts.includes(deviceId)) return false;
                    // Must have claimed players OR be in connected devices (actively participating)
                    return activeDeviceIds.has(deviceId);
                });
                
                // Also filter co-hosts to only show ones that are still active
                const activeCoHosts = coHosts.filter(coHostId => {
                    return devices[coHostId] && (activeDeviceIds.has(coHostId) || coHostId === currentDeviceId);
                });
                
                let html = '';
                
                // Current co-hosts (only active ones)
                if (activeCoHosts.length > 0) {
                    html += '<div style="margin-bottom: 10px;">';
                    activeCoHosts.forEach(coHostId => {
                        const device = devices[coHostId];
                        const displayName = device ? (device.initials || device.name || 'Unknown') : 'Unknown Device';
                        html += `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: white; border: 1px solid #c4b5fd; border-radius: 6px; margin-bottom: 6px;">
                                <span style="font-size: 13px; color: #5b21b6; font-weight: 500;">ð ${displayName}</span>
                                <button onclick="removeCoHost('${coHostId}')" style="padding: 4px 8px; background: #fee2e2; color: #dc2626; border: none; border-radius: 4px; font-size: 11px; cursor: pointer;">Remove</button>
                            </div>
                        `;
                    });
                    html += '</div>';
                }
                
                // Available devices to promote
                if (availableDevices.length > 0) {
                    html += `
                        <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                            ${availableDevices.map(([deviceId, device]) => {
                                const displayName = device.initials || device.name || 'Device';
                                return `
                                    <button onclick="addCoHost('${deviceId}')" style="padding: 6px 10px; background: white; color: #7c3aed; border: 1.5px solid #c4b5fd; border-radius: 6px; font-size: 11px; font-weight: 500; cursor: pointer;">
                                        + ${displayName}
                                    </button>
                                `;
                            }).join('')}
                        </div>
                    `;
                } else if (activeCoHosts.length === 0) {
                    html += '<p style="font-size: 12px; color: #8b5cf6; margin: 0;">No other devices connected yet. Share the link to add co-hosts.</p>';
                }
                
                content.innerHTML = html;
            } catch (error) {
                console.error('Error rendering co-hosts:', error);
                content.innerHTML = '<p style="font-size: 12px; color: #dc2626; margin: 0;">Error loading co-hosts</p>';
            }
        }
        
        // Add a device as co-host
        async function addCoHost(deviceId) {
            if (!isHost) {
                showNotification('Not Authorized', 'Only the host can add co-hosts');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const coHosts = tournament.coHosts || [];
                
                if (!coHosts.includes(deviceId)) {
                    coHosts.push(deviceId);
                    
                    await tournamentRef.update({
                        coHosts: coHosts,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    const device = tournament.devices[deviceId];
                    const displayName = device ? (device.initials || device.name) : 'Device';
                    showNotification('Co-host Added', `${displayName} can now manage the tournament`);
                    renderCoHostsSection();
                }
            } catch (error) {
                console.error('Error adding co-host:', error);
                showNotification('Error', 'Failed to add co-host');
            }
        }
        
        // Remove a co-host
        async function removeCoHost(deviceId) {
            if (!isHost) {
                showNotification('Not Authorized', 'Only the host can remove co-hosts');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                let coHosts = tournament.coHosts || [];
                coHosts = coHosts.filter(id => id !== deviceId);
                
                await tournamentRef.update({
                    coHosts: coHosts,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                const device = tournament.devices[deviceId];
                const displayName = device ? (device.initials || device.name) : 'Device';
                showNotification('Co-host Removed', `${displayName} is no longer a co-host`);
                renderCoHostsSection();
            } catch (error) {
                console.error('Error removing co-host:', error);
                showNotification('Error', 'Failed to remove co-host');
            }
        }
        
        // Clear scores for a single player
        async function clearPlayerScores(playerName) {
            if (!confirm(`Clear all scores for ${playerName}?`)) return;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) return;
                
                tournament.players[playerIndex].scores = Array(18).fill(null);
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update local data
                tournamentData.players = tournament.players;
                saveToLocalStorage();
                
                showNotification('Cleared', `Scores cleared for ${playerName}`);
                showPlayerManagement();
            } catch (error) {
                console.error('Error clearing player scores:', error);
                showNotification('Error', 'Failed to clear scores');
            }
        }
        
        // Variable to track selected tee in management
        let managementSelectedTee = null;
        
        // Update tee options in management based on selected course
        function updateManageTeeOptions() {
            const courseKey = document.getElementById('manageTournamentCourse').value;
            const course = courses[courseKey] || customCourses[courseKey];
            const container = document.getElementById('manageTeeButtons');
            
            if (!container) return;
            
            if (!course || !course.tees) {
                container.innerHTML = '<span style="font-size: 12px; color: #94a3b8;">No tee data available</span>';
                return;
            }
            
            const teeColors = {
                black: '#1e293b',
                blue: '#3b82f6',
                white: '#e2e8f0',
                gold: '#fbbf24',
                silver: '#94a3b8',
                red: '#ef4444',
                green: '#10b981'
            };
            
            let html = '';
            Object.keys(course.tees).forEach(teeKey => {
                const tee = course.tees[teeKey];
                const bgColor = teeColors[teeKey] || '#64748b';
                const textColor = (teeKey === 'white' || teeKey === 'gold' || teeKey === 'silver') ? '#1e293b' : 'white';
                // For white tee, use gray border when not selected so it's visible
                const defaultBorderColor = teeKey === 'white' ? '#cbd5e1' : bgColor;
                const isSelected = managementSelectedTee === teeKey;
                
                html += `
                    <button type="button" onclick="selectManageTee('${teeKey}')"
                        style="padding: 6px 10px; border: 2px solid ${isSelected ? '#10b981' : defaultBorderColor}; 
                        background: ${bgColor}; color: ${textColor}; border-radius: 6px; font-size: 11px; font-weight: 600; 
                        cursor: pointer; ${isSelected ? 'box-shadow: 0 0 0 2px #10b981;' : ''}">
                        ${tee.name}
                    </button>
                `;
            });
            
            container.innerHTML = html;
        }
        
        // Select tee in management
        function selectManageTee(teeKey) {
            managementSelectedTee = teeKey;
            updateManageTeeOptions();
        }
        
        // Save tournament details
        async function saveTournamentDetails() {
            const name = document.getElementById('manageTournamentName').value.trim();
            const date = document.getElementById('manageTournamentDate').value;
            const course = document.getElementById('manageTournamentCourse').value;
            const newTee = managementSelectedTee;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const oldCourse = tournament.course;
                const oldTee = tournament.tee;
                
                // Check if tee changed - need to recalculate handicaps
                const teeChanged = (newTee !== oldTee) || (course !== oldCourse);
                let updatedPlayers = tournament.players;
                let courseHcpPlayersCount = 0;
                
                if (teeChanged && newTee) {
                    const courseObj = courses[course] || customCourses[course];
                    const newTeeData = courseObj?.tees?.[newTee];
                    const oldTeeData = courseObj?.tees?.[oldTee];
                    
                    if (newTeeData && courseObj) {
                        // Recalculate course handicaps for all players
                        updatedPlayers = tournament.players.map(player => {
                            const updatedPlayer = { ...player };
                            
                            if (player.hcpMode === 'course') {
                                // Player used Course HCP mode - try to reverse calculate
                                courseHcpPlayersCount++;
                                
                                if (oldTeeData && player.handicap) {
                                    // Reverse calculate the index from old course HCP
                                    // Course HCP = Index Ã (Slope Ã· 113) + (Rating - Par)
                                    // Index = (Course HCP - (Rating - Par)) Ã (113 Ã· Slope)
                                    const estimatedIndex = (player.handicap - (oldTeeData.rating - courseObj.totalPar)) * (113 / oldTeeData.slope);
                                    
                                    // Calculate new course HCP from estimated index
                                    const newCourseHcp = calculateCourseHandicap(
                                        estimatedIndex,
                                        newTeeData.slope,
                                        newTeeData.rating,
                                        courseObj.totalPar
                                    );
                                    
                                    updatedPlayer.handicap = newCourseHcp;
                                    updatedPlayer.estimatedIndex = Math.round(estimatedIndex * 10) / 10;
                                }
                                
                                // Mark for confirmation
                                updatedPlayer.needsHcpConfirmation = true;
                                updatedPlayer.tee = newTee;
                            } else if (player.handicapIndex !== null && player.handicapIndex !== undefined) {
                                // Player used Index mode - straightforward recalculation
                                const newCourseHcp = calculateCourseHandicap(
                                    player.handicapIndex, 
                                    newTeeData.slope, 
                                    newTeeData.rating, 
                                    courseObj.totalPar
                                );
                                updatedPlayer.handicap = newCourseHcp;
                                updatedPlayer.tee = newTee;
                                updatedPlayer.needsHcpConfirmation = true;
                            } else {
                                // No index data - mark for confirmation
                                updatedPlayer.needsHcpConfirmation = true;
                                updatedPlayer.tee = newTee;
                            }
                            
                            return updatedPlayer;
                        });
                    }
                }
                
                // Show warning if there are Course HCP players
                if (teeChanged && courseHcpPlayersCount > 0) {
                    const courseHcpNames = tournament.players
                        .filter(p => p.hcpMode === 'course')
                        .map(p => p.name)
                        .join(', ');
                    
                    const confirmed = confirm(
                        `â ï¸ Tee Change Warning\n\n` +
                        `${courseHcpPlayersCount} player(s) have manually entered Course HCPs:\n` +
                        `${courseHcpNames}\n\n` +
                        `Their handicaps will be estimated for the new tees and marked for confirmation.\n\n` +
                        `Continue with tee change?`
                    );
                    
                    if (!confirmed) return;
                }
                
                await tournamentRef.update({
                    name: name,
                    date: date,
                    course: course,
                    tee: newTee,
                    players: updatedPlayers,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update local data
                tournamentData.name = name;
                tournamentData.date = date;
                tournamentData.course = course;
                tournamentData.tee = newTee;
                tournamentData.players = updatedPlayers;
                courseData = courses[course] || customCourses[course];
                saveToLocalStorage();
                
                // Update smart info lines
                generateSmartInfoLine('scoringSmartInfo');
                generateSmartInfoLine('resultsSmartInfo');
                
                if (teeChanged) {
                    const teeData = courseData?.tees?.[newTee];
                    const teeName = teeData?.name || newTee;
                    if (courseHcpPlayersCount > 0) {
                        showNotification('Saved', `Switched to ${teeName} tees. ${courseHcpPlayersCount} player(s) need HCP confirmation.`);
                    } else {
                        showNotification('Saved', `Switched to ${teeName} tees. Handicaps recalculated.`);
                    }
                } else {
                    showNotification('Saved', 'Tournament details updated');
                }
            } catch (error) {
                console.error('Error saving tournament details:', error);
                showNotification('Error', 'Failed to save tournament details');
            }
        }
        
        // Show Host Code modal (original host only)
        async function showHostCodeModal() {
            if (!activeTournamentId) return;
            
            try {
                const tournamentDoc = await db.collection('tournaments').doc(activeTournamentId).get();
                const tournament = tournamentDoc.data();
                
                // Only original host can see this
                if (tournament.hostDevice !== currentDeviceId) {
                    showNotification('Not Available', 'Only the original host can view the host code');
                    return;
                }
                
                const hostCode = tournament.hostCode || 'Not Set';
                
                const modal = document.createElement('div');
                modal.id = 'hostCodeModal';
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.8); z-index: 10001;
                    display: flex; align-items: center; justify-content: center; padding: 20px;
                `;
                
                modal.innerHTML = `
                    <div style="background: white; border-radius: 16px; padding: 24px; max-width: 320px; width: 100%; text-align: center;">
                        <div style="display: flex; justify-content: flex-end; margin: -8px -8px 8px 0;">
                            <button onclick="closeHostCodeModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b; line-height: 1;">â</button>
                        </div>
                        
                        <div style="font-size: 40px; margin-bottom: 8px;">ð</div>
                        <h2 style="color: #1e40af; font-size: 18px; margin: 0 0 16px 0;">Host Code</h2>
                        
                        <div id="hostCodeDisplay" style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 12px; padding: 16px; margin-bottom: 16px;">
                            <span id="hostCodeValue" style="font-size: 28px; font-weight: 700; font-family: monospace; letter-spacing: 4px; color: #92400e;">${hostCode}</span>
                        </div>
                        
                        <div id="hostCodeEditSection" style="display: none; margin-bottom: 16px;">
                            <input type="text" id="hostCodeEditInput" value="${hostCode}" maxlength="6" 
                                style="width: 100%; padding: 12px; font-size: 20px; font-weight: 700; text-align: center; 
                                border: 2px solid #f59e0b; border-radius: 8px; font-family: monospace; letter-spacing: 3px;
                                text-transform: uppercase; box-sizing: border-box;"
                                oninput="this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0,6);">
                        </div>
                        
                        <p style="color: #64748b; font-size: 12px; margin-bottom: 20px;">Share this code with trusted people to grant them co-host access.</p>
                        
                        <div id="hostCodeActions" style="display: flex; gap: 12px;">
                            <button onclick="editHostCode()" style="flex: 1; padding: 12px; background: #f1f5f9; border: none; border-radius: 10px; color: #475569; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;">
                                âï¸ Edit
                            </button>
                            <button onclick="copyHostCode()" style="flex: 1; padding: 12px; background: #3b82f6; border: none; border-radius: 10px; color: white; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;">
                                ð Copy
                            </button>
                        </div>
                        
                        <div id="hostCodeSaveActions" style="display: none; gap: 12px;">
                            <button onclick="cancelEditHostCode()" style="flex: 1; padding: 12px; background: #f1f5f9; border: none; border-radius: 10px; color: #475569; font-size: 14px; font-weight: 600; cursor: pointer;">
                                Cancel
                            </button>
                            <button onclick="saveHostCode()" style="flex: 1; padding: 12px; background: #10b981; border: none; border-radius: 10px; color: white; font-size: 14px; font-weight: 600; cursor: pointer;">
                                Save
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                modal.onclick = (e) => {
                    if (e.target === modal) closeHostCodeModal();
                };
            } catch (error) {
                console.error('Error showing host code:', error);
                showNotification('Error', 'Could not load host code');
            }
        }
        
        function closeHostCodeModal() {
            const modal = document.getElementById('hostCodeModal');
            if (modal) modal.remove();
        }
        
        function editHostCode() {
            document.getElementById('hostCodeDisplay').style.display = 'none';
            document.getElementById('hostCodeEditSection').style.display = 'block';
            document.getElementById('hostCodeActions').style.display = 'none';
            document.getElementById('hostCodeSaveActions').style.display = 'flex';
            document.getElementById('hostCodeEditInput').focus();
        }
        
        function cancelEditHostCode() {
            document.getElementById('hostCodeDisplay').style.display = 'block';
            document.getElementById('hostCodeEditSection').style.display = 'none';
            document.getElementById('hostCodeActions').style.display = 'flex';
            document.getElementById('hostCodeSaveActions').style.display = 'none';
        }
        
        async function saveHostCode() {
            const newCode = document.getElementById('hostCodeEditInput').value.trim().toUpperCase();
            
            if (newCode.length < 4) {
                showNotification('Error', 'Host code must be at least 4 characters');
                return;
            }
            
            try {
                await db.collection('tournaments').doc(activeTournamentId).update({
                    hostCode: newCode,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update display
                document.getElementById('hostCodeValue').textContent = newCode;
                cancelEditHostCode();
                showNotification('Saved', 'Host code updated');
            } catch (error) {
                console.error('Error saving host code:', error);
                showNotification('Error', 'Could not save host code');
            }
        }
        
        function copyHostCode() {
            const code = document.getElementById('hostCodeValue').textContent;
            navigator.clipboard.writeText(code).then(() => {
                showNotification('Copied', 'Host code copied to clipboard');
            }).catch(() => {
                showNotification('Error', 'Could not copy to clipboard');
            });
        }
        
        // Verify host code to become co-host
        async function verifyHostCode() {
            const input = document.getElementById('coHostCodeInput');
            const errorEl = document.getElementById('coHostCodeError');
            
            if (!input) return;
            
            const code = input.value.trim().toUpperCase();
            
            if (code.length < 4) {
                if (errorEl) errorEl.textContent = 'Enter at least 4 characters';
                return;
            }
            
            try {
                const tournamentDoc = await db.collection('tournaments').doc(activeTournamentId).get();
                const tournament = tournamentDoc.data();
                
                if (tournament.hostCode === code) {
                    // Grant co-host access
                    const coHosts = tournament.coHosts || [];
                    if (!coHosts.includes(currentDeviceId)) {
                        coHosts.push(currentDeviceId);
                        await db.collection('tournaments').doc(activeTournamentId).update({
                            coHosts: coHosts,
                            [`devices.${currentDeviceId}.isCoHost`]: true,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                    
                    // Update local state
                    isCoHost = true;
                    
                    // Hide the become co-host section
                    document.getElementById('becomeCoHostSection').style.display = 'none';
                    
                    showNotification('Success! ð', 'You are now a co-host');
                    
                    // Clear input
                    input.value = '';
                    if (errorEl) errorEl.textContent = '';
                } else {
                    if (errorEl) {
                        errorEl.textContent = 'Invalid host code';
                    }
                }
            } catch (error) {
                console.error('Error verifying host code:', error);
                if (errorEl) errorEl.textContent = 'Error verifying code';
            }
        }
        
        // Confirm delete tournament
        function confirmDeleteTournament() {
            if (!confirm('Are you sure you want to delete this tournament? This cannot be undone.')) return;
            if (!confirm('FINAL WARNING: All scores and data will be permanently deleted. Continue?')) return;
            deleteTournament();
        }
        
        // Delete tournament
        async function deleteTournament() {
            try {
                await db.collection('tournaments').doc(activeTournamentId).delete();
                
                // Clear local data
                localStorage.removeItem('letsgolf_data');
                activeTournamentId = null;
                tournamentData = null;
                isHost = false;
                
                showNotification('Deleted', 'Tournament has been deleted');
                showPage('setupPage');
            } catch (error) {
                console.error('Error deleting tournament:', error);
                showNotification('Error', 'Failed to delete tournament');
            }
        }
        
        // Clear all scores (all 18 holes)
        async function clearAllScores() {
            if (!confirm('Clear ALL scores AND stats for ALL players? This cannot be undone.')) return;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                tournament.players.forEach(p => {
                    p.scores = Array(18).fill(null);
                });
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                tournamentData.players = tournament.players;
                
                // Clear all player stats (FIR, GIR, Putts, Dots)
                playerStats = {};
                savePlayerStatsToLocalStorage();
                
                saveToLocalStorage();
                
                showNotification('Cleared', 'All scores and stats have been cleared');
                showPlayerManagement();
            } catch (error) {
                console.error('Error clearing scores:', error);
                showNotification('Error', 'Failed to clear scores');
            }
        }
        
        // Clear front 9 scores
        async function clearFront9Scores() {
            if (!confirm('Clear Front 9 scores AND stats (holes 1-9) for ALL players?')) return;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                tournament.players.forEach(p => {
                    if (!p.scores) p.scores = Array(18).fill(null);
                    for (let i = 0; i < 9; i++) {
                        p.scores[i] = null;
                    }
                });
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                tournamentData.players = tournament.players;
                
                // Clear front 9 stats for all players
                Object.keys(playerStats).forEach(playerName => {
                    const stats = playerStats[playerName];
                    if (stats) {
                        for (let i = 0; i < 9; i++) {
                            if (stats.fir) stats.fir[i] = null;
                            if (stats.gir) stats.gir[i] = null;
                            if (stats.putts) stats.putts[i] = null;
                            if (stats.dots) stats.dots[i] = null;
                        }
                    }
                });
                savePlayerStatsToLocalStorage();
                
                saveToLocalStorage();
                
                showNotification('Cleared', 'Front 9 scores and stats have been cleared');
                showPlayerManagement();
            } catch (error) {
                console.error('Error clearing front 9:', error);
                showNotification('Error', 'Failed to clear scores');
            }
        }
        
        // Clear back 9 scores
        async function clearBack9Scores() {
            if (!confirm('Clear Back 9 scores AND stats (holes 10-18) for ALL players?')) return;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                tournament.players.forEach(p => {
                    if (!p.scores) p.scores = Array(18).fill(null);
                    for (let i = 9; i < 18; i++) {
                        p.scores[i] = null;
                    }
                });
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                tournamentData.players = tournament.players;
                
                // Clear back 9 stats for all players
                Object.keys(playerStats).forEach(playerName => {
                    const stats = playerStats[playerName];
                    if (stats) {
                        for (let i = 9; i < 18; i++) {
                            if (stats.fir) stats.fir[i] = null;
                            if (stats.gir) stats.gir[i] = null;
                            if (stats.putts) stats.putts[i] = null;
                            if (stats.dots) stats.dots[i] = null;
                        }
                    }
                });
                savePlayerStatsToLocalStorage();
                
                saveToLocalStorage();
                
                showNotification('Cleared', 'Back 9 scores and stats have been cleared');
                showPlayerManagement();
            } catch (error) {
                console.error('Error clearing back 9:', error);
                showNotification('Error', 'Failed to clear scores');
            }
        }
        
        // Unclaim a player (host and co-hosts)
        async function unclaimPlayer(playerName) {
            if (!activeTournamentId || !canManageTournament()) {
                showNotification('Not Authorized', 'Only hosts and co-hosts can release claims');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex === -1) return;
                
                tournament.players[playerIndex].claimedBy = null;
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                showNotification('Released', `${playerName} is now unclaimed`);
                showPlayerManagement(); // Refresh the page
            } catch (error) {
                console.error('Error unclaiming player:', error);
                showNotification('Error', 'Failed to release claim');
            }
        }
        
        // Show add player form
        function showAddPlayerForm() {
            document.getElementById('addPlayerForm').style.display = 'block';
            document.getElementById('newPlayerName').focus();
        }
        
        // Hide add player form
        function hideAddPlayerForm() {
            document.getElementById('addPlayerForm').style.display = 'none';
            document.getElementById('newPlayerName').value = '';
            document.getElementById('newPlayerHandicap').value = '0';
        }
        
        // Refresh player management
        function refreshPlayerManagement() {
            showPlayerManagement();
            showNotification('Refreshed', 'Player list updated');
        }
        
        // Add new player from management page
        async function addNewPlayerFromManagement() {
            const name = document.getElementById('newPlayerName').value.trim();
            const handicap = parseFloat(document.getElementById('newPlayerHandicap').value) || 0;
            
            if (!name) {
                showNotification('Error', 'Please enter a player name');
                return;
            }
            
            if (!activeTournamentId) {
                showNotification('Error', 'No active tournament');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Check if name already exists
                if (tournament.players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                    showNotification('Error', 'Player with this name already exists');
                    return;
                }
                
                // Add new player
                const newPlayer = {
                    name: name,
                    handicap: handicap,
                    scores: new Array(18).fill(0),
                    claimedBy: null
                };
                
                tournament.players.push(newPlayer);
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Also update local data
                tournamentData.players.push(newPlayer);
                saveToLocalStorage();
                
                hideAddPlayerForm();
                showNotification('Added', `${name} added to tournament`);
                showPlayerManagement(); // Refresh
            } catch (error) {
                console.error('Error adding player:', error);
                showNotification('Error', 'Failed to add player');
            }
        }

        // ========================================
        // MY PLAYERS MANAGEMENT FUNCTIONS
        // ========================================
        
        // Load player order from localStorage
        function loadPlayerOrder() {
            // Use tournament-specific key to avoid cross-contamination between tournaments
            const storageKey = activeTournamentId ? `playerOrder_${currentDeviceId}_${activeTournamentId}` : `playerOrder_${currentDeviceId}`;
            const saved = localStorage.getItem(storageKey);
            if (saved) {
                try {
                    playerOrder = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading player order:', e);
                    playerOrder = { claimed: [], watching: [] };
                }
            } else {
                // No saved order for this tournament - start fresh
                playerOrder = { claimed: [], watching: [] };
            }
        }
        
        // Save player order to localStorage
        function savePlayerOrder() {
            // Use tournament-specific key
            const storageKey = activeTournamentId ? `playerOrder_${currentDeviceId}_${activeTournamentId}` : `playerOrder_${currentDeviceId}`;
            localStorage.setItem(storageKey, JSON.stringify(playerOrder));
        }
        
        // Get device name for display
        function getDeviceName(tournament, deviceId) {
            if (!deviceId) return 'UNK';
            if (!tournament || !tournament.devices) return deviceId.substring(0, 3).toUpperCase();
            if (tournament.devices[deviceId]) {
                return tournament.devices[deviceId].initials || tournament.devices[deviceId].name || deviceId.substring(0, 3).toUpperCase();
            }
            return deviceId.substring(0, 3).toUpperCase();
        }
        
        // Sort players by saved order
        function sortPlayersByOrder(players, orderArray) {
            const ordered = [];
            const unordered = [...players];
            
            orderArray.forEach(name => {
                const player = unordered.find(p => p.name === name);
                if (player) {
                    ordered.push(player);
                    unordered.splice(unordered.indexOf(player), 1);
                }
            });
            
            return [...ordered, ...unordered];
        }
        
        // Render individual player row
        function renderPlayerRow(player, index, type, totalCount) {
            const canEdit = type === 'claimed';
            const isFirst = index === 0;
            const isLast = index === totalCount - 1;
            
            const bgColor = type === 'claimed' ? '#fef3c7' : '#dbeafe';
            const borderColor = type === 'claimed' ? '#f59e0b' : '#3b82f6';
            
            return `
                <div style="background: ${bgColor}; border: 2px solid ${borderColor}; border-radius: 8px; padding: 12px; margin-bottom: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <div style="flex: 1;">
                            <div style="font-weight: 700; font-size: 15px;">${player.name}</div>
                            <div style="font-size: 13px; color: #64748b;">Handicap: ${player.handicap}</div>
                            ${type === 'watching' && player.claimedBy ? 
                                `<div style="font-size: 12px; color: #3b82f6;">Scored by: ${player.claimedBy.substring(0, 3).toUpperCase()}</div>` : 
                                ''}
                        </div>
                        <div style="display: flex; gap: 4px; align-items: center;">
                            <button 
                                onclick="movePlayer('${player.name}', ${index}, -1, '${type}')"
                                ${isFirst ? 'disabled' : ''}
                                style="width: 32px; height: 32px; background: ${isFirst ? '#e2e8f0' : '#ffffff'}; border: 2px solid ${borderColor}; border-radius: 6px; cursor: ${isFirst ? 'not-allowed' : 'pointer'}; font-size: 16px;">
                                â¬ï¸
                            </button>
                            <button 
                                onclick="movePlayer('${player.name}', ${index}, 1, '${type}')"
                                ${isLast ? 'disabled' : ''}
                                style="width: 32px; height: 32px; background: ${isLast ? '#e2e8f0' : '#ffffff'}; border: 2px solid ${borderColor}; border-radius: 6px; cursor: ${isLast ? 'not-allowed' : 'pointer'}; font-size: 16px;">
                                â¬ï¸
                            </button>
                            ${canEdit ? `
                                <button 
                                    onclick="editPlayerModal('${player.name}', ${player.handicap})"
                                    style="width: 32px; height: 32px; background: #ffffff; border: 2px solid ${borderColor}; border-radius: 6px; cursor: pointer; font-size: 16px;">
                                    âï¸
                                </button>
                            ` : ''}
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        ${canEdit ? `
                            <button onclick="releasePlayer('${player.name}')" style="flex: 1; padding: 8px; background: #ef4444; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                                Release Player
                            </button>
                        ` : `
                            <button onclick="removeFromWatchList('${player.name}')" style="flex: 1; padding: 8px; background: #64748b; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                                Stop Watching
                            </button>
                        `}
                    </div>
                </div>
            `;
        }
        
        // Show My Players Page (Full Page for Non-Hosts)
        async function showMyPlayersPage() {
            if (!activeTournamentId) {
                showNotification('Error', 'No active tournament');
                return;
            }
            
            loadPlayerOrder();
            
            // Show the Host/Player toggle if host in player mode
            updateMyPlayersHostToggle();
            
            // Update notification toggle button state
            updateNotificationToggleUI();
            
            try {
                // Check if db is available
                if (!db) {
                    showNotification('Offline', 'Cannot load - no database connection');
                    return;
                }
                
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                
                if (!tournamentDoc.exists) {
                    showNotification('Not Found', 'Tournament not found');
                    return;
                }
                
                const tournament = tournamentDoc.data();
                
                if (!tournament || !tournament.players) {
                    showNotification('Error', 'Tournament has no player data');
                    return;
                }
                
                // Update local tournamentData
                tournamentData = tournament;
                
                const claimedPlayers = tournament.players.filter(p => p.claimedBy === currentDeviceId);
                const watchedPlayerNames = playerOrder.watching || [];
                const watchedPlayers = tournament.players.filter(p => 
                    watchedPlayerNames.includes(p.name) && p.claimedBy !== currentDeviceId
                );
                const availablePlayers = tournament.players.filter(p => 
                    !claimedPlayers.includes(p) && !watchedPlayers.includes(p)
                );
                
                // IMPORTANT: Ensure claimed players are in the order array
                claimedPlayers.forEach(p => {
                    if (!playerOrder.claimed.includes(p.name)) {
                        playerOrder.claimed.push(p.name);
                    }
                });
                // Remove any players from order that are no longer claimed
                playerOrder.claimed = playerOrder.claimed.filter(name => 
                    claimedPlayers.some(p => p.name === name)
                );
                savePlayerOrder();
                
                const sortedClaimed = sortPlayersByOrder(claimedPlayers, playerOrder.claimed);
                const sortedWatched = sortPlayersByOrder(watchedPlayers, playerOrder.watching);
                
                const content = document.getElementById('myPlayersPageContent');
                
                // Load stats config
                loadStatsConfig();
                
                content.innerHTML = `
                    <!-- STATS TRACKER BOX -->
                    <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border: 2px solid #f59e0b; border-radius: 10px; padding: 12px; margin-bottom: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="color: #92400e; font-size: 13px; margin: 0;">ð Stats Tracker</h3>
                            <button onclick="showStatsHistoryModal()" style="padding: 6px 12px; background: #92400e; color: white; border: none; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer;">
                                ð History
                            </button>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;">
                            <button onclick="toggleStat('fir')" style="padding: 10px 6px; border-radius: 8px; border: 2px solid ${statsTrackerConfig.fir ? '#10b981' : '#d1d5db'}; background: ${statsTrackerConfig.fir ? '#10b981' : 'white'}; color: ${statsTrackerConfig.fir ? 'white' : '#64748b'}; font-size: 11px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 2px;">
                                <span style="font-size: 16px;">ð¯</span>
                                <span>FIR</span>
                            </button>
                            <button onclick="toggleStat('gir')" style="padding: 10px 6px; border-radius: 8px; border: 2px solid ${statsTrackerConfig.gir ? '#10b981' : '#d1d5db'}; background: ${statsTrackerConfig.gir ? '#10b981' : 'white'}; color: ${statsTrackerConfig.gir ? 'white' : '#64748b'}; font-size: 11px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 2px;">
                                <span style="font-size: 16px;">ð¯</span>
                                <span>GIR</span>
                            </button>
                            <button onclick="toggleStat('putts')" style="padding: 10px 6px; border-radius: 8px; border: 2px solid ${statsTrackerConfig.putts ? '#10b981' : '#d1d5db'}; background: ${statsTrackerConfig.putts ? '#10b981' : 'white'}; color: ${statsTrackerConfig.putts ? 'white' : '#64748b'}; font-size: 11px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 2px;">
                                <span style="font-size: 16px;">â³</span>
                                <span>Putts</span>
                            </button>
                            <button onclick="toggleStat('dots')" style="padding: 10px 6px; border-radius: 8px; border: 2px solid ${statsTrackerConfig.dots ? '#10b981' : '#d1d5db'}; background: ${statsTrackerConfig.dots ? '#10b981' : 'white'}; color: ${statsTrackerConfig.dots ? 'white' : '#64748b'}; font-size: 11px; font-weight: 600; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 2px;">
                                <span style="font-size: 16px; color: ${statsTrackerConfig.dots ? 'white' : '#10b981'};">â</span>
                                <span>Dots</span>
                            </button>
                        </div>
                        <p style="color: #92400e; font-size: 10px; margin: 8px 0 0 0; text-align: center; opacity: 0.8;">Tap to enable/disable stats in Hole View</p>
                    </div>
                    
                    <!-- SECTION 1: My Claimed Players - GREEN theme -->
                    <div style="background: #dcfce7; border: 1.5px solid #22c55e; border-radius: 10px; padding: 10px; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <h3 style="color: #166534; font-size: 12px; margin: 0;">â My Claimed Players</h3>
                            ${sortedClaimed.length > 0 ? `<button onclick="clearAllClaimed()" style="padding: 4px 8px; background: #fee2e2; color: #ef4444; border: 1px solid #ef4444; border-radius: 4px; font-size: 10px; font-weight: 600; cursor: pointer;">Clear All</button>` : ''}
                        </div>
                        ${sortedClaimed.length === 0 ? 
                            '<p style="color: #166534; font-size: 12px; opacity: 0.7;">No claimed players</p>' :
                            sortedClaimed.map((p, index) => renderMyPlayerRow(p, index, 'claimed', sortedClaimed.length)).join('')
                        }
                    </div>
                    
                    <!-- SECTION 2: Watching -->
                    <div style="background: #dbeafe; border: 1.5px solid #3b82f6; border-radius: 10px; padding: 10px; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <h3 style="color: #1e40af; font-size: 12px; margin: 0;">ðï¸ Watching</h3>
                            ${sortedWatched.length > 0 ? `<button onclick="clearAllWatched()" style="padding: 4px 8px; background: #fee2e2; color: #ef4444; border: 1px solid #ef4444; border-radius: 4px; font-size: 10px; font-weight: 600; cursor: pointer;">Clear All</button>` : ''}
                        </div>
                        ${sortedWatched.length === 0 ? 
                            '<p style="color: #1e40af; font-size: 12px; opacity: 0.7;">Not watching any players</p>' :
                            sortedWatched.map((p, index) => renderMyPlayerRow(p, index, 'watching', sortedWatched.length)).join('')
                        }
                    </div>
                    
                    <!-- SECTION 3: Available Players -->
                    <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; padding: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <h3 style="color: #64748b; font-size: 12px; margin: 0;">ð Available Players</h3>
                            <button onclick="showAddPlayerDialogFromMyPlayers()" style="padding: 4px 10px; background: #10b981; color: white; border: none; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer;">
                                + Add Player
                            </button>
                        </div>
                        ${availablePlayers.length === 0 ? 
                            '<p style="color: #64748b; font-size: 12px; opacity: 0.7;">All players claimed or watched</p>' :
                            availablePlayers.map(p => `
                                <div style="background: white; border: 1.5px solid #e2e8f0; border-radius: 8px; padding: 10px; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="font-weight: 600; font-size: 14px; color: #1e293b;">${p.name}</div>
                                        <div style="font-size: 11px; color: #64748b;">HCP ${p.handicap}${p.claimedBy ? ' â¢ Claimed by ' + getDeviceName(tournament, p.claimedBy) : ''}</div>
                                    </div>
                                    <div style="display: flex; gap: 6px;">
                                        ${!p.claimedBy ? `
                                            <button onclick="claimPlayerFromMyPage('${p.name}')" style="padding: 6px 10px; background: #10b981; color: white; border: none; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer;">
                                                Claim
                                            </button>
                                        ` : ''}
                                        <button onclick="addToWatchListFromPage('${p.name}')" style="padding: 6px 10px; background: #3b82f6; color: white; border: none; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer;">
                                            ðï¸ Watch
                                        </button>
                                    </div>
                                </div>
                            `).join('')
                        }
                    </div>
                `;
                
                showPage('myPlayersPage');
            } catch (error) {
                console.error('Error loading my players:', error);
                showNotification('Error', 'Failed to load players');
            }
        }
        
        // Render player row for My Players page
        function renderMyPlayerRow(player, index, type, totalCount) {
            const canMoveUp = index > 0;
            const canMoveDown = index < totalCount - 1;
            // Green theme for claimed, blue for watching
            const bgColor = type === 'claimed' ? '#f0fdf4' : '#eff6ff';
            const borderColor = type === 'claimed' ? '#22c55e' : '#3b82f6';
            
            return `
                <div style="background: ${bgColor}; border: 1.5px solid ${borderColor}; border-radius: 8px; padding: 10px; margin-bottom: 6px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <div>
                            <div style="font-weight: 600; font-size: 14px; color: #1e293b;">${player.name}</div>
                            <div style="font-size: 11px; color: #64748b;">Handicap: ${player.handicap}</div>
                        </div>
                        <div style="display: flex; gap: 4px;">
                            <button onclick="movePlayerInPage('${player.name}', ${index}, -1, '${type}')" 
                                style="width: 32px; height: 32px; border-radius: 6px; border: 1px solid #d1d5db; background: white; font-size: 14px; cursor: pointer; opacity: ${canMoveUp ? '1' : '0.3'};"
                                ${!canMoveUp ? 'disabled' : ''}>â¬ï¸</button>
                            <button onclick="movePlayerInPage('${player.name}', ${index}, 1, '${type}')" 
                                style="width: 32px; height: 32px; border-radius: 6px; border: 1px solid #d1d5db; background: white; font-size: 14px; cursor: pointer; opacity: ${canMoveDown ? '1' : '0.3'};"
                                ${!canMoveDown ? 'disabled' : ''}>â¬ï¸</button>
                            ${type === 'claimed' ? `<button onclick="editPlayerFromPage('${player.name}', ${player.handicap})" 
                                style="width: 32px; height: 32px; border-radius: 6px; border: 1px solid #d1d5db; background: white; font-size: 14px; cursor: pointer;">âï¸</button>` : ''}
                        </div>
                    </div>
                    <button onclick="${type === 'claimed' ? `releasePlayerFromPage('${player.name}')` : `removeFromWatchListFromPage('${player.name}')`}" 
                        style="width: 100%; padding: 8px; background: #ef4444; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">
                        ${type === 'claimed' ? 'Release Player' : 'Stop Watching'}
                    </button>
                </div>
            `;
        }
        
        // My Players Page helper functions
        function movePlayerInPage(playerName, currentIndex, direction, type) {
            const orderArray = type === 'claimed' ? playerOrder.claimed : playerOrder.watching;
            const newIndex = currentIndex + direction;
            
            if (newIndex < 0 || newIndex >= orderArray.length) return;
            
            // Swap
            [orderArray[currentIndex], orderArray[newIndex]] = [orderArray[newIndex], orderArray[currentIndex]];
            savePlayerOrder();
            showMyPlayersPage();
        }
        
        // Show add player dialog from My Players page
        function showAddPlayerDialogFromMyPlayers() {
            // Get username for pre-fill suggestion
            const suggestedName = currentAuthUser?.displayName || '';
            
            showModal(
                'â Add New Player',
                `
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <div>
                        <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Player Name</label>
                        <input type="text" id="newPlayerNameInput" value="${suggestedName}" placeholder="Enter player name" 
                            style="width: 100%; padding: 10px; border: 1.5px solid #e2e8f0; border-radius: 8px; font-size: 14px; box-sizing: border-box;">
                    </div>
                    <div>
                        <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Handicap</label>
                        <input type="number" id="newPlayerHandicapInput" value="0" min="-10" max="54" 
                            style="width: 100%; padding: 10px; border: 1.5px solid #e2e8f0; border-radius: 8px; font-size: 14px; box-sizing: border-box;">
                    </div>
                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                        <button onclick="closeModal()" style="flex: 1; padding: 12px; background: #94a3b8; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                        <button onclick="addPlayerFromMyPlayersDialog()" style="flex: 1; padding: 12px; background: #10b981; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            Add & Claim
                        </button>
                    </div>
                </div>
                `,
                null,
                false
            );
            
            // Focus on name input
            setTimeout(() => {
                const input = document.getElementById('newPlayerNameInput');
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 100);
        }
        
        // Add player from My Players dialog and claim them
        async function addPlayerFromMyPlayersDialog() {
            const nameInput = document.getElementById('newPlayerNameInput');
            const handicapInput = document.getElementById('newPlayerHandicapInput');
            
            const playerName = nameInput?.value?.trim();
            const handicap = parseInt(handicapInput?.value) || 0;
            
            if (!playerName) {
                showNotification('Error', 'Please enter a player name');
                return;
            }
            
            // Check if player already exists
            if (tournamentData.players.some(p => p.name.toLowerCase() === playerName.toLowerCase())) {
                showNotification('Error', 'A player with this name already exists');
                return;
            }
            
            closeModal();
            
            try {
                // Add player to tournament
                const newPlayer = {
                    name: playerName,
                    handicap: handicap,
                    scores: new Array(18).fill(null),
                    claimedBy: currentDeviceId // Claim immediately
                };
                
                // Update Firebase
                if (activeTournamentId) {
                    await db.collection('tournaments').doc(activeTournamentId).update({
                        players: firebase.firestore.FieldValue.arrayUnion(newPlayer),
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
                
                // Update local
                tournamentData.players.push(newPlayer);
                
                // Add to claimed list
                if (!claimedPlayers.includes(playerName)) {
                    claimedPlayers.push(playerName);
                }
                if (!playerOrder.claimed.includes(playerName)) {
                    playerOrder.claimed.push(playerName);
                }
                savePlayerOrder();
                
                saveToLocalStorage();
                showNotification('Added!', `${playerName} added and claimed`);
                
                // Refresh My Players page
                showMyPlayersPage();
                
            } catch (error) {
                console.error('Error adding player:', error);
                showNotification('Error', 'Failed to add player');
            }
        }
        
        async function claimPlayerFromMyPage(playerName) {
            // Get current handicap
            const player = tournamentData.players.find(p => p.name === playerName);
            if (player) {
                showHandicapConfirmDialog(activeTournamentId, playerName, player.handicap);
                // Set flag to return to My Players page after claiming
                window.returnToMyPlayersPage = true;
            }
        }
        
        function addToWatchListFromPage(playerName) {
            if (!playerOrder.watching.includes(playerName)) {
                playerOrder.watching.push(playerName);
                savePlayerOrder();
                showMyPlayersPage();
            }
        }
        
        function removeFromWatchListFromPage(playerName) {
            playerOrder.watching = playerOrder.watching.filter(n => n !== playerName);
            savePlayerOrder();
            showMyPlayersPage();
        }
        
        // Clear all claimed players
        async function clearAllClaimed() {
            if (!activeTournamentId) return;
            
            showConfirm(
                'Release All Players?',
                'This will release all your claimed players. Their scores will be preserved.',
                async function() {
                    try {
                        const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                        const tournamentDoc = await tournamentRef.get();
                        const tournament = tournamentDoc.data();
                        
                        // Release all players claimed by this device
                        let releasedCount = 0;
                        tournament.players.forEach(player => {
                            if (player.claimedBy === currentDeviceId) {
                                player.claimedBy = null;
                                player.deviceInitials = null;
                                releasedCount++;
                            }
                        });
                        
                        if (releasedCount > 0) {
                            await tournamentRef.update({ players: tournament.players });
                            
                            // Clear local order
                            playerOrder.claimed = [];
                            savePlayerOrder();
                            
                            showNotification('Released', `${releasedCount} player(s) released`);
                        }
                        
                        showMyPlayersPage();
                    } catch (error) {
                        console.error('Error clearing claimed players:', error);
                        showNotification('Error', 'Failed to release players');
                    }
                }
            );
        }
        
        // Clear all watched players
        function clearAllWatched() {
            showConfirm(
                'Stop Watching All?',
                'This will remove all players from your watch list.',
                function() {
                    playerOrder.watching = [];
                    savePlayerOrder();
                    showNotification('Cleared', 'Watch list cleared');
                    showMyPlayersPage();
                }
            );
        }
        
        async function releasePlayerFromPage(playerName) {
            if (!activeTournamentId) return;
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex !== -1 && tournament.players[playerIndex].claimedBy === currentDeviceId) {
                    tournament.players[playerIndex].claimedBy = null;
                    tournament.players[playerIndex].deviceInitials = null;
                    
                    await tournamentRef.update({ players: tournament.players });
                    
                    // Remove from local order
                    playerOrder.claimed = playerOrder.claimed.filter(n => n !== playerName);
                    savePlayerOrder();
                    
                    showNotification('Released', `${playerName} is now available`);
                    showMyPlayersPage();
                }
            } catch (error) {
                console.error('Error releasing player:', error);
                showNotification('Error', 'Failed to release player');
            }
        }
        
        function editPlayerFromPage(playerName, currentHandicap) {
            // Edit dialog with name and handicap fields
            const dialog = document.getElementById('confirmDialog');
            const titleEl = document.getElementById('confirmTitle');
            const messageEl = document.getElementById('confirmMessage');
            const cancelBtn = document.getElementById('confirmCancel');
            const okBtn = document.getElementById('confirmOk');
            
            titleEl.textContent = `Edit Player`;
            messageEl.innerHTML = `
                <div style="margin: 12px 0;">
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 14px;">Name:</label>
                    <input type="text" id="editPlayerNameInput" value="${playerName}" 
                        style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px;"
                        maxlength="30">
                </div>
                <div style="margin: 12px 0;">
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 14px;">Handicap:</label>
                    <input type="number" id="editPlayerHcpInput" value="${currentHandicap}" 
                        style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; text-align: center;"
                        min="-10" max="54">
                </div>
            `;
            
            cancelBtn.textContent = 'Cancel';
            okBtn.textContent = 'Save';
            okBtn.style.background = '#3b82f6';
            
            const newCancelHandler = () => {
                dialog.style.display = 'none';
            };
            const newOkHandler = async () => {
                const newName = document.getElementById('editPlayerNameInput').value.trim();
                const newHandicap = parseInt(document.getElementById('editPlayerHcpInput').value) || 0;
                
                if (!newName) {
                    showNotification('Error', 'Player name cannot be empty');
                    return;
                }
                
                await updateClaimedPlayer(playerName, newName, newHandicap);
                dialog.style.display = 'none';
                showMyPlayersPage();
            };
            
            cancelBtn.replaceWith(cancelBtn.cloneNode(true));
            okBtn.replaceWith(okBtn.cloneNode(true));
            document.getElementById('confirmCancel').addEventListener('click', newCancelHandler);
            document.getElementById('confirmOk').addEventListener('click', newOkHandler);
            
            dialog.style.display = 'flex';
        }
        
        // Update claimed player name and handicap
        async function updateClaimedPlayer(oldName, newName, newHandicap) {
            try {
                // Find the player in local data
                const playerIdx = tournamentData.players.findIndex(p => p.name === oldName);
                if (playerIdx === -1) {
                    showNotification('Error', 'Player not found');
                    return;
                }
                
                // Update local data
                tournamentData.players[playerIdx].name = newName;
                tournamentData.players[playerIdx].handicap = newHandicap;
                
                // Update player order if name changed
                if (oldName !== newName) {
                    const orderIdx = playerOrder.claimed.indexOf(oldName);
                    if (orderIdx > -1) {
                        playerOrder.claimed[orderIdx] = newName;
                        savePlayerOrder();
                    }
                }
                
                // Save locally
                saveToLocalStorage();
                
                // Update Firebase if in multi-device mode
                if (activeTournamentId && tournamentMode === 'multi') {
                    const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                    const tournamentDoc = await tournamentRef.get();
                    const tournament = tournamentDoc.data();
                    
                    const fbPlayerIdx = tournament.players.findIndex(p => p.name === oldName);
                    if (fbPlayerIdx > -1) {
                        tournament.players[fbPlayerIdx].name = newName;
                        tournament.players[fbPlayerIdx].handicap = newHandicap;
                        
                        await tournamentRef.update({
                            players: tournament.players,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                }
                
                showNotification('Updated', `${newName} saved`);
            } catch (error) {
                console.error('Error updating player:', error);
                showNotification('Error', 'Failed to update player');
            }
        }
        
        // Show Guest Home Page (Non-Host)
        function showGuestHomePage() {
            // Populate tournament info
            if (tournamentData) {
                document.getElementById('guestTournamentName').textContent = tournamentData.name || 'Tournament';
                const courseName = courseData?.name || tournamentData.course || '';
                document.getElementById('guestTournamentInfo').textContent = 
                    `${courseName} â¢ ${formatDateDisplay(tournamentData.date) || ''}`;
                
                // Update role badge based on user's role
                const roleBadge = document.getElementById('guestRoleBadge');
                if (roleBadge) {
                    if (isHost) {
                        roleBadge.innerHTML = 'ð HOST';
                        roleBadge.style.background = 'white';
                        roleBadge.style.color = '#f97316';
                        roleBadge.style.borderColor = '#f97316';
                    } else if (canManageTournament()) {
                        roleBadge.innerHTML = 'ð CO-HOST';
                        roleBadge.style.background = '#fef3c7';
                        roleBadge.style.color = '#92400e';
                        roleBadge.style.borderColor = '#f59e0b';
                    } else {
                        roleBadge.innerHTML = 'ð¤ PLAYER';
                        roleBadge.style.background = '#dbeafe';
                        roleBadge.style.color = '#1e40af';
                        roleBadge.style.borderColor = '#3b82f6';
                    }
                }
                
                // Update host info
                const hostNameEl = document.getElementById('guestHostName');
                if (hostNameEl) {
                    // Try to get host name from tournament data
                    const hostName = tournamentData.hostName || tournamentData.createdByName || 'Unknown';
                    hostNameEl.textContent = hostName;
                }
                
                // Show Current Tournament card
                document.getElementById('guestCurrentTournament').style.display = 'block';
                document.getElementById('guestActiveButtons').style.display = 'flex';
            }
            
            // Update device initials display
            updateDeviceInitialsDisplay();
            
            // Update tournament history count
            updateHistoryCountDisplay();
            
            // Check if device has claimed or watched any players
            const hasClaimedOrWatched = checkIfDeviceHasPlayers();
            
            // If device has claimed/watched players, they're considered joined
            if (hasClaimedOrWatched) {
                hasJoinedTournament = true;
            }
            
            // Update Enter/Leave Tournament button based on join status
            updateEnterLeaveButton();
            
            showPage('guestHomePage');
        }
        
        // Check if current device has claimed or watched any players
        function checkIfDeviceHasPlayers() {
            if (!tournamentData || !tournamentData.players) return false;
            
            // Check claimed players
            const hasClaimed = tournamentData.players.some(p => p.claimedBy === currentDeviceId);
            
            // Check watched players from playerOrder
            const hasWatched = playerOrder.watching && playerOrder.watching.length > 0;
            
            return hasClaimed || hasWatched;
        }
        
        // Update the Enter/Leave Tournament button based on hasJoinedTournament
        function updateEnterLeaveButton() {
            const enterCard = document.getElementById('enterTournamentCard');
            const leaveBtn = document.getElementById('guestLeaveBtn');
            const activeButtons = document.getElementById('guestActiveButtons');
            const currentTournamentCard = document.getElementById('guestCurrentTournament');
            const loadTournamentCard = document.getElementById('loadTournamentCard');
            
            // Also check if device has players (another indicator of being joined)
            const hasPlayers = checkIfDeviceHasPlayers();
            const isJoined = hasJoinedTournament || hasPlayers;
            
            if (isJoined) {
                // Hide Enter Tournament card, show Leave button, enable active buttons
                if (enterCard) enterCard.style.display = 'none';
                if (leaveBtn) leaveBtn.style.display = 'flex';
                if (activeButtons) activeButtons.style.display = 'flex';
                if (currentTournamentCard) currentTournamentCard.style.display = 'block';
                if (loadTournamentCard) loadTournamentCard.style.display = 'block';
            } else {
                // Show Enter Tournament card, hide Leave button
                // Also hide Load Tournament card to simplify the initial view
                if (enterCard) enterCard.style.display = 'block';
                if (leaveBtn) leaveBtn.style.display = 'none';
                if (loadTournamentCard) loadTournamentCard.style.display = 'none';
            }
        }
        
        // Handle Enter Tournament button click
        function handleEnterTournament() {
            if (activeTournamentId) {
                showJoinTournamentScreen(activeTournamentId);
            } else {
                showNotification('Error', 'No tournament to enter');
            }
        }
        
        // Handle Enter/Leave Tournament button click
        function handleEnterLeaveTournament() {
            if (hasJoinedTournament) {
                confirmLeaveTournament();
            } else {
                // Go to join tournament page
                if (activeTournamentId) {
                    showJoinTournamentScreen(activeTournamentId);
                } else {
                    showNotification('Error', 'No tournament to enter');
                }
            }
        }
        
        // Guest Resume Scoring - check if joined first
        function guestResumeScoring() {
            if (!hasJoinedTournament) {
                showNotification('Not Joined', 'Please enter the tournament first to access scoring');
                return;
            }
            showPage('scoringPage');
        }
        
        // Guest View Results - check if joined first
        function guestViewResults() {
            if (!hasJoinedTournament) {
                showNotification('Not Joined', 'Please enter the tournament first to view results');
                return;
            }
            showPage('resultsPage');
        }
        
        // Host/Player View Mode Toggle
        function setHostViewMode(mode) {
            hostViewMode = mode;
            saveToLocalStorage();
            
            const hostBtn = document.getElementById('toggleHostMode');
            const playerBtn = document.getElementById('togglePlayerMode');
            
            if (mode === 'host') {
                // Host selected - orange fill
                hostBtn.style.background = '#f59e0b';
                hostBtn.style.color = 'white';
                // Player not selected - white fill
                playerBtn.style.background = 'white';
                playerBtn.style.color = '#92400e';
                // Show host management
                showPlayerManagement();
            } else {
                // Host not selected - white fill
                hostBtn.style.background = 'white';
                hostBtn.style.color = '#92400e';
                // Player selected - orange fill
                playerBtn.style.background = '#f59e0b';
                playerBtn.style.color = 'white';
                // Show My Players page (player view)
                showMyPlayersPage();
            }
            
            // Update Host Home button
            updateHostHomeManageButton();
        }
        
        // Switch from My Players page to Host mode (Tournament Management)
        function switchToHostMode() {
            hostViewMode = 'host';
            saveToLocalStorage();
            showPlayerManagement();
        }
        
        // Show/hide the Host/Player toggle on My Players page based on whether user is host
        function updateMyPlayersHostToggle() {
            const toggle = document.getElementById('myPlayersHostToggle');
            if (toggle) {
                // Show toggle for hosts (or co-hosts) so they can switch to Tournament Management
                if (isHost || canManageTournament()) {
                    toggle.style.display = 'flex';
                    // Update button styles based on current mode
                    const hostBtn = document.getElementById('myPlayersHostBtn');
                    const playerBtn = document.getElementById('myPlayersPlayerBtn');
                    if (hostBtn && playerBtn) {
                        // Player mode is active (we're on My Players page)
                        hostBtn.style.background = 'white';
                        hostBtn.style.color = '#92400e';
                        playerBtn.style.background = '#f59e0b';
                        playerBtn.style.color = 'white';
                    }
                } else {
                    toggle.style.display = 'none';
                }
            }
        }
        
        // Reopen a finished tournament (allow all players to edit again)
        async function reopenTournament() {
            if (!activeTournamentId) {
                showNotification('Error', 'No active tournament');
                return;
            }
            
            try {
                // Update Firebase
                await db.collection('tournaments').doc(activeTournamentId).update({
                    isFinished: false
                });
                
                // Update local
                if (tournamentData) {
                    tournamentData.isFinished = false;
                }
                
                // Update history
                updateTournamentHistoryItem(activeTournamentId, { isFinished: false });
                
                // Hide the finished actions
                const finishedActions = document.getElementById('finishedTournamentActions');
                if (finishedActions) {
                    finishedActions.style.display = 'none';
                }
                
                // Update Host Home badge
                updateHostHomeBadge();
                
                saveToLocalStorage();
                showNotification('Reopened', 'Tournament is now open for editing');
                
            } catch (error) {
                console.error('Error reopening tournament:', error);
                showNotification('Error', 'Failed to reopen tournament');
            }
        }
        
        // Confirm restart for current tournament
        function confirmRestartCurrentTournament() {
            if (!activeTournamentId) {
                showNotification('Error', 'No active tournament');
                return;
            }
            
            showConfirm(
                'ð Restart Tournament?',
                'This will clear ALL scores and player claims. The tournament will start fresh as if no one had ever joined. This cannot be undone!',
                async function() {
                    try {
                        const tournamentDoc = await db.collection('tournaments').doc(activeTournamentId).get();
                        const tournament = tournamentDoc.data();
                        
                        // Reset all players - clear scores and claims
                        const resetPlayers = tournament.players.map(p => ({
                            ...p,
                            scores: new Array(18).fill(null),
                            claimedBy: null,
                            deviceInitials: null
                        }));
                        
                        // Update Firebase
                        await db.collection('tournaments').doc(activeTournamentId).update({
                            players: resetPlayers,
                            isFinished: false
                        });
                        
                        // Update local
                        tournamentData.players = resetPlayers;
                        tournamentData.isFinished = false;
                        
                        // Clear player stats
                        clearAllPlayerStats();
                        localStorage.removeItem('playerStats_' + activeTournamentId);
                        
                        // Hide the finished actions
                        const finishedActions = document.getElementById('finishedTournamentActions');
                        if (finishedActions) {
                            finishedActions.style.display = 'none';
                        }
                        
                        // Update Host Home badge
                        updateHostHomeBadge();
                        
                        saveToLocalStorage();
                        hideConfirmDialog();
                        showNotification('Restarted', 'Tournament has been reset');
                        
                        // Refresh the management page
                        showPlayerManagement();
                        
                    } catch (error) {
                        console.error('Error restarting tournament:', error);
                        showNotification('Error', 'Failed to restart tournament');
                        hideConfirmDialog();
                    }
                }
            );
        }
        
        // Update tournament history item
        function updateTournamentHistoryItem(tournamentId, updates) {
            const history = getTournamentHistory();
            const index = history.findIndex(t => t.id === tournamentId);
            if (index !== -1) {
                history[index] = { ...history[index], ...updates };
                localStorage.setItem('tournamentHistory', JSON.stringify(history));
            }
        }
        
        // Update Host Home badge based on tournament status
        function updateHostHomeBadge() {
            const badge = document.getElementById('hostTournamentBadge');
            if (badge) {
                if (tournamentData?.isFinished) {
                    badge.innerHTML = 'ð HOST <span style="background: #fef3c7; color: #92400e; font-size: 9px; margin-left: 4px; padding: 1px 4px; border-radius: 3px;">FINISHED</span>';
                } else {
                    badge.innerHTML = 'ð HOST';
                }
            }
        }
        
        
        // Update Host Home manage button based on hostViewMode
        function updateHostHomeManageButton() {
            const btn = document.getElementById('hostHomeManageBtn');
            const icon = document.getElementById('hostHomeManageBtnIcon');
            const text = document.getElementById('hostHomeManageBtnText');
            
            if (btn && icon && text) {
                if (hostViewMode === 'player') {
                    // In Player mode - show Tournament Management
                    icon.textContent = 'âï¸';
                    text.textContent = 'Tournament Management';
                    btn.onclick = function() { showPlayerManagement(); };
                } else {
                    // In Host mode - show Manage Tournament (same function, different label)
                    icon.textContent = 'âï¸';
                    text.textContent = 'Manage Tournament';
                    btn.onclick = function() { showPlayerManagement(); };
                }
            }
        }
        
        // Update toggle buttons to reflect current mode
        function updateHostViewModeUI() {
            const hostBtn = document.getElementById('toggleHostMode');
            const playerBtn = document.getElementById('togglePlayerMode');
            
            if (hostBtn && playerBtn) {
                if (hostViewMode === 'host') {
                    // Host selected - orange fill
                    hostBtn.style.background = '#f59e0b';
                    hostBtn.style.color = 'white';
                    // Player not selected - white fill
                    playerBtn.style.background = 'white';
                    playerBtn.style.color = '#92400e';
                } else {
                    // Host not selected - white fill
                    hostBtn.style.background = 'white';
                    hostBtn.style.color = '#92400e';
                    // Player selected - orange fill
                    playerBtn.style.background = '#f59e0b';
                    playerBtn.style.color = 'white';
                }
            }
            
            // Also update Host Home button
            updateHostHomeManageButton();
        }
        
        // Update device initials display on home pages
        function updateDeviceInitialsDisplay() {
            const initials = localStorage.getItem('deviceInitials') || '--';
            const guestEl = document.getElementById('guestDeviceInitials');
            const hostEl = document.getElementById('hostDeviceInitials');
            if (guestEl) guestEl.textContent = initials;
            if (hostEl) hostEl.textContent = initials;
        }
        
        // Show edit device name dialog
        function showEditDeviceNameDialog() {
            const currentInitials = localStorage.getItem('deviceInitials') || '';
            
            const dialog = document.getElementById('confirmDialog');
            const titleEl = document.getElementById('confirmTitle');
            const messageEl = document.getElementById('confirmMessage');
            const cancelBtn = document.getElementById('confirmCancel');
            const okBtn = document.getElementById('confirmOk');
            
            titleEl.textContent = 'ð± Edit Device Name';
            messageEl.innerHTML = `
                <p style="color: #64748b; font-size: 14px; margin-bottom: 12px;">Your initials are shown to the host so they know who's scoring which players.</p>
                <div style="margin: 12px 0;">
                    <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 14px;">Your Initials:</label>
                    <input type="text" id="editDeviceInitialsInput" value="${currentInitials}" 
                        style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 18px; text-align: center; text-transform: uppercase; font-weight: 600;"
                        maxlength="3" placeholder="ABC">
                </div>
            `;
            
            cancelBtn.textContent = 'Cancel';
            okBtn.textContent = 'Save';
            okBtn.style.background = '#3b82f6';
            
            const newCancelHandler = () => {
                dialog.style.display = 'none';
            };
            const newOkHandler = async () => {
                const newInitials = document.getElementById('editDeviceInitialsInput').value.trim().toUpperCase();
                
                if (!newInitials) {
                    showNotification('Error', 'Please enter your initials');
                    return;
                }
                
                // Save locally
                localStorage.setItem('deviceInitials', newInitials);
                
                // Update Firebase if in multi-device mode
                if (activeTournamentId && tournamentMode === 'multi') {
                    try {
                        const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                        const tournamentDoc = await tournamentRef.get();
                        const tournament = tournamentDoc.data();
                        
                        // Update devices object
                        if (!tournament.devices) tournament.devices = {};
                        tournament.devices[currentDeviceId] = {
                            ...tournament.devices[currentDeviceId],
                            initials: newInitials
                        };
                        
                        // Also update deviceInitials on any claimed players
                        tournament.players.forEach(p => {
                            if (p.claimedBy === currentDeviceId) {
                                p.deviceInitials = newInitials;
                            }
                        });
                        
                        await tournamentRef.update({
                            devices: tournament.devices,
                            players: tournament.players,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    } catch (error) {
                        console.error('Error updating device initials:', error);
                    }
                }
                
                dialog.style.display = 'none';
                updateDeviceInitialsDisplay();
                showNotification('Saved', `Device name set to "${newInitials}"`);
            };
            
            cancelBtn.replaceWith(cancelBtn.cloneNode(true));
            okBtn.replaceWith(okBtn.cloneNode(true));
            document.getElementById('confirmCancel').addEventListener('click', newCancelHandler);
            document.getElementById('confirmOk').addEventListener('click', newOkHandler);
            
            dialog.style.display = 'flex';
            
            // Auto-focus and select the input
            setTimeout(() => {
                const input = document.getElementById('editDeviceInitialsInput');
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 100);
        }
        
        // Leave tournament (non-host) - 3 options: Cancel, Save & Leave, Leave
        function confirmLeaveTournament() {
            // Create custom 3-button modal
            let modal = document.getElementById('leaveConfirmModal');
            if (modal) modal.remove();
            
            modal = document.createElement('div');
            modal.id = 'leaveConfirmModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                padding: 20px;
            `;
            
            const tournamentName = tournamentData?.name || tournamentData?.course || 'Tournament';
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; max-width: 400px; width: 100%; text-align: center;">
                    <div style="font-size: 40px; margin-bottom: 12px;">ðª</div>
                    <h2 style="color: #1e293b; margin-bottom: 12px; font-size: 20px;">Leave Tournament?</h2>
                    <p style="color: #64748b; margin-bottom: 8px; font-size: 14px;">
                        <strong>${tournamentName}</strong>
                    </p>
                    <p style="color: #64748b; margin-bottom: 20px; font-size: 13px;">
                        Your claimed players will be released.
                    </p>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="handleLeaveCancel()" style="width: 100%; padding: 14px; background: #cbd5e1; color: #334155; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                        <button onclick="handleSaveAndLeave()" style="width: 100%; padding: 14px; background: #ca8a04; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            ð¾ Save & Leave
                        </button>
                        <button onclick="handleLeaveOnly()" style="width: 100%; padding: 14px; background: #ef4444; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Leave Without Saving
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function handleLeaveCancel() {
            document.getElementById('leaveConfirmModal')?.remove();
        }
        
        async function handleSaveAndLeave() {
            document.getElementById('leaveConfirmModal')?.remove();
            
            // Save tournament first
            if (tournamentData) {
                const saveData = {
                    ...tournamentData,
                    savedAt: new Date().toISOString()
                };
                
                const savedTournaments = JSON.parse(localStorage.getItem('savedTournaments') || '[]');
                savedTournaments.unshift(saveData);
                if (savedTournaments.length > 10) savedTournaments.pop();
                localStorage.setItem('savedTournaments', JSON.stringify(savedTournaments));
            }
            
            // Then leave
            await leaveTournament();
            showNotification('Saved & Left', 'Tournament saved for later viewing');
        }
        
        async function handleLeaveOnly() {
            document.getElementById('leaveConfirmModal')?.remove();
            await leaveTournament();
        }
        
        async function leaveTournament() {
            try {
                // Release all claimed players and remove device from tournament
                if (activeTournamentId) {
                    const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                    const tournamentDoc = await tournamentRef.get();
                    const tournament = tournamentDoc.data();
                    
                    // Release all players claimed by this device
                    tournament.players.forEach(p => {
                        if (p.claimedBy === currentDeviceId) {
                            p.claimedBy = null;
                            p.deviceInitials = null;
                        }
                    });
                    
                    // Remove this device from devices list
                    if (tournament.devices && tournament.devices[currentDeviceId]) {
                        delete tournament.devices[currentDeviceId];
                    }
                    
                    // Remove this device from connectedDevices list
                    if (tournament.connectedDevices && tournament.connectedDevices[currentDeviceId]) {
                        delete tournament.connectedDevices[currentDeviceId];
                    }
                    
                    // Remove this device from coHosts list if present
                    if (tournament.coHosts && tournament.coHosts.includes(currentDeviceId)) {
                        tournament.coHosts = tournament.coHosts.filter(id => id !== currentDeviceId);
                    }
                    
                    await tournamentRef.update({ 
                        players: tournament.players,
                        devices: tournament.devices || {},
                        connectedDevices: tournament.connectedDevices || {},
                        coHosts: tournament.coHosts || []
                    });
                }
                
                // Clear all session data
                activeTournamentId = null;
                tournamentData = null;
                isHost = false;
                isCoHost = false;
                hasJoinedTournament = false;
                playerOrder = { claimed: [], watching: [] };
                claimedPlayers = [];
                
                localStorage.removeItem('activeTournamentId');
                localStorage.removeItem('playerOrder');
                localStorage.removeItem('indianHillsScoring');
                
                // Hide Current Tournament card and Enter Tournament card
                document.getElementById('guestCurrentTournament').style.display = 'none';
                document.getElementById('enterTournamentCard').style.display = 'none';
                
                // Show only Load Tournament card
                document.getElementById('loadTournamentCard').style.display = 'block';
                
                showNotification('Left', 'You have left the tournament');
                showPage('guestHomePage');
            } catch (error) {
                console.error('Error leaving tournament:', error);
                showNotification('Error', 'Failed to leave tournament');
                // Still try to show guest home even if error
                showPage('guestHomePage');
            }
        }
        
        // Delete last tournament and hide the card
        function deleteLastTournament() {
            // Clear tournament data from memory
            tournamentData = null;
            localStorage.removeItem('indianHillsScoring');
            
            // Hide the Last Tournament card entirely
            document.getElementById('guestCurrentTournament').style.display = 'none';
            
            showNotification('Deleted', 'Tournament data cleared');
        }
        
        // Save last tournament data for later viewing (called from Save & Leave)
        function saveLastTournament() {
            if (tournamentData) {
                const saveData = {
                    ...tournamentData,
                    savedAt: new Date().toISOString()
                };
                
                // Get existing saved tournaments or create new array
                const savedTournaments = JSON.parse(localStorage.getItem('savedTournaments') || '[]');
                savedTournaments.unshift(saveData); // Add to front
                
                // Keep only last 10 tournaments
                if (savedTournaments.length > 10) {
                    savedTournaments.pop();
                }
                
                localStorage.setItem('savedTournaments', JSON.stringify(savedTournaments));
                
                // Clear tournament data from memory
                tournamentData = null;
                localStorage.removeItem('indianHillsScoring');
            }
        }
        
        // Load a previously saved tournament for viewing
        function loadPreviousTournament() {
            const savedTournaments = JSON.parse(localStorage.getItem('savedTournaments') || '[]');
            
            if (savedTournaments.length === 0) {
                showNotification('No Saved Tournaments', 'No tournaments have been saved');
                return;
            }
            
            // For now, just load the most recent one
            // TODO: Show a picker if multiple tournaments
            const tournament = savedTournaments[0];
            tournamentData = tournament;
            
            // Update course data
            if (tournament.course && courses[tournament.course]) {
                courseData = courses[tournament.course];
            }
            
            // Go to results page
            showPage('resultsPage');
        }
        
        // Legacy function for compatibility
        function showMyPlayersModal() {
            showMyPlayersPage();
        }
        
        function closeMyPlayersModal() {
            showPage('scoringPage');
            renderScoringPage();
        }
        
        function movePlayer(playerName, currentIndex, direction, type) {
            const orderArray = type === 'claimed' ? playerOrder.claimed : playerOrder.watching;
            const newIndex = currentIndex + direction;
            
            if (newIndex < 0 || newIndex >= orderArray.length) return;
            
            [orderArray[currentIndex], orderArray[newIndex]] = [orderArray[newIndex], orderArray[currentIndex]];
            
            savePlayerOrder();
            showMyPlayersModal();
        }
        
        function addToWatchList(playerName) {
            if (!playerOrder.watching.includes(playerName)) {
                playerOrder.watching.push(playerName);
                savePlayerOrder();
                showMyPlayersModal();
                showNotification('Added', `Now watching ${playerName}`);
                
                // Refresh current view to show the new watched player
                if (currentView === 'hole') {
                    renderHoleView();
                } else {
                    renderCompactPlayerView(getPlayersToShow());
                }
            }
        }
        
        function removeFromWatchList(playerName) {
            const index = playerOrder.watching.indexOf(playerName);
            if (index > -1) {
                playerOrder.watching.splice(index, 1);
                savePlayerOrder();
                showMyPlayersModal();
                showNotification('Removed', `Stopped watching ${playerName}`);
                
                // Refresh current view to remove the unwatched player
                if (currentView === 'hole') {
                    renderHoleView();
                } else {
                    renderCompactPlayerView(getPlayersToShow());
                }
            }
        }
        
        // Helper function to get filtered players list
        function getPlayersToShow() {
            let playersToShow = tournamentData.players;
            // Show filtered view for non-hosts OR when host is in player mode
            if (tournamentMode === 'multi' && (!canManageTournament() || isHostInPlayerMode())) {
                // Separate claimed and watched players
                const claimedPlayers = tournamentData.players.filter(p => p.claimedBy === currentDeviceId);
                const watchedPlayers = tournamentData.players.filter(p => 
                    playerOrder.watching && playerOrder.watching.includes(p.name) && p.claimedBy !== currentDeviceId
                );
                // Sort each group by their saved order
                const sortedClaimed = sortPlayersByOrder(claimedPlayers, playerOrder.claimed || []);
                const sortedWatched = sortPlayersByOrder(watchedPlayers, playerOrder.watching || []);
                // Claimed first, then watched
                playersToShow = [...sortedClaimed, ...sortedWatched];
                
                // DON'T fallback to all players - return empty array if no claims/watches
                // This ensures player mode users only see their claimed/watched players
            }
            return playersToShow;
        }
        
        // Track if claiming from My Players modal
        let claimingFromMyPlayersModal = false;
        
        async function claimPlayerFromModal(playerName) {
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                const player = tournament.players.find(p => p.name === playerName);
                
                if (!player) {
                    showNotification('Error', 'Player not found');
                    return;
                }
                
                // Set flag to return to My Players page after claiming
                claimingFromMyPlayersModal = true;
                showHandicapConfirmDialog(activeTournamentId, playerName, player.handicap);
            } catch (error) {
                console.error('Error claiming player:', error);
                showNotification('Error', 'Failed to claim player');
            }
        }
        
        async function releasePlayer(playerName) {
            showConfirm(
                'Release Player?',
                `Are you sure you want to release ${playerName}? You'll stop scoring for them, but their scores will be preserved.`,
                async function() {
                    try {
                        const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                        const tournamentDoc = await tournamentRef.get();
                        const tournament = tournamentDoc.data();
                        
                        const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                        if (playerIndex > -1) {
                            tournament.players[playerIndex].claimedBy = null;
                            
                            await tournamentRef.update({
                                players: tournament.players,
                                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                            });
                            
                            const index = playerOrder.claimed.indexOf(playerName);
                            if (index > -1) {
                                playerOrder.claimed.splice(index, 1);
                            }
                            
                            const cpIndex = claimedPlayers.indexOf(playerName);
                            if (cpIndex > -1) {
                                claimedPlayers.splice(cpIndex, 1);
                            }
                            
                            savePlayerOrder();
                            hideConfirmDialog();
                            showMyPlayersModal();
                            showNotification('Released', `${playerName} is now unclaimed`);
                        }
                    } catch (error) {
                        console.error('Error releasing player:', error);
                        showNotification('Error', 'Failed to release player');
                    }
                }
            );
        }
        
        function editPlayerModal(playerName, currentHandicap) {
            const dialog = document.getElementById('confirmDialog');
            const titleEl = document.getElementById('confirmTitle');
            const messageEl = document.getElementById('confirmMessage');
            const cancelBtn = document.getElementById('confirmCancel');
            const okBtn = document.getElementById('confirmOk');
            
            // Get player's handicap index if stored, otherwise use course handicap as estimate
            const player = tournamentData.players.find(p => p.name === playerName);
            const currentIndex = player?.handicapIndex ?? currentHandicap;
            
            // Get course slope and rating from selected tee
            let slopeRating = 113;
            let courseRating = 72;
            let totalPar = 72;
            
            if (courseData) {
                totalPar = courseData.totalPar || 72;
                // Get selected tee data
                const selectedTeeId = tournamentData.selectedTee || 'white';
                if (courseData.tees && courseData.tees[selectedTeeId]) {
                    slopeRating = courseData.tees[selectedTeeId].slope || 113;
                    courseRating = courseData.tees[selectedTeeId].rating || 72;
                }
            }
            
            titleEl.textContent = `Edit ${playerName}`;
            messageEl.innerHTML = `
                <div style="margin: 16px 0;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">Name:</label>
                    <input type="text" id="editPlayerName" value="${playerName}" 
                        style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                    
                    <label style="display: block; margin: 16px 0 8px; font-weight: 600;">Handicap Index:</label>
                    <input type="number" id="editPlayerIndex" value="${currentIndex}" step="0.1"
                        onchange="calculateCourseHandicapEdit()"
                        oninput="calculateCourseHandicapEdit()"
                        style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                    <p style="font-size: 11px; color: #64748b; margin: 4px 0 0 0;">Your official GHIN handicap index</p>
                    
                    <label style="display: block; margin: 16px 0 8px; font-weight: 600;">Course Handicap:</label>
                    <input type="number" id="editPlayerHandicap" value="${currentHandicap}" 
                        style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                    <p style="font-size: 11px; color: #64748b; margin: 4px 0 0 0;">Auto-calculated (Slope: ${slopeRating}, Rating: ${courseRating})</p>
                </div>
            `;
            
            dialog.style.display = 'flex';
            
            // Auto-calculate course handicap when index changes using USGA formula
            // Store values in closure for the callback
            const _slopeRating = slopeRating;
            const _courseRating = courseRating;
            const _totalPar = totalPar;
            window.calculateCourseHandicapEdit = function() {
                const indexInput = document.getElementById('editPlayerIndex');
                const hcpInput = document.getElementById('editPlayerHandicap');
                if (indexInput && hcpInput) {
                    const index = parseFloat(indexInput.value) || 0;
                    // USGA Formula: Course Handicap = Index Ã (Slope / 113) + (Rating - Par)
                    const courseHcp = Math.round(index * (_slopeRating / 113) + (_courseRating - _totalPar));
                    hcpInput.value = courseHcp;
                }
            };
            
            const handleOk = async () => {
                const newName = document.getElementById('editPlayerName').value.trim();
                const newIndex = parseFloat(document.getElementById('editPlayerIndex').value) || 0;
                const newHandicap = parseInt(document.getElementById('editPlayerHandicap').value) || 0;
                
                if (!newName) {
                    alert('Name cannot be empty');
                    return;
                }
                
                try {
                    const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                    const tournamentDoc = await tournamentRef.get();
                    const tournament = tournamentDoc.data();
                    
                    const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                    if (playerIndex > -1) {
                        tournament.players[playerIndex].name = newName;
                        tournament.players[playerIndex].handicapIndex = newIndex;
                        tournament.players[playerIndex].handicap = newHandicap;
                        
                        await tournamentRef.update({
                            players: tournament.players,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        
                        tournamentData.players = tournament.players;
                        saveToLocalStorage();
                        
                        if (newName !== playerName) {
                            const claimedIndex = playerOrder.claimed.indexOf(playerName);
                            if (claimedIndex > -1) {
                                playerOrder.claimed[claimedIndex] = newName;
                            }
                            const watchingIndex = playerOrder.watching.indexOf(playerName);
                            if (watchingIndex > -1) {
                                playerOrder.watching[watchingIndex] = newName;
                            }
                            savePlayerOrder();
                        }
                        
                        hideConfirmDialog();
                        showMyPlayersModal();
                        showNotification('Updated', `Player updated successfully`);
                    }
                } catch (error) {
                    console.error('Error updating player:', error);
                    showNotification('Error', 'Failed to update player');
                }
            };
            
            okBtn.onclick = handleOk;
            cancelBtn.onclick = hideConfirmDialog;
        }
        
        function getOrderedPlayers() {
            loadPlayerOrder();
            
            let playersToShow = tournamentData.players;
            
            // Show filtered view for non-hosts OR when host is in player mode
            if (tournamentMode === 'multi' && (!canManageTournament() || isHostInPlayerMode())) {
                const claimed = playersToShow.filter(p => p.claimedBy === currentDeviceId);
                const watched = playersToShow.filter(p => playerOrder.watching && playerOrder.watching.includes(p.name) && p.claimedBy !== currentDeviceId);
                
                const sortedClaimed = sortPlayersByOrder(claimed, playerOrder.claimed);
                const sortedWatched = sortPlayersByOrder(watched, playerOrder.watching);
                
                playersToShow = [...sortedClaimed, ...sortedWatched];
                
                // DON'T fallback to all players - return empty if no claims/watches
            }
            
            return playersToShow;
        }
        
        function setResultsFilter(filter) {
            currentResultsFilter = filter;
            
            const allBtn = document.getElementById('resultsToggleAll');
            const mineBtn = document.getElementById('resultsToggleMine');
            
            if (allBtn && mineBtn) {
                if (filter === 'all') {
                    allBtn.style.background = '#3b82f6';
                    allBtn.style.color = 'white';
                    mineBtn.style.background = 'transparent';
                    mineBtn.style.color = '#64748b';
                } else {
                    mineBtn.style.background = '#3b82f6';
                    mineBtn.style.color = 'white';
                    allBtn.style.background = 'transparent';
                    allBtn.style.color = '#64748b';
                }
            }
            
            updateResultsDisplay();
        }
        
        // Edit player from management page (host function)
        async function editPlayerFromManagement(playerName, currentHandicap) {
            const dialog = document.getElementById('confirmDialog');
            const titleEl = document.getElementById('confirmTitle');
            const messageEl = document.getElementById('confirmMessage');
            const cancelBtn = document.getElementById('confirmCancel');
            const okBtn = document.getElementById('confirmOk');
            
            // Get player's handicap index if stored
            const player = tournamentData.players.find(p => p.name === playerName);
            const currentIndex = player?.handicapIndex ?? currentHandicap;
            
            // Get course slope and rating from selected tee
            let slopeRating = 113;
            let courseRating = 72;
            let totalPar = 72;
            
            if (courseData) {
                totalPar = courseData.totalPar || 72;
                const selectedTeeId = tournamentData.selectedTee || 'white';
                if (courseData.tees && courseData.tees[selectedTeeId]) {
                    slopeRating = courseData.tees[selectedTeeId].slope || 113;
                    courseRating = courseData.tees[selectedTeeId].rating || 72;
                }
            }
            
            titleEl.textContent = `Edit ${playerName}`;
            messageEl.innerHTML = `
                <div style="margin: 16px 0;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">Name:</label>
                    <input type="text" id="editPlayerName" value="${playerName}" 
                        style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                    
                    <label style="display: block; margin: 16px 0 8px; font-weight: 600;">Handicap Index:</label>
                    <input type="number" id="editPlayerIndex" value="${currentIndex}" step="0.1"
                        onchange="calculateCourseHandicapMgmt()"
                        oninput="calculateCourseHandicapMgmt()"
                        style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                    <p style="font-size: 11px; color: #64748b; margin: 4px 0 0 0;">Your official GHIN handicap index</p>
                    
                    <label style="display: block; margin: 16px 0 8px; font-weight: 600;">Course Handicap:</label>
                    <input type="number" id="editPlayerHandicap" value="${currentHandicap}" 
                        style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                    <p style="font-size: 11px; color: #64748b; margin: 4px 0 0 0;">Auto-calculated (Slope: ${slopeRating}, Rating: ${courseRating})</p>
                </div>
            `;
            
            dialog.style.display = 'flex';
            
            // Auto-calculate course handicap when index changes using USGA formula
            // Store values in closure for the callback
            const _slopeRating = slopeRating;
            const _courseRating = courseRating;
            const _totalPar = totalPar;
            window.calculateCourseHandicapMgmt = function() {
                const indexInput = document.getElementById('editPlayerIndex');
                const hcpInput = document.getElementById('editPlayerHandicap');
                if (indexInput && hcpInput) {
                    const index = parseFloat(indexInput.value) || 0;
                    // USGA Formula: Course Handicap = Index Ã (Slope / 113) + (Rating - Par)
                    const courseHcp = Math.round(index * (_slopeRating / 113) + (_courseRating - _totalPar));
                    hcpInput.value = courseHcp;
                }
            };
            
            const handleOk = async () => {
                const newName = document.getElementById('editPlayerName').value.trim();
                const newIndex = parseFloat(document.getElementById('editPlayerIndex').value) || 0;
                const newHandicap = parseInt(document.getElementById('editPlayerHandicap').value) || 0;
                
                if (!newName) {
                    alert('Name cannot be empty');
                    return;
                }
                
                try {
                    const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                    const tournamentDoc = await tournamentRef.get();
                    const tournament = tournamentDoc.data();
                    
                    const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                    if (playerIndex > -1) {
                        tournament.players[playerIndex].name = newName;
                        tournament.players[playerIndex].handicapIndex = newIndex;
                        tournament.players[playerIndex].handicap = newHandicap;
                        
                        await tournamentRef.update({
                            players: tournament.players,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        
                        // Update local tournamentData
                        tournamentData.players = tournament.players;
                        saveToLocalStorage();
                        
                        hideConfirmDialog();
                        showPlayerManagement(); // Refresh the page
                        showNotification('Updated', `Player updated successfully`);
                    }
                } catch (error) {
                    console.error('Error updating player:', error);
                    showNotification('Error', 'Failed to update player');
                }
            };
            
            okBtn.onclick = handleOk;
            cancelBtn.onclick = hideConfirmDialog;
        }
        
        // Confirm player HCP after tee change (clears the warning indicator)
        async function confirmPlayerHcp(playerName) {
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                if (playerIndex > -1) {
                    tournament.players[playerIndex].needsHcpConfirmation = false;
                    
                    await tournamentRef.update({
                        players: tournament.players,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    // Update local tournamentData
                    tournamentData.players = tournament.players;
                    saveToLocalStorage();
                    
                    showPlayerManagement(); // Refresh the page
                    showNotification('Confirmed', `${playerName}'s handicap confirmed`);
                }
            } catch (error) {
                console.error('Error confirming player HCP:', error);
                showNotification('Error', 'Failed to confirm handicap');
            }
        }
        
        // Add player to tournament (host and co-hosts)
        async function addPlayerToTournament() {
            if (!activeTournamentId || !canManageTournament()) {
                showNotification('Not Authorized', 'Only hosts and co-hosts can add players');
                return;
            }
            
            const nameInput = document.getElementById('newPlayerName');
            const handicapInput = document.getElementById('newPlayerHandicap');
            const name = nameInput.value.trim();
            const handicap = parseInt(handicapInput.value) || 0;
            
            if (!name) {
                showNotification('Error', 'Please enter a player name');
                return;
            }
            
            try {
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                const tournament = tournamentDoc.data();
                
                // Check if player already exists
                if (tournament.players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                    showNotification('Error', 'Player already exists');
                    return;
                }
                
                // Add new player with empty scores
                const newPlayer = {
                    name: name,
                    handicap: handicap,
                    scores: new Array(18).fill(0),
                    claimedBy: null
                };
                
                tournament.players.push(newPlayer);
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update local data
                tournamentData.players = tournament.players;
                saveToLocalStorage();
                
                // Clear inputs
                nameInput.value = '';
                handicapInput.value = '0';
                
                showNotification('Added', `${name} added to tournament`);
                showPlayerManagement(); // Refresh
            } catch (error) {
                console.error('Error adding player:', error);
                showNotification('Error', 'Failed to add player');
            }
        }
        
        // Delete player from tournament (host and co-hosts)
        async function deletePlayerFromTournament(playerName) {
            if (!activeTournamentId || !canManageTournament()) {
                showNotification('Not Authorized', 'Only hosts and co-hosts can delete players');
                return;
            }
            
            showConfirm(
                'Delete Player?',
                `Are you sure you want to remove ${playerName} from the tournament? All their scores will be lost.`,
                async function() {
                    try {
                        const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                        const tournamentDoc = await tournamentRef.get();
                        const tournament = tournamentDoc.data();
                        
                        // TOMBSTONE: Record deletion time to prevent zombie reappearance
                        const deletionTime = Date.now();
                        deletedPlayers[playerName] = deletionTime;
                        console.log(`ðª¦ TOMBSTONE created for "${playerName}" at ${deletedPlayers[playerName]}`);
                        
                        // Remove player
                        tournament.players = tournament.players.filter(p => p.name !== playerName);
                        
                        // Store tombstone in Firebase so all devices know this player was deleted
                        const cloudTombstones = tournament.deletedPlayers || {};
                        cloudTombstones[playerName] = deletionTime;
                        
                        await tournamentRef.update({
                            players: tournament.players,
                            deletedPlayers: cloudTombstones,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        
                        // Update local data
                        tournamentData.players = tournament.players;
                        saveToLocalStorage();
                        
                        hideConfirmDialog();
                        showNotification('Deleted', `${playerName} removed from tournament`);
                        showPlayerManagement(); // Refresh
                    } catch (error) {
                        console.error('Error deleting player:', error);
                        showNotification('Error', 'Failed to delete player');
                    }
                }
            );
        }

        // Render the scoring page
        function renderScoringPage() {
            // Load the correct course data (check both built-in and custom courses)
            courseData = courses[tournamentData.course] || customCourses[tournamentData.course];
            
            // Debug logging
            console.log('ðï¸ renderScoringPage:', {
                course: tournamentData.course,
                courseDataLoaded: !!courseData,
                holesLoaded: courseData?.holes?.length,
                playersCount: tournamentData?.players?.length
            });
            
            // Update smart info line
            setTimeout(() => {
                generateSmartInfoLine('scoringSmartInfo');
            }, 10);

            // Clear the player cards container - content will be rendered by view-specific functions
            const container = document.getElementById('playerCards');
            container.innerHTML = '';
            
            // Show/hide crown badge for host in player mode
            const scoringHostBadge = document.getElementById('scoringHostBadge');
            if (scoringHostBadge) {
                scoringHostBadge.style.display = isHostInPlayerMode() ? 'inline-block' : 'none';
            }
            
            // Show/hide Manage Players button (for host and co-hosts, but NOT when host is in player mode)
            const manageBtn = document.getElementById('managePlayersBtn');
            if (manageBtn) {
                if (canManageTournament() && !isHostInPlayerMode()) {
                    manageBtn.style.display = 'flex';
                } else {
                    manageBtn.style.display = 'none';
                }
            }
            
            // Show My Players button for non-hosts/non-co-hosts OR when host is in player mode
            const myPlayersBtnHeader = document.getElementById('myPlayersBtnHeader');
            if (myPlayersBtnHeader) {
                if (tournamentMode === 'multi' && (!canManageTournament() || isHostInPlayerMode())) {
                    myPlayersBtnHeader.style.display = 'flex';
                } else {
                    myPlayersBtnHeader.style.display = 'none';
                }
            }
            
            // Show/hide Claim Another Player button (only for non-hosts/non-co-hosts in multi-device mode, OR host in player mode)
            const claimBtn = document.getElementById('claimAnotherBtn');
            if (claimBtn) {
                if (tournamentMode === 'multi' && (!canManageTournament() || isHostInPlayerMode())) {
                    claimBtn.style.display = 'block';
                } else {
                    claimBtn.style.display = 'none';
                }
            }
            
            // Update connection status
            updateConnectionStatus();
            
            // FIXED: Default to hole view if not set, and always render content
            if (!currentView) {
                currentView = 'hole';
            }
            
            // Render the current active view (hole or player)
            // Use setTimeout to ensure DOM is ready
            setTimeout(() => {
                if (currentView === 'hole') {
                    renderHoleView();
                } else if (currentView === 'player') {
                    renderCompactPlayerView(getPlayersToShow());
                } else {
                    // Fallback to hole view
                    currentView = 'hole';
                    renderHoleView();
                }
            }, 10);
        }

        // Score modification functions
        async function updateScore(playerIndex, holeIndex, value) {
            const score = parseInt(value) || 0;
            tournamentData.players[playerIndex].scores[holeIndex] = score;
            
            // NEWEST WINS: Record timestamp for this score change
            const playerName = tournamentData.players[playerIndex].name;
            const timestampKey = `${playerName}-${holeIndex}`;
            scoreTimestamps[timestampKey] = Date.now();
            
            // IMMEDIATE SAVE with verification - this happens FIRST before any async
            const saveSuccess = saveToLocalStorage();
            
            // VERIFY the score was actually saved
            if (saveSuccess) {
                const verified = await verifyScoreSaved(playerIndex, holeIndex, score);
                if (!verified) {
                    console.error('â MANUAL INPUT: Score verification failed! Retrying save...');
                    tournamentData.players[playerIndex].scores[holeIndex] = score;
                    saveToLocalStorage();
                }
            }
            
            // Sync to Firebase if in cloud mode - AWAIT to ensure completion
            if (activeTournamentId && tournamentMode === 'multi') {
                const playerName = tournamentData.players[playerIndex].name;
                try {
                    await updatePlayerScore(activeTournamentId, playerName, holeIndex, score);
                } catch (error) {
                    console.error('â Firebase sync failed, but localStorage has the score:', error);
                }
            }
            
            updateProgressBar();
            
            // Preserve carousel position when re-rendering
            const savedCarouselIndex = currentCarouselIndex;
            renderScoringPage();
            currentCarouselIndex = savedCarouselIndex;
            updateCarouselPosition();
        }

        async function incrementScore(playerIndex, holeIndex) {
            console.log('=== INCREMENT SCORE CALLED ===');
            console.log('playerIndex:', playerIndex, 'holeIndex:', holeIndex);
            
            if (playerIndex === undefined || holeIndex === undefined) {
                console.error('â Invalid parameters:', { playerIndex, holeIndex });
                return;
            }
            
            if (!tournamentData || !tournamentData.players || !tournamentData.players[playerIndex]) {
                console.error('â Invalid player data:', { 
                    hasTournamentData: !!tournamentData, 
                    playersLength: tournamentData?.players?.length,
                    playerIndex 
                });
                return;
            }
            
            const currentScore = tournamentData.players[playerIndex].scores[holeIndex];
            const par = (courseData?.holes?.[holeIndex]?.par) || 4;
            
            console.log('Player:', tournamentData.players[playerIndex].name);
            console.log('Hole:', holeIndex + 1);
            console.log('Current score:', currentScore);
            
            // If score is 0 or null, set to par first
            if (!currentScore || currentScore === 0) {
                tournamentData.players[playerIndex].scores[holeIndex] = par;
            } else {
                tournamentData.players[playerIndex].scores[holeIndex] = Math.min(currentScore + 1, 15);
            }
            
            const newScore = tournamentData.players[playerIndex].scores[holeIndex];
            console.log('New score:', newScore);
            console.log('Full scores array:', tournamentData.players[playerIndex].scores);
            
            // NEWEST WINS: Record timestamp for this score change
            const playerName = tournamentData.players[playerIndex].name;
            const timestampKey = `${playerName}-${holeIndex}`;
            scoreTimestamps[timestampKey] = Date.now();
            
            // IMMEDIATE SAVE with verification
            console.log('ð¾ Attempting localStorage save...');
            const saveSuccess = saveToLocalStorage();
            console.log('ð¾ Save result:', saveSuccess);
            
            // VERIFY the score was actually saved
            if (saveSuccess) {
                const verified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                if (!verified) {
                    console.error('â INCREMENT: Score verification failed! Retrying save...');
                    tournamentData.players[playerIndex].scores[holeIndex] = newScore;
                    const retrySuccess = saveToLocalStorage();
                    console.log('ð¾ Retry save result:', retrySuccess);
                    
                    // Verify again
                    const reVerified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                    if (!reVerified) {
                        console.error('ð¨ CRITICAL: Score still not saved after retry!');
                        // Don't alert - Firebase has it
                    }
                }
            } else {
                console.error('ð¨ CRITICAL: Initial save failed!');
                // Don't alert - Firebase has it
            }
            
            // Sync to Firebase if in cloud mode
            console.log('Checking Firebase sync:');
            console.log('  activeTournamentId:', activeTournamentId);
            console.log('  tournamentMode:', tournamentMode);
            
            if (activeTournamentId && tournamentMode === 'multi') {
                console.log('â SYNCING to Firebase:', playerName, 'Hole', holeIndex + 1, '=', newScore);
                updatePlayerScore(activeTournamentId, playerName, holeIndex, newScore);
            } else {
                console.log('â NOT syncing - missing activeTournamentId or not in multi mode');
            }
            
            updateProgressBar();
            
            // Update only the specific score input without full re-render
            updateScoreDisplay(playerIndex, holeIndex, newScore, par);
            
            // Check if hole is complete for auto-advance
            setTimeout(() => checkAutoAdvance(), 500);
        }

        async function decrementScore(playerIndex, holeIndex) {
            console.log('=== DECREMENT SCORE CALLED ===');
            console.log('playerIndex:', playerIndex, 'holeIndex:', holeIndex);
            
            if (playerIndex === undefined || holeIndex === undefined) {
                console.error('â Invalid parameters:', { playerIndex, holeIndex });
                return;
            }
            
            if (!tournamentData || !tournamentData.players || !tournamentData.players[playerIndex]) {
                console.error('â Invalid player data:', { 
                    hasTournamentData: !!tournamentData, 
                    playersLength: tournamentData?.players?.length,
                    playerIndex 
                });
                return;
            }
            
            const currentScore = tournamentData.players[playerIndex].scores[holeIndex];
            const par = (courseData?.holes?.[holeIndex]?.par) || 4;
            
            console.log('Player:', tournamentData.players[playerIndex].name);
            console.log('Hole:', holeIndex + 1);
            console.log('Current score:', currentScore);
            
            // If score is 0 or null, set to par first
            if (!currentScore || currentScore === 0) {
                tournamentData.players[playerIndex].scores[holeIndex] = par;
            } else {
                tournamentData.players[playerIndex].scores[holeIndex] = Math.max(currentScore - 1, 0);
            }
            
            const newScore = tournamentData.players[playerIndex].scores[holeIndex];
            console.log('New score:', newScore);
            console.log('Full scores array:', tournamentData.players[playerIndex].scores);
            
            // NEWEST WINS: Record timestamp for this score change
            const playerName = tournamentData.players[playerIndex].name;
            const timestampKey = `${playerName}-${holeIndex}`;
            scoreTimestamps[timestampKey] = Date.now();
            
            // IMMEDIATE SAVE with verification
            console.log('ð¾ Attempting localStorage save...');
            const saveSuccess = saveToLocalStorage();
            console.log('ð¾ Save result:', saveSuccess);
            
            // VERIFY the score was actually saved
            if (saveSuccess) {
                const verified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                if (!verified) {
                    console.error('â DECREMENT: Score verification failed! Retrying save...');
                    tournamentData.players[playerIndex].scores[holeIndex] = newScore;
                    const retrySuccess = saveToLocalStorage();
                    console.log('ð¾ Retry save result:', retrySuccess);
                    
                    // Verify again
                    const reVerified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                    if (!reVerified) {
                        console.error('ð¨ CRITICAL: Score still not saved after retry!');
                        // Don't alert - Firebase has it
                    }
                }
            } else {
                console.error('ð¨ CRITICAL: Initial save failed!');
                // Don't alert - Firebase has it
            }
            
            // Sync to Firebase if in cloud mode
            console.log('Checking Firebase sync:');
            console.log('  activeTournamentId:', activeTournamentId);
            console.log('  tournamentMode:', tournamentMode);
            
            if (activeTournamentId && tournamentMode === 'multi') {
                console.log('â SYNCING to Firebase:', playerName, 'Hole', holeIndex + 1, '=', newScore);
                updatePlayerScore(activeTournamentId, playerName, holeIndex, newScore);
            } else {
                console.log('â NOT syncing - missing activeTournamentId or not in multi mode');
            }
            
            updateProgressBar();
            
            // Update only the specific score input without full re-render
            updateScoreDisplay(playerIndex, holeIndex, newScore, par);
        }
        
        // Update just the score display without re-rendering entire page
        function updateScoreDisplay(playerIndex, holeIndex, score, par) {
            // Find the score input for this player/hole
            const grid = document.getElementById(`player${playerIndex}Grid`);
            if (!grid) return; // Player not visible (filtered out)
            
            const holeInputs = grid.querySelectorAll('.hole-input-group');
            if (!holeInputs[holeIndex]) return;
            
            const scoreInput = holeInputs[holeIndex].querySelector('.score-input');
            if (!scoreInput) return;
            
            // Update value
            scoreInput.value = score || '';
            
            // Update color class
            scoreInput.className = 'score-input';
            if (score > 0) {
                const diff = score - par;
                if (diff >= 2) {
                    scoreInput.classList.add('double-bogey-plus');
                } else if (diff === 1) {
                    scoreInput.classList.add('bogey');
                } else if (diff === 0) {
                    scoreInput.classList.add('par');
                } else if (diff <= -1) {
                    scoreInput.classList.add('birdie-better');
                }
            }
            
            // Update player total
            const playerCard = scoreInput.closest('.player-card');
            if (playerCard) {
                const player = tournamentData.players[playerIndex];
                const total = player.scores.reduce((sum, s) => sum + (s || 0), 0);
                const toPar = total - courseData.totalPar;
                const toParText = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar);
                
                const totalDisplay = playerCard.querySelector('.player-total');
                if (totalDisplay) {
                    totalDisplay.innerHTML = `${total > 0 ? total : '-'} <span style="font-size: 16px; color: #64748b;">(${toParText})</span>`;
                }
            }
        }

        // Update progress bar
        function updateProgressBar() {
            const progressBar = document.getElementById('tournamentProgress');
            if (progressBar) {
                const progress = getTournamentProgress();
                progressBar.style.width = progress + '%';
            }
        }

        // Show finish confirmation dialog with 3 options
        function showFinishConfirmation() {
            const modal = document.createElement('div');
            modal.id = 'finishConfirmModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; max-width: 340px; width: 100%; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 12px;">ð</div>
                    <h2 style="color: #1e40af; margin-bottom: 8px; font-size: 20px;">View Results?</h2>
                    <p style="color: #64748b; margin-bottom: 20px; font-size: 14px;">
                        What would you like to do?
                    </p>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="confirmFinishAndView()" style="padding: 14px; background: #10b981; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            â View Results
                        </button>
                        <button onclick="saveAndStay()" style="padding: 14px; background: #3b82f6; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            ð¾ Save Backup & Stay
                        </button>
                        <button onclick="document.getElementById('finishConfirmModal').remove()" style="padding: 14px; background: #e2e8f0; color: #64748b; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Confirm and go to results
        function confirmFinishAndView() {
            document.getElementById('finishConfirmModal')?.remove();
            finishRound();
        }
        
        // Save backup and stay on scoring page
        function saveAndStay() {
            document.getElementById('finishConfirmModal')?.remove();
            saveTournamentFile();
            showNotification('Saved!', 'Backup file downloaded');
        }

        // Finish round and show results
        async function finishRound() {
            // Force sync from Firestore in multi-device mode before showing results
            if (tournamentMode === 'multi' && activeTournamentId) {
                try {
                    const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                    const tournamentDoc = await tournamentRef.get();
                    if (tournamentDoc.exists) {
                        const tournament = tournamentDoc.data();
                        updateLocalTournamentState(tournament);
                    }
                } catch (error) {
                    console.error('Error syncing tournament data:', error);
                }
            }
            
            renderResultsPage();
            showPage('resultsPage');
            // Celebrate with confetti!
            setTimeout(() => showConfetti(), 300);
        }

        function backToScoring() {
            showPage('scoringPage');
        }

        // Helper functions for net score calculations
        function getNetScore(grossScore, playerHcp, holeHcp, method = 'full') {
            if (grossScore === 0) return 0;
            
            let strokes = 0;
            
            // Handle plus handicaps (negative values)
            if (playerHcp < 0) {
                const absHcp = Math.abs(playerHcp);
                
                if (method === 'full') {
                    // Plus handicap: add strokes on EASIEST holes (18, 17, 16...)
                    strokes = -Math.floor(absHcp / 18); // Negative = add to score
                    if (holeHcp > (18 - (absHcp % 18))) {
                        strokes -= 1; // Add another stroke on easier holes
                    }
                } else if (method === '18max') {
                    // 18 Max: max 1 stroke added per hole on easiest holes
                    if (holeHcp > (18 - Math.min(absHcp, 18))) {
                        strokes = -1;
                    }
                } else if (method === 'half') {
                    // Half Pop: 0.5 stroke added per allocated stroke
                    const fullStrokes = Math.floor(absHcp / 18);
                    const extraStroke = holeHcp > (18 - (absHcp % 18)) ? 1 : 0;
                    strokes = -(fullStrokes + extraStroke) * 0.5;
                }
            } 
            // Handle regular (positive) handicaps
            else if (playerHcp > 0) {
                if (method === 'full') {
                    // Regular handicap: subtract strokes on HARDEST holes (1, 2, 3...)
                    strokes = Math.floor(playerHcp / 18);
                    if (holeHcp <= (playerHcp % 18)) {
                        strokes += 1;
                    }
                } else if (method === '18max') {
                    // 18 Max: max 1 stroke per hole
                    if (holeHcp <= Math.min(playerHcp, 18)) {
                        strokes = 1;
                    }
                } else if (method === 'half') {
                    // Half Pop: 0.5 stroke per allocated stroke
                    const fullStrokes = Math.floor(playerHcp / 18);
                    const extraStroke = holeHcp <= (playerHcp % 18) ? 1 : 0;
                    strokes = (fullStrokes + extraStroke) * 0.5;
                }
            }
            
            return grossScore - strokes;
        }
        
        // Get the number of handicap strokes for a specific hole
        // Returns: positive = strokes subtracted (getting pops), negative = strokes added (plus handicap)
        function getHandicapStrokesForHole(playerHcp, holeHcp, method = 'full') {
            if (playerHcp === 0) return 0;
            
            let strokes = 0;
            
            // Handle plus handicaps (negative values) - add strokes on easiest holes
            if (playerHcp < 0) {
                const absHcp = Math.abs(playerHcp);
                
                if (method === 'full') {
                    strokes = -Math.floor(absHcp / 18);
                    if (holeHcp > (18 - (absHcp % 18))) {
                        strokes -= 1;
                    }
                } else if (method === '18max') {
                    if (holeHcp > (18 - Math.min(absHcp, 18))) {
                        strokes = -1;
                    }
                } else if (method === 'half') {
                    const fullStrokes = Math.floor(absHcp / 18);
                    const extraStroke = holeHcp > (18 - (absHcp % 18)) ? 1 : 0;
                    strokes = -(fullStrokes + extraStroke) * 0.5;
                }
            } 
            // Handle regular (positive) handicaps - subtract strokes on hardest holes
            else if (playerHcp > 0) {
                if (method === 'full') {
                    strokes = Math.floor(playerHcp / 18);
                    if (holeHcp <= (playerHcp % 18)) {
                        strokes += 1;
                    }
                } else if (method === '18max') {
                    if (holeHcp <= Math.min(playerHcp, 18)) {
                        strokes = 1;
                    }
                } else if (method === 'half') {
                    const fullStrokes = Math.floor(playerHcp / 18);
                    const extraStroke = holeHcp <= (playerHcp % 18) ? 1 : 0;
                    strokes = (fullStrokes + extraStroke) * 0.5;
                }
            }
            
            return strokes;
        }

        function getStablefordPoints(netScore, par, modified = false) {
            const diff = netScore - par;
            
            if (modified) {
                // Modified Stableford
                if (diff <= -4) return 11;  // Condor
                if (diff === -3) return 8;   // Albatross
                if (diff === -2) return 5;   // Eagle
                if (diff === -1) return 2;   // Birdie
                if (diff === 0) return 0;    // Par
                if (diff === 1) return -1;   // Bogey
                return -3;                    // Double bogey or worse
            } else {
                // Standard Stableford
                if (diff <= -4) return 6;    // Condor
                if (diff === -3) return 5;   // Albatross
                if (diff === -2) return 4;   // Eagle
                if (diff === -1) return 3;   // Birdie
                if (diff === 0) return 2;    // Par
                if (diff === 1) return 1;    // Bogey
                return 0;                     // Double bogey or worse
            }
        }

        function renderResultsPage() {
            // Load the correct course data
            courseData = courses[tournamentData.course];
            
            // Update smart info line
            setTimeout(() => {
                generateSmartInfoLine('resultsSmartInfo');
            }, 10);
            
            // Show/hide crown badge for host in player mode
            const resultsHostBadge = document.getElementById('resultsHostBadge');
            if (resultsHostBadge) {
                resultsHostBadge.style.display = isHostInPlayerMode() ? 'inline-block' : 'none';
            }
            
            // Show/hide manage button for hosts and co-hosts (but NOT when host is in player mode)
            const manageBtn = document.getElementById('resultsManageBtn');
            if (manageBtn) {
                manageBtn.style.display = (canManageTournament() && !isHostInPlayerMode()) ? 'flex' : 'none';
            }
            
            // Show/hide finish button (only for hosts/co-hosts, but NOT when host is in player mode)
            const finishBtn = document.getElementById('newRoundBtnTop');
            if (finishBtn) {
                finishBtn.style.display = (canManageTournament() && !isHostInPlayerMode()) ? 'flex' : 'none';
            }
            
            // Show My Players button for non-hosts/non-co-hosts OR when host is in player mode
            const myPlayersBtn = document.getElementById('resultsMyPlayersBtn');
            if (myPlayersBtn) {
                myPlayersBtn.style.display = ((!canManageTournament() || isHostInPlayerMode()) && tournamentMode === 'multi') ? 'flex' : 'none';
            }
            
            // Show/hide filter toggle (only for non-hosts/non-co-hosts in multi mode, OR host in player mode)
            const filterToggle = document.getElementById('resultsFilterToggle');
            if (filterToggle) {
                filterToggle.style.display = ((!canManageTournament() || isHostInPlayerMode()) && tournamentMode === 'multi') ? 'flex' : 'none';
            }
            
            // Set the dropdown to match current game type
            const resultsGameTypeEl = document.getElementById('resultsGameType');
            if (resultsGameTypeEl) {
                // Map old game types to new consolidated types
                let displayGameType = tournamentData.gameType;
                if (displayGameType.includes('Stroke Play')) displayGameType = 'Stroke Play';
                if (displayGameType.includes('Skins')) displayGameType = 'Skins';
                resultsGameTypeEl.value = displayGameType;
            }
            
            // Update scoring method buttons based on game type
            updateScoringMethodButtons();
            
            updateResultsDisplay();
        }

        // Current scoring method state
        let currentScoringMethod = 'gross'; // 'gross', 'net', 'net18', 'netHalf'
        let currentBestBallView = false; // Whether viewing Best Ball results
        
        // Results page Best Ball config (separate from setup page)
        let resultsBestBallConfig = null; // Will hold { playersPerTeam, scoresPerHole, format, teams }
        
        // Set scoring method
        function setScoringMethod(method) {
            currentScoringMethod = method;
            
            // Determine button color based on current mode
            const activeColor = currentResultsMode === 'sideGame' ? '#10b981' : '#3b82f6';
            
            // Update button styles
            const methods = ['gross', 'net', 'net18', 'netHalf'];
            methods.forEach(m => {
                const btn = document.getElementById(`scoringMethod${m.charAt(0).toUpperCase() + m.slice(1)}`);
                if (btn && !btn.disabled) {
                    if (m === method) {
                        btn.style.background = activeColor;
                        btn.style.borderColor = activeColor;
                        btn.style.color = 'white';
                    } else {
                        btn.style.background = 'white';
                        btn.style.borderColor = '#d1d5db';
                        btn.style.color = '#475569';
                    }
                }
            });
            
            // Update results display
            updateResultsDisplay();
        }
        
        // Update scoring method buttons based on game type
        function updateScoringMethodButtons() {
            const gameType = document.getElementById('resultsGameType')?.value || tournamentData.gameType;
            const netHalfBtn = document.getElementById('scoringMethodNetHalf');
            
            // Enable Net Â½ only for Skins
            if (netHalfBtn) {
                const isSkins = gameType === 'Skins' || gameType.includes('Skins');
                netHalfBtn.disabled = !isSkins;
                netHalfBtn.style.opacity = isSkins ? '1' : '0.5';
                netHalfBtn.style.color = isSkins ? '#475569' : '#9ca3af';
                
                // If currently on netHalf and switching away from Skins, reset to gross
                if (!isSkins && currentScoringMethod === 'netHalf') {
                    setScoringMethod('gross');
                }
            }
        }
        
        // Current results mode: 'tourney' or 'sideGame'
        let currentResultsMode = 'tourney';
        
        // Set results mode (Tourney or Side Game)
        function setResultsMode(mode) {
            currentResultsMode = mode;
            
            const tourneyBtn = document.getElementById('tourneyModeBtn');
            const sideGameBtn = document.getElementById('sideGameModeBtn');
            const gameTypeSelect = document.getElementById('resultsGameType');
            const filterRow = document.getElementById('resultsFilterRow');
            
            if (mode === 'tourney') {
                // Tourney mode - show dropdown and filter toggle
                tourneyBtn.style.background = '#3b82f6';
                tourneyBtn.style.color = 'white';
                sideGameBtn.style.background = 'transparent';
                sideGameBtn.style.color = '#64748b';
                
                if (gameTypeSelect) gameTypeSelect.style.display = '';
                if (filterRow) filterRow.style.display = 'flex';
                
                // Reset to regular view
                currentBestBallView = false;
                
                // Reset scoring method buttons to blue
                updateScoringMethodButtonColors('blue');
                
                updateResultsDisplay();
            } else {
                // Side Game mode - hide dropdown and filter toggle
                tourneyBtn.style.background = 'transparent';
                tourneyBtn.style.color = '#64748b';
                sideGameBtn.style.background = '#10b981';
                sideGameBtn.style.color = 'white';
                
                if (gameTypeSelect) gameTypeSelect.style.display = 'none';
                if (filterRow) filterRow.style.display = 'none';
                
                // Update scoring method buttons to green
                updateScoringMethodButtonColors('green');
                
                // Check if we have saved config
                const savedConfig = loadBestBallConfig();
                if (savedConfig && savedConfig.teams && savedConfig.teams.length >= 2) {
                    resultsBestBallConfig = savedConfig;
                    currentBestBallView = true;
                    updateResultsDisplay();
                } else {
                    // First time - show setup modal
                    showResultsBestBallSetup();
                }
            }
        }
        
        // Update scoring method button colors based on mode
        function updateScoringMethodButtonColors(colorScheme) {
            // Simply re-apply the current scoring method which will use the correct color
            // based on currentResultsMode
            setScoringMethod(currentScoringMethod);
        }
        
        // Toggle Best Ball view (legacy - now handled by setResultsMode)
        function toggleBestBallView() {
            if (currentBestBallView) {
                setResultsMode('tourney');
            } else {
                setResultsMode('sideGame');
            }
        }
        
        // Show Best Ball setup modal for results page
        function showResultsBestBallSetup() {
            const players = tournamentData.players || [];
            if (players.length < 2) {
                showNotification('Not Enough Players', 'Need at least 2 players for Best Ball');
                return;
            }
            
            // Load saved config if exists
            const savedConfig = loadBestBallConfig();
            const config = savedConfig || {
                playersPerTeam: 2,
                scoresPerHole: 1,
                format: 'stroke',
                teams: []
            };
            
            const modal = document.createElement('div');
            modal.id = 'bestBallSetupModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.85);
                display: flex;
                align-items: flex-start;
                justify-content: center;
                z-index: 10002;
                padding: 20px;
                overflow-y: auto;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 20px; max-width: 400px; width: 100%; margin: 20px auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h2 style="color: #1e40af; margin: 0; font-size: 18px;">â³ Best Ball Setup</h2>
                        <button onclick="closeBestBallSetup()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">â</button>
                    </div>
                    
                    <!-- Players Per Team -->
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; font-size: 13px; font-weight: 600; color: #475569; margin-bottom: 8px;">Players Per Team</label>
                        <div style="display: flex; gap: 8px;">
                            ${[1, 2, 3, 4].map(n => `
                                <button type="button" onclick="setBestBallPlayersPerTeam(${n})" id="bbPPT${n}"
                                    style="flex: 1; padding: 12px; border: 2px solid ${config.playersPerTeam === n ? '#10b981' : '#e2e8f0'}; 
                                    background: ${config.playersPerTeam === n ? '#dcfce7' : 'white'}; 
                                    color: ${config.playersPerTeam === n ? '#065f46' : '#475569'}; 
                                    border-radius: 8px; font-size: 16px; font-weight: 700; cursor: pointer;">${n}</button>
                            `).join('')}
                        </div>
                    </div>
                    
                    <!-- Scores Per Hole -->
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; font-size: 13px; font-weight: 600; color: #475569; margin-bottom: 8px;">Scores to Count Per Hole</label>
                        <div style="display: flex; gap: 8px;">
                            ${[1, 2, 3].map(n => `
                                <button type="button" onclick="setBestBallScoresPerHole(${n})" id="bbSPH${n}"
                                    style="flex: 1; padding: 12px; border: 2px solid ${config.scoresPerHole === n ? '#3b82f6' : '#e2e8f0'}; 
                                    background: ${config.scoresPerHole === n ? '#dbeafe' : 'white'}; 
                                    color: ${config.scoresPerHole === n ? '#1e40af' : '#475569'}; 
                                    border-radius: 8px; font-size: 16px; font-weight: 700; cursor: pointer;">${n}</button>
                            `).join('')}
                        </div>
                    </div>
                    
                    <!-- Format -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-size: 13px; font-weight: 600; color: #475569; margin-bottom: 8px;">Format</label>
                        <div style="display: flex; gap: 8px;">
                            <button type="button" onclick="setBestBallFormat('stroke')" id="bbFormatStroke"
                                style="flex: 1; padding: 12px; border: 2px solid ${config.format === 'stroke' ? '#f59e0b' : '#e2e8f0'}; 
                                background: ${config.format === 'stroke' ? '#fef3c7' : 'white'}; 
                                color: ${config.format === 'stroke' ? '#92400e' : '#475569'}; 
                                border-radius: 8px; font-size: 14px; font-weight: 700; cursor: pointer;">Stroke Play</button>
                            <button type="button" onclick="setBestBallFormat('match')" id="bbFormatMatch"
                                style="flex: 1; padding: 12px; border: 2px solid ${config.format === 'match' ? '#8b5cf6' : '#e2e8f0'}; 
                                background: ${config.format === 'match' ? '#ede9fe' : 'white'}; 
                                color: ${config.format === 'match' ? '#5b21b6' : '#475569'}; 
                                border-radius: 8px; font-size: 14px; font-weight: 700; cursor: pointer;">Match Play</button>
                        </div>
                    </div>
                    
                    <!-- Team Assignment Section -->
                    <div style="border-top: 2px solid #e2e8f0; padding-top: 16px; margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <label style="font-size: 14px; font-weight: 700; color: #1e40af;">Assign Teams</label>
                            <button type="button" onclick="addBestBallTeam()" style="padding: 6px 12px; background: #10b981; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">+ Add Team</button>
                        </div>
                        <div id="bestBallTeamsContainer">
                            <!-- Teams will be rendered here -->
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button type="button" onclick="saveBestBallAndShowResults()" style="padding: 14px; background: #10b981; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            â View Results
                        </button>
                        <button type="button" onclick="clearBestBallTeams()" style="padding: 12px; background: #fee2e2; color: #dc2626; border: none; border-radius: 10px; font-size: 14px; font-weight: 600; cursor: pointer;">
                            ðï¸ Clear Teams
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Store temp config for editing
            window.tempBestBallConfig = { ...config, teams: [...(config.teams || [])] };
            
            // Render existing teams or add default ones
            if (window.tempBestBallConfig.teams.length === 0) {
                // Auto-create teams based on player count
                autoCreateBestBallTeams();
            } else {
                renderBestBallTeams();
            }
        }
        
        // Load saved Best Ball config from localStorage
        function loadBestBallConfig() {
            const key = activeTournamentId ? `bestBall_${activeTournamentId}` : 'bestBall_local';
            const saved = localStorage.getItem(key);
            return saved ? JSON.parse(saved) : null;
        }
        
        // Save Best Ball config to localStorage
        function saveBestBallConfig(config) {
            const key = activeTournamentId ? `bestBall_${activeTournamentId}` : 'bestBall_local';
            localStorage.setItem(key, JSON.stringify(config));
        }
        
        // Close Best Ball setup modal
        function closeBestBallSetup() {
            document.getElementById('bestBallSetupModal')?.remove();
            window.tempBestBallConfig = null;
        }
        
        // Set players per team
        function setBestBallPlayersPerTeam(n) {
            if (!window.tempBestBallConfig) return;
            window.tempBestBallConfig.playersPerTeam = n;
            
            // Update button styles
            [1, 2, 3, 4].forEach(num => {
                const btn = document.getElementById(`bbPPT${num}`);
                if (btn) {
                    btn.style.borderColor = num === n ? '#10b981' : '#e2e8f0';
                    btn.style.background = num === n ? '#dcfce7' : 'white';
                    btn.style.color = num === n ? '#065f46' : '#475569';
                }
            });
            
            // Re-render teams to adjust player count per team
            renderBestBallTeams();
        }
        
        // Set scores per hole
        function setBestBallScoresPerHole(n) {
            if (!window.tempBestBallConfig) return;
            window.tempBestBallConfig.scoresPerHole = n;
            
            [1, 2, 3].forEach(num => {
                const btn = document.getElementById(`bbSPH${num}`);
                if (btn) {
                    btn.style.borderColor = num === n ? '#3b82f6' : '#e2e8f0';
                    btn.style.background = num === n ? '#dbeafe' : 'white';
                    btn.style.color = num === n ? '#1e40af' : '#475569';
                }
            });
        }
        
        // Set format (stroke/match)
        function setBestBallFormat(format) {
            if (!window.tempBestBallConfig) return;
            window.tempBestBallConfig.format = format;
            
            const strokeBtn = document.getElementById('bbFormatStroke');
            const matchBtn = document.getElementById('bbFormatMatch');
            
            if (strokeBtn) {
                strokeBtn.style.borderColor = format === 'stroke' ? '#f59e0b' : '#e2e8f0';
                strokeBtn.style.background = format === 'stroke' ? '#fef3c7' : 'white';
                strokeBtn.style.color = format === 'stroke' ? '#92400e' : '#475569';
            }
            if (matchBtn) {
                matchBtn.style.borderColor = format === 'match' ? '#8b5cf6' : '#e2e8f0';
                matchBtn.style.background = format === 'match' ? '#ede9fe' : 'white';
                matchBtn.style.color = format === 'match' ? '#5b21b6' : '#475569';
            }
        }
        
        // Auto-create teams based on number of players
        function autoCreateBestBallTeams() {
            if (!window.tempBestBallConfig) return;
            const players = tournamentData.players || [];
            const ppt = window.tempBestBallConfig.playersPerTeam;
            const numTeams = Math.floor(players.length / ppt);
            
            window.tempBestBallConfig.teams = [];
            for (let i = 0; i < numTeams; i++) {
                const team = [];
                for (let j = 0; j < ppt; j++) {
                    const playerIndex = i * ppt + j;
                    if (playerIndex < players.length) {
                        team.push(players[playerIndex].name);
                    }
                }
                window.tempBestBallConfig.teams.push(team);
            }
            
            renderBestBallTeams();
        }
        
        // Add a new team
        function addBestBallTeam() {
            if (!window.tempBestBallConfig) return;
            const ppt = window.tempBestBallConfig.playersPerTeam;
            const newTeam = Array(ppt).fill('');
            window.tempBestBallConfig.teams.push(newTeam);
            renderBestBallTeams();
        }
        
        // Remove a team
        function removeBestBallTeam(teamIndex) {
            if (!window.tempBestBallConfig) return;
            window.tempBestBallConfig.teams.splice(teamIndex, 1);
            renderBestBallTeams();
        }
        
        // Update a player in a team
        function updateBestBallTeamPlayer(teamIndex, playerSlot, playerName) {
            if (!window.tempBestBallConfig) return;
            window.tempBestBallConfig.teams[teamIndex][playerSlot] = playerName;
        }
        
        // Render teams in the modal
        function renderBestBallTeams() {
            const container = document.getElementById('bestBallTeamsContainer');
            if (!container || !window.tempBestBallConfig) return;
            
            const teams = window.tempBestBallConfig.teams;
            const ppt = window.tempBestBallConfig.playersPerTeam;
            const players = tournamentData.players || [];
            
            // Get list of already assigned players
            const assignedPlayers = new Set();
            teams.forEach(team => {
                team.forEach(name => {
                    if (name) assignedPlayers.add(name);
                });
            });
            
            container.innerHTML = teams.map((team, teamIdx) => {
                // Build player dropdown options
                const playerOptions = players.map(p => {
                    const isAssigned = assignedPlayers.has(p.name);
                    const isInThisTeam = team.includes(p.name);
                    return `<option value="${p.name}" ${isAssigned && !isInThisTeam ? 'disabled style="color: #9ca3af;"' : ''}>${p.name}${isAssigned && !isInThisTeam ? ' (assigned)' : ''}</option>`;
                }).join('');
                
                // Build player slots
                const slots = [];
                for (let i = 0; i < ppt; i++) {
                    const selectedPlayer = team[i] || '';
                    slots.push(`
                        <select onchange="updateBestBallTeamPlayer(${teamIdx}, ${i}, this.value)" 
                            style="flex: 1; padding: 8px; border: 1.5px solid #d1d5db; border-radius: 6px; font-size: 13px; min-width: 0;">
                            <option value="">Select Player</option>
                            ${playerOptions.replace(`value="${selectedPlayer}"`, `value="${selectedPlayer}" selected`)}
                        </select>
                    `);
                }
                
                return `
                    <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 10px; padding: 12px; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-size: 13px; font-weight: 700; color: #1e40af;">Team ${teamIdx + 1}</span>
                            <button type="button" onclick="removeBestBallTeam(${teamIdx})" style="background: none; border: none; color: #ef4444; font-size: 16px; cursor: pointer; padding: 4px;">â</button>
                        </div>
                        <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                            ${slots.join('')}
                        </div>
                    </div>
                `;
            }).join('');
            
            if (teams.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 16px; color: #64748b; font-size: 13px;">No teams created yet. Click "+ Add Team" to start.</div>';
            }
        }
        
        // Save config and show results
        function saveBestBallAndShowResults() {
            if (!window.tempBestBallConfig) return;
            
            // Validate teams have at least some players
            const validTeams = window.tempBestBallConfig.teams.filter(team => 
                team.some(name => name && name.trim() !== '')
            );
            
            if (validTeams.length < 2) {
                showNotification('Need More Teams', 'Create at least 2 teams with players');
                return;
            }
            
            // Save config
            resultsBestBallConfig = { ...window.tempBestBallConfig, teams: validTeams };
            saveBestBallConfig(resultsBestBallConfig);
            
            // Close modal and show results
            closeBestBallSetup();
            currentBestBallView = true;
            currentResultsMode = 'sideGame';
            
            // Update toggle buttons
            const tourneyBtn = document.getElementById('tourneyModeBtn');
            const sideGameBtn = document.getElementById('sideGameModeBtn');
            if (tourneyBtn && sideGameBtn) {
                tourneyBtn.style.background = 'transparent';
                tourneyBtn.style.color = '#64748b';
                sideGameBtn.style.background = '#10b981';
                sideGameBtn.style.color = 'white';
            }
            
            // Update scoring method button color
            setScoringMethod(currentScoringMethod);
            
            updateResultsDisplay();
        }
        
        // Clear teams and close
        function clearBestBallTeams() {
            resultsBestBallConfig = null;
            const key = activeTournamentId ? `bestBall_${activeTournamentId}` : 'bestBall_local';
            localStorage.removeItem(key);
            
            currentBestBallView = false;
            
            // Switch back to tourney mode
            setResultsMode('tourney');
            
            closeBestBallSetup();
            showNotification('Cleared', 'Best Ball teams cleared');
        }
        
        // Edit existing Best Ball teams
        function editBestBallTeams() {
            showResultsBestBallSetup();
        }
        
        // Render Best Ball results
        function renderBestBallResults(container, config) {
            const { playersPerTeam, scoresPerHole, format, teams } = config;
            const players = tournamentData.players || [];
            const isNet = currentScoringMethod !== 'gross';
            const netMethod = currentScoringMethod === 'net' ? 'full' : 
                             currentScoringMethod === 'net18' ? '18max' : 
                             currentScoringMethod === 'netHalf' ? 'half' : 'full';
            
            // Build label
            let formatLabel = format === 'match' ? 'Match Play' : 'Stroke Play';
            let scoringLabel = isNet ? (currentScoringMethod === 'net18' ? 'Net (18 Max)' : 'Net') : 'Gross';
            let teamLabel = `${playersPerTeam}-Player, ${scoresPerHole} Best`;
            
            container.innerHTML = `
                <div style="text-align: center; margin-bottom: 12px;">
                    <span style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 4px 12px; border-radius: 12px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">
                        Best Ball ${formatLabel} (${scoringLabel})
                    </span>
                    <div style="font-size: 11px; color: #64748b; margin-top: 4px;">${teamLabel}</div>
                </div>
            `;
            
            // Calculate team scores
            const teamResults = teams.map((team, teamIdx) => {
                // Get player objects for this team
                const teamPlayers = team.map(name => players.find(p => p.name === name)).filter(p => p);
                
                if (teamPlayers.length === 0) {
                    return { teamIdx, teamName: `Team ${teamIdx + 1}`, players: team, total: 0, holeScores: [], holesWon: 0, holesLost: 0, status: 'AS' };
                }
                
                // Calculate best ball score for each hole
                const holeScores = [];
                let total = 0;
                
                for (let holeIdx = 0; holeIdx < 18; holeIdx++) {
                    const holeData = courseData.holes[holeIdx];
                    const playerScores = teamPlayers.map(p => {
                        const gross = p.scores[holeIdx] || 0;
                        if (gross === 0) return 999;
                        
                        if (isNet) {
                            return getNetScore(gross, p.handicap, holeData.handicap, netMethod);
                        }
                        return gross;
                    }).filter(s => s < 999).sort((a, b) => a - b);
                    
                    // Take the best N scores for this hole
                    const bestScores = playerScores.slice(0, scoresPerHole);
                    const holeTotal = bestScores.reduce((sum, s) => sum + s, 0);
                    
                    holeScores.push({
                        scores: bestScores,
                        total: holeTotal,
                        par: holeData.par * scoresPerHole
                    });
                    
                    if (bestScores.length > 0) {
                        total += holeTotal;
                    }
                }
                
                return {
                    teamIdx,
                    teamName: `Team ${teamIdx + 1}`,
                    players: team.filter(n => n),
                    total,
                    holeScores,
                    holesWon: 0,
                    holesLost: 0,
                    status: 'AS'
                };
            });
            
            // Match Play: Calculate holes won/lost between teams
            if (format === 'match' && teamResults.length >= 2) {
                renderMatchPlayResults(container, teamResults);
            } else {
                // Stroke Play: Sort by total and display
                renderStrokePlayBestBallResults(container, teamResults);
            }
            
            // Add Edit Teams button
            container.innerHTML += `
                <div style="margin-top: 16px; display: flex; gap: 8px;">
                    <button type="button" onclick="editBestBallTeams()" style="flex: 1; padding: 10px; background: #f1f5f9; color: #475569; border: 1px solid #e2e8f0; border-radius: 8px; font-size: 13px; font-weight: 600; cursor: pointer;">
                        âï¸ Edit Teams
                    </button>
                    <button type="button" onclick="clearBestBallTeams()" style="flex: 1; padding: 10px; background: #fee2e2; color: #dc2626; border: none; border-radius: 8px; font-size: 13px; font-weight: 600; cursor: pointer;">
                        ðï¸ Clear
                    </button>
                </div>
            `;
        }
        
        // Render Stroke Play Best Ball results
        function renderStrokePlayBestBallResults(container, teamResults) {
            // Sort by total (lowest first)
            const sortedTeams = [...teamResults].filter(t => t.total > 0).sort((a, b) => a.total - b.total);
            
            // Calculate total par for scoring type
            const scoresPerHole = resultsBestBallConfig?.scoresPerHole || 1;
            const totalPar = courseData.totalPar * scoresPerHole;
            
            sortedTeams.forEach((team, position) => {
                const medal = position === 0 ? 'ð' : position === 1 ? 'ð¥' : position === 2 ? 'ð¥' : `${position + 1}.`;
                const toPar = team.total - totalPar;
                const toParText = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : `${toPar}`);
                
                const div = document.createElement('div');
                div.style.cssText = 'background: #f8fafc; border-radius: 12px; padding: 14px; margin-bottom: 10px; animation: fadeIn 0.3s ease-out;';
                
                div.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: space-between;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: ${position < 3 ? '24px' : '16px'}; ${position >= 3 ? 'color: #64748b; font-weight: 700;' : ''}">${medal}</span>
                            <div>
                                <div style="font-weight: 700; color: #1e40af; font-size: 15px;">${team.teamName}</div>
                                <div style="font-size: 11px; color: #64748b;">${team.players.join(' & ')}</div>
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 20px; font-weight: 800; color: #1e293b;">${team.total}</div>
                            <div style="font-size: 12px; color: ${toPar < 0 ? '#10b981' : toPar > 0 ? '#ef4444' : '#64748b'};">${toParText}</div>
                        </div>
                    </div>
                `;
                
                container.appendChild(div);
            });
            
            if (sortedTeams.length === 0) {
                container.innerHTML += '<div style="text-align: center; padding: 24px; color: #64748b;">No scores yet</div>';
            }
        }
        
        // Render Match Play results
        function renderMatchPlayResults(container, teamResults) {
            // For match play, we compare teams head to head on each hole
            // If more than 2 teams, we'll show all matchups
            
            if (teamResults.length === 2) {
                // Single match
                renderSingleMatchPlay(container, teamResults[0], teamResults[1]);
            } else {
                // Multiple teams - show round robin or bracket style
                container.innerHTML += `
                    <div style="font-size: 12px; color: #64748b; font-weight: 600; margin-bottom: 10px; text-transform: uppercase;">Team Matchups</div>
                `;
                
                // Show each pair
                for (let i = 0; i < teamResults.length; i++) {
                    for (let j = i + 1; j < teamResults.length; j++) {
                        renderSingleMatchPlay(container, teamResults[i], teamResults[j], true);
                    }
                }
            }
        }
        
        // Render a single match play matchup between two teams
        function renderSingleMatchPlay(container, team1, team2, compact = false) {
            // Calculate match play result
            let team1Up = 0;
            let holesPlayed = 0;
            let team1Wins = 0, team2Wins = 0, halved = 0;
            
            for (let holeIdx = 0; holeIdx < 18; holeIdx++) {
                const score1 = team1.holeScores[holeIdx];
                const score2 = team2.holeScores[holeIdx];
                
                // Only count holes where both teams have scores
                if (score1.scores.length > 0 && score2.scores.length > 0) {
                    holesPlayed++;
                    
                    if (score1.total < score2.total) {
                        team1Up++;
                        team1Wins++;
                    } else if (score2.total < score1.total) {
                        team1Up--;
                        team2Wins++;
                    } else {
                        halved++;
                    }
                }
            }
            
            // Determine match status
            const holesRemaining = 18 - holesPlayed;
            let status = '';
            let winner = null;
            let statusColor = '#64748b';
            
            if (holesPlayed === 0) {
                status = 'Not Started';
            } else if (Math.abs(team1Up) > holesRemaining) {
                // Match is over - one team can't catch up
                winner = team1Up > 0 ? team1 : team2;
                const margin = Math.abs(team1Up);
                status = `${margin}&${holesRemaining}`;
                statusColor = '#10b981';
            } else if (holesPlayed === 18) {
                // All 18 played
                if (team1Up === 0) {
                    status = 'AS';
                    statusColor = '#f59e0b';
                } else {
                    winner = team1Up > 0 ? team1 : team2;
                    status = `${Math.abs(team1Up)}UP`;
                    statusColor = '#10b981';
                }
            } else {
                // Match in progress
                if (team1Up === 0) {
                    status = 'AS';
                    statusColor = '#3b82f6';
                } else {
                    const leader = team1Up > 0 ? team1 : team2;
                    status = `${Math.abs(team1Up)}UP`;
                    statusColor = '#3b82f6';
                }
            }
            
            // Build the display
            const matchDiv = document.createElement('div');
            matchDiv.style.cssText = `background: linear-gradient(135deg, #ede9fe 0%, #ddd6fe 100%); border: 2px solid #8b5cf6; border-radius: 12px; padding: ${compact ? '12px' : '16px'}; margin-bottom: ${compact ? '10px' : '12px'};`;
            
            if (compact) {
                // Compact view for multiple matchups
                const leader = team1Up > 0 ? team1 : team1Up < 0 ? team2 : null;
                const loser = team1Up > 0 ? team2 : team1Up < 0 ? team1 : null;
                
                matchDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex: 1;">
                            <div style="font-weight: ${team1Up >= 0 ? '700' : '500'}; color: ${team1Up > 0 ? '#5b21b6' : '#6b7280'}; font-size: 13px;">${team1.teamName}</div>
                            <div style="font-size: 10px; color: #64748b;">${team1.players.join(', ')}</div>
                        </div>
                        <div style="padding: 6px 12px; background: ${winner ? '#10b981' : team1Up === 0 ? '#f59e0b' : '#8b5cf6'}; color: white; border-radius: 8px; font-weight: 700; font-size: 14px;">
                            ${status}
                        </div>
                        <div style="flex: 1; text-align: right;">
                            <div style="font-weight: ${team1Up <= 0 ? '700' : '500'}; color: ${team1Up < 0 ? '#5b21b6' : '#6b7280'}; font-size: 13px;">${team2.teamName}</div>
                            <div style="font-size: 10px; color: #64748b;">${team2.players.join(', ')}</div>
                        </div>
                    </div>
                `;
            } else {
                // Full view for single matchup
                matchDiv.innerHTML = `
                    <div style="text-align: center; margin-bottom: 12px;">
                        <div style="font-size: 11px; color: #7c3aed; font-weight: 600; text-transform: uppercase; margin-bottom: 4px;">Match Play</div>
                        <div style="font-size: 32px; font-weight: 800; color: ${statusColor};">${status}</div>
                        ${winner ? `<div style="font-size: 13px; color: #059669; font-weight: 600;">${winner.teamName} Wins!</div>` : ''}
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; gap: 12px;">
                        <div style="flex: 1; text-align: center; padding: 12px; background: ${team1Up > 0 ? '#dcfce7' : team1Up < 0 ? '#f8fafc' : '#fef9c3'}; border-radius: 10px;">
                            <div style="font-weight: 700; color: ${team1Up > 0 ? '#065f46' : '#1e40af'}; font-size: 15px;">${team1.teamName}</div>
                            <div style="font-size: 11px; color: #64748b; margin-top: 2px;">${team1.players.join(' & ')}</div>
                            <div style="font-size: 12px; color: #64748b; margin-top: 6px;">${team1Wins}W Â· ${halved}H</div>
                        </div>
                        
                        <div style="font-size: 16px; font-weight: 700; color: #8b5cf6;">VS</div>
                        
                        <div style="flex: 1; text-align: center; padding: 12px; background: ${team1Up < 0 ? '#dcfce7' : team1Up > 0 ? '#f8fafc' : '#fef9c3'}; border-radius: 10px;">
                            <div style="font-weight: 700; color: ${team1Up < 0 ? '#065f46' : '#1e40af'}; font-size: 15px;">${team2.teamName}</div>
                            <div style="font-size: 11px; color: #64748b; margin-top: 2px;">${team2.players.join(' & ')}</div>
                            <div style="font-size: 12px; color: #64748b; margin-top: 6px;">${team2Wins}W Â· ${halved}H</div>
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin-top: 12px; font-size: 11px; color: #64748b;">
                        ${holesPlayed} holes played Â· ${holesRemaining} remaining
                    </div>
                `;
            }
            
            container.appendChild(matchDiv);
        }

        function updateResultsGameType() {
            const newGameType = document.getElementById('resultsGameType').value;
            
            // Update scoring method buttons
            updateScoringMethodButtons();
            
            // Update results display with new game type
            updateResultsDisplay(newGameType);
        }
        
        // Refresh results data from Firebase
        async function refreshResultsData() {
            if (!activeTournamentId) {
                // Single device mode - just re-render
                updateResultsDisplay();
                showNotification('Refreshed', 'Results updated');
                return;
            }
            
            try {
                // Fetch latest from Firebase
                const tournamentRef = db.collection('tournaments').doc(activeTournamentId);
                const tournamentDoc = await tournamentRef.get();
                
                if (tournamentDoc.exists) {
                    const tournament = tournamentDoc.data();
                    updateLocalTournamentState(tournament);
                    updateResultsDisplay();
                    showNotification('Refreshed', 'Latest scores loaded');
                } else {
                    showNotification('Error', 'Tournament not found');
                }
            } catch (error) {
                console.error('Error refreshing results:', error);
                showNotification('Error', 'Failed to refresh');
            }
        }

        function updateResultsDisplay(displayGameType) {
            const baseGameType = displayGameType || document.getElementById('resultsGameType')?.value || tournamentData.gameType;
            const container = document.getElementById('resultsContent');
            
            // Handle Best Ball view separately
            if (currentBestBallView && resultsBestBallConfig) {
                renderBestBallResults(container, resultsBestBallConfig);
                return;
            }
            
            // Determine display label based on game type and scoring method
            let displayLabel = baseGameType;
            if (baseGameType === 'Stroke Play' || baseGameType === 'Footlong' || baseGameType === 'Nassau') {
                if (currentScoringMethod === 'net') displayLabel = baseGameType + ' Net';
                else if (currentScoringMethod === 'net18') displayLabel = baseGameType + ' Net (18 Max)';
                else displayLabel = baseGameType + ' Gross';
            } else if (baseGameType === 'Skins') {
                if (currentScoringMethod === 'net') displayLabel = 'Net Skins (Full Hcp)';
                else if (currentScoringMethod === 'net18') displayLabel = 'Net Skins (18 Max)';
                else if (currentScoringMethod === 'netHalf') displayLabel = 'Net Skins (1/2 Pop)';
                else displayLabel = 'Gross Skins';
            }
            
            container.innerHTML = `<div style="text-align: center; margin-bottom: 12px;">
                <span style="background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: white; padding: 4px 12px; border-radius: 12px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">${displayLabel}</span>
            </div>`;
            
            // Filter players based on currentResultsFilter
            let playersToDisplay = tournamentData.players || [];
            if (currentResultsFilter === 'mine' && tournamentMode === 'multi' && !canManageTournament()) {
                loadPlayerOrder();
                playersToDisplay = playersToDisplay.filter(p => 
                    p.claimedBy === currentDeviceId || playerOrder.watching.includes(p.name)
                );
            }
            
            // Map to internal game type for processing
            let gameType = baseGameType;
            
            // Handle Stroke Play with scoring method
            if (baseGameType === 'Stroke Play') {
                if (currentScoringMethod === 'gross') {
                    gameType = 'Stroke Play Gross';
                } else {
                    gameType = 'Stroke Play Net';
                }
            }
            
            // Handle Skins with scoring method
            if (baseGameType === 'Skins') {
                if (currentScoringMethod === 'gross') gameType = 'Gross Skins';
                else if (currentScoringMethod === 'net') gameType = 'Net Skins (Full Hcp)';
                else if (currentScoringMethod === 'net18') gameType = 'Net Skins (18 Max)';
                else if (currentScoringMethod === 'netHalf') gameType = 'Net Skins (1/2 Pop)';
            }
            
            // Get net method for calculations
            const netMethod = currentScoringMethod === 'net' ? 'full' : 
                             currentScoringMethod === 'net18' ? '18max' : 
                             currentScoringMethod === 'netHalf' ? 'half' : 'full';

            // Stroke Play Gross
            if (gameType === 'Stroke Play Gross') {
                renderStrokePlayResults(container, playersToDisplay, 'gross');
            }

            // Stroke Play Net
            else if (gameType === 'Stroke Play Net') {
                renderStrokePlayResults(container, playersToDisplay, netMethod);
            }
            
            // Footlong - Front 9 and Back 9 winners
            else if (baseGameType === 'Footlong') {
                renderFootlongResults(container, playersToDisplay, currentScoringMethod === 'gross' ? 'gross' : netMethod);
            }
            
            // Nassau - Front 9, Back 9, and Overall winners
            else if (baseGameType === 'Nassau') {
                renderNassauResults(container, playersToDisplay, currentScoringMethod === 'gross' ? 'gross' : netMethod);
            }

            // Skins Games
            else if (gameType.includes('Skins')) {
                const method = gameType === 'Gross Skins' ? 'gross' : 
                              gameType === 'Net Skins (Full Hcp)' ? 'full' :
                              gameType === 'Net Skins (18 Max)' ? '18max' : 'half';
                
                renderSkinsResults(container, playersToDisplay, method);
            }

            // Stableford
            else if (gameType === 'Stableford') {
                renderStablefordResults(container, playersToDisplay, false, currentScoringMethod === 'gross' ? 'gross' : netMethod);
            }

            // Stableford (Modified)
            else if (gameType === 'Stableford (Modified)') {
                renderStablefordResults(container, playersToDisplay, true, currentScoringMethod === 'gross' ? 'gross' : netMethod);
            }

            // Best Ball Games - for now just show message
            else if (gameType === 'Best Ball' || gameType.includes('Best Ball')) {
                container.innerHTML += '<div style="text-align: center; padding: 24px; color: #64748b;">Best Ball results - use the Best Ball button below to configure teams</div>';
            }
        }
        
        // Render Stroke Play results
        function renderStrokePlayResults(container, players, method) {
            const isNet = method !== 'gross';
            
            const results = players.map((player, idx) => {
                let total = 0;
                player.scores.forEach((score, holeIdx) => {
                    if (score > 0) {
                        if (isNet) {
                            total += getNetScore(score, player.handicap, courseData.holes[holeIdx].handicap, method);
                        } else {
                            total += score;
                        }
                    }
                });
                const toPar = total - courseData.totalPar;
                return { player, total, toPar, index: idx };
            }).filter(r => r.total > 0);

            // Sort by total, then by tiebreaker on hardest holes
            results.sort((a, b) => {
                if (a.total !== b.total) return a.total - b.total;
                
                for (let hcp = 1; hcp <= 18; hcp++) {
                    const holeIdx = courseData.holes.findIndex(h => h.handicap === hcp);
                    let scoreA = a.player.scores[holeIdx] || 0;
                    let scoreB = b.player.scores[holeIdx] || 0;
                    if (isNet) {
                        scoreA = getNetScore(scoreA, a.player.handicap, hcp, method);
                        scoreB = getNetScore(scoreB, b.player.handicap, hcp, method);
                    }
                    if (scoreA !== scoreB) return scoreA - scoreB;
                }
                return 0;
            });

            results.forEach((r, position) => {
                const medal = position === 0 ? 'ð¥' : position === 1 ? 'ð¥' : position === 2 ? 'ð¥' : `${position + 1}.`;
                const toParText = r.toPar === 0 ? 'E' : (r.toPar > 0 ? `+${r.toPar}` : `${r.toPar}`);
                container.appendChild(createPlayerResultCard(medal, r.player.name, r.total, toParText, r.player.handicap, isNet ? 'Net' : 'Gross'));
            });
        }
        
        // Render Footlong results (Front 9 + Back 9 winners)
        function renderFootlongResults(container, players, method) {
            const isNet = method !== 'gross';
            
            // Calculate front 9 and back 9 totals
            const results = players.map((player, idx) => {
                let front9 = 0, back9 = 0;
                
                player.scores.forEach((score, holeIdx) => {
                    if (score > 0) {
                        const netScore = isNet ? 
                            getNetScore(score, player.handicap, courseData.holes[holeIdx].handicap, method) : score;
                        
                        if (holeIdx < 9) front9 += netScore;
                        else back9 += netScore;
                    }
                });
                
                return { player, front9, back9, index: idx };
            });
            
            // Front 9 Winner
            const front9Results = results.filter(r => r.front9 > 0).sort((a, b) => {
                if (a.front9 !== b.front9) return a.front9 - b.front9;
                return footlongTiebreaker(a, b, 0, 8, isNet, method); // Holes 0-8 (front 9)
            });
            
            // Back 9 Winner  
            const back9Results = results.filter(r => r.back9 > 0).sort((a, b) => {
                if (a.back9 !== b.back9) return a.back9 - b.back9;
                return footlongTiebreaker(a, b, 9, 17, isNet, method); // Holes 9-17 (back 9)
            });
            
            // Front 9 par
            const front9Par = courseData.holes.slice(0, 9).reduce((sum, h) => sum + h.par, 0);
            const back9Par = courseData.holes.slice(9, 18).reduce((sum, h) => sum + h.par, 0);
            
            // Display Front 9 Winner
            container.innerHTML += `
                <div style="background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%); border: 2px solid #10b981; border-radius: 12px; padding: 16px; margin-bottom: 12px;">
                    <div style="font-size: 13px; color: #065f46; font-weight: 700; margin-bottom: 8px; text-transform: uppercase;">ð Front 9 (OUT) Winner</div>
                    ${front9Results.length > 0 ? `
                        <div style="font-size: 20px; font-weight: 800; color: #065f46;">${front9Results[0].player.name}</div>
                        <div style="font-size: 14px; color: #047857;">${front9Results[0].front9} (${front9Results[0].front9 - front9Par >= 0 ? '+' : ''}${front9Results[0].front9 - front9Par})</div>
                    ` : '<div style="color: #6b7280;">No scores yet</div>'}
                </div>
            `;
            
            // Display Back 9 Winner
            container.innerHTML += `
                <div style="background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%); border: 2px solid #3b82f6; border-radius: 12px; padding: 16px; margin-bottom: 12px;">
                    <div style="font-size: 13px; color: #1e40af; font-weight: 700; margin-bottom: 8px; text-transform: uppercase;">ð Back 9 (IN) Winner</div>
                    ${back9Results.length > 0 ? `
                        <div style="font-size: 20px; font-weight: 800; color: #1e40af;">${back9Results[0].player.name}</div>
                        <div style="font-size: 14px; color: #2563eb;">${back9Results[0].back9} (${back9Results[0].back9 - back9Par >= 0 ? '+' : ''}${back9Results[0].back9 - back9Par})</div>
                    ` : '<div style="color: #6b7280;">No scores yet</div>'}
                </div>
            `;
            
            // Show all players breakdown
            container.innerHTML += `<div style="font-size: 12px; color: #64748b; font-weight: 600; margin: 16px 0 8px 0; text-transform: uppercase;">All Players</div>`;
            
            results.filter(r => r.front9 > 0 || r.back9 > 0).forEach(r => {
                const div = document.createElement('div');
                div.style.cssText = 'display: flex; justify-content: space-between; padding: 10px 12px; background: #f8fafc; border-radius: 8px; margin-bottom: 6px;';
                div.innerHTML = `
                    <span style="font-weight: 600; color: #1e293b;">${r.player.name}</span>
                    <span style="color: #64748b;">OUT: <strong>${r.front9 || '-'}</strong> | IN: <strong>${r.back9 || '-'}</strong></span>
                `;
                container.appendChild(div);
            });
        }
        
        // Footlong tiebreaker - compare hardest holes within the 9
        function footlongTiebreaker(a, b, startHole, endHole, isNet, method) {
            // Get holes in this range sorted by handicap (hardest first)
            const holesInRange = courseData.holes
                .map((h, idx) => ({ ...h, idx }))
                .filter(h => h.idx >= startHole && h.idx <= endHole)
                .sort((x, y) => x.handicap - y.handicap);
            
            for (const hole of holesInRange) {
                let scoreA = a.player.scores[hole.idx] || 0;
                let scoreB = b.player.scores[hole.idx] || 0;
                
                if (isNet) {
                    scoreA = scoreA > 0 ? getNetScore(scoreA, a.player.handicap, hole.handicap, method) : 0;
                    scoreB = scoreB > 0 ? getNetScore(scoreB, b.player.handicap, hole.handicap, method) : 0;
                }
                
                if (scoreA !== scoreB && scoreA > 0 && scoreB > 0) {
                    return scoreA - scoreB;
                }
            }
            return 0;
        }
        
        // Render Nassau results (Front 9 + Back 9 + Overall winners)
        function renderNassauResults(container, players, method) {
            const isNet = method !== 'gross';
            
            // Calculate totals
            const results = players.map((player, idx) => {
                let front9 = 0, back9 = 0, total = 0;
                
                player.scores.forEach((score, holeIdx) => {
                    if (score > 0) {
                        const netScore = isNet ? 
                            getNetScore(score, player.handicap, courseData.holes[holeIdx].handicap, method) : score;
                        
                        if (holeIdx < 9) front9 += netScore;
                        else back9 += netScore;
                        total += netScore;
                    }
                });
                
                return { player, front9, back9, total, index: idx };
            });
            
            // Sort for each category
            const front9Results = results.filter(r => r.front9 > 0).sort((a, b) => {
                if (a.front9 !== b.front9) return a.front9 - b.front9;
                return footlongTiebreaker(a, b, 0, 8, isNet, method);
            });
            
            const back9Results = results.filter(r => r.back9 > 0).sort((a, b) => {
                if (a.back9 !== b.back9) return a.back9 - b.back9;
                return footlongTiebreaker(a, b, 9, 17, isNet, method);
            });
            
            const overallResults = results.filter(r => r.total > 0).sort((a, b) => {
                if (a.total !== b.total) return a.total - b.total;
                // Overall tiebreaker: all 18 holes by handicap
                for (let hcp = 1; hcp <= 18; hcp++) {
                    const holeIdx = courseData.holes.findIndex(h => h.handicap === hcp);
                    let scoreA = a.player.scores[holeIdx] || 0;
                    let scoreB = b.player.scores[holeIdx] || 0;
                    if (isNet) {
                        scoreA = scoreA > 0 ? getNetScore(scoreA, a.player.handicap, hcp, method) : 0;
                        scoreB = scoreB > 0 ? getNetScore(scoreB, b.player.handicap, hcp, method) : 0;
                    }
                    if (scoreA !== scoreB && scoreA > 0 && scoreB > 0) return scoreA - scoreB;
                }
                return 0;
            });
            
            const front9Par = courseData.holes.slice(0, 9).reduce((sum, h) => sum + h.par, 0);
            const back9Par = courseData.holes.slice(9, 18).reduce((sum, h) => sum + h.par, 0);
            
            // Display winners
            container.innerHTML += `
                <div style="background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%); border: 2px solid #10b981; border-radius: 12px; padding: 14px; margin-bottom: 10px;">
                    <div style="font-size: 12px; color: #065f46; font-weight: 700; margin-bottom: 6px; text-transform: uppercase;">ð Front 9</div>
                    ${front9Results.length > 0 ? `
                        <div style="font-size: 18px; font-weight: 800; color: #065f46;">${front9Results[0].player.name} <span style="font-size: 14px; font-weight: 600;">(${front9Results[0].front9})</span></div>
                    ` : '<div style="color: #6b7280;">-</div>'}
                </div>
                
                <div style="background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%); border: 2px solid #3b82f6; border-radius: 12px; padding: 14px; margin-bottom: 10px;">
                    <div style="font-size: 12px; color: #1e40af; font-weight: 700; margin-bottom: 6px; text-transform: uppercase;">ð Back 9</div>
                    ${back9Results.length > 0 ? `
                        <div style="font-size: 18px; font-weight: 800; color: #1e40af;">${back9Results[0].player.name} <span style="font-size: 14px; font-weight: 600;">(${back9Results[0].back9})</span></div>
                    ` : '<div style="color: #6b7280;">-</div>'}
                </div>
                
                <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border: 2px solid #f59e0b; border-radius: 12px; padding: 14px; margin-bottom: 10px;">
                    <div style="font-size: 12px; color: #92400e; font-weight: 700; margin-bottom: 6px; text-transform: uppercase;">ð Overall 18</div>
                    ${overallResults.length > 0 ? `
                        <div style="font-size: 18px; font-weight: 800; color: #92400e;">${overallResults[0].player.name} <span style="font-size: 14px; font-weight: 600;">(${overallResults[0].total})</span></div>
                    ` : '<div style="color: #6b7280;">-</div>'}
                </div>
            `;
            
            // All players breakdown
            container.innerHTML += `<div style="font-size: 12px; color: #64748b; font-weight: 600; margin: 12px 0 8px 0; text-transform: uppercase;">All Players</div>`;
            
            results.filter(r => r.total > 0).sort((a, b) => a.total - b.total).forEach(r => {
                const div = document.createElement('div');
                div.style.cssText = 'display: flex; justify-content: space-between; padding: 10px 12px; background: #f8fafc; border-radius: 8px; margin-bottom: 6px; font-size: 13px;';
                div.innerHTML = `
                    <span style="font-weight: 600; color: #1e293b;">${r.player.name}</span>
                    <span style="color: #64748b;">OUT: <strong>${r.front9 || '-'}</strong> | IN: <strong>${r.back9 || '-'}</strong> | TOT: <strong>${r.total || '-'}</strong></span>
                `;
                container.appendChild(div);
            });
        }
        
        // Render Skins results
        function renderSkinsResults(container, players, method) {
            const useHalf = method === 'half';
            const skinWinners = {};
            const skinDetails = {}; // Now stores {hole: number, score: number}[]
            
            players.forEach((p, idx) => {
                skinWinners[idx] = 0;
                skinDetails[idx] = [];
            });
            
            for (let holeIdx = 0; holeIdx < 18; holeIdx++) {
                const holeScores = players.map((player, pIdx) => {
                    const gross = player.scores[holeIdx];
                    if (!gross || gross === 0) return { pIdx, score: 999, gross: 0 };
                    
                    let score;
                    if (method === 'gross') {
                        score = gross;
                    } else {
                        score = getNetScore(gross, player.handicap, courseData.holes[holeIdx].handicap, method);
                        // For half method, don't round - keep as decimal
                    }
                    return { pIdx, score, gross };
                }).filter(s => s.score < 999);
                
                if (holeScores.length === 0) continue;
                
                const minScore = Math.min(...holeScores.map(s => s.score));
                const winners = holeScores.filter(s => s.score === minScore);
                
                if (winners.length === 1) {
                    skinWinners[winners[0].pIdx]++;
                    // Store hole number AND winning score
                    skinDetails[winners[0].pIdx].push({
                        hole: holeIdx + 1,
                        score: winners[0].score
                    });
                }
            }
            
            // Sort by skins won
            const results = Object.entries(skinWinners)
                .map(([idx, skins]) => ({ 
                    player: players[parseInt(idx)], 
                    skins, 
                    holes: skinDetails[parseInt(idx)] 
                }))
                .filter(r => r.skins > 0)
                .sort((a, b) => b.skins - a.skins);
            
            if (results.length === 0) {
                container.innerHTML += '<div style="text-align: center; padding: 24px; color: #64748b;">No skins won yet</div>';
                return;
            }
            
            results.forEach((r, position) => {
                const medal = position === 0 ? 'ð¥' : position === 1 ? 'ð¥' : position === 2 ? 'ð¥' : `${position + 1}.`;
                // Format holes with scores: "Holes: 1(4), 2(3)" - holes/numbers blue, scores gray
                let holesText = '';
                if (r.holes.length > 0) {
                    const holesList = r.holes.map(h => 
                        `<span style="color: #3b82f6; font-weight: 600;">${h.hole}</span><span style="color: #6b7280;">(${h.score})</span>`
                    ).join('<span style="color: #3b82f6;">, </span>');
                    holesText = `<span style="color: #3b82f6; font-weight: 600;">Holes: </span>${holesList}`;
                }
                
                const div = document.createElement('div');
                div.className = 'results-player card-shadow';
                div.style.animation = 'fadeIn 0.3s ease-out';
                
                let rankHtml = medal === 'ð¥' ? '<span style="font-size: 28px; margin-right: 10px;">ð</span>' :
                              medal === 'ð¥' ? '<span style="font-size: 24px; margin-right: 10px;">ð¥</span>' :
                              medal === 'ð¥' ? '<span style="font-size: 22px; margin-right: 10px;">ð¥</span>' :
                              `<span style="font-weight: 700; font-size: 16px; color: #64748b; margin-right: 10px;">${medal}</span>`;
                
                div.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px 14px;">
                        <div style="display: flex; align-items: center; flex: 1; min-width: 0;">
                            ${rankHtml}
                            <div>
                                <div style="color: #1e293b; font-weight: 600; font-size: 15px;">${r.player.name}</div>
                                <div style="font-size: 11px;">${holesText}</div>
                            </div>
                        </div>
                        <div style="font-size: 22px; font-weight: 700; color: #10b981;">${r.skins} <span style="font-size: 12px; color: #6b7280;">skin${r.skins !== 1 ? 's' : ''}</span></div>
                    </div>
                `;
                container.appendChild(div);
            });
        }
        
        // Render Stableford results
        function renderStablefordResults(container, players, isModified, method) {
            const isNet = method !== 'gross';
            
            const results = players.map((player, idx) => {
                let points = 0;
                
                player.scores.forEach((score, holeIdx) => {
                    if (score > 0) {
                        const par = courseData.holes[holeIdx].par;
                        let effectiveScore = score;
                        
                        if (isNet) {
                            effectiveScore = getNetScore(score, player.handicap, courseData.holes[holeIdx].handicap, method);
                        }
                        
                        const diff = effectiveScore - par;
                        
                        if (isModified) {
                            // Modified Stableford (PGA style)
                            if (diff <= -3) points += 8;      // Albatross or better
                            else if (diff === -2) points += 5; // Eagle
                            else if (diff === -1) points += 2; // Birdie
                            else if (diff === 0) points += 0;  // Par
                            else if (diff === 1) points -= 1;  // Bogey
                            else points -= 3;                   // Double or worse
                        } else {
                            // Standard Stableford
                            if (diff <= -3) points += 5;       // Albatross or better
                            else if (diff === -2) points += 4; // Eagle
                            else if (diff === -1) points += 3; // Birdie
                            else if (diff === 0) points += 2;  // Par
                            else if (diff === 1) points += 1;  // Bogey
                            else points += 0;                   // Double or worse
                        }
                    }
                });
                
                return { player, points, index: idx };
            }).filter(r => r.points !== 0 || players.some(p => p.scores.some(s => s > 0)));
            
            // Sort by points (highest first for Stableford)
            results.sort((a, b) => b.points - a.points);
            
            results.forEach((r, position) => {
                const medal = position === 0 ? 'ð¥' : position === 1 ? 'ð¥' : position === 2 ? 'ð¥' : `${position + 1}.`;
                container.appendChild(createPlayerResultCard(medal, r.player.name, r.points, 'pts', r.player.handicap, isNet ? 'Net' : 'Gross'));
            });
        }

        function createPlayerResultCard(medal, name, score, toPar, handicap, scoreType = 'Gross') {
            const div = document.createElement('div');
            div.className = 'results-player card-shadow';
            div.style.animation = 'fadeIn 0.3s ease-out';
            
            // Handicap display in smaller gray font
            const hcpDisplay = handicap !== 0 ? `<span style="color: #6b7280; font-size: 13px; font-weight: 500; margin-left: 6px;">(${handicap > 0 ? handicap : '+' + Math.abs(handicap)})</span>` : '';
            
            // Medal/rank display
            let rankHtml = '';
            if (medal === 'ð¥') {
                rankHtml = '<span style="font-size: 28px; margin-right: 10px;">ð</span>';
            } else if (medal === 'ð¥') {
                rankHtml = '<span style="font-size: 24px; margin-right: 10px;">ð¥</span>';
            } else if (medal === 'ð¥') {
                rankHtml = '<span style="font-size: 22px; margin-right: 10px;">ð¥</span>';
            } else {
                rankHtml = `<span style="font-weight: 700; font-size: 16px; color: #64748b; margin-right: 10px; min-width: 24px;">${medal}</span>`;
            }
            
            div.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px 14px;">
                    <div style="display: flex; align-items: center; flex: 1; min-width: 0;">
                        ${rankHtml}
                        <span style="color: #1e293b; font-weight: 600; font-size: 15px;">${name}</span>${hcpDisplay}
                    </div>
                    <div style="font-size: 18px; font-weight: 700; color: #1e293b; white-space: nowrap; margin-left: 12px;">${score}</div>
                </div>
            `;
            return div;
        }

        // New round - with custom confirmation dialog
        function confirmNewRound() {
            const modal = document.createElement('div');
            modal.id = 'newRoundConfirmModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; max-width: 340px; width: 100%; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 12px;">â ï¸</div>
                    <h2 style="color: #ef4444; margin-bottom: 8px; font-size: 20px;">End Current Round?</h2>
                    <p style="color: #64748b; margin-bottom: 20px; font-size: 14px;">
                        All current scores will be cleared. This cannot be undone.
                    </p>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button onclick="executeNewRound()" style="padding: 14px; background: #ef4444; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            â Confirm New Round
                        </button>
                        <button onclick="saveAndDismissNewRound()" style="padding: 14px; background: #3b82f6; color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            ð¾ Save Backup First
                        </button>
                        <button onclick="document.getElementById('newRoundConfirmModal').remove()" style="padding: 14px; background: #e2e8f0; color: #64748b; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function executeNewRound() {
            document.getElementById('newRoundConfirmModal')?.remove();
            newRound();
        }
        
        function saveAndDismissNewRound() {
            document.getElementById('newRoundConfirmModal')?.remove();
            saveTournamentFile();
            showNotification('Saved!', 'Backup downloaded. Tap Finish again to start new round.');
        }

        function newRound() {
            localStorage.removeItem('indianHillsScoring');
            tournamentData = { id: '', date: '', gameType: '', course: '', players: [], teams: [] };
            document.getElementById('tournamentDate').value = ''; // Clear date
            
            // Reset player list to default 1
            const playerList = document.getElementById('playerList');
            playerList.innerHTML = `
                <div class="player-row" data-player="1">
                    <input type="text" class="player-name-input" placeholder="Player Name" id="player1">
                    <input type="text" class="player-hcp-input" placeholder="HCP" id="hcp1" pattern="-?[0-9.]*" inputmode="decimal" oninput="updateCourseHandicap(1)">
                    <div class="course-hcp-display" id="courseHcp1" title="Course handicap for this round">-</div>
                </div>
            `;
            
            currentPlayerCount = 1;
            nextPlayerId = 2;
            document.getElementById('addPlayerBtn').disabled = false;
            document.getElementById('addPlayerBtn').textContent = '+ Add Player';
            
            // Reset course and game type selection to directives
            document.getElementById('courseSelect').value = '';
            document.getElementById('gameType').value = '';
            courseData = null;
            
            showPage('setupPage');
        }

        // Load saved data on startup
        window.addEventListener('load', () => {
            // Delay to ensure DOM and Firebase are ready
            setTimeout(() => {
                console.log('ð Window load - starting app...');
                
                // ALWAYS start at Host Home page
                // Setup page is ONLY shown when user clicks "New Tournament"
                
                const savedData = localStorage.getItem('indianHillsScoring');
                if (savedData) {
                    try {
                        const data = JSON.parse(savedData);
                        const savedTournamentId = data._activeTournamentId;
                        const savedMode = data._tournamentMode;
                        const savedIsHost = data._isHost;
                        const hasPlayers = data.players && data.players.length > 0;
                        
                        console.log('ð Saved data found:', { savedTournamentId, savedMode, savedIsHost, hasPlayers });
                        
                        // Restore state from saved data
                        if (savedTournamentId) {
                            activeTournamentId = savedTournamentId;
                            tournamentMode = savedMode || 'multi';
                            isHost = savedIsHost !== false; // Default to true unless explicitly false
                            hasJoinedTournament = true;
                            
                            // Load tournament data (exclude metadata)
                            const metadataKeys = ['_activeTournamentId', '_tournamentMode', '_isHost', '_hostForTournament', 
                                                '_hasJoinedTournament', '_hostViewMode', '_scoreTimestamps', '_deletedPlayers', '_lastSaved'];
                            const dataCopy = JSON.parse(savedData);
                            metadataKeys.forEach(key => delete dataCopy[key]);
                            tournamentData = dataCopy;
                            
                            // Restore course data
                            courseData = courses[tournamentData.course] || customCourses[tournamentData.course];
                            
                            // Subscribe to Firebase
                            setTimeout(() => subscribToTournamentUpdates(activeTournamentId), 500);
                        }
                        
                        // Check if this is a guest (not host)
                        if (savedTournamentId && savedIsHost === false && data._hasJoinedTournament) {
                            console.log('ð  Guest detected - navigating to Guest Home');
                            showGuestHomePage();
                            return;
                        }
                    } catch (e) {
                        console.error('Error parsing saved data:', e);
                    }
                }
                
                // ALWAYS go to Host Home - it handles empty state gracefully
                console.log('ð  Navigating to Host Home');
                updateHostHomePage();
                showPage('hostHomePage');
                
            }, 300);
        });

        // Prevent accidental page refresh
        // Prevent accidental page refresh/close when there's data
        window.addEventListener('beforeunload', (e) => {
            // Force save to localStorage before leaving
            if (tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                saveToLocalStorage();
            }
            
            const hasData = localStorage.getItem('indianHillsScoring');
            const hasPlayers = tournamentData && tournamentData.players && tournamentData.players.length > 0;
            
            if (hasData || hasPlayers) {
                const message = 'You have an active round in progress. Leaving will lose unsaved data.';
                e.preventDefault();
                e.returnValue = message; // For Chrome
                return message; // For other browsers
            }
        });
        
        // iOS Safari specific - save when app goes to background or tab loses focus
        // These events are more reliable on iOS than beforeunload
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                console.log('ð± Page hidden - emergency save triggered');
                if (tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                    saveToLocalStorage();
                }
            } else if (document.visibilityState === 'visible') {
                // CRITICAL FIX: Reconnect to Firebase when app wakes up
                console.log('ð± Page visible - checking Firebase connection...');
                if (tournamentMode === 'multi' && activeTournamentId) {
                    console.log('ð Resubscribing to Firebase after wake...');
                    // Small delay to let network reconnect
                    setTimeout(() => {
                        subscribToTournamentUpdates(activeTournamentId);
                        console.log('â Firebase resubscription triggered');
                    }, 500);
                }
            }
        });
        
        // Additional iOS Safari handler - pagehide is more reliable than beforeunload
        window.addEventListener('pagehide', () => {
            console.log('ð± Page hide - emergency save triggered');
            if (tournamentData && tournamentData.players && tournamentData.players.length > 0) {
                saveToLocalStorage();
            }
        });

        // Universal button handler for iOS compatibility
        // This uses event delegation on the document level
        function handleButtonClick(e) {
            let target = e.target;
            
            // Find button if clicked on emoji or text inside button
            while (target && target !== document.body) {
                if (target.tagName === 'BUTTON' && target.hasAttribute('data-action')) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const action = target.getAttribute('data-action');
                    
                    // Execute the corresponding function
                    try {
                        switch(action) {
                            case 'confirmBackToSetup':
                                confirmBackToSetup();
                                break;
                            case 'finishRound':
                                finishRound();
                                break;
                            case 'shareResults':
                                shareResults();
                                break;
                            case 'exportToCsv':
                                exportToCsv();
                                break;
                            case 'printScorecard':
                                printScorecard();
                                break;
                            case 'backToScoring':
                                backToScoring();
                                break;
                            case 'confirmNewRound':
                                confirmNewRound();
                                break;
                            default:
                        }
                    } catch (err) {
                        console.error('Error executing button action:', err);
                        alert('Button error: ' + err.message);
                    }
                    
                    return false;
                }
                target = target.parentElement;
            }
        }

        // Attach to both click and touchend for maximum compatibility
        document.addEventListener('click', handleButtonClick, true);
        document.addEventListener('touchend', handleButtonClick, true);

        // Print Scorecard Function
        // Share results as text
        function shareResults() {
            let shareText = `â³ ${courseData.name} - ${formatDateDisplay(tournamentData.date)}\n`;
            shareText += `Game: ${tournamentData.gameType}\n\n`;
            shareText += `ð FINAL RESULTS\n`;
            shareText += `${'='.repeat(40)}\n\n`;
            
            // Calculate scores for all players
            const playerResults = tournamentData.players.map(player => {
                const grossScore = player.scores.reduce((sum, s) => sum + s, 0);
                const netScore = grossScore - player.handicap;
                const toPar = grossScore - courseData.totalPar;
                return { player, grossScore, netScore, toPar };
            });
            
            // Sort by appropriate score
            const isNet = tournamentData.gameType.includes('Net');
            playerResults.sort((a, b) => {
                const aScore = isNet ? a.netScore : a.grossScore;
                const bScore = isNet ? b.netScore : b.grossScore;
                return aScore - bScore;
            });
            
            // Format results
            playerResults.forEach((r, idx) => {
                const medal = idx === 0 ? 'ð¥ ' : idx === 1 ? 'ð¥ ' : idx === 2 ? 'ð¥ ' : '';
                const score = isNet ? r.netScore : r.grossScore;
                const toParText = r.toPar === 0 ? 'E' : (r.toPar > 0 ? `+${r.toPar}` : r.toPar);
                shareText += `${medal}${r.player.name}: ${score} (${toParText})\n`;
            });
            
            shareText += `\n---\nCreated with Let's Golf by Otis Williams`;
            
            // Use Web Share API if available
            if (navigator.share) {
                navigator.share({
                    title: `${courseData.name} Results`,
                    text: shareText
                }).catch(err => {
                    copyToClipboard(shareText);
                });
            } else {
                // Fallback to copy to clipboard
                copyToClipboard(shareText);
            }
        }
        
        // Copy to clipboard helper
        function copyToClipboard(text) {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text).then(() => {
                    alert('Results copied to clipboard!');
                }).catch(() => {
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }
        
        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                alert('Results copied to clipboard!');
            } catch (err) {
                alert('Could not copy results. Please try again.');
            }
            document.body.removeChild(textarea);
        }
        
        // ===== PHASE 1: SHARING FEATURES =====
        
        // Get current page URL
        function getCurrentPageURL() {
            return window.location.origin + window.location.pathname;
        }
        
        // Copy shareable tournament link
        
        // Download tournament file (wrapper for button)
        function downloadTournamentFile() {
            if (!tournamentData || !tournamentData.players || tournamentData.players.length === 0) {
                showNotification('No Tournament', 'Start or load a tournament first to download');
                return;
            }
            downloadTournamentData();
        }
        
        // Download tournament data as JSON backup
        function downloadTournamentData() {
            if (!tournamentData.id) {
                alert('No active tournament to download');
                return;
            }
            
            const backup = {
                ...tournamentData,
                courseData: courseData,
                timestamp: new Date().toISOString(),
                version: '1.0'
            };
            
            const dataStr = JSON.stringify(backup, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const dateStr = formatDateDisplay(tournamentData.date).replace(/\//g, '-');
            const filename = `LetsGolf_${tournamentData.id}_${dateStr}.json`;
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            
            URL.revokeObjectURL(url);
            
            alert('â Tournament backup downloaded!\n\nYou can import this file later to restore the tournament.');
        }
        
        // Load tournament from URL parameter
        function loadTournamentFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const tournamentId = urlParams.get('tournament');
            
            if (tournamentId) {
                // Try to load from localStorage
                const savedData = localStorage.getItem('indianHillsScoring');
                if (savedData) {
                    const data = JSON.parse(savedData);
                    if (data.id === tournamentId) {
                        // Found matching tournament
                        alert(`ð Tournament "${tournamentId}" loaded!\n\nViewing shared tournament.`);
                        // Auto-resume if tournament exists
                        const resumeBtn = document.getElementById('resumeScoringBtn');
                        if (resumeBtn && resumeBtn.style.display !== 'none') {
                            resumeScoring();
                        }
                        return true;
                    }
                }
                
                // Tournament not found locally
                alert(`â ï¸ Tournament "${tournamentId}" not found on this device.\n\nMake sure you're on the same device where the tournament was created, or import the tournament backup file.`);
                return false;
            }
            return false;
        }
        
        // Import tournament from backup file
        function importTournamentBackup(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const backup = JSON.parse(e.target.result);
                    
                    // Validate backup structure
                    if (!backup.id || !backup.players || !backup.courseData) {
                        alert('â Invalid backup file format');
                        return;
                    }
                    
                    // Restore tournament data
                    tournamentData = {
                        id: backup.id,
                        date: backup.date,
                        gameType: backup.gameType,
                        course: backup.course,
                        players: backup.players,
                        teams: backup.teams || []
                    };
                    
                    courseData = backup.courseData;
                    
                    // Save to localStorage
                    saveToLocalStorage();
                    
                    // Show success and offer to resume
                    alert(`â Tournament imported successfully!\n\nID: ${backup.id}\nDate: ${formatDateDisplay(backup.date)}\nCourse: ${backup.courseData.name}\nPlayers: ${backup.players.length}`);
                    
                    // Reload page to show resume option
                    location.reload();
                    
                } catch (error) {
                    alert('â Error reading backup file. Please make sure it\'s a valid Let\'s Golf backup.');
                    console.error('Import error:', error);
                }
            };
            
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }
        
        // Export to CSV
        function exportToCsv() {
            const dateStr = formatDateDisplay(tournamentData.date).replace(/\//g, '-');
            const filename = `${courseData.name.replace(/\s+/g, '_')}_${dateStr}.csv`;
            
            let csv = `"Course","Game Type","Date"\n`;
            csv += `"${courseData.name}","${tournamentData.gameType}","${formatDateDisplay(tournamentData.date)}"\n\n`;
            
            // Player scores by hole
            csv += `"Player","Handicap"`;
            for (let i = 1; i <= 18; i++) {
                csv += `,"Hole ${i}"`;
            }
            csv += `,"Total","Net","To Par"\n`;
            
            tournamentData.players.forEach(player => {
                const total = player.scores.reduce((sum, s) => sum + s, 0);
                const net = total - player.handicap;
                const toPar = total - courseData.totalPar;
                const toParText = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar);
                
                csv += `"${player.name}","${player.handicap}"`;
                player.scores.forEach(score => {
                    csv += `,"${score || ''}"`;
                });
                csv += `,"${total}","${net}","${toParText}"\n`;
            });
            
            // Download CSV
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        function printScorecard() {
            // Print the current scorecard view
            window.print();
        }

        // Open scorecard modal
        function openScorecardModal() {
            const modal = document.getElementById('scorecardModal');
            const select = document.getElementById('scorecardViewSelect');
            
            // Populate individual player options
            const playerOptions = tournamentData.players
                .map((player, idx) => `<option value="player-${idx}">${player.name}</option>`)
                .join('');
            
            // Check if we're in multi-device mode (show My Players options)
            const showMyPlayersOptions = tournamentMode === 'multi';
            
            // Rebuild select to include players
            select.innerHTML = `
                <option value="all-summary">All Players - Summary Table</option>
                <option value="all-individual">All Players - Individual Cards</option>
                ${showMyPlayersOptions ? `
                    <option disabled>âââââââââââââââââ</option>
                    <option value="mine-summary">My Players - Summary Table</option>
                    <option value="mine-individual">My Players - Individual Cards</option>
                ` : ''}
                <option disabled>âââââââââââââââââ</option>
                ${playerOptions}
            `;
            
            modal.classList.add('active');
            updateScorecardView();
        }

        // Close scorecard modal
        function closeScorecardModal() {
            const modal = document.getElementById('scorecardModal');
            modal.classList.remove('active');
        }

        // Update scorecard view based on selection
        function updateScorecardView() {
            const select = document.getElementById('scorecardViewSelect');
            const body = document.getElementById('scorecardBody');
            const viewType = select.value;
            
            if (viewType === 'all-summary') {
                body.innerHTML = generateSummaryTable(false);
            } else if (viewType === 'mine-summary') {
                body.innerHTML = generateSummaryTable(true);
            } else if (viewType === 'all-individual') {
                body.innerHTML = generateAllIndividualCards(false);
            } else if (viewType === 'mine-individual') {
                body.innerHTML = generateAllIndividualCards(true);
            } else if (viewType.startsWith('player-')) {
                const playerIndex = parseInt(viewType.split('-')[1]);
                body.innerHTML = generateIndividualCard(playerIndex);
            }
        }

        // Generate summary table for all players - single scrollable table with sticky player column
        function generateSummaryTable(myPlayersOnly = false) {
            const currentGameType = document.getElementById('resultsGameType').value;
            
            // Determine handicap method based on game type
            let hcpMethod = 'full';
            if (currentGameType.includes('18 Max')) {
                hcpMethod = '18max';
            } else if (currentGameType.includes('1/2 Pop')) {
                hcpMethod = 'half';
            }
            
            // Check if this is a net or team game (team games use net scores)
            const isNetOrTeam = currentGameType.includes('Net') || 
                                currentGameType.includes('Best Ball') || 
                                currentGameType.includes('Select Shot');
            
            // Check if this is a skins game
            const isSkinsGame = currentGameType.includes('Skins');
            
            // Get skins winners if applicable
            let skinWinners = {};
            if (isSkinsGame) {
                skinWinners = calculateSkinsForScorecard(currentGameType, hcpMethod);
            }
            
            // Load player order for highlighting
            loadPlayerOrder();
            
            // Determine which players to show
            let playersToShow = tournamentData.players;
            let allPlayers = tournamentData.players;
            
            if (myPlayersOnly) {
                playersToShow = tournamentData.players.filter(p => 
                    p.claimedBy === currentDeviceId || playerOrder.watching.includes(p.name)
                );
            }
            
            const frontPar = courseData.holes.slice(0, 9).reduce((sum, h) => sum + h.par, 0);
            const backPar = courseData.holes.slice(9).reduce((sum, h) => sum + h.par, 0);
            
            let html = `
                <div style="margin-bottom: 8px; text-align: center;">
                    ${tournamentData.name ? `<h2 style="color: #1e40af; margin-bottom: 4px; font-size: 18px; font-weight: 700;">${tournamentData.name}</h2>` : ''}
                    <h3 style="color: #1e40af; margin-bottom: 2px; font-size: 16px;">${courseData.name}</h3>
                    <p style="color: #64748b; font-size: 12px; margin: 0;">${currentGameType} - ${formatDateDisplay(tournamentData.date)}${myPlayersOnly ? ' (My Players)' : ''}</p>
                </div>
            `;
            
            // Check which stats columns to show (only if any player has data)
            const showFirColumn = hasAnyStatsData('fir');
            const showGirColumn = hasAnyStatsData('gir');
            const showPuttsColumn = hasAnyStatsData('putts') || hasAnyCompletePuttData();
            const showDotsColumn = hasAnyStatsData('dots');
            
            // Single scrollable table with sticky first column
            html += `<div class="table-wrapper" style="overflow-x: auto; -webkit-overflow-scrolling: touch;">
                <table class="scorecard-table" style="border-collapse: collapse; min-width: 100%;">
                    <thead>
                        <tr>
                            <th style="position: sticky; left: 0; z-index: 2; background: #1e40af; min-width: 70px; text-align: left; font-size: 10px;">Player</th>`;
            
            // Front 9 headers
            for (let i = 0; i < 9; i++) {
                html += `<th style="width: 28px; font-size: 10px; padding: 4px 2px;">${i + 1}</th>`;
            }
            html += `<th style="width: 32px; font-size: 10px; background: #334155; padding: 4px 2px;">OUT</th>`;
            
            // Back 9 headers
            for (let i = 9; i < 18; i++) {
                html += `<th style="width: 28px; font-size: 10px; padding: 4px 2px;">${i + 1}</th>`;
            }
            html += `<th style="width: 32px; font-size: 10px; background: #334155; padding: 4px 2px;">IN</th>`;
            html += `<th style="width: 34px; font-size: 10px; background: #1e40af; padding: 4px 2px;">TOT</th>`;
            
            // Add stats headers at the end
            if (showFirColumn) {
                html += `<th style="width: 36px; font-size: 9px; background: #0d9488; padding: 4px 2px;">FIR</th>`;
            }
            if (showGirColumn) {
                html += `<th style="width: 36px; font-size: 9px; background: #0d9488; padding: 4px 2px;">GIR</th>`;
            }
            if (showPuttsColumn) {
                html += `<th style="width: 36px; font-size: 9px; background: #7c3aed; padding: 4px 2px;">Putts</th>`;
            }
            if (showDotsColumn) {
                html += `<th style="width: 36px; font-size: 9px; background: #10b981; padding: 4px 2px;">Dots</th>`;
            }
            
            html += `</tr>`;
            
            // Par row
            html += `<tr style="background: #f1f5f9;">
                <td style="position: sticky; left: 0; z-index: 1; background: #f1f5f9; font-size: 9px; font-weight: 600; text-align: left; padding: 2px 4px;">Par</td>`;
            for (let i = 0; i < 9; i++) {
                html += `<td style="font-size: 10px; padding: 2px;">${courseData.holes[i].par}</td>`;
            }
            html += `<td style="font-size: 10px; background: #e2e8f0; font-weight: 600; padding: 2px;">${frontPar}</td>`;
            for (let i = 9; i < 18; i++) {
                html += `<td style="font-size: 10px; padding: 2px;">${courseData.holes[i].par}</td>`;
            }
            html += `<td style="font-size: 10px; background: #e2e8f0; font-weight: 600; padding: 2px;">${backPar}</td>`;
            html += `<td style="font-size: 10px; background: #dbeafe; font-weight: 600; padding: 2px;">${courseData.totalPar}</td>`;
            // Empty cells for stats columns in par row
            if (showFirColumn) html += `<td style="background: #ccfbf1; padding: 2px;"></td>`;
            if (showGirColumn) html += `<td style="background: #ccfbf1; padding: 2px;"></td>`;
            if (showPuttsColumn) html += `<td style="background: #f5f3ff; padding: 2px;"></td>`;
            if (showDotsColumn) html += `<td style="background: #d1fae5; padding: 2px;"></td>`;
            html += `</tr>`;
            
            // Handicap row
            html += `<tr style="background: #f8fafc;">
                <td style="position: sticky; left: 0; z-index: 1; background: #f8fafc; font-size: 8px; font-weight: 500; text-align: left; padding: 2px 4px; color: #64748b;">Hcp</td>`;
            for (let i = 0; i < 9; i++) {
                html += `<td style="font-size: 9px; color: #64748b; padding: 2px;">${courseData.holes[i].handicap}</td>`;
            }
            html += `<td style="background: #e2e8f0; padding: 2px;"></td>`;
            for (let i = 9; i < 18; i++) {
                html += `<td style="font-size: 9px; color: #64748b; padding: 2px;">${courseData.holes[i].handicap}</td>`;
            }
            html += `<td style="background: #e2e8f0; padding: 2px;"></td>`;
            html += `<td style="background: #dbeafe; padding: 2px;"></td>`;
            // Empty cells for stats columns in handicap row
            if (showFirColumn) html += `<td style="background: #ccfbf1; padding: 2px;"></td>`;
            if (showGirColumn) html += `<td style="background: #ccfbf1; padding: 2px;"></td>`;
            if (showPuttsColumn) html += `<td style="background: #f5f3ff; padding: 2px;"></td>`;
            if (showDotsColumn) html += `<td style="background: #d1fae5; padding: 2px;"></td>`;
            html += `</tr></thead><tbody>`;
            
            // Player rows
            playersToShow.forEach(player => {
                const playerIdx = allPlayers.findIndex(p => p.name === player.name);
                
                // Row highlighting
                let rowBg = 'white';
                let stickyBg = 'white';
                if (player.claimedBy === currentDeviceId) {
                    rowBg = '#fef9c3';
                    stickyBg = '#fef9c3';
                } else if (playerOrder.watching && playerOrder.watching.includes(player.name)) {
                    rowBg = '#e0f2fe';
                    stickyBg = '#e0f2fe';
                }
                
                html += `<tr style="background: ${rowBg}; height: 36px;">`;
                
                // Player name cell (sticky)
                const hcpDisplay = player.handicap > 0 ? player.handicap : player.handicap < 0 ? '+' + Math.abs(player.handicap) : 'Scr';
                html += `<td style="position: sticky; left: 0; z-index: 1; background: ${stickyBg}; font-size: 10px; font-weight: 600; text-align: left; padding: 4px; white-space: nowrap; border-right: 2px solid #e2e8f0; vertical-align: middle; height: 36px;">
                    ${player.name}<br><span style="font-size: 8px; color: #64748b; font-weight: 400;">(${hcpDisplay})</span>
                </td>`;
                
                // Calculate totals
                let frontTotal = 0;
                let frontNetTotal = 0;
                let backTotal = 0;
                let backNetTotal = 0;
                
                // Front 9 scores
                for (let i = 0; i < 9; i++) {
                    const score = player.scores[i] || '';
                    if (score) {
                        frontTotal += score;
                        const netScore = getNetScore(score, player.handicap, courseData.holes[i].handicap, hcpMethod);
                        frontNetTotal += netScore;
                    }
                    
                    let cellStyle = 'vertical-align: middle; height: 36px;';
                    if (isSkinsGame && skinWinners[i] && skinWinners[i].includes(playerIdx)) {
                        cellStyle += ' background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);';
                    }
                    
                    let scoreDisplay = score || '';
                    if (score) {
                        const diff = score - courseData.holes[i].par;
                        let scoreColor = '';
                        if (diff <= -1) scoreColor = 'color: #059669;';
                        else if (diff === 0) scoreColor = 'color: #2563eb;';
                        else if (diff === 1) scoreColor = 'color: #d97706;';
                        else if (diff >= 2) scoreColor = 'color: #dc2626;';
                        
                        const netScore = getNetScore(score, player.handicap, courseData.holes[i].handicap, hcpMethod);
                        const netStr = Number.isInteger(netScore) ? netScore : netScore.toFixed(1);
                        const netDisplay = player.handicap !== 0 ? `<br><span style="font-size: 8px; color: #6b7280;">${netStr}</span>` : '<br><span style="font-size: 8px; visibility: hidden;">0</span>';
                        scoreDisplay = `<span style="${scoreColor} font-weight: 600; font-size: 11px;">${score}</span>${netDisplay}`;
                    }
                    
                    html += `<td style="${cellStyle} padding: 2px;">${scoreDisplay}</td>`;
                }
                
                // Front 9 OUT
                const frontNetStr = Number.isInteger(frontNetTotal) ? frontNetTotal : frontNetTotal.toFixed(1);
                const frontNetDisplay = player.handicap !== 0 && frontTotal ? `<br><span style="font-size: 8px; color: #6b7280;">${frontNetStr}</span>` : '<br><span style="font-size: 8px; visibility: hidden;">0</span>';
                html += `<td style="background: #e2e8f0; font-weight: 700; font-size: 11px; padding: 2px; vertical-align: middle; height: 36px;">
                    ${frontTotal || ''}${frontTotal ? frontNetDisplay : ''}
                </td>`;
                
                // Back 9 scores
                for (let i = 9; i < 18; i++) {
                    const score = player.scores[i] || '';
                    if (score) {
                        backTotal += score;
                        const netScore = getNetScore(score, player.handicap, courseData.holes[i].handicap, hcpMethod);
                        backNetTotal += netScore;
                    }
                    
                    let cellStyle = 'vertical-align: middle; height: 36px;';
                    if (isSkinsGame && skinWinners[i] && skinWinners[i].includes(playerIdx)) {
                        cellStyle += ' background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);';
                    }
                    
                    let scoreDisplay = score || '';
                    if (score) {
                        const diff = score - courseData.holes[i].par;
                        let scoreColor = '';
                        if (diff <= -1) scoreColor = 'color: #059669;';
                        else if (diff === 0) scoreColor = 'color: #2563eb;';
                        else if (diff === 1) scoreColor = 'color: #d97706;';
                        else if (diff >= 2) scoreColor = 'color: #dc2626;';
                        
                        const netScore = getNetScore(score, player.handicap, courseData.holes[i].handicap, hcpMethod);
                        const netStr = Number.isInteger(netScore) ? netScore : netScore.toFixed(1);
                        const netDisplay = player.handicap !== 0 ? `<br><span style="font-size: 8px; color: #6b7280;">${netStr}</span>` : '<br><span style="font-size: 8px; visibility: hidden;">0</span>';
                        scoreDisplay = `<span style="${scoreColor} font-weight: 600; font-size: 11px;">${score}</span>${netDisplay}`;
                    }
                    
                    html += `<td style="${cellStyle} padding: 2px;">${scoreDisplay}</td>`;
                }
                
                // Back 9 IN
                const backNetStr = Number.isInteger(backNetTotal) ? backNetTotal : backNetTotal.toFixed(1);
                const backNetDisplay = player.handicap !== 0 && backTotal ? `<br><span style="font-size: 8px; color: #6b7280;">${backNetStr}</span>` : '<br><span style="font-size: 8px; visibility: hidden;">0</span>';
                html += `<td style="background: #e2e8f0; font-weight: 700; font-size: 11px; padding: 2px; vertical-align: middle; height: 36px;">
                    ${backTotal || ''}${backTotal ? backNetDisplay : ''}
                </td>`;
                
                // Total
                const grandTotal = frontTotal + backTotal;
                const grandNetTotal = frontNetTotal + backNetTotal;
                const grandNetStr = Number.isInteger(grandNetTotal) ? grandNetTotal : grandNetTotal.toFixed(1);
                const toPar = grandTotal - courseData.totalPar;
                const toParText = grandTotal ? (toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar)) : '';
                const totalNetDisplay = player.handicap !== 0 && grandTotal ? `<br><span style="font-size: 8px; color: #6b7280;">${grandNetStr}</span>` : '<br><span style="font-size: 8px; visibility: hidden;">0</span>';
                
                html += `<td style="background: #dbeafe; font-weight: 700; font-size: 11px; padding: 2px; vertical-align: middle; height: 36px;">
                    ${grandTotal || ''}${grandTotal ? totalNetDisplay : ''}
                </td>`;
                
                // Get player stats for all columns
                const playerScorecardStats = getPlayerStatsForScorecard(player.name);
                
                // FIR column
                if (showFirColumn) {
                    let firDisplay = '--';
                    if (playerScorecardStats && playerScorecardStats.fir) {
                        firDisplay = `${playerScorecardStats.fir.hit}/${playerScorecardStats.fir.total}`;
                    }
                    html += `<td style="background: #ccfbf1; font-weight: 700; font-size: 10px; padding: 2px; vertical-align: middle; height: 36px; color: #0d9488;">
                        ${firDisplay}
                    </td>`;
                }
                
                // GIR column
                if (showGirColumn) {
                    let girDisplay = '--';
                    if (playerScorecardStats && playerScorecardStats.gir) {
                        girDisplay = `${playerScorecardStats.gir.hit}/${playerScorecardStats.gir.total}`;
                    }
                    html += `<td style="background: #ccfbf1; font-weight: 700; font-size: 10px; padding: 2px; vertical-align: middle; height: 36px; color: #0d9488;">
                        ${girDisplay}
                    </td>`;
                }
                
                // PUTTS column
                if (showPuttsColumn) {
                    let puttsDisplay = '--';
                    // Try new stats first, then fall back to legacy putts
                    if (playerScorecardStats && playerScorecardStats.putts !== null) {
                        puttsDisplay = playerScorecardStats.putts;
                    } else {
                        const totalPutts = getPlayerTotalPutts(player);
                        if (totalPutts !== null) puttsDisplay = totalPutts;
                    }
                    html += `<td style="background: #f5f3ff; font-weight: 700; font-size: 11px; padding: 2px; vertical-align: middle; height: 36px; color: #7c3aed;">
                        ${puttsDisplay}
                    </td>`;
                }
                
                // DOTS column
                if (showDotsColumn) {
                    let dotsDisplay = '--';
                    if (playerScorecardStats && playerScorecardStats.dots !== null) {
                        dotsDisplay = playerScorecardStats.dots;
                    }
                    html += `<td style="background: #d1fae5; font-weight: 700; font-size: 11px; padding: 2px; vertical-align: middle; height: 36px; color: #10b981;">
                        ${dotsDisplay}
                    </td>`;
                }
                
                html += `</tr>`;
            });
            
            html += `</tbody></table></div>`;
            
            return html;
        }
        
        // Calculate skins winners for scorecard display
        function calculateSkinsForScorecard(gameType, hcpMethod) {
            const skinWinners = {}; // hole index => array of player indices who won
            
            for (let holeIdx = 0; holeIdx < 18; holeIdx++) {
                const hole = courseData.holes[holeIdx];
                let scores = [];
                
                tournamentData.players.forEach((player, pIdx) => {
                    let score = player.scores[holeIdx];
                    if (score > 0) {
                        if (gameType.includes('Net')) {
                            score = getNetScore(score, player.handicap, hole.handicap, hcpMethod);
                        }
                        scores.push({ playerIdx: pIdx, score });
                    }
                });
                
                if (scores.length > 0) {
                    const minScore = Math.min(...scores.map(s => s.score));
                    const winners = scores.filter(s => s.score === minScore);
                    
                    // Only award skin if there's a single winner (no tie)
                    if (winners.length === 1) {
                        skinWinners[holeIdx] = [winners[0].playerIdx];
                    }
                }
            }
            
            return skinWinners;
        }

        // Generate all individual cards
        function generateAllIndividualCards(myPlayersOnly = false) {
            let html = '';
            let playersToShow = tournamentData.players;
            
            if (myPlayersOnly) {
                loadPlayerOrder();
                playersToShow = tournamentData.players.filter(p => 
                    p.claimedBy === currentDeviceId || playerOrder.watching.includes(p.name)
                );
            }
            
            playersToShow.forEach((player) => {
                const playerIdx = tournamentData.players.findIndex(p => p.name === player.name);
                html += generateIndividualCard(playerIdx);
            });
            return html;
        }

        // Generate individual scorecard for one player
        function generateIndividualCard(playerIndex) {
            const player = tournamentData.players[playerIndex];
            const currentGameType = document.getElementById('resultsGameType').value;
            
            // Determine handicap method based on game type
            let hcpMethod = 'full';
            if (currentGameType.includes('18 Max')) {
                hcpMethod = '18max';
            } else if (currentGameType.includes('1/2 Pop')) {
                hcpMethod = 'half';
            }
            
            let html = `
                <div class="scorecard-individual">
                    <div class="scorecard-player-header">
                        <div class="scorecard-player-name">${player.name}</div>
                        <div class="scorecard-player-info">
                            ${tournamentData.name ? `<strong>${tournamentData.name}</strong><br>` : ''}
                            ${courseData.name} â¢ ${currentGameType}<br>
                            ${formatDateDisplay(tournamentData.date)} â¢ Handicap: ${player.handicap > 0 ? player.handicap : player.handicap < 0 ? '+' + Math.abs(player.handicap) : 'Scratch'}
                        </div>
                    </div>
                    
                    <div class="table-wrapper">
                    <table class="scorecard-table">
                        <thead>
                            <tr>
                                <th>Hole</th>
            `;
            
            // Front 9
            for (let i = 1; i <= 9; i++) {
                html += `<th>${i}</th>`;
            }
            html += `<th>OUT</th>`;
            
            // Back 9
            for (let i = 10; i <= 18; i++) {
                html += `<th>${i}</th>`;
            }
            html += `<th>IN</th><th>TOT</th>`;
            
            html += `</tr></thead><tbody>`;
            
            // Par row
            html += `<tr><td><strong>Par</strong></td>`;
            let frontPar = 0, backPar = 0;
            for (let i = 0; i < 9; i++) {
                frontPar += courseData.holes[i].par;
                html += `<td>${courseData.holes[i].par}</td>`;
            }
            html += `<td><strong>${frontPar}</strong></td>`;
            for (let i = 9; i < 18; i++) {
                backPar += courseData.holes[i].par;
                html += `<td>${courseData.holes[i].par}</td>`;
            }
            html += `<td><strong>${backPar}</strong></td><td><strong>${courseData.totalPar}</strong></td></tr>`;
            
            // Handicap row
            html += `<tr><td><strong>HCP</strong></td>`;
            for (let i = 0; i < 9; i++) {
                html += `<td style="font-size: 11px;">${courseData.holes[i].handicap}</td>`;
            }
            html += `<td></td>`;
            for (let i = 9; i < 18; i++) {
                html += `<td style="font-size: 11px;">${courseData.holes[i].handicap}</td>`;
            }
            html += `<td></td><td></td></tr>`;
            
            // Gross score row with color coding
            html += `<tr style="background: #f0f9ff;"><td><strong>Gross</strong></td>`;
            let frontGross = 0, backGross = 0;
            for (let i = 0; i < 9; i++) {
                const score = player.scores[i] || '';
                if (score) {
                    frontGross += score;
                    const diff = score - courseData.holes[i].par;
                    let scoreColor = '';
                    if (diff <= -2) scoreColor = 'color: #047857; font-weight: 800;'; // Eagle or better - dark green
                    else if (diff === -1) scoreColor = 'color: #059669;'; // Birdie - green
                    else if (diff === 0) scoreColor = 'color: #2563eb;'; // Par - blue
                    else if (diff === 1) scoreColor = 'color: #d97706;'; // Bogey - orange
                    else if (diff >= 2) scoreColor = 'color: #dc2626;'; // Double+ - red
                    html += `<td><strong style="${scoreColor}">${score}</strong></td>`;
                } else {
                    html += `<td><strong>${score}</strong></td>`;
                }
            }
            html += `<td><strong>${frontGross || ''}</strong></td>`;
            for (let i = 9; i < 18; i++) {
                const score = player.scores[i] || '';
                if (score) {
                    backGross += score;
                    const diff = score - courseData.holes[i].par;
                    let scoreColor = '';
                    if (diff <= -2) scoreColor = 'color: #047857; font-weight: 800;'; // Eagle or better
                    else if (diff === -1) scoreColor = 'color: #059669;'; // Birdie
                    else if (diff === 0) scoreColor = 'color: #2563eb;'; // Par
                    else if (diff === 1) scoreColor = 'color: #d97706;'; // Bogey
                    else if (diff >= 2) scoreColor = 'color: #dc2626;'; // Double+
                    html += `<td><strong style="${scoreColor}">${score}</strong></td>`;
                } else {
                    html += `<td><strong>${score}</strong></td>`;
                }
            }
            const totalGross = frontGross + backGross;
            html += `<td><strong>${backGross || ''}</strong></td><td><strong>${totalGross || ''}</strong></td></tr>`;
            
            // Net score row (if applicable - for net games OR team games)
            const isNetOrTeam = currentGameType.includes('Net') || 
                                currentGameType.includes('Best Ball') || 
                                currentGameType.includes('Select Shot');
            
            if (isNetOrTeam && player.handicap !== 0) {
                html += `<tr style="background: #dcfce7;"><td><strong>Net</strong></td>`;
                let frontNet = 0, backNet = 0;
                for (let i = 0; i < 9; i++) {
                    const gross = player.scores[i];
                    if (gross) {
                        const net = getNetScore(gross, player.handicap, courseData.holes[i].handicap, hcpMethod);
                        frontNet += net;
                        html += `<td><strong>${net}</strong></td>`;
                    } else {
                        html += `<td></td>`;
                    }
                }
                html += `<td><strong>${frontNet || ''}</strong></td>`;
                for (let i = 9; i < 18; i++) {
                    const gross = player.scores[i];
                    if (gross) {
                        const net = getNetScore(gross, player.handicap, courseData.holes[i].handicap, hcpMethod);
                        backNet += net;
                        html += `<td><strong>${net}</strong></td>`;
                    } else {
                        html += `<td></td>`;
                    }
                }
                const totalNet = frontNet + backNet;
                html += `<td><strong>${backNet || ''}</strong></td><td><strong>${totalNet || ''}</strong></td></tr>`;
            }
            
            // Get player stats from stats tracker
            const playerScorecardStats = getPlayerStatsForScorecard(player.name);
            
            // FIR row (if player has any FIR data)
            if (playerScorecardStats && playerScorecardStats.fir !== null) {
                html += `<tr style="background: #ccfbf1;"><td><strong style="color: #0d9488;">FIR</strong></td>`;
                let frontFir = 0, frontFirTotal = 0, backFir = 0, backFirTotal = 0;
                for (let i = 0; i < 9; i++) {
                    const isPar3 = courseData.holes[i].par === 3;
                    const firVal = playerScorecardStats.firByHole[i];
                    let cellContent = '';
                    if (isPar3) {
                        cellContent = '-';
                    } else if (firVal === true) {
                        cellContent = 'â';
                        frontFir++;
                        frontFirTotal++;
                    } else if (firVal === false) {
                        cellContent = 'â';
                        frontFirTotal++;
                    }
                    html += `<td style="color: ${firVal === true ? '#10b981' : firVal === false ? '#ef4444' : '#94a3b8'}; font-size: 11px;"><strong>${cellContent}</strong></td>`;
                }
                html += `<td style="color: #0d9488; font-size: 10px;"><strong>${frontFirTotal > 0 ? frontFir + '/' + frontFirTotal : ''}</strong></td>`;
                for (let i = 9; i < 18; i++) {
                    const isPar3 = courseData.holes[i].par === 3;
                    const firVal = playerScorecardStats.firByHole[i];
                    let cellContent = '';
                    if (isPar3) {
                        cellContent = '-';
                    } else if (firVal === true) {
                        cellContent = 'â';
                        backFir++;
                        backFirTotal++;
                    } else if (firVal === false) {
                        cellContent = 'â';
                        backFirTotal++;
                    }
                    html += `<td style="color: ${firVal === true ? '#10b981' : firVal === false ? '#ef4444' : '#94a3b8'}; font-size: 11px;"><strong>${cellContent}</strong></td>`;
                }
                const totalFir = frontFir + backFir;
                const totalFirTotal = frontFirTotal + backFirTotal;
                html += `<td style="color: #0d9488; font-size: 10px;"><strong>${backFirTotal > 0 ? backFir + '/' + backFirTotal : ''}</strong></td>`;
                html += `<td style="color: #0d9488; font-size: 10px;"><strong>${totalFirTotal > 0 ? totalFir + '/' + totalFirTotal : ''}</strong></td></tr>`;
            }
            
            // GIR row (if player has any GIR data)
            if (playerScorecardStats && playerScorecardStats.gir !== null) {
                html += `<tr style="background: #ccfbf1;"><td><strong style="color: #0d9488;">GIR</strong></td>`;
                let frontGir = 0, frontGirTotal = 0, backGir = 0, backGirTotal = 0;
                for (let i = 0; i < 9; i++) {
                    const girVal = playerScorecardStats.girByHole[i];
                    let cellContent = '';
                    if (girVal === true) {
                        cellContent = 'â';
                        frontGir++;
                        frontGirTotal++;
                    } else if (girVal === false) {
                        cellContent = 'â';
                        frontGirTotal++;
                    }
                    html += `<td style="color: ${girVal === true ? '#10b981' : girVal === false ? '#ef4444' : '#94a3b8'}; font-size: 11px;"><strong>${cellContent}</strong></td>`;
                }
                html += `<td style="color: #0d9488; font-size: 10px;"><strong>${frontGirTotal > 0 ? frontGir + '/' + frontGirTotal : ''}</strong></td>`;
                for (let i = 9; i < 18; i++) {
                    const girVal = playerScorecardStats.girByHole[i];
                    let cellContent = '';
                    if (girVal === true) {
                        cellContent = 'â';
                        backGir++;
                        backGirTotal++;
                    } else if (girVal === false) {
                        cellContent = 'â';
                        backGirTotal++;
                    }
                    html += `<td style="color: ${girVal === true ? '#10b981' : girVal === false ? '#ef4444' : '#94a3b8'}; font-size: 11px;"><strong>${cellContent}</strong></td>`;
                }
                const totalGirCount = frontGir + backGir;
                const totalGirTotal = frontGirTotal + backGirTotal;
                html += `<td style="color: #0d9488; font-size: 10px;"><strong>${backGirTotal > 0 ? backGir + '/' + backGirTotal : ''}</strong></td>`;
                html += `<td style="color: #0d9488; font-size: 10px;"><strong>${totalGirCount > 0 ? totalGirCount + '/' + totalGirTotal : ''}</strong></td></tr>`;
            }
            
            // Putts row (from stats tracker or legacy)
            const hasPuttsData = (playerScorecardStats && playerScorecardStats.putts !== null) || getPlayerTotalPutts(player) !== null;
            if (hasPuttsData) {
                html += `<tr style="background: #f5f3ff;"><td><strong style="color: #7c3aed;">Putts</strong></td>`;
                let frontPutts = 0, backPutts = 0;
                for (let i = 0; i < 9; i++) {
                    // Try stats tracker first, then legacy
                    let putt = '';
                    if (playerScorecardStats && playerScorecardStats.puttsByHole[i] !== null && playerScorecardStats.puttsByHole[i] !== undefined) {
                        putt = playerScorecardStats.puttsByHole[i];
                    } else if (player.putts && player.putts[i] !== null) {
                        putt = player.putts[i];
                    }
                    if (putt !== '') frontPutts += putt;
                    html += `<td style="color: #7c3aed;"><strong>${putt}</strong></td>`;
                }
                html += `<td style="color: #7c3aed;"><strong>${frontPutts || ''}</strong></td>`;
                for (let i = 9; i < 18; i++) {
                    let putt = '';
                    if (playerScorecardStats && playerScorecardStats.puttsByHole[i] !== null && playerScorecardStats.puttsByHole[i] !== undefined) {
                        putt = playerScorecardStats.puttsByHole[i];
                    } else if (player.putts && player.putts[i] !== null) {
                        putt = player.putts[i];
                    }
                    if (putt !== '') backPutts += putt;
                    html += `<td style="color: #7c3aed;"><strong>${putt}</strong></td>`;
                }
                const totalPuttsCalc = frontPutts + backPutts;
                html += `<td style="color: #7c3aed;"><strong>${backPutts || ''}</strong></td><td style="color: #7c3aed;"><strong>${totalPuttsCalc || ''}</strong></td></tr>`;
            }
            
            // Dots row (if player has any dots data)
            if (playerScorecardStats && playerScorecardStats.dots !== null) {
                html += `<tr style="background: #d1fae5;"><td><strong style="color: #10b981;">Dots</strong></td>`;
                let frontDots = 0, backDots = 0;
                for (let i = 0; i < 9; i++) {
                    const dotVal = playerScorecardStats.dotsByHole[i];
                    const cellContent = dotVal !== null && dotVal !== undefined ? dotVal : '';
                    if (cellContent !== '') frontDots += cellContent;
                    html += `<td style="color: #10b981;"><strong>${cellContent}</strong></td>`;
                }
                html += `<td style="color: #10b981;"><strong>${frontDots || ''}</strong></td>`;
                for (let i = 9; i < 18; i++) {
                    const dotVal = playerScorecardStats.dotsByHole[i];
                    const cellContent = dotVal !== null && dotVal !== undefined ? dotVal : '';
                    if (cellContent !== '') backDots += cellContent;
                    html += `<td style="color: #10b981;"><strong>${cellContent}</strong></td>`;
                }
                const totalDotsCalc = frontDots + backDots;
                html += `<td style="color: #10b981;"><strong>${backDots || ''}</strong></td><td style="color: #10b981;"><strong>${totalDotsCalc || ''}</strong></td></tr>`;
            }
            
            // To Par row
            const toPar = totalGross - courseData.totalPar;
            const toParText = toPar === 0 ? 'Even' : (toPar > 0 ? `+${toPar}` : toPar);
            html += `<tr class="total-row"><td colspan="11"><strong>To Par:</strong></td><td colspan="10"><strong>${toParText}</strong></td></tr>`;
            
            html += `</tbody></table>`;
            html += `</div>`; // Close table-wrapper
            html += `</div>`; // Close scorecard-individual
            
            return html;
        }
        // Check for saved round on page load
        let initialLoadComplete = false;
        function checkForSavedRound(allowNavigation = false) {
            const savedData = localStorage.getItem('indianHillsScoring');
            
            // If no saved data and we're allowing navigation, go to Host Home (fresh start)
            if (!savedData && allowNavigation && !initialLoadComplete) {
                initialLoadComplete = true;
                console.log('ð  No saved tournament - showing Host Home for fresh start');
                updateHostHomePage();
                showPage('hostHomePage');
                return;
            }
            
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    
                    // CRITICAL: Restore activeTournamentId and tournamentMode first
                    activeTournamentId = data._activeTournamentId || null;
                    tournamentMode = data._tournamentMode || 'single';
                    
                    // IMPROVED HOST RESTORATION: Same logic as loadFromLocalStorage
                    const savedHostForTournament = data._hostForTournament || null;
                    if (savedHostForTournament && savedHostForTournament === activeTournamentId) {
                        isHost = data._isHost || false;
                        console.log('ð checkForSavedRound - Host status restored for tournament:', activeTournamentId);
                    } else if (data._isHost && activeTournamentId) {
                        // Fallback for old data format
                        isHost = data._isHost;
                        console.log('ð checkForSavedRound - Host status restored (legacy format)');
                    } else {
                        isHost = false;
                    }
                    
                    // AUTO-FIX: If there's a Firebase tournament ID, it MUST be multi-device mode
                    // Firebase IDs look like T1768522029360yc63i0 (T + 13-digit timestamp + random)
                    // Local IDs look like Tmkhhwu1sfr3ql (T + base36 timestamp, shorter)
                    const isFirebaseIdCheck = activeTournamentId && /^T\d{13}/.test(activeTournamentId);
                    if (isFirebaseIdCheck && tournamentMode !== 'multi') {
                        console.log('ð§ AUTO-FIX: Detected Firebase tournament ID, forcing multi-device mode');
                        tournamentMode = 'multi';
                        isHost = true;
                    }
                    
                    hasJoinedTournament = data._hasJoinedTournament || false;
                    hostViewMode = data._hostViewMode || 'host';
                    
                    // Hosts are always considered joined
                    if (isHost) {
                        hasJoinedTournament = true;
                    }
                    
                    // Debug logging
                    console.log('ð checkForSavedRound - tournamentMode:', tournamentMode);
                    console.log('ð checkForSavedRound - activeTournamentId:', activeTournamentId);
                    console.log('ð checkForSavedRound - isHost:', isHost);
                    console.log('ð checkForSavedRound - hasJoinedTournament:', hasJoinedTournament);
                    console.log('ð checkForSavedRound - players count:', data.players?.length || 0);
                    console.log('ð checkForSavedRound - allowNavigation:', allowNavigation);
                    
                    // Only navigate on initial load, not when called from showPage
                    if (allowNavigation && !initialLoadComplete) {
                        initialLoadComplete = true;
                        
                        // AUTO-NAVIGATE: If this is a host with an active tournament, go to Host Home
                        if (activeTournamentId && tournamentMode === 'multi' && isHost) {
                            console.log('ð  Host detected with active tournament - navigating to Host Home');
                            
                            // Load tournament data first (exclude metadata)
                            const metadataKeys = ['_activeTournamentId', '_tournamentMode', '_isHost', '_hostForTournament', 
                                                '_hasJoinedTournament', '_hostViewMode', '_scoreTimestamps', '_deletedPlayers', '_lastSaved'];
                            metadataKeys.forEach(key => delete data[key]);
                            tournamentData = data;
                            
                            // Restore course data
                            courseData = courses[tournamentData.course] || customCourses[tournamentData.course];
                            
                            // Reconnect to Firebase (with delay to ensure Firebase is ready)
                            setTimeout(() => {
                                subscribToTournamentUpdates(activeTournamentId);
                            }, 500);
                            
                            // Navigate to Host Home immediately
                            updateHostHomePage();
                            const currentTournamentCard = document.getElementById('hostCurrentTournament');
                            if (currentTournamentCard) currentTournamentCard.style.display = 'block';
                            showPage('hostHomePage');
                            console.log('â Auto-navigated to Host Home');
                            return; // Don't show setup page
                        }
                        
                        // AUTO-NAVIGATE: If this is a non-host with joined tournament, go to Guest Home
                        if (activeTournamentId && tournamentMode === 'multi' && hasJoinedTournament && !isHost) {
                            console.log('ð  Guest detected with joined tournament - navigating to Guest Home');
                            
                            // Load tournament data
                            const metadataKeys = ['_activeTournamentId', '_tournamentMode', '_isHost', '_hostForTournament', 
                                                '_hasJoinedTournament', '_hostViewMode', '_scoreTimestamps', '_deletedPlayers', '_lastSaved'];
                            metadataKeys.forEach(key => delete data[key]);
                            tournamentData = data;
                            
                            // Restore course data
                            courseData = courses[tournamentData.course] || customCourses[tournamentData.course];
                            
                            // Reconnect to Firebase
                            setTimeout(() => {
                                subscribToTournamentUpdates(activeTournamentId);
                            }, 500);
                            
                            // Navigate to Guest Home
                            showGuestHomePage();
                            console.log('â Auto-navigated to Guest Home');
                            return; // Don't show setup page
                        }
                    }
                    
                    // Fallback: Show resume section on setup page (for non-multi mode or no tournament)
                    const resumeSection = document.getElementById('resumeRoundSection');
                    const resumeInfo = document.getElementById('resumeRoundInfo');
                    const shareButtons = document.getElementById('resumeShareButtons');
                    const manageBtn = document.getElementById('resumeManageBtn');
                    
                    if (data.players && data.players.length > 0) {
                        // Show resume section
                        resumeSection.classList.add('active');
                        
                        // Update Manage button text based on role
                        if (manageBtn) {
                            if (isHost || isCoHost) {
                                manageBtn.textContent = 'Manage';
                            } else {
                                manageBtn.textContent = 'My Players';
                            }
                        }
                        
                        // Format info
                        const playerCount = data.players.length;
                        const date = data.date ? new Date(data.date).toLocaleDateString() : 'Today';
                        const gametype = data.gameType || 'Round';
                        const tournamentName = data.name || '';
                        
                        let infoText = `${playerCount} player${playerCount > 1 ? 's' : ''} â¢ ${gametype}`;
                        if (tournamentName) {
                            infoText = `${tournamentName} â¢ ${infoText}`;
                        }
                        resumeInfo.textContent = infoText;
                        
                        // Show share buttons in multi-device mode (even if tournament creation failed)
                        if (shareButtons && tournamentMode === 'multi' && activeTournamentId) {
                            console.log('â Showing share buttons - activeTournamentId:', activeTournamentId);
                            
                            // Add class for CSS-based visibility (better for iOS)
                            shareButtons.classList.add('visible');
                            
                            // Also set inline styles with !important
                            shareButtons.style.setProperty('display', 'grid', 'important');
                            shareButtons.style.setProperty('visibility', 'visible', 'important');
                            shareButtons.style.setProperty('opacity', '1', 'important');
                            
                            // Triple-check with multiple delays (for iOS)
                            setTimeout(() => {
                                if (shareButtons) {
                                    shareButtons.classList.add('visible');
                                    shareButtons.style.setProperty('display', 'grid', 'important');
                                    console.log('â Re-confirmed share buttons visible (100ms)');
                                }
                            }, 100);
                            
                            setTimeout(() => {
                                if (shareButtons) {
                                    shareButtons.classList.add('visible');
                                    shareButtons.style.setProperty('display', 'grid', 'important');
                                    console.log('â Re-confirmed share buttons visible (500ms)');
                                }
                            }, 500);
                        } else if (shareButtons) {
                            console.log('â Hiding share buttons - mode:', tournamentMode, 'tournamentId:', activeTournamentId);
                            shareButtons.classList.remove('visible');
                            shareButtons.style.display = 'none';
                        }
                    }
                } catch (e) {
                    console.error('Error loading saved round:', e);
                }
            }
        }

        // Resume saved round
        function resumeSavedRound() {
            if (loadFromLocalStorage()) {
                // Restore the course data
                courseData = courses[tournamentData.course];
                
                // Re-save to persist any auto-fixes
                saveToLocalStorage();
                
                // CRITICAL FIX: Reconnect to Firebase in multi-device mode
                if (tournamentMode === 'multi' && activeTournamentId) {
                    console.log('ð Reconnecting to Firebase after resume...');
                    subscribToTournamentUpdates(activeTournamentId);
                }
                
                renderScoringPage();
                showPage('scoringPage');
                showRoundIndicator();
            }
        }

        // Discard saved round and start fresh
        function discardSavedRound() {
            showConfirm(
                'Discard Saved Round?',
                'This will permanently delete your saved round. Are you sure?',
                function() {
                    localStorage.removeItem('indianHillsScoring');
                    document.getElementById('resumeRoundSection').classList.remove('active');
                    
                    // Hide Resume Scoring button
                    const resumeBtn = document.getElementById('resumeScoringBtn');
                    if (resumeBtn) {
                        resumeBtn.style.display = 'none';
                    }
                    
                    hideConfirmDialog();
                }
            );
        }

        // Show round in progress indicator
        function showRoundIndicator() {
            const indicator = document.getElementById('roundIndicator');
            if (indicator) {
                indicator.classList.add('active');
            }
        }

        // Hide round in progress indicator
        function hideRoundIndicator() {
            const indicator = document.getElementById('roundIndicator');
            if (indicator) {
                indicator.classList.remove('active');
            }
        }

        // Show auto-save toast
        function showAutoSaveToast() {
            const toast = document.getElementById('autoSaveToast');
            if (toast) {
                toast.classList.add('show');
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 800);
            }
        }

        // Override saveToLocalStorage to add visual feedback
        const originalSave = saveToLocalStorage;
        saveToLocalStorage = function() {
            originalSave();
            showAutoSaveToast();
        };

        // Disable pull-to-refresh on iOS during active round
        function disablePullToRefresh() {
            document.body.style.overscrollBehavior = 'none';
            document.documentElement.style.overscrollBehavior = 'none';
        }

        // Enable pull-to-refresh
        function enablePullToRefresh() {
            document.body.style.overscrollBehavior = 'auto';
            document.documentElement.style.overscrollBehavior = 'auto';
        }

        // Switch to player view
        function switchToPlayerView() {
            currentView = 'player';
            document.getElementById('playerCards').style.display = 'block';
            document.getElementById('holeView').style.display = 'none';
            
            // Update toggle button visual state
            const holeBtn = document.getElementById('toggleHoleView');
            const playerBtn = document.getElementById('togglePlayerView');
            if (playerBtn) {
                playerBtn.classList.add('active');
                playerBtn.style.background = '#3b82f6';
                playerBtn.style.color = 'white';
            }
            if (holeBtn) {
                holeBtn.classList.remove('active');
                holeBtn.style.background = 'transparent';
                holeBtn.style.color = '#64748b';
            }
            
            // Use compact view rendering with sorted players (claimed first, then watched)
            renderCompactPlayerView(getPlayersToShow());
        }
        
        // Player carousel state
        let currentCarouselIndex = 0;
        let carouselTouchStartX = 0;
        let carouselTouchEndX = 0;
        
        // Input mode state
        let inputMode = 'keyboard'; // 'keyboard' or 'voice'
        let currentVoiceTarget = null; // { playerIndex, holeIndex }
        let recognition = null;
        
        // Set input mode
        function setInputMode(mode) {
            inputMode = mode;
            const keyboardBtn = document.getElementById('keyboardModeBtn');
            const voiceBtn = document.getElementById('voiceModeBtn');
            
            keyboardBtn.classList.toggle('active', mode === 'keyboard');
            voiceBtn.classList.toggle('active', mode === 'voice');
            voiceBtn.classList.toggle('voice-active', mode === 'voice');
            
            // Update visual state for inline styles
            if (mode === 'keyboard') {
                if (keyboardBtn) {
                    keyboardBtn.style.background = '#3b82f6';
                    keyboardBtn.style.color = 'white';
                }
                if (voiceBtn) {
                    voiceBtn.style.background = 'transparent';
                    voiceBtn.style.color = '#64748b';
                }
            } else {
                if (voiceBtn) {
                    voiceBtn.style.background = '#3b82f6';
                    voiceBtn.style.color = 'white';
                }
                if (keyboardBtn) {
                    keyboardBtn.style.background = 'transparent';
                    keyboardBtn.style.color = '#64748b';
                }
            }
            
            // Check if voice is supported
            if (mode === 'voice' && !('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                alert('Voice input is not supported in this browser. Please use Chrome or Safari.');
                setInputMode('keyboard');
            }
        }
        
        // Initialize speech recognition
        function initSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) return null;
            
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';
            recognition.maxAlternatives = 3;
            
            recognition.onresult = (event) => {
                const result = event.results[0][0].transcript.toLowerCase().trim();
                console.log('Voice result:', result);
                processVoiceResult(result);
            };
            
            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                hideVoiceListening();
                if (event.error === 'not-allowed') {
                    alert('Microphone access denied. Please enable microphone permissions.');
                    setInputMode('keyboard');
                }
            };
            
            recognition.onend = () => {
                // Auto-hide after timeout if no result
                setTimeout(() => {
                    hideVoiceListening();
                }, 500);
            };
            
            return recognition;
        }
        
        // Process voice input result
        function processVoiceResult(result) {
            if (!currentVoiceTarget) {
                console.log('No voice target, ignoring result:', result);
                return;
            }
            
            // Capture target immediately in case it gets cleared
            const targetPlayerIndex = currentVoiceTarget.playerIndex;
            const targetHoleIndex = currentVoiceTarget.holeIndex;
            
            let score = null;
            
            // Direct number parsing
            const numMatch = result.match(/\d+/);
            if (numMatch) {
                score = parseInt(numMatch[0]);
            }
            
            // Word to number mapping
            const wordNumbers = {
                'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,
                'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9,
                'ten': 10, 'eleven': 11, 'twelve': 12
            };
            
            for (const [word, num] of Object.entries(wordNumbers)) {
                if (result.includes(word)) {
                    score = num;
                    break;
                }
            }
            
            // Golf terms (relative to par)
            if (courseData && courseData.holes[targetHoleIndex]) {
                const hole = courseData.holes[targetHoleIndex];
                const par = hole.par;
                
                if (result.includes('ace') || result.includes('hole in one')) {
                    score = 1;
                } else if (result.includes('double eagle') || result.includes('albatross')) {
                    score = par - 3;
                } else if (result.includes('eagle')) {
                    score = par - 2;
                } else if (result.includes('birdie')) {
                    score = par - 1;
                } else if (result.includes('par')) {
                    score = par;
                } else if (result.includes('bogey') && !result.includes('double') && !result.includes('triple')) {
                    score = par + 1;
                } else if (result.includes('double bogey') || result.includes('double')) {
                    score = par + 2;
                } else if (result.includes('triple bogey') || result.includes('triple')) {
                    score = par + 3;
                }
            }
            
            // Show result and save
            if (score !== null && score >= 1 && score <= 15) {
                document.getElementById('voiceResult').textContent = score;
                
                setTimeout(() => {
                    updateScore(targetPlayerIndex, targetHoleIndex, score);
                    hideVoiceListening();
                    // Refresh appropriate view
                    if (currentView === 'hole') {
                        renderHoleView();
                    } else {
                        switchToPlayerView();
                    }
                }, 800);
            } else {
                document.getElementById('voiceResult').textContent = '?';
                setTimeout(hideVoiceListening, 1000);
            }
        }
        
        // Show voice listening overlay
        function showVoiceListening(playerIndex, holeIndex) {
            currentVoiceTarget = { playerIndex, holeIndex };
            document.getElementById('voiceResult').textContent = '';
            document.getElementById('voiceListening').classList.add('active');
            
            if (!recognition) {
                recognition = initSpeechRecognition();
            }
            
            if (recognition) {
                try {
                    recognition.start();
                } catch (e) {
                    console.error('Could not start recognition:', e);
                }
            }
            
            // Auto-timeout after 4 seconds
            setTimeout(() => {
                if (document.getElementById('voiceListening').classList.contains('active')) {
                    hideVoiceListening();
                }
            }, 4000);
        }
        
        // Hide voice listening overlay
        function hideVoiceListening() {
            document.getElementById('voiceListening').classList.remove('active');
            currentVoiceTarget = null;
            if (recognition) {
                try {
                    recognition.stop();
                } catch (e) {}
            }
        }
        
        // Handle score cell click (keyboard or voice based on mode)
        function handleScoreCellClick(playerIndex, holeIndex, currentScore) {
            if (inputMode === 'voice') {
                showVoiceListening(playerIndex, holeIndex);
            } else {
                // Keyboard mode - show prompt
                const hole = courseData.holes[holeIndex];
                const newScore = prompt(`Hole ${hole.number} (Par ${hole.par}) - Enter score:`, currentScore || hole.par);
                if (newScore !== null) {
                    const score = parseInt(newScore);
                    if (!isNaN(score) && score >= 0 && score <= 15) {
                        updateScore(playerIndex, holeIndex, score);
                        renderScoringPage();
                    }
                }
            }
        }
        
        // Render compact player view (9-column grid)
        function renderCompactPlayerView(playersToShow) {
            const container = document.getElementById('playerCards');
            
            // Build carousel with compact cards (6 columns x 3 rows)
            let slidesHTML = playersToShow.map((player, idx) => {
                const actualPlayerIndex = tournamentData.players.indexOf(player);
                const total = player.scores.reduce((sum, score) => sum + (score || 0), 0);
                
                // Calculate running to-par based only on holes played
                let holesPlayed = 0;
                let parForPlayedHoles = 0;
                for (let i = 0; i < 18; i++) {
                    if (player.scores[i] && player.scores[i] > 0) {
                        holesPlayed++;
                        parForPlayedHoles += courseData.holes[i].par;
                    }
                }
                const toPar = holesPlayed > 0 ? total - parForPlayedHoles : 0;
                const toParText = holesPlayed === 0 ? '-' : (toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : toPar));
                const hcpDisplay = player.handicap !== 0 ? ` (${player.handicap})` : '';
                
                // Check if this is a watched player (view only)
                // Hosts/co-hosts in HOST mode can edit all players
                // Hosts/co-hosts in PLAYER mode can only edit their claimed players
                const isHostInHostModeCompact = canManageTournament() && !isHostInPlayerMode();
                const isMyClaimedPlayerCompact = player.claimedBy === currentDeviceId;
                const isWatchedPlayer = tournamentMode === 'multi' && !isHostInHostModeCompact && !isMyClaimedPlayerCompact;
                const watchIndicator = isWatchedPlayer ? ' ð' : '';
                
                // Calculate front/back 9 totals
                const front9 = player.scores.slice(0, 9).reduce((sum, s) => sum + (s || 0), 0);
                const back9 = player.scores.slice(9, 18).reduce((sum, s) => sum + (s || 0), 0);
                
                // Generate hole cells in 3 rows of 6
                let row1Cells = ''; // Holes 1-6
                let row2Cells = ''; // Holes 7-12
                let row3Cells = ''; // Holes 13-18
                
                // Determine net method for dots
                let netMethod = 'full';
                const gameTypeLower = tournamentData.gameType.toLowerCase();
                if (gameTypeLower.includes('18 max')) {
                    netMethod = '18max';
                } else if (gameTypeLower.includes('1/2 pop') || gameTypeLower.includes('half pop')) {
                    netMethod = 'half';
                }
                
                for (let i = 0; i < 18; i++) {
                    const hole = courseData.holes[i];
                    const score = player.scores[i];
                    const diff = score ? score - hole.par : 0;
                    let scoreClass = 'empty';
                    if (score > 0) {
                        if (diff <= -1) scoreClass = 'birdie-better';
                        else if (diff === 0) scoreClass = 'par';
                        else if (diff === 1) scoreClass = 'bogey';
                        else scoreClass = 'double-plus';
                    }
                    
                    // Calculate handicap dots
                    let hcpDotsHtml = '';
                    if (player.handicap !== 0) {
                        const strokes = getHandicapStrokesForHole(player.handicap, hole.handicap, netMethod);
                        if (strokes !== 0) {
                            const isHalfPop = netMethod === 'half';
                            const dotCount = isHalfPop ? Math.abs(strokes * 2) : Math.abs(strokes);
                            const dotColor = strokes > 0 ? 'green' : 'red';
                            
                            hcpDotsHtml = '<div class="hcp-dots-compact">';
                            for (let d = 0; d < Math.min(dotCount, 3); d++) {
                                hcpDotsHtml += `<span class="hcp-dot-compact ${dotColor}"></span>`;
                            }
                            hcpDotsHtml += '</div>';
                        }
                    }
                    
                    // Calculate net score for display
                    let netScoreHTML = '';
                    if (score > 0 && player.handicap !== 0) {
                        const netScore = getNetScore(score, player.handicap, hole.handicap, netMethod);
                        netScoreHTML = `<div class="net-score">(${netScore})</div>`;
                    }
                    
                    const cellHTML = `
                        <div class="hole-cell" onclick="handleCompactCellClick(${actualPlayerIndex}, ${i}, ${score || 0}, '${player.name}')">
                            <div class="hole-num">${hole.number}</div>
                            <div class="par-hcp-stack">
                                <div class="par-hcp-line">
                                    <span class="label">Par</span>
                                    <span class="value">${hole.par}</span>
                                </div>
                                <div class="par-hcp-line">
                                    <span class="label">Hcp</span>
                                    <span class="value">${hole.handicap}</span>
                                </div>
                            </div>
                            ${hcpDotsHtml}
                            <div class="score-cell ${scoreClass}">
                                ${score || '-'}
                            </div>
                            ${netScoreHTML}
                        </div>
                    `;
                    
                    if (i < 6) row1Cells += cellHTML;
                    else if (i < 12) row2Cells += cellHTML;
                    else row3Cells += cellHTML;
                }
                
                return `
                    <div class="player-carousel-slide" data-index="${idx}">
                        <div class="player-card-compact ${isWatchedPlayer ? 'watched' : ''}">
                            <div class="player-header-compact">
                                <div class="player-name-compact">
                                    <span>${player.name}${watchIndicator}</span>
                                </div>
                                <button onclick="showGhinModal('${player.name.replace(/'/g, "\\'")}', ${player.handicap}, ${actualPlayerIndex})" style="padding: 4px 8px; background: #1e40af; color: white; border: none; border-radius: 6px; font-size: 11px; font-weight: 700; cursor: pointer;">GHIN</button>
                                <div class="player-total-compact">${total > 0 ? total : '-'} (${toParText})</div>
                            </div>
                            
                            <div class="nine-section">
                                <div class="nine-section-label">
                                    <span>HOLES 1-6</span>
                                </div>
                                <div class="holes-grid-6">
                                    ${row1Cells}
                                </div>
                            </div>
                            
                            <div class="nine-section">
                                <div class="nine-section-label">
                                    <span>HOLES 7-12</span>
                                </div>
                                <div class="holes-grid-6">
                                    ${row2Cells}
                                </div>
                            </div>
                            
                            <div class="nine-section">
                                <div class="nine-section-label">
                                    <span>HOLES 13-18</span>
                                </div>
                                <div class="holes-grid-6">
                                    ${row3Cells}
                                </div>
                            </div>
                            
                            <div class="totals-row">
                                <div class="total-item">
                                    <div class="total-label">OUT</div>
                                    <div class="total-value">${front9 > 0 ? front9 : '-'}</div>
                                </div>
                                <div class="total-item">
                                    <div class="total-label">IN</div>
                                    <div class="total-value">${back9 > 0 ? back9 : '-'}</div>
                                </div>
                                <div class="total-item">
                                    <div class="total-label">TOTAL</div>
                                    <div class="total-value">${total > 0 ? total : '-'}</div>
                                </div>
                                <div class="total-item">
                                    <div class="total-label">TO PAR</div>
                                    <div class="total-value">${toParText}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Single player - no carousel needed
            if (playersToShow.length === 1) {
                container.innerHTML = `
                    <div style="padding: 0 8px;">
                        <div style="display: flex; justify-content: center; gap: 8px; padding: 6px 8px; background: rgba(255,255,255,0.95); border-radius: 10px; margin-bottom: 8px;">
                            <button id="fullscreenToggleBtn" onclick="toggleFullscreenPlayerView()" title="Toggle fullscreen" style="padding: 8px 14px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">â¶</button>
                        </div>
                        ${slidesHTML.replace('class="player-carousel-slide"', '')}
                    </div>
                `;
                return;
            }
            
            // Store players globally for nav access
            window.carouselPlayers = playersToShow;
            
            // Get prev/next player names for initial state (infinite wrap)
            const getFirstName = (name) => name ? name.split(' ')[0] : '';
            // At first player: prev wraps to last, next goes to second
            const prevPlayerName = playersToShow.length > 1 ? getFirstName(playersToShow[playersToShow.length - 1].name) : '';
            const nextPlayerName = playersToShow.length > 1 ? getFirstName(playersToShow[1].name) : '';
            
            // Multiple players - use carousel with player names in nav (infinite - always enabled)
            const carouselHTML = `
                <div class="carousel-nav" style="display: flex; align-items: center; justify-content: space-between; padding: 6px 8px; background: rgba(255,255,255,0.95); border-radius: 10px; margin: 0 8px 8px 8px; gap: 4px;">
                    <button class="carousel-nav-btn" id="carouselPrev" onclick="carouselPrev()" style="display: flex; align-items: center; gap: 3px; padding: 8px 10px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; flex: 1; justify-content: center; max-width: 110px;">
                        <span>â</span> <span id="prevPlayerName" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${prevPlayerName}</span>
                    </button>
                    <button onclick="showPlayerSearchModal()" title="Search players" style="padding: 8px 10px; background: #f1f5f9; border: 2px solid #e2e8f0; border-radius: 8px; cursor: pointer; font-size: 14px;">ð</button>
                    <button id="fullscreenToggleBtn" onclick="toggleFullscreenPlayerView()" title="Toggle fullscreen" style="padding: 8px 10px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">â¶</button>
                    <button class="carousel-nav-btn" id="carouselNext" onclick="carouselNext()" style="display: flex; align-items: center; gap: 3px; padding: 8px 10px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; flex: 1; justify-content: center; max-width: 110px;">
                        <span id="nextPlayerName" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${nextPlayerName}</span> <span>â</span>
                    </button>
                </div>
                <div class="player-carousel" id="playerCarousel">
                    <div class="player-carousel-track" id="carouselTrack">
                        ${slidesHTML}
                    </div>
                </div>
                <div class="carousel-dots" id="carouselDots">
                    ${playersToShow.map((_, idx) => `
                        <div class="carousel-dot ${idx === 0 ? 'active' : ''}" onclick="goToCarouselSlide(${idx})"></div>
                    `).join('')}
                </div>
            `;
            
            container.innerHTML = carouselHTML;
            
            // Setup swipe listeners
            const carousel = document.getElementById('playerCarousel');
            
            carousel.addEventListener('touchstart', (e) => {
                carouselTouchStartX = e.changedTouches[0].screenX;
            }, { passive: true });
            
            carousel.addEventListener('touchend', (e) => {
                carouselTouchEndX = e.changedTouches[0].screenX;
                handleCarouselSwipe();
            }, { passive: true });
            
            // Don't reset carousel index here - preserve position when re-rendering
            // currentCarouselIndex is preserved by updateScore before calling renderScoringPage
            updateCarouselNav();
        }
        
        // Player search modal
        function showPlayerSearchModal() {
            const players = window.carouselPlayers || [];
            if (players.length === 0) return;
            
            let listHTML = players.map((p, idx) => `
                <button onclick="goToCarouselSlide(${idx}); closePlayerSearchModal();" style="
                    display: block;
                    width: 100%;
                    padding: 14px 16px;
                    margin-bottom: 8px;
                    background: ${idx === currentCarouselIndex ? '#3b82f6' : '#f1f5f9'};
                    color: ${idx === currentCarouselIndex ? 'white' : '#1e293b'};
                    border: none;
                    border-radius: 8px;
                    font-size: 16px;
                    font-weight: 600;
                    text-align: left;
                    cursor: pointer;
                ">${p.name}</button>
            `).join('');
            
            const modal = document.createElement('div');
            modal.id = 'playerSearchModal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;';
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 20px; width: 100%; max-width: 320px; max-height: 70vh; overflow-y: auto;">
                    <h3 style="margin: 0 0 16px 0; color: #1e40af; font-size: 18px;">Jump to Player</h3>
                    ${listHTML}
                    <button onclick="closePlayerSearchModal()" style="width: 100%; padding: 14px; background: #e2e8f0; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 8px;">Cancel</button>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function closePlayerSearchModal() {
            const modal = document.getElementById('playerSearchModal');
            if (modal) modal.remove();
        }
        
        // Fullscreen state
        let isFullscreenPlayerView = false;
        
        function toggleFullscreenPlayerView() {
            const container = document.getElementById('playerCards');
            const scoringHeader = document.querySelector('.scoring-header');
            const btn = document.getElementById('fullscreenToggleBtn');
            
            if (isFullscreenPlayerView) {
                // Exit fullscreen
                container.style.position = '';
                container.style.top = '';
                container.style.left = '';
                container.style.right = '';
                container.style.bottom = '';
                container.style.zIndex = '';
                container.style.background = '';
                container.style.paddingTop = '';
                container.style.overflow = '';
                container.style.overflowY = '';
                container.style.overflowX = '';
                container.style.touchAction = '';
                container.classList.remove('fullscreen-mode');
                document.body.style.overflow = '';
                if (scoringHeader) scoringHeader.style.display = '';
                if (btn) btn.textContent = 'â¶';
                isFullscreenPlayerView = false;
            } else {
                // Enter fullscreen
                container.style.position = 'fixed';
                container.style.top = '0';
                container.style.left = '0';
                container.style.right = '0';
                container.style.bottom = '0';
                container.style.zIndex = '9999';
                container.style.background = 'linear-gradient(135deg, #059669 0%, #10b981 20%, #3b82f6 60%, #1e40af 100%)';
                container.style.paddingTop = '20px';
                container.style.overflow = 'hidden'; // Lock all scroll
                container.style.overflowY = 'hidden'; // Lock vertical scroll
                container.style.overflowX = 'hidden'; // Lock horizontal scroll (swipe handled by JS)
                container.style.touchAction = 'pan-x'; // Only allow horizontal touch
                container.classList.add('fullscreen-mode');
                document.body.style.overflow = 'hidden'; // Prevent body scroll
                if (scoringHeader) scoringHeader.style.display = 'none';
                if (btn) btn.textContent = 'â';
                isFullscreenPlayerView = true;
            }
        }
        
        // Handle compact cell click - voice or expanded view
        function handleCompactCellClick(playerIndex, holeIndex, currentScore, playerName) {
            // Check if this is a watched player (view only, no scoring) - doesn't apply to hosts/co-hosts
            if (tournamentMode === 'multi' && !canManageTournament()) {
                const player = tournamentData.players[playerIndex];
                // If player is not claimed by this device, they're being watched - no interaction
                if (player && player.claimedBy !== currentDeviceId) {
                    // Just viewing - no popup
                    return;
                }
            }
            
            if (inputMode === 'voice') {
                showVoiceListening(playerIndex, holeIndex);
            } else {
                showExpandedScoreInput(playerIndex, holeIndex, currentScore, playerName);
            }
        }
        
        // Expanded score input state
        let expandedTarget = null;
        let expandedCurrentScore = 0;
        
        // Putt tracking state
        let puttTarget = null; // { playerIndex, holeIndex }
        
        // Initialize putts array for a player if not exists
        function initPlayerPutts(player) {
            if (!player.putts) {
                player.putts = new Array(18).fill(null);
            }
        }
        
        // Show putt input popup
        function showPuttPopup(playerIndex, holeIndex) {
            const player = tournamentData.players[playerIndex];
            initPlayerPutts(player);
            
            puttTarget = { playerIndex, holeIndex };
            
            const hole = courseData.holes[holeIndex];
            const currentPutt = player.putts[holeIndex];
            
            document.getElementById('puttPopupInfo').textContent = `Hole ${holeIndex + 1} â¢ Par ${hole.par}`;
            
            // Generate putt option buttons (0-7 in 4x2 grid)
            let optionsHtml = '';
            for (let i = 0; i <= 7; i++) {
                const isSelected = currentPutt === i;
                optionsHtml += `<button class="putt-option-btn ${isSelected ? 'selected' : ''}" onclick="setPutt(${i})">${i}</button>`;
            }
            document.getElementById('puttOptions').innerHTML = optionsHtml;
            
            document.getElementById('puttPopup').classList.add('active');
        }
        
        // Set putt value and close popup
        function setPutt(value) {
            if (!puttTarget) return;
            
            const { playerIndex, holeIndex } = puttTarget;
            const player = tournamentData.players[playerIndex];
            initPlayerPutts(player);
            
            player.putts[holeIndex] = value;
            
            // Save and sync
            saveToLocalStorage();
            
            // Sync to Firebase if in multi-device mode
            if (activeTournamentId && tournamentMode === 'multi') {
                updatePlayerPutts(activeTournamentId, player.name, holeIndex, value);
            }
            
            closePuttPopup();
            
            // Refresh the current view
            if (currentView === 'hole') {
                renderHoleView();
            }
        }
        
        // Clear putt for current hole
        function clearPutt() {
            if (!puttTarget) return;
            
            const { playerIndex, holeIndex } = puttTarget;
            const player = tournamentData.players[playerIndex];
            initPlayerPutts(player);
            
            player.putts[holeIndex] = null;
            
            // Save and sync
            saveToLocalStorage();
            
            // Sync to Firebase if in multi-device mode
            if (activeTournamentId && tournamentMode === 'multi') {
                updatePlayerPutts(activeTournamentId, player.name, holeIndex, null);
            }
            
            closePuttPopup();
            
            // Refresh the current view
            if (currentView === 'hole') {
                renderHoleView();
            }
        }
        
        // Close putt popup
        function closePuttPopup() {
            document.getElementById('puttPopup').classList.remove('active');
            puttTarget = null;
        }
        
        // Update player putts in Firebase
        async function updatePlayerPutts(tournamentId, playerName, holeIndex, puttValue) {
            try {
                const tournamentRef = db.collection('tournaments').doc(tournamentId);
                const tournamentDoc = await tournamentRef.get();
                if (!tournamentDoc.exists) return;
                
                const tournament = tournamentDoc.data();
                const playerIndex = tournament.players.findIndex(p => p.name === playerName);
                
                if (playerIndex === -1) return;
                
                // Initialize putts array if needed
                if (!tournament.players[playerIndex].putts) {
                    tournament.players[playerIndex].putts = new Array(18).fill(null);
                }
                
                tournament.players[playerIndex].putts[holeIndex] = puttValue;
                
                await tournamentRef.update({
                    players: tournament.players,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                console.log(`â Putt synced: ${playerName} hole ${holeIndex + 1} = ${puttValue}`);
            } catch (error) {
                console.error('Error updating putts:', error);
            }
        }
        
        // Get total putts for a player (returns null if incomplete)
        function getPlayerTotalPutts(player) {
            if (!player.putts) return null;
            
            // Check if all 18 holes have putts entered
            for (let i = 0; i < 18; i++) {
                if (player.putts[i] === null || player.putts[i] === undefined) {
                    return null;
                }
            }
            
            // Sum all putts
            return player.putts.reduce((sum, p) => sum + (p || 0), 0);
        }
        
        // Check if any player has complete putt data
        function hasAnyCompletePuttData() {
            if (!tournamentData || !tournamentData.players) return false;
            
            return tournamentData.players.some(player => getPlayerTotalPutts(player) !== null);
        }
        
        // Get player stats totals from playerStats storage
        function getPlayerStatsForScorecard(playerName) {
            loadPlayerStatsFromLocalStorage();
            initPlayerStats(playerName);
            
            const stats = playerStats[playerName];
            if (!stats) return null;
            
            // Calculate FIR stats (exclude par 3s)
            let firHit = 0, firTotal = 0;
            for (let i = 0; i < 18; i++) {
                if (courseData.holes[i].par !== 3) {
                    if (stats.fir[i] !== null && stats.fir[i] !== undefined) {
                        firTotal++;
                        if (stats.fir[i] === true) firHit++;
                    }
                }
            }
            
            // Calculate GIR stats
            let girHit = 0, girTotal = 0;
            for (let i = 0; i < 18; i++) {
                if (stats.gir[i] !== null && stats.gir[i] !== undefined) {
                    girTotal++;
                    if (stats.gir[i] === true) girHit++;
                }
            }
            
            // Calculate Putts total
            let puttsTotal = 0, puttsCount = 0;
            for (let i = 0; i < 18; i++) {
                if (stats.putts[i] !== null && stats.putts[i] !== undefined) {
                    puttsTotal += stats.putts[i];
                    puttsCount++;
                }
            }
            
            // Calculate Dots total
            let dotsTotal = 0, dotsCount = 0;
            for (let i = 0; i < 18; i++) {
                if (stats.dots[i] !== null && stats.dots[i] !== undefined) {
                    dotsTotal += stats.dots[i];
                    dotsCount++;
                }
            }
            
            return {
                fir: firTotal > 0 ? { hit: firHit, total: firTotal } : null,
                gir: girTotal > 0 ? { hit: girHit, total: girTotal } : null,
                putts: puttsCount > 0 ? puttsTotal : null,
                dots: dotsCount > 0 ? dotsTotal : null,
                // Per-hole data for individual cards
                firByHole: stats.fir,
                girByHole: stats.gir,
                puttsByHole: stats.putts,
                dotsByHole: stats.dots
            };
        }
        
        // Check if any player has stats data for a specific stat type
        function hasAnyStatsData(statType) {
            if (!tournamentData || !tournamentData.players) return false;
            
            return tournamentData.players.some(player => {
                const stats = getPlayerStatsForScorecard(player.name);
                if (!stats) return false;
                
                if (statType === 'fir') return stats.fir !== null;
                if (statType === 'gir') return stats.gir !== null;
                if (statType === 'putts') return stats.putts !== null;
                if (statType === 'dots') return stats.dots !== null;
                return false;
            });
        }
        
        // Show expanded score input modal
        function showExpandedScoreInput(playerIndex, holeIndex, currentScore, playerName) {
            expandedTarget = { playerIndex, holeIndex };
            expandedCurrentScore = currentScore || 0;
            
            const hole = courseData.holes[holeIndex];
            const par = hole.par;
            
            document.getElementById('expandedHoleNumber').textContent = `HOLE ${hole.number}`;
            document.getElementById('expandedHoleInfo').textContent = `Par ${par} â¢ HCP ${hole.handicap}`;
            document.getElementById('expandedPlayerName').textContent = playerName;
            document.getElementById('expandedScoreValue').textContent = expandedCurrentScore || '-';
            
            // Generate quick score buttons based on par (8 buttons: Eagle through +5)
            const quickScores = document.getElementById('expandedQuickScores');
            let quickHTML = '';
            for (let s = Math.max(1, par - 2); s <= par + 5; s++) {
                const label = s === par - 2 ? `${s} (Eagle)` : 
                              s === par - 1 ? `${s} (Birdie)` : 
                              s === par ? `${s} (Par)` : 
                              s === par + 1 ? `${s} (Bogey)` : 
                              s === par + 2 ? `${s} (Dbl)` :
                              s === par + 3 ? `${s} (Trpl)` :
                              s === par + 4 ? `${s} (Quad)` :
                              s === par + 5 ? `${s} (Qunt)` : s;
                quickHTML += `<button class="quick-score-btn" onclick="setExpandedScore(${s})">${label}</button>`;
            }
            quickScores.innerHTML = quickHTML;
            
            document.getElementById('expandedScoreModal').classList.add('active');
        }
        
        function closeExpandedScore() {
            document.getElementById('expandedScoreModal').classList.remove('active');
            expandedTarget = null;
        }
        
        // Quick score tap - auto save and close immediately
        async function setExpandedScore(score) {
            expandedCurrentScore = score;
            document.getElementById('expandedScoreValue').textContent = score;
            
            // Auto-save and close for quick score taps
            if (expandedTarget && score > 0) {
                // Capture values BEFORE closing (in case async operations are slow)
                const playerIndex = expandedTarget.playerIndex;
                const holeIndex = expandedTarget.holeIndex;
                const savedCarouselIndex = currentCarouselIndex;
                
                // Close modal first for responsive feel
                closeExpandedScore();
                
                // AWAIT the save to ensure it completes before re-rendering
                await updateScore(playerIndex, holeIndex, score);
                
                // Refresh the current view but stay on current player
                if (currentView === 'hole') {
                    renderHoleView();
                } else {
                    renderCompactPlayerView(getPlayersToShow());
                    // Restore carousel position
                    currentCarouselIndex = savedCarouselIndex;
                    updateCarouselPosition();
                }
            }
        }
        
        function expandedIncrement() {
            if (expandedCurrentScore < 15) {
                expandedCurrentScore++;
                document.getElementById('expandedScoreValue').textContent = expandedCurrentScore;
            }
        }
        
        function expandedDecrement() {
            if (expandedCurrentScore > 0) {
                expandedCurrentScore--;
                document.getElementById('expandedScoreValue').textContent = expandedCurrentScore || '-';
            }
        }
        
        // Manual save - for when user adjusts with +/- buttons or wants to clear
        async function saveExpandedScore() {
            if (expandedTarget) {
                const savedCarouselIndex = currentCarouselIndex;
                const playerIndex = expandedTarget.playerIndex;
                const holeIndex = expandedTarget.holeIndex;
                const scoreToSave = expandedCurrentScore;
                
                // Close modal first for responsive feel
                closeExpandedScore();
                
                if (scoreToSave > 0) {
                    // AWAIT the save to ensure it completes
                    await updateScore(playerIndex, holeIndex, scoreToSave);
                } else {
                    // Clear the score (set to 0/null)
                    tournamentData.players[playerIndex].scores[holeIndex] = 0;
                    saveToLocalStorage();
                    
                    // Also sync to Firebase if in multi-device mode
                    if (activeTournamentId && tournamentMode === 'multi') {
                        const playerName = tournamentData.players[playerIndex].name;
                        await updatePlayerScore(activeTournamentId, playerName, holeIndex, 0);
                    }
                }
                
                // Refresh the current view but stay on current player
                if (currentView === 'hole') {
                    renderHoleView();
                } else {
                    renderCompactPlayerView(getPlayersToShow());
                    // Restore carousel position
                    currentCarouselIndex = savedCarouselIndex;
                    updateCarouselPosition();
                }
            } else {
                closeExpandedScore();
            }
        }
        
        // Initialize player carousel for swipe navigation
        
        function handleCarouselSwipe() {
            const swipeThreshold = 50;
            const diff = carouselTouchStartX - carouselTouchEndX;
            
            if (Math.abs(diff) > swipeThreshold) {
                if (diff > 0) {
                    // Swiped left - go next
                    carouselNext();
                } else {
                    // Swiped right - go prev
                    carouselPrev();
                }
            }
        }
        
        function carouselNext() {
            const track = document.getElementById('carouselTrack');
            const slides = track?.querySelectorAll('.player-carousel-slide');
            if (!slides || slides.length === 0) return;
            
            // Infinite wrap - go to first if at end
            if (currentCarouselIndex >= slides.length - 1) {
                currentCarouselIndex = 0;
            } else {
                currentCarouselIndex++;
            }
            updateCarouselPosition();
        }
        
        function carouselPrev() {
            const track = document.getElementById('carouselTrack');
            const slides = track?.querySelectorAll('.player-carousel-slide');
            if (!slides || slides.length === 0) return;
            
            // Infinite wrap - go to last if at beginning
            if (currentCarouselIndex <= 0) {
                currentCarouselIndex = slides.length - 1;
            } else {
                currentCarouselIndex--;
            }
            updateCarouselPosition();
        }
        
        function goToCarouselSlide(index) {
            const track = document.getElementById('carouselTrack');
            const slides = track?.querySelectorAll('.player-carousel-slide');
            if (!slides || index < 0 || index >= slides.length) return;
            
            currentCarouselIndex = index;
            updateCarouselPosition();
        }
        
        function resetCarousel() {
            currentCarouselIndex = 0;
            updateCarouselPosition();
        }
        
        function updateCarouselPosition() {
            const track = document.getElementById('carouselTrack');
            const slides = track?.querySelectorAll('.player-carousel-slide');
            if (!track || !slides) return;
            
            // Move track
            track.style.transform = `translateX(-${currentCarouselIndex * 100}%)`;
            
            // Update dots
            const dots = document.querySelectorAll('.carousel-dot');
            dots.forEach((dot, idx) => {
                dot.classList.toggle('active', idx === currentCarouselIndex);
            });
            
            // Update nav buttons with player names
            updateCarouselNav();
        }
        
        function updateCarouselNav() {
            const players = window.carouselPlayers || [];
            if (players.length === 0) return;
            
            const prevBtn = document.getElementById('carouselPrev');
            const nextBtn = document.getElementById('carouselNext');
            const prevName = document.getElementById('prevPlayerName');
            const nextName = document.getElementById('nextPlayerName');
            
            // Infinite carousel - buttons always enabled
            if (prevBtn) {
                prevBtn.disabled = false;
                prevBtn.style.opacity = '1';
            }
            if (nextBtn) {
                nextBtn.disabled = false;
                nextBtn.style.opacity = '1';
            }
            
            // Update player names in nav buttons (wrap around)
            if (prevName && players.length > 0) {
                // Previous player wraps to last if at beginning
                const prevIndex = currentCarouselIndex === 0 ? players.length - 1 : currentCarouselIndex - 1;
                const prevPlayer = players[prevIndex];
                prevName.textContent = prevPlayer ? prevPlayer.name.split(' ')[0] : '';
            }
            if (nextName && players.length > 0) {
                // Next player wraps to first if at end
                const nextIndex = currentCarouselIndex >= players.length - 1 ? 0 : currentCarouselIndex + 1;
                const nextPlayer = players[nextIndex];
                nextName.textContent = nextPlayer ? nextPlayer.name.split(' ')[0] : '';
            }
        }

        // Switch to hole view
        function switchToHoleView() {
            currentView = 'hole';
            document.getElementById('playerCards').style.display = 'none';
            document.getElementById('holeView').style.display = 'block';
            
            // Update toggle button visual state
            const holeBtn = document.getElementById('toggleHoleView');
            const playerBtn = document.getElementById('togglePlayerView');
            if (holeBtn) {
                holeBtn.classList.add('active');
                holeBtn.style.background = '#3b82f6';
                holeBtn.style.color = 'white';
            }
            if (playerBtn) {
                playerBtn.classList.remove('active');
                playerBtn.style.background = 'transparent';
                playerBtn.style.color = '#64748b';
            }
            
            renderHoleView();
        }

        // Render hole view
        async function renderHoleView() {
            console.log('=== RENDER HOLE VIEW CALLED ===');
            console.log('tournamentData:', tournamentData);
            console.log('tournamentData.players:', tournamentData?.players);
            console.log('currentHole:', currentHole);
            console.log('courseData:', courseData);
            console.log('isHost:', isHost, 'tournamentMode:', tournamentMode);
            
            // Safety check for tournament data
            if (!tournamentData || !tournamentData.players || tournamentData.players.length === 0) {
                console.error('â No tournament data or players available');
                document.getElementById('holeViewContent').innerHTML = '<p style="text-align:center;padding:20px;">No players found. Go back and add players.</p>';
                return;
            }
            
            // Safety check for course data - try multiple sources
            if (!courseData || !courseData.holes) {
                console.error('â No course data available, attempting to load...');
                console.log('Looking for course:', tournamentData.course);
                console.log('Built-in courses available:', Object.keys(courses));
                
                // Try built-in courses first
                courseData = courses[tournamentData.course];
                console.log('From built-in courses:', !!courseData);
                
                // Try custom courses
                if (!courseData) {
                    courseData = customCourses[tournamentData.course];
                    console.log('From custom courses:', !!courseData);
                }
                
                // Try embedded course data from tournament
                if (!courseData && tournamentData.courseData) {
                    console.log('ð Loading course data from tournament embed');
                    courseData = tournamentData.courseData;
                    customCourses[tournamentData.course] = tournamentData.courseData;
                }
                
                // For API courses, try to fetch directly from Golf API
                if (!courseData && tournamentData.course && tournamentData.course.startsWith('api_')) {
                    const apiCourseId = tournamentData.course.replace('api_', '');
                    console.log('ð Attempting to fetch from Golf API for course:', apiCourseId);
                    try {
                        const response = await fetch(`https://api.golfcourseapi.com/v1/courses/${apiCourseId}`, {
                            headers: { 'Authorization': `Key ${GOLF_API_KEY}` }
                        });
                        if (response.ok) {
                            const data = await response.json();
                            const course = data.course || data;
                            console.log('â Got course from Golf API:', course.club_name);
                            
                            // Convert to our format
                            const convertedCourse = {
                                name: course.club_name || course.course_name,
                                totalPar: 72,
                                tees: {},
                                holes: []
                            };
                            
                            let teesArray = course.tees?.male || course.tees?.female || (Array.isArray(course.tees) ? course.tees : []);
                            let holesFromTee = null;
                            
                            teesArray.forEach(tee => {
                                const teeKey = tee.tee_name?.toLowerCase().replace(/\s+/g, '_') || 'default';
                                convertedCourse.tees[teeKey] = {
                                    name: tee.tee_name || 'Default',
                                    rating: parseFloat(tee.course_rating) || 72,
                                    slope: parseInt(tee.slope_rating) || 113,
                                    yardage: parseInt(tee.total_yards) || 6000,
                                    par: parseInt(tee.par_total) || 72
                                };
                                if (!holesFromTee && tee.holes?.length > 0) {
                                    holesFromTee = tee.holes;
                                }
                            });
                            
                            if (Object.keys(convertedCourse.tees).length === 0) {
                                convertedCourse.tees.default = { name: 'Default', rating: 72, slope: 113, yardage: 6000, par: 72 };
                            }
                            convertedCourse.defaultTee = Object.keys(convertedCourse.tees)[0];
                            
                            if (holesFromTee?.length > 0) {
                                convertedCourse.holes = holesFromTee.map((h, i) => ({
                                    number: i + 1,
                                    par: parseInt(h.par) || 4,
                                    handicap: parseInt(h.handicap) || (i + 1)
                                }));
                                convertedCourse.totalPar = convertedCourse.holes.reduce((sum, h) => sum + h.par, 0);
                            } else {
                                const defaultPars = [4,4,3,4,5,4,3,4,5,4,4,3,4,5,4,3,4,4];
                                for (let i = 0; i < 18; i++) {
                                    convertedCourse.holes.push({ number: i + 1, par: defaultPars[i] || 4, handicap: i + 1 });
                                }
                            }
                            
                            courseData = convertedCourse;
                            customCourses[tournamentData.course] = convertedCourse;
                            tournamentData.courseData = convertedCourse;
                            
                            // Also update Firebase with this course data for future use
                            if (activeTournamentId) {
                                db.collection('tournaments').doc(activeTournamentId).update({
                                    courseData: convertedCourse
                                }).catch(e => console.log('Could not update Firebase with courseData:', e));
                            }
                            
                            // Re-render now that we have data
                            renderHoleView();
                            return;
                        }
                    } catch (apiErr) {
                        console.error('Golf API fetch error:', apiErr);
                    }
                }
                
                // Final check
                if (!courseData || !courseData.holes) {
                    console.error('â Could not load course data for:', tournamentData.course);
                    console.log('tournamentData.courseData:', tournamentData.courseData);
                    console.log('customCourses keys:', Object.keys(customCourses));
                    
                    // Last resort: Try to fetch from Firebase directly
                    if (activeTournamentId) {
                        console.log('ð Attempting to fetch courseData from Firebase...');
                        try {
                            const doc = await db.collection('tournaments').doc(activeTournamentId).get();
                            if (doc.exists) {
                                const fbTournament = doc.data();
                                if (fbTournament.courseData && fbTournament.courseData.holes) {
                                    console.log('â Got courseData from Firebase!');
                                    courseData = fbTournament.courseData;
                                    customCourses[tournamentData.course] = fbTournament.courseData;
                                    tournamentData.courseData = fbTournament.courseData;
                                    // Re-render now that we have data
                                    renderHoleView();
                                    return;
                                }
                            }
                        } catch (err) {
                            console.error('Firebase fetch error:', err);
                        }
                    }
                    
                    document.getElementById('holeViewContent').innerHTML = `
                        <div style="text-align:center;padding:20px;">
                            <p>Course data not loaded.</p>
                            <p style="font-size: 12px; color: #64748b; margin-top: 8px;">Course: ${tournamentData.course || 'Unknown'}</p>
                            <button onclick="location.reload()" style="margin-top: 12px; padding: 10px 20px; background: #3b82f6; color: white; border: none; border-radius: 8px; cursor: pointer;">
                                Reload Page
                            </button>
                        </div>
                    `;
                    return;
                }
            }
            
            const hole = courseData.holes[currentHole];
            const holeNumber = currentHole + 1;
            
            // Calculate prev/next for infinite carousel
            const prevHole = currentHole === 0 ? 18 : currentHole;
            const nextHole = currentHole === 17 ? 1 : currentHole + 2;
            
            // Check if this hole has notes
            const hasNotes = getCourseNote(tournamentData.course, holeNumber);
            const notesButtonStyle = hasNotes 
                ? 'background: #fbbf24; color: #78350f; border: 2px solid #f59e0b;' 
                : 'background: white; color: #64748b; border: 2px solid #e2e8f0;';
            
            // Auto-advance button style
            const autoAdvanceStyle = autoAdvanceEnabled
                ? 'background: #10b981; color: white; border: 2px solid #059669;'
                : 'background: white; color: #64748b; border: 2px solid #e2e8f0;';
            
            let html = `
                <div class="hole-view-container" id="holeViewContainer">
                    <div class="hole-header">
                        <div class="hole-nav-top">
                            <button type="button" class="hole-nav-btn-compact" onclick="goToPrevHole()">
                                â ${prevHole}
                            </button>
                            <button type="button" onclick="event.stopPropagation(); toggleAutoAdvance(); renderHoleView();" style="padding: 6px 10px; border-radius: 8px; font-size: 14px; cursor: pointer; ${autoAdvanceStyle}" title="${autoAdvanceEnabled ? 'Auto-advance ON - tap to disable' : 'Auto-advance OFF - tap to enable'}">â­ï¸</button>
                            <div class="hole-title-section" onclick="showHoleJumpModal()">
                                <div class="hole-number">HOLE ${holeNumber}</div>
                                <div class="hole-info">Par ${hole.par} â¢ HCP ${hole.handicap}</div>
                            </div>
                            <button type="button" onclick="event.stopPropagation(); showCourseNoteModal(${holeNumber})" style="padding: 6px 10px; border-radius: 8px; font-size: 14px; cursor: pointer; ${notesButtonStyle}" title="${hasNotes ? 'View/Edit Notes' : 'Add Notes'}">ð</button>
                            <button type="button" class="hole-nav-btn-compact" onclick="goToNextHole()">
                                ${nextHole} â
                            </button>
                        </div>
                    </div>
            `;
            
            // Determine net scoring method from game type
            // ALWAYS show net scores, using full handicap by default
            let netMethod = 'full'; // Default to full handicap
            const gameTypeLower = tournamentData.gameType.toLowerCase();
            
            // Override with specific methods if applicable
            if (gameTypeLower.includes('18 max')) {
                netMethod = '18max';
            } else if (gameTypeLower.includes('1/2 pop') || gameTypeLower.includes('half pop')) {
                netMethod = 'half';
            }
            // Otherwise stays as 'full' for all other games
            
            console.log('renderHoleView - gameType:', tournamentData.gameType);
            console.log('renderHoleView - netMethod:', netMethod);
            
            // Filter players based on multi-device mode and claims (same as scoring page)
            let playersToShow = tournamentData.players;
            
            // Show filtered view for non-hosts OR when host is in player mode
            if (tournamentMode === 'multi' && (!canManageTournament() || isHostInPlayerMode())) {
                // Non-hosts/non-co-hosts (or host in player mode) only see their claimed players AND watched players
                const claimedPlayers = tournamentData.players.filter(p => p.claimedBy === currentDeviceId);
                const watchedPlayers = tournamentData.players.filter(p => 
                    playerOrder.watching && playerOrder.watching.includes(p.name) && p.claimedBy !== currentDeviceId
                );
                
                // Sort each group by their saved order
                const sortedClaimed = sortPlayersByOrder(claimedPlayers, playerOrder.claimed || []);
                const sortedWatched = sortPlayersByOrder(watchedPlayers, playerOrder.watching || []);
                
                // Claimed players first, then watched players
                playersToShow = [...sortedClaimed, ...sortedWatched];
                console.log('ð Hole View - Claimed players:', sortedClaimed.map(p => p.name));
                console.log('ð Hole View - Watched players:', sortedWatched.map(p => p.name));
                
                // DON'T fallback - show message if no claims
                if (playersToShow.length === 0) {
                    console.log('â¹ï¸ No claimed/watched players');
                    document.getElementById('holeViewContent').innerHTML = `
                        <div style="text-align: center; padding: 40px 20px;">
                            <div style="font-size: 48px; margin-bottom: 16px;">ð¤</div>
                            <h3 style="color: #1e40af; margin-bottom: 8px;">No Players to Score</h3>
                            <p style="color: #64748b; margin-bottom: 20px;">Claim or watch players to see their scorecards here.</p>
                            <button onclick="showMyPlayersPage()" style="padding: 12px 24px; background: #f59e0b; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                                ð¤ Go to My Players
                            </button>
                        </div>
                    `;
                    return;
                }
            }
            
            // Add player rows with inline ticker
            playersToShow.forEach((player, index) => {
                // Get actual index in full players array for score updates
                const playerIndex = tournamentData.players.indexOf(player);
                
                const score = player.scores[currentHole]; // Don't default to par - allow blank
                const hasScore = score !== undefined && score !== null && score !== 0;
                const displayScore = hasScore ? score : '';
                
                let scoreClass = '';
                
                if (hasScore) {
                    const diff = score - hole.par;
                    
                    if (diff >= 2) {
                        scoreClass = 'double-bogey-plus';
                    } else if (diff === 1) {
                        scoreClass = 'bogey';
                    } else if (diff === 0) {
                        scoreClass = 'par'; // Add par class
                    } else if (diff <= -1) {
                        scoreClass = 'birdie-better';
                    }
                }
                
                // Calculate handicap dots
                let hcpDotsHtml = '';
                if (player.handicap !== 0) {
                    const strokes = getHandicapStrokesForHole(player.handicap, hole.handicap, netMethod);
                    if (strokes !== 0) {
                        const isHalfPop = netMethod === 'half';
                        const dotCount = isHalfPop ? Math.abs(strokes * 2) : Math.abs(strokes); // For half pop, show dots for half strokes
                        const dotColor = strokes > 0 ? 'green' : 'red'; // Green = subtract (getting strokes), Red = add (plus handicap)
                        
                        hcpDotsHtml = '<div class="hole-hcp-dots">';
                        for (let d = 0; d < Math.min(dotCount, 4); d++) {
                            hcpDotsHtml += `<div class="hcp-dot ${dotColor}"></div>`;
                        }
                        hcpDotsHtml += '</div>';
                    }
                }
                
                // Check if this is a watched player (view only)
                // Hosts/co-hosts in HOST mode can edit all players
                // Hosts/co-hosts in PLAYER mode can only edit their claimed players
                // Regular players can only edit their claimed players
                const isHostInHostMode = canManageTournament() && !isHostInPlayerMode();
                const isMyClaimedPlayer = player.claimedBy === currentDeviceId;
                const isWatchedPlayer = tournamentMode === 'multi' && !isHostInHostMode && !isMyClaimedPlayer;
                
                // Load player stats
                loadStatsConfig();
                loadPlayerStatsFromLocalStorage();
                initPlayerStats(player.name);
                const playerStatsData = playerStats[player.name];
                const statTotals = getPlayerStatTotals(player.name);
                
                // Check if any stats are enabled
                const anyStatsEnabled = statsTrackerConfig.putts || statsTrackerConfig.dots || statsTrackerConfig.fir || statsTrackerConfig.gir;
                
                // FIR is not applicable on par 3s
                const isPar3 = hole.par === 3;
                
                // Build stats row HTML for claimed players - Order: FIR, GIR, Putts, Dots - compact for single row
                let statsRowHtml = '';
                if (!isWatchedPlayer && anyStatsEnabled) {
                    statsRowHtml = `<div style="display: flex; gap: 4px; flex-wrap: nowrap;">`;
                    
                    // FIR stat box (not on par 3s) - 3-state toggle: green checkmark -> red X -> white bullseye
                    if (statsTrackerConfig.fir && !isPar3) {
                        const firVal = playerStatsData.fir[currentHole];
                        const hasFirStat = firVal !== null && firVal !== undefined;
                        const firBg = firVal === true ? '#10b981' : firVal === false ? '#ef4444' : 'white';
                        const firBorder = firVal === true ? '#10b981' : firVal === false ? '#ef4444' : '#94a3b8';
                        const firIcon = firVal === true ? 'â' : firVal === false ? 'â' : 'ð¯';
                        statsRowHtml += `
                            <div style="display: flex; flex-direction: column; align-items: center;">
                                <span style="font-size: 9px; color: #374151; font-weight: 600;">FIR</span>
                                <button onclick="event.stopPropagation(); toggleBooleanStat('${player.name}', 'fir', ${currentHole})" 
                                    style="width: 34px; height: 34px; border-radius: 6px; border: 2px solid ${firBorder}; background: ${firBg}; color: ${hasFirStat ? 'white' : '#1e293b'}; font-size: 14px; font-weight: 700; cursor: pointer; padding: 0;">
                                    ${firIcon}
                                </button>
                                <span style="font-size: 9px; color: #374151; font-weight: 500;">${statTotals.firHit}/${statTotals.firTotal}</span>
                            </div>
                        `;
                    }
                    
                    // GIR stat box - 3-state toggle
                    if (statsTrackerConfig.gir) {
                        const girVal = playerStatsData.gir[currentHole];
                        const hasGirStat = girVal !== null && girVal !== undefined;
                        const girBg = girVal === true ? '#10b981' : girVal === false ? '#ef4444' : 'white';
                        const girBorder = girVal === true ? '#10b981' : girVal === false ? '#ef4444' : '#94a3b8';
                        const girIcon = girVal === true ? 'â' : girVal === false ? 'â' : 'ð¯';
                        statsRowHtml += `
                            <div style="display: flex; flex-direction: column; align-items: center;">
                                <span style="font-size: 9px; color: #374151; font-weight: 600;">GIR</span>
                                <button onclick="event.stopPropagation(); toggleBooleanStat('${player.name}', 'gir', ${currentHole})" 
                                    style="width: 34px; height: 34px; border-radius: 6px; border: 2px solid ${girBorder}; background: ${girBg}; color: ${hasGirStat ? 'white' : '#1e293b'}; font-size: 14px; font-weight: 700; cursor: pointer; padding: 0;">
                                    ${girIcon}
                                </button>
                                <span style="font-size: 9px; color: #374151; font-weight: 500;">${statTotals.girHit}/${statTotals.girTotal}</span>
                            </div>
                        `;
                    }
                    
                    // Putts stat box - 0-2 green, 3+ red, show number
                    if (statsTrackerConfig.putts) {
                        const puttVal = playerStatsData.putts[currentHole];
                        const hasPuttStat = puttVal !== null && puttVal !== undefined;
                        let puttBg = 'white';
                        let puttBorder = '#94a3b8';
                        let puttColor = '#374151';
                        if (hasPuttStat) {
                            if (puttVal <= 2) {
                                puttBg = '#10b981'; // Green for 0-2
                                puttBorder = '#10b981';
                                puttColor = 'white';
                            } else {
                                puttBg = '#ef4444'; // Red for 3+
                                puttBorder = '#ef4444';
                                puttColor = 'white';
                            }
                        }
                        statsRowHtml += `
                            <div style="display: flex; flex-direction: column; align-items: center;">
                                <span style="font-size: 9px; color: #374151; font-weight: 600;">PUTT</span>
                                <button onclick="event.stopPropagation(); showStatPopup('${player.name}', 'putts', ${currentHole})" 
                                    style="width: 34px; height: 34px; border-radius: 6px; border: 2px solid ${puttBorder}; background: ${puttBg}; color: ${puttColor}; font-size: ${hasPuttStat ? '14px' : '12px'}; font-weight: 700; cursor: pointer; padding: 0;">
                                    ${hasPuttStat ? puttVal : 'â³'}
                                </button>
                                <span style="font-size: 9px; color: #374151; font-weight: 500;">${statTotals.puttsTotal}</span>
                            </div>
                        `;
                    }
                    
                    // Dots stat box - red for 0, green for 1+, white icon/number when filled
                    if (statsTrackerConfig.dots) {
                        const dotVal = playerStatsData.dots[currentHole];
                        const hasDotStat = dotVal !== null && dotVal !== undefined;
                        const dotIcon = hasDotStat ? dotVal : 'â';
                        let dotBg = 'white';
                        let dotBorder = '#94a3b8';
                        let dotColor = '#10b981';
                        if (hasDotStat) {
                            if (dotVal === 0) {
                                dotBg = '#ef4444'; // Red for 0
                                dotBorder = '#ef4444';
                                dotColor = 'white';
                            } else {
                                dotBg = '#10b981'; // Green for 1+
                                dotBorder = '#10b981';
                                dotColor = 'white';
                            }
                        }
                        statsRowHtml += `
                            <div style="display: flex; flex-direction: column; align-items: center;">
                                <span style="font-size: 9px; color: #374151; font-weight: 600;">DOT</span>
                                <button onclick="event.stopPropagation(); showStatPopup('${player.name}', 'dots', ${currentHole})" 
                                    style="width: 34px; height: 34px; border-radius: 6px; border: 2px solid ${dotBorder}; background: ${dotBg}; color: ${dotColor}; font-size: ${hasDotStat ? '14px' : '16px'}; font-weight: 700; cursor: pointer; padding: 0;">
                                    ${dotIcon}
                                </button>
                                <span style="font-size: 9px; color: #374151; font-weight: 500;">${statTotals.dotsTotal}</span>
                            </div>
                        `;
                    }
                    
                    statsRowHtml += `</div>`;
                }
                
                // Calculate running totals for bottom row
                const runningGross = player.scores.slice(0, currentHole + 1).reduce((sum, s) => sum + (s || 0), 0);
                const coursePar = courseData.holes.slice(0, currentHole + 1).reduce((sum, h) => sum + h.par, 0);
                const runningToPar = runningGross - coursePar;
                const toParDisplay = runningToPar === 0 ? 'E' : (runningToPar > 0 ? '+' + runningToPar : runningToPar);
                
                // Calculate running net total using current scoring method
                let runningNet = 0;
                let netStrokesUsed = 0;
                for (let h = 0; h <= currentHole; h++) {
                    const holeScore = player.scores[h] || 0;
                    if (holeScore > 0) {
                        const holeData = courseData.holes[h];
                        const netScore = getNetScore(holeScore, player.handicap, holeData.handicap, netMethod);
                        runningNet += netScore;
                        netStrokesUsed += (holeScore - netScore);
                    }
                }
                const netToPar = runningNet - coursePar;
                const netToParDisplay = netToPar === 0 ? 'E' : (netToPar > 0 ? '+' + netToPar : netToPar);
                
                // Calculate net score for display
                let netScoreDisplay = '';
                if (hasScore && netMethod) {
                    const netScore = getNetScore(score, player.handicap, hole.handicap, netMethod);
                    netScoreDisplay = `<div class="hole-net-score">${netScore}</div>`;
                }
                
                // Build running totals HTML - only show if player has entered a score on THIS hole
                let runningTotalsHtml = '';
                if (hasScore) {
                    runningTotalsHtml = `
                        <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 0px; margin-top: 4px;">
                            <span style="font-size: 11px; color: #1e40af; font-weight: 600;">Gross: ${runningGross} (${toParDisplay})</span>
                            <span style="font-size: 11px; color: #64748b; font-weight: 600;">Net: ${runningNet} (${netToParDisplay})</span>
                        </div>
                    `;
                }
                
                // Build the player row with layout:
                // LEFT: Name, HCP, Stats (vertically stacked)
                // RIGHT: Scores at top, Running totals below
                html += `
                    <div class="hole-player-row-ticker ${isWatchedPlayer ? 'watch-only' : ''}" style="padding: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                            <!-- LEFT: Name, HCP, Stats vertically stacked -->
                            <div style="display: flex; flex-direction: column;">
                                <div class="hole-player-name" style="font-size: 17px; font-weight: 700; color: #1e293b;">${player.name}${isWatchedPlayer ? ' ð' : ''}</div>
                                <div class="hole-player-hcp" style="font-size: 12px; color: #64748b; margin-bottom: 8px;">HCP: ${player.handicap > 0 ? player.handicap : player.handicap < 0 ? '+' + Math.abs(player.handicap) : '0'}</div>
                                ${!isWatchedPlayer && anyStatsEnabled ? statsRowHtml : ''}
                            </div>
                            
                            <!-- RIGHT: Scores and Running Totals -->
                            <div style="display: flex; flex-direction: column; align-items: flex-end;">
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    ${isWatchedPlayer ? `
                                        <div class="hole-score-display" style="display: flex; align-items: center; gap: 4px;">
                                            ${hcpDotsHtml}
                                            <div class="score-input ${scoreClass}" style="pointer-events: none; width: 52px; height: 52px; font-size: 24px; display: flex; align-items: center; justify-content: center; border-radius: 50%; background: ${hasScore ? '' : '#e2e8f0'};">
                                                ${displayScore || 'â'}
                                            </div>
                                        </div>
                                    ` : `
                                        <div class="hole-score-ticker" style="display: flex; align-items: center; gap: 4px;">
                                            ${hcpDotsHtml}
                                            <input type="number" 
                                                   class="score-input ${scoreClass}" 
                                                   id="holeScore_${playerIndex}_${currentHole}"
                                                   value="${displayScore}" 
                                                   placeholder="â"
                                                   readonly
                                                   onclick="handleHoleInputFocus(${playerIndex}, ${currentHole}, this)"
                                                   style="width: 56px; height: 56px; font-size: 26px; text-align: center; cursor: pointer;">
                                        </div>
                                    `}
                                    ${netScoreDisplay}
                                </div>
                                ${runningTotalsHtml}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            // Close container
            html += `
                </div>
            `;
            
            document.getElementById('holeViewContent').innerHTML = html;
            setupHoleViewSwipe();
        }

        // Handle input focus in hole view - voice or touch based on mode
        function handleHoleInputFocus(playerIndex, holeIndex, inputElement) {
            // Always blur to prevent keyboard
            inputElement.blur();
            
            // If voice mode, use voice input
            if (inputMode === 'voice') {
                showVoiceListening(playerIndex, holeIndex);
                return;
            }
            
            // Touch mode - use expanded input modal
            const currentScore = tournamentData.players[playerIndex].scores[holeIndex] || 0;
            const playerName = tournamentData.players[playerIndex].name;
            showExpandedScoreInput(playerIndex, holeIndex, currentScore, playerName);
        }

        // Adjust score directly in hole view (inline ticker)
        async function adjustHoleScoreDirect(playerIndex, holeIndex, delta) {
            console.log('=== ADJUST HOLE SCORE CALLED ===');
            console.log('playerIndex:', playerIndex, 'holeIndex:', holeIndex, 'delta:', delta);
            
            const currentScore = tournamentData.players[playerIndex].scores[holeIndex];
            const hole = courseData.holes[holeIndex];
            let newScore;
            
            console.log('Current score:', currentScore);
            console.log('Player:', tournamentData.players[playerIndex].name);
            
            // If no score yet (blank), first press sets to par
            if (currentScore === undefined || currentScore === null || currentScore === 0) {
                newScore = hole.par;
            } else {
                // Score exists, adjust by delta
                if (delta > 0) {
                    newScore = currentScore + 1;
                } else {
                    newScore = Math.max(currentScore - 1, 1); // Min score is 1
                }
            }
            
            console.log('New score:', newScore);
            
            tournamentData.players[playerIndex].scores[holeIndex] = newScore;
            
            // IMMEDIATE SAVE with verification
            console.log('ð¾ Attempting localStorage save...');
            const saveSuccess = saveToLocalStorage();
            console.log('ð¾ Save result:', saveSuccess);
            
            // VERIFY the score was actually saved
            if (saveSuccess) {
                const verified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                if (!verified) {
                    console.error('â HOLE VIEW: Score verification failed! Retrying save...');
                    tournamentData.players[playerIndex].scores[holeIndex] = newScore;
                    const retrySuccess = saveToLocalStorage();
                    console.log('ð¾ Retry save result:', retrySuccess);
                    
                    // Verify again
                    const reVerified = await verifyScoreSaved(playerIndex, holeIndex, newScore);
                    if (!reVerified) {
                        console.error('ð¨ CRITICAL: Score still not saved after retry!');
                        // Don't alert - just log. Score is in Firebase anyway.
                    }
                }
            } else {
                console.error('ð¨ CRITICAL: Initial save failed!');
                // Don't alert - just log. Score is in Firebase anyway.
            }
            
            // Sync to Firebase if in multi-device mode
            if (activeTournamentId && tournamentMode === 'multi') {
                const playerName = tournamentData.players[playerIndex].name;
                console.log('ð¥ FIREBASE SYNC STARTING');
                console.log('   Player:', playerName);
                console.log('   Hole:', holeIndex + 1);
                console.log('   Score:', newScore);
                
                updatePlayerScore(activeTournamentId, playerName, holeIndex, newScore);
            } else {
                console.log('â¹ï¸ Skipping Firebase sync (single-device mode)');
            }
            
            // Update hole view
            updateHoleViewScore(playerIndex, holeIndex, newScore);
            
            // Update player view if visible
            renderScoringPage();
        }

        // Helper function to update hole view score display
        function updateHoleViewScore(playerIndex, holeIndex, newScore) {
            const input = document.getElementById(`holeScore_${playerIndex}_${holeIndex}`);
            if (!input) return;
            
            input.value = newScore;
            
            // Update color class
            const hole = courseData.holes[holeIndex];
            const diff = newScore - hole.par;
            
            input.classList.remove('birdie-better', 'par', 'bogey', 'double-bogey-plus');
            
            if (diff >= 2) {
                input.classList.add('double-bogey-plus');
            } else if (diff === 1) {
                input.classList.add('bogey');
            } else if (diff === 0) {
                input.classList.add('par');
            } else if (diff <= -1) {
                input.classList.add('birdie-better');
            }
            
            // Update net score if applicable
            const player = tournamentData.players[playerIndex];
            let netMethod = null;
            const gameTypeLower = tournamentData.gameType.toLowerCase();
            
            // Check for any net game
            if (gameTypeLower.includes('net')) {
                if (gameTypeLower.includes('full') || gameTypeLower.includes('full hcp')) {
                    netMethod = 'full';
                } else if (gameTypeLower.includes('18 max')) {
                    netMethod = '18max';
                } else if (gameTypeLower.includes('1/2 pop') || gameTypeLower.includes('half pop')) {
                    netMethod = 'half';
                } else {
                    // Default to full handicap for any other net game
                    netMethod = 'full';
                }
            }
            
            if (netMethod) {
                const netScore = getNetScore(newScore, player.handicap, hole.handicap, netMethod);
                const netDisplay = input.parentElement.parentElement.querySelector('.hole-net-score');
                
                if (netDisplay) {
                    netDisplay.textContent = `${netScore}`;
                } else {
                    // Add net score display if it doesn't exist
                    const netDiv = document.createElement('div');
                    netDiv.className = 'hole-net-score';
                    netDiv.textContent = `${netScore}`;
                    input.parentElement.parentElement.appendChild(netDiv);
                }
            }
        }

        // Update score from manual input in hole view
        function updateHoleScore(playerIndex, holeIndex, value) {
            const numValue = parseInt(value);
            
            // If empty or invalid, delete the score
            if (!value || isNaN(numValue) || numValue === 0) {
                tournamentData.players[playerIndex].scores[holeIndex] = 0;
                
                // Clear display
                const input = document.getElementById(`holeScore_${playerIndex}_${holeIndex}`);
                if (input) {
                    input.value = '';
                    input.classList.remove('birdie-better', 'par', 'bogey', 'double-bogey-plus');
                }
                
                // Remove net score
                const netDisplay = input?.parentElement?.parentElement?.querySelector('.hole-net-score');
                if (netDisplay) {
                    netDisplay.remove();
                }
                
                // Update player view
                renderScoringPage();
                saveToLocalStorage();
                return;
            }
            
            tournamentData.players[playerIndex].scores[holeIndex] = numValue;
            
            // Update hole view
            updateHoleViewScore(playerIndex, holeIndex, numValue);
            
            // Update player view
            renderScoringPage();
            
            saveToLocalStorage();
        }

        // Navigate to previous hole
        function goToPrevHole() {
            // Cancel any pending auto-advance
            cancelAutoAdvance();
            
            // Infinite carousel - wrap from hole 1 to hole 18
            if (currentHole === 0) {
                currentHole = 17;
            } else {
                currentHole--;
            }
            renderHoleView();
        }

        // Navigate to next hole
        function goToNextHole() {
            // Cancel any pending auto-advance
            cancelAutoAdvance();
            
            // Infinite carousel - wrap from hole 18 to hole 1
            if (currentHole === 17) {
                currentHole = 0;
            } else {
                currentHole++;
            }
            renderHoleView();
        }
        
        // Jump to specific hole
        function jumpToHole(holeIndex) {
            // Cancel any pending auto-advance
            cancelAutoAdvance();
            
            currentHole = holeIndex;
            renderHoleView();
            closeHoleJumpModal();
        }
        
        // Show hole jump modal
        function showHoleJumpModal() {
            const modal = document.createElement('div');
            modal.id = 'holeJumpModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                padding: 20px;
            `;
            
            let holesGrid = '';
            for (let i = 0; i < 18; i++) {
                const isCurrentHole = i === currentHole;
                holesGrid += `
                    <button onclick="jumpToHole(${i})" style="
                        width: 48px;
                        height: 48px;
                        border-radius: 10px;
                        border: 2px solid ${isCurrentHole ? '#3b82f6' : '#e2e8f0'};
                        background: ${isCurrentHole ? '#3b82f6' : 'white'};
                        color: ${isCurrentHole ? 'white' : '#1e40af'};
                        font-size: 18px;
                        font-weight: 700;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        padding: 0;
                        line-height: 1;
                    ">${i + 1}</button>
                `;
            }
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; max-width: 340px; width: 90%; text-align: center;">
                    <h2 style="color: #1e40af; margin-bottom: 20px; font-size: 22px; font-weight: 700;">Jump to Hole</h2>
                    <div style="display: grid; grid-template-columns: repeat(6, 48px); gap: 8px; margin-bottom: 24px; justify-content: center;">
                        ${holesGrid}
                    </div>
                    <button onclick="closeHoleJumpModal()" style="padding: 14px 32px; background: #e2e8f0; color: #64748b; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function closeHoleJumpModal() {
            const modal = document.getElementById('holeJumpModal');
            if (modal) modal.remove();
        }

        // Setup swipe gestures for hole view
        function setupHoleViewSwipe() {
            const container = document.getElementById('holeViewContainer');
            if (!container) return;
            
            let touchStartX = 0;
            let touchEndX = 0;
            
            container.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
            }, { passive: true });
            
            container.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].screenX;
                handleSwipe();
            }, { passive: true });
            
            function handleSwipe() {
                const swipeThreshold = 50;
                const diff = touchStartX - touchEndX;
                
                if (Math.abs(diff) > swipeThreshold) {
                    if (diff > 0) {
                        // Swipe left - next hole
                        goToNextHole();
                    } else {
                        // Swipe right - previous hole
                        goToPrevHole();
                    }
                }
            }
        }

        // Update startScoring to show indicator and disable pull-to-refresh
        const originalStartScoring = startScoring;
        startScoring = function() {
            originalStartScoring();
            showRoundIndicator();
            disablePullToRefresh();
        };

        // Confirm finish tournament from Host Home
        function confirmFinishTournament() {
            showConfirm(
                'ð Finish Tournament?',
                'This will mark the tournament as finished. Players will no longer be able to edit scores or player info, but can still view results.',
                async function() {
                    // Store IDs before clearing
                    const tournamentId = activeTournamentId;
                    const historyEntry = {
                        id: tournamentId,
                        joinCode: tournamentData?.joinCode || '',
                        name: tournamentData?.name || 'Tournament',
                        course: tournamentData?.course || '',
                        date: tournamentData?.date || new Date().toISOString().split('T')[0],
                        gameType: tournamentData?.gameType || '',
                        role: 'host',
                        isFinished: true
                    };
                    
                    // Save to tournament history FIRST (synchronous, shouldn't fail)
                    try {
                        addToTournamentHistory(historyEntry);
                        console.log('â Saved to tournament history:', historyEntry);
                    } catch (historyError) {
                        console.error('Failed to save history:', historyError);
                    }
                    
                    // Try to mark tournament as finished in Firebase
                    let firebaseSuccess = false;
                    if (tournamentId && db) {
                        try {
                            const tournamentRef = db.collection('tournaments').doc(tournamentId);
                            await tournamentRef.update({ isFinished: true });
                            console.log('â Firebase updated');
                            firebaseSuccess = true;
                        } catch (fbError) {
                            console.error('Firebase update failed:', fbError);
                        }
                    }
                    
                    // Mark locally
                    if (tournamentData) {
                        tournamentData.isFinished = true;
                    }
                    
                    // Hide Current Tournament card
                    const currentTournamentCard = document.getElementById('hostCurrentTournament');
                    if (currentTournamentCard) {
                        currentTournamentCard.style.display = 'none';
                    }
                    
                    // CLEAR ALL ACTIVE TOURNAMENT STATE
                    activeTournamentId = null;
                    isHost = false;
                    tournamentMode = 'single';
                    
                    // Clear localStorage
                    localStorage.removeItem('activeTournamentId');
                    localStorage.removeItem('indianHillsScoring');
                    localStorage.removeItem('currentTournamentId');
                    localStorage.removeItem('pendingPurchase');
                    
                    // Reset tournamentData
                    tournamentData = {
                        id: '',
                        date: '',
                        gameType: '',
                        course: '',
                        players: [],
                        teams: []
                    };
                    
                    // Safely unsubscribe from listeners
                    try {
                        unsubscribeFunctions.forEach(fn => {
                            if (typeof fn === 'function') fn();
                        });
                        unsubscribeFunctions = [];
                    } catch (unsubError) {
                        console.error('Unsubscribe error:', unsubError);
                    }
                    
                    hideConfirmDialog();
                    
                    if (firebaseSuccess) {
                        showNotification('â Finished', 'Tournament saved');
                    } else {
                        showNotification('â Saved', 'Tournament saved locally');
                    }
                    
                    showPage('hostHomePage');
                    updateHostHomeDisplay();
                }
            );
        }
        
        // Check if tournament is finished (for disabling edits)
        function isTournamentFinished() {
            return tournamentData?.isFinished === true;
        }
        
        // Check if current user can edit (host can always edit in View mode)
        function canEditTournament() {
            if (!isTournamentFinished()) return true;
            // If finished, only host can edit (View mode)
            return isHost || isCoHost;
        }

        // Update confirmNewRound to hide indicator and enable pull-to-refresh
        const originalConfirmNewRound = confirmNewRound;
        confirmNewRound = function() {
            showConfirm(
                'End Current Round?',
                'This will end the current round and clear all data. Make sure you\'ve saved your results!',
                function() {
                    localStorage.removeItem('indianHillsScoring');
                    tournamentData = {
                        date: '',
                        gameType: '',
                        course: 'indian_hills',
                        players: [],
                        teams: []
                    };
                    hideRoundIndicator();
                    enablePullToRefresh();
                    showPage('setupPage');
                    hideConfirmDialog();
                    location.reload(); // Reload to reset everything
                }
            );
        };

        // iOS Install Prompt - Show if not running as standalone app
        function showInstallPrompt() {
            // Check if running as standalone (home screen app)
            const isStandalone = window.matchMedia('(display-mode: standalone)').matches || 
                               window.navigator.standalone === true;
            
            // Check if on iOS
            const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
            
            // Check if already dismissed
            const dismissed = localStorage.getItem('installPromptDismissed');
            
            if (!isStandalone && isIOS && !dismissed) {
                // Show after 3 seconds
                setTimeout(() => {
                    const banner = document.createElement('div');
                    banner.style.cssText = `
                        position: fixed;
                        bottom: 0;
                        left: 0;
                        right: 0;
                        background: rgba(30, 64, 175, 0.95);
                        color: white;
                        padding: 16px;
                        text-align: center;
                        z-index: 10000;
                        font-size: 14px;
                        line-height: 1.4;
                        box-shadow: 0 -4px 12px rgba(0,0,0,0.3);
                    `;
                    banner.innerHTML = `
                        <div style="margin-bottom: 8px;">ð± <strong>Install for Full Screen</strong></div>
                        <div style="font-size: 12px; opacity: 0.9; margin-bottom: 12px;">
                            Tap <strong>Share</strong> â <strong>Add to Home Screen</strong> to hide browser controls
                        </div>
                        <button onclick="this.closest('div').remove(); localStorage.setItem('installPromptDismissed', 'true');" 
                                style="background: white; color: #1e40af; border: none; padding: 8px 20px; border-radius: 6px; font-weight: 600; font-size: 13px;">
                            Got it
                        </button>
                    `;
                    document.body.appendChild(banner);
                    
                    // Auto-dismiss after 10 seconds
                    setTimeout(() => {
                        if (banner.parentNode) {
                            banner.remove();
                        }
                    }, 10000);
                }, 3000);
            }
        }
        
        // DISABLED: Homescreen install notification - will bring back later
        // showInstallPrompt();
    </script>
</body>
</html>
